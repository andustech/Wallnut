/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkecomm_levity"] = self["webpackChunkecomm_levity"] || []).push([["npm.terser"],{

/***/ "./node_modules/terser/dist/bundle.min.js":
/*!************************************************!*\
  !*** ./node_modules/terser/dist/bundle.min.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("(function (global, factory) {\n true ? factory(exports, __webpack_require__(/*! source-map */ \"./node_modules/terser/node_modules/source-map/source-map.js\")) :\n0;\n}(this, (function (exports, MOZ_SourceMap) { 'use strict';\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar MOZ_SourceMap__default = /*#__PURE__*/_interopDefaultLegacy(MOZ_SourceMap);\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nfunction characters(str) {\n    return str.split(\"\");\n}\n\nfunction member(name, array) {\n    return array.includes(name);\n}\n\nclass DefaultsError extends Error {\n    constructor(msg, defs) {\n        super();\n\n        this.name = \"DefaultsError\";\n        this.message = msg;\n        this.defs = defs;\n    }\n}\n\nfunction defaults(args, defs, croak) {\n    if (args === true) {\n        args = {};\n    } else if (args != null && typeof args === \"object\") {\n        args = {...args};\n    }\n\n    const ret = args || {};\n\n    if (croak) for (const i in ret) if (HOP(ret, i) && !HOP(defs, i)) {\n        throw new DefaultsError(\"`\" + i + \"` is not a supported option\", defs);\n    }\n\n    for (const i in defs) if (HOP(defs, i)) {\n        if (!args || !HOP(args, i)) {\n            ret[i] = defs[i];\n        } else if (i === \"ecma\") {\n            let ecma = args[i] | 0;\n            if (ecma > 5 && ecma < 2015) ecma += 2009;\n            ret[i] = ecma;\n        } else {\n            ret[i] = (args && HOP(args, i)) ? args[i] : defs[i];\n        }\n    }\n\n    return ret;\n}\n\nfunction noop() {}\nfunction return_false() { return false; }\nfunction return_true() { return true; }\nfunction return_this() { return this; }\nfunction return_null() { return null; }\n\nvar MAP = (function() {\n    function MAP(a, f, backwards) {\n        var ret = [], top = [], i;\n        function doit() {\n            var val = f(a[i], i);\n            var is_last = val instanceof Last;\n            if (is_last) val = val.v;\n            if (val instanceof AtTop) {\n                val = val.v;\n                if (val instanceof Splice) {\n                    top.push.apply(top, backwards ? val.v.slice().reverse() : val.v);\n                } else {\n                    top.push(val);\n                }\n            } else if (val !== skip) {\n                if (val instanceof Splice) {\n                    ret.push.apply(ret, backwards ? val.v.slice().reverse() : val.v);\n                } else {\n                    ret.push(val);\n                }\n            }\n            return is_last;\n        }\n        if (Array.isArray(a)) {\n            if (backwards) {\n                for (i = a.length; --i >= 0;) if (doit()) break;\n                ret.reverse();\n                top.reverse();\n            } else {\n                for (i = 0; i < a.length; ++i) if (doit()) break;\n            }\n        } else {\n            for (i in a) if (HOP(a, i)) if (doit()) break;\n        }\n        return top.concat(ret);\n    }\n    MAP.at_top = function(val) { return new AtTop(val); };\n    MAP.splice = function(val) { return new Splice(val); };\n    MAP.last = function(val) { return new Last(val); };\n    var skip = MAP.skip = {};\n    function AtTop(val) { this.v = val; }\n    function Splice(val) { this.v = val; }\n    function Last(val) { this.v = val; }\n    return MAP;\n})();\n\nfunction make_node(ctor, orig, props) {\n    if (!props) props = {};\n    if (orig) {\n        if (!props.start) props.start = orig.start;\n        if (!props.end) props.end = orig.end;\n    }\n    return new ctor(props);\n}\n\nfunction push_uniq(array, el) {\n    if (!array.includes(el))\n        array.push(el);\n}\n\nfunction string_template(text, props) {\n    return text.replace(/{(.+?)}/g, function(str, p) {\n        return props && props[p];\n    });\n}\n\nfunction remove(array, el) {\n    for (var i = array.length; --i >= 0;) {\n        if (array[i] === el) array.splice(i, 1);\n    }\n}\n\nfunction mergeSort(array, cmp) {\n    if (array.length < 2) return array.slice();\n    function merge(a, b) {\n        var r = [], ai = 0, bi = 0, i = 0;\n        while (ai < a.length && bi < b.length) {\n            cmp(a[ai], b[bi]) <= 0\n                ? r[i++] = a[ai++]\n                : r[i++] = b[bi++];\n        }\n        if (ai < a.length) r.push.apply(r, a.slice(ai));\n        if (bi < b.length) r.push.apply(r, b.slice(bi));\n        return r;\n    }\n    function _ms(a) {\n        if (a.length <= 1)\n            return a;\n        var m = Math.floor(a.length / 2), left = a.slice(0, m), right = a.slice(m);\n        left = _ms(left);\n        right = _ms(right);\n        return merge(left, right);\n    }\n    return _ms(array);\n}\n\nfunction makePredicate(words) {\n    if (!Array.isArray(words)) words = words.split(\" \");\n\n    return new Set(words.sort());\n}\n\nfunction map_add(map, key, value) {\n    if (map.has(key)) {\n        map.get(key).push(value);\n    } else {\n        map.set(key, [ value ]);\n    }\n}\n\nfunction map_from_object(obj) {\n    var map = new Map();\n    for (var key in obj) {\n        if (HOP(obj, key) && key.charAt(0) === \"$\") {\n            map.set(key.substr(1), obj[key]);\n        }\n    }\n    return map;\n}\n\nfunction map_to_object(map) {\n    var obj = Object.create(null);\n    map.forEach(function (value, key) {\n        obj[\"$\" + key] = value;\n    });\n    return obj;\n}\n\nfunction HOP(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction keep_name(keep_setting, name) {\n    return keep_setting === true\n        || (keep_setting instanceof RegExp && keep_setting.test(name));\n}\n\nvar lineTerminatorEscape = {\n    \"\\0\": \"0\",\n    \"\\n\": \"n\",\n    \"\\r\": \"r\",\n    \"\\u2028\": \"u2028\",\n    \"\\u2029\": \"u2029\",\n};\nfunction regexp_source_fix(source) {\n    // V8 does not escape line terminators in regexp patterns in node 12\n    // We'll also remove literal \\0\n    return source.replace(/[\\0\\n\\r\\u2028\\u2029]/g, function (match, offset) {\n        var escaped = source[offset - 1] == \"\\\\\"\n            && (source[offset - 2] != \"\\\\\"\n            || /(?:^|[^\\\\])(?:\\\\{2})*$/.test(source.slice(0, offset - 1)));\n        return (escaped ? \"\" : \"\\\\\") + lineTerminatorEscape[match];\n    });\n}\nconst all_flags = \"gimuy\";\nfunction sort_regexp_flags(flags) {\n    const existing_flags = new Set(flags.split(\"\"));\n    let out = \"\";\n    for (const flag of all_flags) {\n        if (existing_flags.has(flag)) {\n            out += flag;\n            existing_flags.delete(flag);\n        }\n    }\n    if (existing_flags.size) {\n        // Flags Terser doesn't know about\n        existing_flags.forEach(flag => { out += flag; });\n    }\n    return out;\n}\n\nfunction has_annotation(node, annotation) {\n    return node._annotations & annotation;\n}\n\nfunction set_annotation(node, annotation) {\n    node._annotations |= annotation;\n}\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nvar LATEST_RAW = \"\";  // Only used for numbers and template strings\nvar LATEST_TEMPLATE_END = true;\n\nvar KEYWORDS = \"break case catch class const continue debugger default delete do else export extends finally for function if in instanceof let new return switch throw try typeof var void while with\";\nvar KEYWORDS_ATOM = \"false null true\";\nvar RESERVED_WORDS = \"enum implements import interface package private protected public static super this \" + KEYWORDS_ATOM + \" \" + KEYWORDS;\nvar KEYWORDS_BEFORE_EXPRESSION = \"return new delete throw else case yield await\";\n\nKEYWORDS = makePredicate(KEYWORDS);\nRESERVED_WORDS = makePredicate(RESERVED_WORDS);\nKEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);\nKEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);\n\nvar OPERATOR_CHARS = makePredicate(characters(\"+-*&%=<>!?|~^\"));\n\nvar RE_NUM_LITERAL = /[0-9a-f]/i;\nvar RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\nvar RE_OCT_NUMBER = /^0[0-7]+$/;\nvar RE_ES6_OCT_NUMBER = /^0o[0-7]+$/i;\nvar RE_BIN_NUMBER = /^0b[01]+$/i;\nvar RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\nvar RE_BIG_INT = /^(0[xob])?[0-9a-f]+n$/i;\n\nvar OPERATORS = makePredicate([\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"new\",\n    \"void\",\n    \"delete\",\n    \"++\",\n    \"--\",\n    \"+\",\n    \"-\",\n    \"!\",\n    \"~\",\n    \"&\",\n    \"|\",\n    \"^\",\n    \"*\",\n    \"**\",\n    \"/\",\n    \"%\",\n    \">>\",\n    \"<<\",\n    \">>>\",\n    \"<\",\n    \">\",\n    \"<=\",\n    \">=\",\n    \"==\",\n    \"===\",\n    \"!=\",\n    \"!==\",\n    \"?\",\n    \"=\",\n    \"+=\",\n    \"-=\",\n    \"||=\",\n    \"&&=\",\n    \"??=\",\n    \"/=\",\n    \"*=\",\n    \"**=\",\n    \"%=\",\n    \">>=\",\n    \"<<=\",\n    \">>>=\",\n    \"|=\",\n    \"^=\",\n    \"&=\",\n    \"&&\",\n    \"??\",\n    \"||\",\n]);\n\nvar WHITESPACE_CHARS = makePredicate(characters(\" \\u00a0\\n\\r\\t\\f\\u000b\\u200b\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\uFEFF\"));\n\nvar NEWLINE_CHARS = makePredicate(characters(\"\\n\\r\\u2028\\u2029\"));\n\nvar PUNC_AFTER_EXPRESSION = makePredicate(characters(\";]),:\"));\n\nvar PUNC_BEFORE_EXPRESSION = makePredicate(characters(\"[{(,;:\"));\n\nvar PUNC_CHARS = makePredicate(characters(\"[]{}(),;:\"));\n\n/* -----[ Tokenizer ]----- */\n\n// surrogate safe regexps adapted from https://github.com/mathiasbynens/unicode-8.0.0/tree/89b412d8a71ecca9ed593d9e9fa073ab64acfebe/Binary_Property\nvar UNICODE = {\n    ID_Start: /[$A-Z_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,\n    ID_Continue: /(?:[$0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF])+/,\n};\n\nfunction get_full_char(str, pos) {\n    if (is_surrogate_pair_head(str.charCodeAt(pos))) {\n        if (is_surrogate_pair_tail(str.charCodeAt(pos + 1))) {\n            return str.charAt(pos) + str.charAt(pos + 1);\n        }\n    } else if (is_surrogate_pair_tail(str.charCodeAt(pos))) {\n        if (is_surrogate_pair_head(str.charCodeAt(pos - 1))) {\n            return str.charAt(pos - 1) + str.charAt(pos);\n        }\n    }\n    return str.charAt(pos);\n}\n\nfunction get_full_char_code(str, pos) {\n    // https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n    if (is_surrogate_pair_head(str.charCodeAt(pos))) {\n        return 0x10000 + (str.charCodeAt(pos) - 0xd800 << 10) + str.charCodeAt(pos + 1) - 0xdc00;\n    }\n    return str.charCodeAt(pos);\n}\n\nfunction get_full_char_length(str) {\n    var surrogates = 0;\n\n    for (var i = 0; i < str.length; i++) {\n        if (is_surrogate_pair_head(str.charCodeAt(i)) && is_surrogate_pair_tail(str.charCodeAt(i + 1))) {\n            surrogates++;\n            i++;\n        }\n    }\n\n    return str.length - surrogates;\n}\n\nfunction from_char_code(code) {\n    // Based on https://github.com/mathiasbynens/String.fromCodePoint/blob/master/fromcodepoint.js\n    if (code > 0xFFFF) {\n        code -= 0x10000;\n        return (String.fromCharCode((code >> 10) + 0xD800) +\n            String.fromCharCode((code % 0x400) + 0xDC00));\n    }\n    return String.fromCharCode(code);\n}\n\nfunction is_surrogate_pair_head(code) {\n    return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction is_surrogate_pair_tail(code) {\n    return code >= 0xdc00 && code <= 0xdfff;\n}\n\nfunction is_digit(code) {\n    return code >= 48 && code <= 57;\n}\n\nfunction is_identifier_start(ch) {\n    return UNICODE.ID_Start.test(ch);\n}\n\nfunction is_identifier_char(ch) {\n    return UNICODE.ID_Continue.test(ch);\n}\n\nconst BASIC_IDENT = /^[a-z_$][a-z0-9_$]*$/i;\n\nfunction is_basic_identifier_string(str) {\n    return BASIC_IDENT.test(str);\n}\n\nfunction is_identifier_string(str, allow_surrogates) {\n    if (BASIC_IDENT.test(str)) {\n        return true;\n    }\n    if (!allow_surrogates && /[\\ud800-\\udfff]/.test(str)) {\n        return false;\n    }\n    var match = UNICODE.ID_Start.exec(str);\n    if (!match || match.index !== 0) {\n        return false;\n    }\n\n    str = str.slice(match[0].length);\n    if (!str) {\n        return true;\n    }\n\n    match = UNICODE.ID_Continue.exec(str);\n    return !!match && match[0].length === str.length;\n}\n\nfunction parse_js_number(num, allow_e = true) {\n    if (!allow_e && num.includes(\"e\")) {\n        return NaN;\n    }\n    if (RE_HEX_NUMBER.test(num)) {\n        return parseInt(num.substr(2), 16);\n    } else if (RE_OCT_NUMBER.test(num)) {\n        return parseInt(num.substr(1), 8);\n    } else if (RE_ES6_OCT_NUMBER.test(num)) {\n        return parseInt(num.substr(2), 8);\n    } else if (RE_BIN_NUMBER.test(num)) {\n        return parseInt(num.substr(2), 2);\n    } else if (RE_DEC_NUMBER.test(num)) {\n        return parseFloat(num);\n    } else {\n        var val = parseFloat(num);\n        if (val == num) return val;\n    }\n}\n\nclass JS_Parse_Error extends Error {\n    constructor(message, filename, line, col, pos) {\n        super();\n\n        this.name = \"SyntaxError\";\n        this.message = message;\n        this.filename = filename;\n        this.line = line;\n        this.col = col;\n        this.pos = pos;\n    }\n}\n\nfunction js_error(message, filename, line, col, pos) {\n    throw new JS_Parse_Error(message, filename, line, col, pos);\n}\n\nfunction is_token(token, type, val) {\n    return token.type == type && (val == null || token.value == val);\n}\n\nvar EX_EOF = {};\n\nfunction tokenizer($TEXT, filename, html5_comments, shebang) {\n    var S = {\n        text            : $TEXT,\n        filename        : filename,\n        pos             : 0,\n        tokpos          : 0,\n        line            : 1,\n        tokline         : 0,\n        col             : 0,\n        tokcol          : 0,\n        newline_before  : false,\n        regex_allowed   : false,\n        brace_counter   : 0,\n        template_braces : [],\n        comments_before : [],\n        directives      : {},\n        directive_stack : []\n    };\n\n    function peek() { return get_full_char(S.text, S.pos); }\n\n    // Used because parsing ?. involves a lookahead for a digit\n    function is_option_chain_op() {\n        const must_be_dot = S.text.charCodeAt(S.pos + 1) === 46;\n        if (!must_be_dot) return false;\n\n        const cannot_be_digit = S.text.charCodeAt(S.pos + 2);\n        return cannot_be_digit < 48 || cannot_be_digit > 57;\n    }\n\n    function next(signal_eof, in_string) {\n        var ch = get_full_char(S.text, S.pos++);\n        if (signal_eof && !ch)\n            throw EX_EOF;\n        if (NEWLINE_CHARS.has(ch)) {\n            S.newline_before = S.newline_before || !in_string;\n            ++S.line;\n            S.col = 0;\n            if (ch == \"\\r\" && peek() == \"\\n\") {\n                // treat a \\r\\n sequence as a single \\n\n                ++S.pos;\n                ch = \"\\n\";\n            }\n        } else {\n            if (ch.length > 1) {\n                ++S.pos;\n                ++S.col;\n            }\n            ++S.col;\n        }\n        return ch;\n    }\n\n    function forward(i) {\n        while (i--) next();\n    }\n\n    function looking_at(str) {\n        return S.text.substr(S.pos, str.length) == str;\n    }\n\n    function find_eol() {\n        var text = S.text;\n        for (var i = S.pos, n = S.text.length; i < n; ++i) {\n            var ch = text[i];\n            if (NEWLINE_CHARS.has(ch))\n                return i;\n        }\n        return -1;\n    }\n\n    function find(what, signal_eof) {\n        var pos = S.text.indexOf(what, S.pos);\n        if (signal_eof && pos == -1) throw EX_EOF;\n        return pos;\n    }\n\n    function start_token() {\n        S.tokline = S.line;\n        S.tokcol = S.col;\n        S.tokpos = S.pos;\n    }\n\n    var prev_was_dot = false;\n    var previous_token = null;\n    function token(type, value, is_comment) {\n        S.regex_allowed = ((type == \"operator\" && !UNARY_POSTFIX.has(value)) ||\n                           (type == \"keyword\" && KEYWORDS_BEFORE_EXPRESSION.has(value)) ||\n                           (type == \"punc\" && PUNC_BEFORE_EXPRESSION.has(value))) ||\n                           (type == \"arrow\");\n        if (type == \"punc\" && (value == \".\" || value == \"?.\")) {\n            prev_was_dot = true;\n        } else if (!is_comment) {\n            prev_was_dot = false;\n        }\n        const line     = S.tokline;\n        const col      = S.tokcol;\n        const pos      = S.tokpos;\n        const nlb      = S.newline_before;\n        const file     = filename;\n        let comments_before = [];\n        let comments_after  = [];\n\n        if (!is_comment) {\n            comments_before = S.comments_before;\n            comments_after = S.comments_before = [];\n        }\n        S.newline_before = false;\n        const tok = new AST_Token(type, value, line, col, pos, nlb, comments_before, comments_after, file);\n\n        if (!is_comment) previous_token = tok;\n        return tok;\n    }\n\n    function skip_whitespace() {\n        while (WHITESPACE_CHARS.has(peek()))\n            next();\n    }\n\n    function read_while(pred) {\n        var ret = \"\", ch, i = 0;\n        while ((ch = peek()) && pred(ch, i++))\n            ret += next();\n        return ret;\n    }\n\n    function parse_error(err) {\n        js_error(err, filename, S.tokline, S.tokcol, S.tokpos);\n    }\n\n    function read_num(prefix) {\n        var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\", is_big_int = false, numeric_separator = false;\n        var num = read_while(function(ch, i) {\n            if (is_big_int) return false;\n\n            var code = ch.charCodeAt(0);\n            switch (code) {\n              case 95: // _\n                return (numeric_separator = true);\n              case 98: case 66: // bB\n                return (has_x = true); // Can occur in hex sequence, don't return false yet\n              case 111: case 79: // oO\n              case 120: case 88: // xX\n                return has_x ? false : (has_x = true);\n              case 101: case 69: // eE\n                return has_x ? true : has_e ? false : (has_e = after_e = true);\n              case 45: // -\n                return after_e || (i == 0 && !prefix);\n              case 43: // +\n                return after_e;\n              case (after_e = false, 46): // .\n                return (!has_dot && !has_x && !has_e) ? (has_dot = true) : false;\n            }\n\n            if (ch === \"n\") {\n                is_big_int = true;\n\n                return true;\n            }\n\n            return RE_NUM_LITERAL.test(ch);\n        });\n        if (prefix) num = prefix + num;\n\n        LATEST_RAW = num;\n\n        if (RE_OCT_NUMBER.test(num) && next_token.has_directive(\"use strict\")) {\n            parse_error(\"Legacy octal literals are not allowed in strict mode\");\n        }\n        if (numeric_separator) {\n            if (num.endsWith(\"_\")) {\n                parse_error(\"Numeric separators are not allowed at the end of numeric literals\");\n            } else if (num.includes(\"__\")) {\n                parse_error(\"Only one underscore is allowed as numeric separator\");\n            }\n            num = num.replace(/_/g, \"\");\n        }\n        if (num.endsWith(\"n\")) {\n            const without_n = num.slice(0, -1);\n            const allow_e = RE_HEX_NUMBER.test(without_n);\n            const valid = parse_js_number(without_n, allow_e);\n            if (!has_dot && RE_BIG_INT.test(num) && !isNaN(valid))\n                return token(\"big_int\", without_n);\n            parse_error(\"Invalid or unexpected token\");\n        }\n        var valid = parse_js_number(num);\n        if (!isNaN(valid)) {\n            return token(\"num\", valid);\n        } else {\n            parse_error(\"Invalid syntax: \" + num);\n        }\n    }\n\n    function is_octal(ch) {\n        return ch >= \"0\" && ch <= \"7\";\n    }\n\n    function read_escaped_char(in_string, strict_hex, template_string) {\n        var ch = next(true, in_string);\n        switch (ch.charCodeAt(0)) {\n          case 110 : return \"\\n\";\n          case 114 : return \"\\r\";\n          case 116 : return \"\\t\";\n          case 98  : return \"\\b\";\n          case 118 : return \"\\u000b\"; // \\v\n          case 102 : return \"\\f\";\n          case 120 : return String.fromCharCode(hex_bytes(2, strict_hex)); // \\x\n          case 117 : // \\u\n            if (peek() == \"{\") {\n                next(true);\n                if (peek() === \"}\")\n                    parse_error(\"Expecting hex-character between {}\");\n                while (peek() == \"0\") next(true); // No significance\n                var result, length = find(\"}\", true) - S.pos;\n                // Avoid 32 bit integer overflow (1 << 32 === 1)\n                // We know first character isn't 0 and thus out of range anyway\n                if (length > 6 || (result = hex_bytes(length, strict_hex)) > 0x10FFFF) {\n                    parse_error(\"Unicode reference out of bounds\");\n                }\n                next(true);\n                return from_char_code(result);\n            }\n            return String.fromCharCode(hex_bytes(4, strict_hex));\n          case 10  : return \"\"; // newline\n          case 13  :            // \\r\n            if (peek() == \"\\n\") { // DOS newline\n                next(true, in_string);\n                return \"\";\n            }\n        }\n        if (is_octal(ch)) {\n            if (template_string && strict_hex) {\n                const represents_null_character = ch === \"0\" && !is_octal(peek());\n                if (!represents_null_character) {\n                    parse_error(\"Octal escape sequences are not allowed in template strings\");\n                }\n            }\n            return read_octal_escape_sequence(ch, strict_hex);\n        }\n        return ch;\n    }\n\n    function read_octal_escape_sequence(ch, strict_octal) {\n        // Read\n        var p = peek();\n        if (p >= \"0\" && p <= \"7\") {\n            ch += next(true);\n            if (ch[0] <= \"3\" && (p = peek()) >= \"0\" && p <= \"7\")\n                ch += next(true);\n        }\n\n        // Parse\n        if (ch === \"0\") return \"\\0\";\n        if (ch.length > 0 && next_token.has_directive(\"use strict\") && strict_octal)\n            parse_error(\"Legacy octal escape sequences are not allowed in strict mode\");\n        return String.fromCharCode(parseInt(ch, 8));\n    }\n\n    function hex_bytes(n, strict_hex) {\n        var num = 0;\n        for (; n > 0; --n) {\n            if (!strict_hex && isNaN(parseInt(peek(), 16))) {\n                return parseInt(num, 16) || \"\";\n            }\n            var digit = next(true);\n            if (isNaN(parseInt(digit, 16)))\n                parse_error(\"Invalid hex-character pattern in string\");\n            num += digit;\n        }\n        return parseInt(num, 16);\n    }\n\n    var read_string = with_eof_error(\"Unterminated string constant\", function() {\n        const start_pos = S.pos;\n        var quote = next(), ret = [];\n        for (;;) {\n            var ch = next(true, true);\n            if (ch == \"\\\\\") ch = read_escaped_char(true, true);\n            else if (ch == \"\\r\" || ch == \"\\n\") parse_error(\"Unterminated string constant\");\n            else if (ch == quote) break;\n            ret.push(ch);\n        }\n        var tok = token(\"string\", ret.join(\"\"));\n        LATEST_RAW = S.text.slice(start_pos, S.pos);\n        tok.quote = quote;\n        return tok;\n    });\n\n    var read_template_characters = with_eof_error(\"Unterminated template\", function(begin) {\n        if (begin) {\n            S.template_braces.push(S.brace_counter);\n        }\n        var content = \"\", raw = \"\", ch, tok;\n        next(true, true);\n        while ((ch = next(true, true)) != \"`\") {\n            if (ch == \"\\r\") {\n                if (peek() == \"\\n\") ++S.pos;\n                ch = \"\\n\";\n            } else if (ch == \"$\" && peek() == \"{\") {\n                next(true, true);\n                S.brace_counter++;\n                tok = token(begin ? \"template_head\" : \"template_substitution\", content);\n                LATEST_RAW = raw;\n                LATEST_TEMPLATE_END = false;\n                return tok;\n            }\n\n            raw += ch;\n            if (ch == \"\\\\\") {\n                var tmp = S.pos;\n                var prev_is_tag = previous_token && (previous_token.type === \"name\" || previous_token.type === \"punc\" && (previous_token.value === \")\" || previous_token.value === \"]\"));\n                ch = read_escaped_char(true, !prev_is_tag, true);\n                raw += S.text.substr(tmp, S.pos - tmp);\n            }\n\n            content += ch;\n        }\n        S.template_braces.pop();\n        tok = token(begin ? \"template_head\" : \"template_substitution\", content);\n        LATEST_RAW = raw;\n        LATEST_TEMPLATE_END = true;\n        return tok;\n    });\n\n    function skip_line_comment(type) {\n        var regex_allowed = S.regex_allowed;\n        var i = find_eol(), ret;\n        if (i == -1) {\n            ret = S.text.substr(S.pos);\n            S.pos = S.text.length;\n        } else {\n            ret = S.text.substring(S.pos, i);\n            S.pos = i;\n        }\n        S.col = S.tokcol + (S.pos - S.tokpos);\n        S.comments_before.push(token(type, ret, true));\n        S.regex_allowed = regex_allowed;\n        return next_token;\n    }\n\n    var skip_multiline_comment = with_eof_error(\"Unterminated multiline comment\", function() {\n        var regex_allowed = S.regex_allowed;\n        var i = find(\"*/\", true);\n        var text = S.text.substring(S.pos, i).replace(/\\r\\n|\\r|\\u2028|\\u2029/g, \"\\n\");\n        // update stream position\n        forward(get_full_char_length(text) /* text length doesn't count \\r\\n as 2 char while S.pos - i does */ + 2);\n        S.comments_before.push(token(\"comment2\", text, true));\n        S.newline_before = S.newline_before || text.includes(\"\\n\");\n        S.regex_allowed = regex_allowed;\n        return next_token;\n    });\n\n    var read_name = with_eof_error(\"Unterminated identifier name\", function() {\n        var name = [], ch, escaped = false;\n        var read_escaped_identifier_char = function() {\n            escaped = true;\n            next();\n            if (peek() !== \"u\") {\n                parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX or u{XXXX}\");\n            }\n            return read_escaped_char(false, true);\n        };\n\n        // Read first character (ID_Start)\n        if ((ch = peek()) === \"\\\\\") {\n            ch = read_escaped_identifier_char();\n            if (!is_identifier_start(ch)) {\n                parse_error(\"First identifier char is an invalid identifier char\");\n            }\n        } else if (is_identifier_start(ch)) {\n            next();\n        } else {\n            return \"\";\n        }\n\n        name.push(ch);\n\n        // Read ID_Continue\n        while ((ch = peek()) != null) {\n            if ((ch = peek()) === \"\\\\\") {\n                ch = read_escaped_identifier_char();\n                if (!is_identifier_char(ch)) {\n                    parse_error(\"Invalid escaped identifier char\");\n                }\n            } else {\n                if (!is_identifier_char(ch)) {\n                    break;\n                }\n                next();\n            }\n            name.push(ch);\n        }\n        const name_str = name.join(\"\");\n        if (RESERVED_WORDS.has(name_str) && escaped) {\n            parse_error(\"Escaped characters are not allowed in keywords\");\n        }\n        return name_str;\n    });\n\n    var read_regexp = with_eof_error(\"Unterminated regular expression\", function(source) {\n        var prev_backslash = false, ch, in_class = false;\n        while ((ch = next(true))) if (NEWLINE_CHARS.has(ch)) {\n            parse_error(\"Unexpected line terminator\");\n        } else if (prev_backslash) {\n            source += \"\\\\\" + ch;\n            prev_backslash = false;\n        } else if (ch == \"[\") {\n            in_class = true;\n            source += ch;\n        } else if (ch == \"]\" && in_class) {\n            in_class = false;\n            source += ch;\n        } else if (ch == \"/\" && !in_class) {\n            break;\n        } else if (ch == \"\\\\\") {\n            prev_backslash = true;\n        } else {\n            source += ch;\n        }\n        const flags = read_name();\n        return token(\"regexp\", \"/\" + source + \"/\" + flags);\n    });\n\n    function read_operator(prefix) {\n        function grow(op) {\n            if (!peek()) return op;\n            var bigger = op + peek();\n            if (OPERATORS.has(bigger)) {\n                next();\n                return grow(bigger);\n            } else {\n                return op;\n            }\n        }\n        return token(\"operator\", grow(prefix || next()));\n    }\n\n    function handle_slash() {\n        next();\n        switch (peek()) {\n          case \"/\":\n            next();\n            return skip_line_comment(\"comment1\");\n          case \"*\":\n            next();\n            return skip_multiline_comment();\n        }\n        return S.regex_allowed ? read_regexp(\"\") : read_operator(\"/\");\n    }\n\n    function handle_eq_sign() {\n        next();\n        if (peek() === \">\") {\n            next();\n            return token(\"arrow\", \"=>\");\n        } else {\n            return read_operator(\"=\");\n        }\n    }\n\n    function handle_dot() {\n        next();\n        if (is_digit(peek().charCodeAt(0))) {\n            return read_num(\".\");\n        }\n        if (peek() === \".\") {\n            next();  // Consume second dot\n            next();  // Consume third dot\n            return token(\"expand\", \"...\");\n        }\n\n        return token(\"punc\", \".\");\n    }\n\n    function read_word() {\n        var word = read_name();\n        if (prev_was_dot) return token(\"name\", word);\n        return KEYWORDS_ATOM.has(word) ? token(\"atom\", word)\n            : !KEYWORDS.has(word) ? token(\"name\", word)\n            : OPERATORS.has(word) ? token(\"operator\", word)\n            : token(\"keyword\", word);\n    }\n\n    function read_private_word() {\n        next();\n        return token(\"privatename\", read_name());\n    }\n\n    function with_eof_error(eof_error, cont) {\n        return function(x) {\n            try {\n                return cont(x);\n            } catch(ex) {\n                if (ex === EX_EOF) parse_error(eof_error);\n                else throw ex;\n            }\n        };\n    }\n\n    function next_token(force_regexp) {\n        if (force_regexp != null)\n            return read_regexp(force_regexp);\n        if (shebang && S.pos == 0 && looking_at(\"#!\")) {\n            start_token();\n            forward(2);\n            skip_line_comment(\"comment5\");\n        }\n        for (;;) {\n            skip_whitespace();\n            start_token();\n            if (html5_comments) {\n                if (looking_at(\"<!--\")) {\n                    forward(4);\n                    skip_line_comment(\"comment3\");\n                    continue;\n                }\n                if (looking_at(\"-->\") && S.newline_before) {\n                    forward(3);\n                    skip_line_comment(\"comment4\");\n                    continue;\n                }\n            }\n            var ch = peek();\n            if (!ch) return token(\"eof\");\n            var code = ch.charCodeAt(0);\n            switch (code) {\n              case 34: case 39: return read_string();\n              case 46: return handle_dot();\n              case 47: {\n                  var tok = handle_slash();\n                  if (tok === next_token) continue;\n                  return tok;\n              }\n              case 61: return handle_eq_sign();\n              case 63: {\n                  if (!is_option_chain_op()) break;  // Handled below\n\n                  next(); // ?\n                  next(); // .\n\n                  return token(\"punc\", \"?.\");\n              }\n              case 96: return read_template_characters(true);\n              case 123:\n                S.brace_counter++;\n                break;\n              case 125:\n                S.brace_counter--;\n                if (S.template_braces.length > 0\n                    && S.template_braces[S.template_braces.length - 1] === S.brace_counter)\n                    return read_template_characters(false);\n                break;\n            }\n            if (is_digit(code)) return read_num();\n            if (PUNC_CHARS.has(ch)) return token(\"punc\", next());\n            if (OPERATOR_CHARS.has(ch)) return read_operator();\n            if (code == 92 || is_identifier_start(ch)) return read_word();\n            if (code == 35) return read_private_word();\n            break;\n        }\n        parse_error(\"Unexpected character '\" + ch + \"'\");\n    }\n\n    next_token.next = next;\n    next_token.peek = peek;\n\n    next_token.context = function(nc) {\n        if (nc) S = nc;\n        return S;\n    };\n\n    next_token.add_directive = function(directive) {\n        S.directive_stack[S.directive_stack.length - 1].push(directive);\n\n        if (S.directives[directive] === undefined) {\n            S.directives[directive] = 1;\n        } else {\n            S.directives[directive]++;\n        }\n    };\n\n    next_token.push_directives_stack = function() {\n        S.directive_stack.push([]);\n    };\n\n    next_token.pop_directives_stack = function() {\n        var directives = S.directive_stack[S.directive_stack.length - 1];\n\n        for (var i = 0; i < directives.length; i++) {\n            S.directives[directives[i]]--;\n        }\n\n        S.directive_stack.pop();\n    };\n\n    next_token.has_directive = function(directive) {\n        return S.directives[directive] > 0;\n    };\n\n    return next_token;\n\n}\n\n/* -----[ Parser (constants) ]----- */\n\nvar UNARY_PREFIX = makePredicate([\n    \"typeof\",\n    \"void\",\n    \"delete\",\n    \"--\",\n    \"++\",\n    \"!\",\n    \"~\",\n    \"-\",\n    \"+\"\n]);\n\nvar UNARY_POSTFIX = makePredicate([ \"--\", \"++\" ]);\n\nvar ASSIGNMENT = makePredicate([ \"=\", \"+=\", \"-=\", \"??=\", \"&&=\", \"||=\", \"/=\", \"*=\", \"**=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\" ]);\n\nvar LOGICAL_ASSIGNMENT = makePredicate([ \"??=\", \"&&=\", \"||=\" ]);\n\nvar PRECEDENCE = (function(a, ret) {\n    for (var i = 0; i < a.length; ++i) {\n        var b = a[i];\n        for (var j = 0; j < b.length; ++j) {\n            ret[b[j]] = i + 1;\n        }\n    }\n    return ret;\n})(\n    [\n        [\"||\"],\n        [\"??\"],\n        [\"&&\"],\n        [\"|\"],\n        [\"^\"],\n        [\"&\"],\n        [\"==\", \"===\", \"!=\", \"!==\"],\n        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n        [\">>\", \"<<\", \">>>\"],\n        [\"+\", \"-\"],\n        [\"*\", \"/\", \"%\"],\n        [\"**\"]\n    ],\n    {}\n);\n\nvar ATOMIC_START_TOKEN = makePredicate([ \"atom\", \"num\", \"big_int\", \"string\", \"regexp\", \"name\" ]);\n\n/* -----[ Parser ]----- */\n\nfunction parse($TEXT, options) {\n    // maps start tokens to count of comments found outside of their parens\n    // Example: /* I count */ ( /* I don't */ foo() )\n    // Useful because comments_before property of call with parens outside\n    // contains both comments inside and outside these parens. Used to find the\n    // right #__PURE__ comments for an expression\n    const outer_comments_before_counts = new WeakMap();\n\n    options = defaults(options, {\n        bare_returns   : false,\n        ecma           : null,  // Legacy\n        expression     : false,\n        filename       : null,\n        html5_comments : true,\n        module         : false,\n        shebang        : true,\n        strict         : false,\n        toplevel       : null,\n    }, true);\n\n    var S = {\n        input         : (typeof $TEXT == \"string\"\n                         ? tokenizer($TEXT, options.filename,\n                                     options.html5_comments, options.shebang)\n                         : $TEXT),\n        token         : null,\n        prev          : null,\n        peeked        : null,\n        in_function   : 0,\n        in_async      : -1,\n        in_generator  : -1,\n        in_directives : true,\n        in_loop       : 0,\n        labels        : []\n    };\n\n    S.token = next();\n\n    function is(type, value) {\n        return is_token(S.token, type, value);\n    }\n\n    function peek() { return S.peeked || (S.peeked = S.input()); }\n\n    function next() {\n        S.prev = S.token;\n\n        if (!S.peeked) peek();\n        S.token = S.peeked;\n        S.peeked = null;\n        S.in_directives = S.in_directives && (\n            S.token.type == \"string\" || is(\"punc\", \";\")\n        );\n        return S.token;\n    }\n\n    function prev() {\n        return S.prev;\n    }\n\n    function croak(msg, line, col, pos) {\n        var ctx = S.input.context();\n        js_error(msg,\n                 ctx.filename,\n                 line != null ? line : ctx.tokline,\n                 col != null ? col : ctx.tokcol,\n                 pos != null ? pos : ctx.tokpos);\n    }\n\n    function token_error(token, msg) {\n        croak(msg, token.line, token.col);\n    }\n\n    function unexpected(token) {\n        if (token == null)\n            token = S.token;\n        token_error(token, \"Unexpected token: \" + token.type + \" (\" + token.value + \")\");\n    }\n\n    function expect_token(type, val) {\n        if (is(type, val)) {\n            return next();\n        }\n        token_error(S.token, \"Unexpected token \" + S.token.type + \" «\" + S.token.value + \"»\" + \", expected \" + type + \" «\" + val + \"»\");\n    }\n\n    function expect(punc) { return expect_token(\"punc\", punc); }\n\n    function has_newline_before(token) {\n        return token.nlb || !token.comments_before.every((comment) => !comment.nlb);\n    }\n\n    function can_insert_semicolon() {\n        return !options.strict\n            && (is(\"eof\") || is(\"punc\", \"}\") || has_newline_before(S.token));\n    }\n\n    function is_in_generator() {\n        return S.in_generator === S.in_function;\n    }\n\n    function is_in_async() {\n        return S.in_async === S.in_function;\n    }\n\n    function can_await() {\n        return (\n            S.in_async === S.in_function\n            || S.in_function === 0 && S.input.has_directive(\"use strict\")\n        );\n    }\n\n    function semicolon(optional) {\n        if (is(\"punc\", \";\")) next();\n        else if (!optional && !can_insert_semicolon()) unexpected();\n    }\n\n    function parenthesised() {\n        expect(\"(\");\n        var exp = expression(true);\n        expect(\")\");\n        return exp;\n    }\n\n    function embed_tokens(parser) {\n        return function _embed_tokens_wrapper(...args) {\n            const start = S.token;\n            const expr = parser(...args);\n            expr.start = start;\n            expr.end = prev();\n            return expr;\n        };\n    }\n\n    function handle_regexp() {\n        if (is(\"operator\", \"/\") || is(\"operator\", \"/=\")) {\n            S.peeked = null;\n            S.token = S.input(S.token.value.substr(1)); // force regexp\n        }\n    }\n\n    var statement = embed_tokens(function statement(is_export_default, is_for_body, is_if_body) {\n        handle_regexp();\n        switch (S.token.type) {\n          case \"string\":\n            if (S.in_directives) {\n                var token = peek();\n                if (!LATEST_RAW.includes(\"\\\\\")\n                    && (is_token(token, \"punc\", \";\")\n                        || is_token(token, \"punc\", \"}\")\n                        || has_newline_before(token)\n                        || is_token(token, \"eof\"))) {\n                    S.input.add_directive(S.token.value);\n                } else {\n                    S.in_directives = false;\n                }\n            }\n            var dir = S.in_directives, stat = simple_statement();\n            return dir && stat.body instanceof AST_String ? new AST_Directive(stat.body) : stat;\n          case \"template_head\":\n          case \"num\":\n          case \"big_int\":\n          case \"regexp\":\n          case \"operator\":\n          case \"atom\":\n            return simple_statement();\n\n          case \"name\":\n            if (S.token.value == \"async\" && is_token(peek(), \"keyword\", \"function\")) {\n                next();\n                next();\n                if (is_for_body) {\n                    croak(\"functions are not allowed as the body of a loop\");\n                }\n                return function_(AST_Defun, false, true, is_export_default);\n            }\n            if (S.token.value == \"import\" && !is_token(peek(), \"punc\", \"(\") && !is_token(peek(), \"punc\", \".\")) {\n                next();\n                var node = import_();\n                semicolon();\n                return node;\n            }\n            return is_token(peek(), \"punc\", \":\")\n                ? labeled_statement()\n                : simple_statement();\n\n          case \"punc\":\n            switch (S.token.value) {\n              case \"{\":\n                return new AST_BlockStatement({\n                    start : S.token,\n                    body  : block_(),\n                    end   : prev()\n                });\n              case \"[\":\n              case \"(\":\n                return simple_statement();\n              case \";\":\n                S.in_directives = false;\n                next();\n                return new AST_EmptyStatement();\n              default:\n                unexpected();\n            }\n\n          case \"keyword\":\n            switch (S.token.value) {\n              case \"break\":\n                next();\n                return break_cont(AST_Break);\n\n              case \"continue\":\n                next();\n                return break_cont(AST_Continue);\n\n              case \"debugger\":\n                next();\n                semicolon();\n                return new AST_Debugger();\n\n              case \"do\":\n                next();\n                var body = in_loop(statement);\n                expect_token(\"keyword\", \"while\");\n                var condition = parenthesised();\n                semicolon(true);\n                return new AST_Do({\n                    body      : body,\n                    condition : condition\n                });\n\n              case \"while\":\n                next();\n                return new AST_While({\n                    condition : parenthesised(),\n                    body      : in_loop(function() { return statement(false, true); })\n                });\n\n              case \"for\":\n                next();\n                return for_();\n\n              case \"class\":\n                next();\n                if (is_for_body) {\n                    croak(\"classes are not allowed as the body of a loop\");\n                }\n                if (is_if_body) {\n                    croak(\"classes are not allowed as the body of an if\");\n                }\n                return class_(AST_DefClass, is_export_default);\n\n              case \"function\":\n                next();\n                if (is_for_body) {\n                    croak(\"functions are not allowed as the body of a loop\");\n                }\n                return function_(AST_Defun, false, false, is_export_default);\n\n              case \"if\":\n                next();\n                return if_();\n\n              case \"return\":\n                if (S.in_function == 0 && !options.bare_returns)\n                    croak(\"'return' outside of function\");\n                next();\n                var value = null;\n                if (is(\"punc\", \";\")) {\n                    next();\n                } else if (!can_insert_semicolon()) {\n                    value = expression(true);\n                    semicolon();\n                }\n                return new AST_Return({\n                    value: value\n                });\n\n              case \"switch\":\n                next();\n                return new AST_Switch({\n                    expression : parenthesised(),\n                    body       : in_loop(switch_body_)\n                });\n\n              case \"throw\":\n                next();\n                if (has_newline_before(S.token))\n                    croak(\"Illegal newline after 'throw'\");\n                var value = expression(true);\n                semicolon();\n                return new AST_Throw({\n                    value: value\n                });\n\n              case \"try\":\n                next();\n                return try_();\n\n              case \"var\":\n                next();\n                var node = var_();\n                semicolon();\n                return node;\n\n              case \"let\":\n                next();\n                var node = let_();\n                semicolon();\n                return node;\n\n              case \"const\":\n                next();\n                var node = const_();\n                semicolon();\n                return node;\n\n              case \"with\":\n                if (S.input.has_directive(\"use strict\")) {\n                    croak(\"Strict mode may not include a with statement\");\n                }\n                next();\n                return new AST_With({\n                    expression : parenthesised(),\n                    body       : statement()\n                });\n\n              case \"export\":\n                if (!is_token(peek(), \"punc\", \"(\")) {\n                    next();\n                    var node = export_();\n                    if (is(\"punc\", \";\")) semicolon();\n                    return node;\n                }\n            }\n        }\n        unexpected();\n    });\n\n    function labeled_statement() {\n        var label = as_symbol(AST_Label);\n        if (label.name === \"await\" && is_in_async()) {\n            token_error(S.prev, \"await cannot be used as label inside async function\");\n        }\n        if (S.labels.some((l) => l.name === label.name)) {\n            // ECMA-262, 12.12: An ECMAScript program is considered\n            // syntactically incorrect if it contains a\n            // LabelledStatement that is enclosed by a\n            // LabelledStatement with the same Identifier as label.\n            croak(\"Label \" + label.name + \" defined twice\");\n        }\n        expect(\":\");\n        S.labels.push(label);\n        var stat = statement();\n        S.labels.pop();\n        if (!(stat instanceof AST_IterationStatement)) {\n            // check for `continue` that refers to this label.\n            // those should be reported as syntax errors.\n            // https://github.com/mishoo/UglifyJS2/issues/287\n            label.references.forEach(function(ref) {\n                if (ref instanceof AST_Continue) {\n                    ref = ref.label.start;\n                    croak(\"Continue label `\" + label.name + \"` refers to non-IterationStatement.\",\n                          ref.line, ref.col, ref.pos);\n                }\n            });\n        }\n        return new AST_LabeledStatement({ body: stat, label: label });\n    }\n\n    function simple_statement(tmp) {\n        return new AST_SimpleStatement({ body: (tmp = expression(true), semicolon(), tmp) });\n    }\n\n    function break_cont(type) {\n        var label = null, ldef;\n        if (!can_insert_semicolon()) {\n            label = as_symbol(AST_LabelRef, true);\n        }\n        if (label != null) {\n            ldef = S.labels.find((l) => l.name === label.name);\n            if (!ldef)\n                croak(\"Undefined label \" + label.name);\n            label.thedef = ldef;\n        } else if (S.in_loop == 0)\n            croak(type.TYPE + \" not inside a loop or switch\");\n        semicolon();\n        var stat = new type({ label: label });\n        if (ldef) ldef.references.push(stat);\n        return stat;\n    }\n\n    function for_() {\n        var for_await_error = \"`for await` invalid in this context\";\n        var await_tok = S.token;\n        if (await_tok.type == \"name\" && await_tok.value == \"await\") {\n            if (!can_await()) {\n                token_error(await_tok, for_await_error);\n            }\n            next();\n        } else {\n            await_tok = false;\n        }\n        expect(\"(\");\n        var init = null;\n        if (!is(\"punc\", \";\")) {\n            init =\n                is(\"keyword\", \"var\") ? (next(), var_(true)) :\n                is(\"keyword\", \"let\") ? (next(), let_(true)) :\n                is(\"keyword\", \"const\") ? (next(), const_(true)) :\n                                       expression(true, true);\n            var is_in = is(\"operator\", \"in\");\n            var is_of = is(\"name\", \"of\");\n            if (await_tok && !is_of) {\n                token_error(await_tok, for_await_error);\n            }\n            if (is_in || is_of) {\n                if (init instanceof AST_Definitions) {\n                    if (init.definitions.length > 1)\n                        token_error(init.start, \"Only one variable declaration allowed in for..in loop\");\n                } else if (!(is_assignable(init) || (init = to_destructuring(init)) instanceof AST_Destructuring)) {\n                    token_error(init.start, \"Invalid left-hand side in for..in loop\");\n                }\n                next();\n                if (is_in) {\n                    return for_in(init);\n                } else {\n                    return for_of(init, !!await_tok);\n                }\n            }\n        } else if (await_tok) {\n            token_error(await_tok, for_await_error);\n        }\n        return regular_for(init);\n    }\n\n    function regular_for(init) {\n        expect(\";\");\n        var test = is(\"punc\", \";\") ? null : expression(true);\n        expect(\";\");\n        var step = is(\"punc\", \")\") ? null : expression(true);\n        expect(\")\");\n        return new AST_For({\n            init      : init,\n            condition : test,\n            step      : step,\n            body      : in_loop(function() { return statement(false, true); })\n        });\n    }\n\n    function for_of(init, is_await) {\n        var lhs = init instanceof AST_Definitions ? init.definitions[0].name : null;\n        var obj = expression(true);\n        expect(\")\");\n        return new AST_ForOf({\n            await  : is_await,\n            init   : init,\n            name   : lhs,\n            object : obj,\n            body   : in_loop(function() { return statement(false, true); })\n        });\n    }\n\n    function for_in(init) {\n        var obj = expression(true);\n        expect(\")\");\n        return new AST_ForIn({\n            init   : init,\n            object : obj,\n            body   : in_loop(function() { return statement(false, true); })\n        });\n    }\n\n    var arrow_function = function(start, argnames, is_async) {\n        if (has_newline_before(S.token)) {\n            croak(\"Unexpected newline before arrow (=>)\");\n        }\n\n        expect_token(\"arrow\", \"=>\");\n\n        var body = _function_body(is(\"punc\", \"{\"), false, is_async);\n\n        var end =\n            body instanceof Array && body.length ? body[body.length - 1].end :\n            body instanceof Array ? start :\n                body.end;\n\n        return new AST_Arrow({\n            start    : start,\n            end      : end,\n            async    : is_async,\n            argnames : argnames,\n            body     : body\n        });\n    };\n\n    var function_ = function(ctor, is_generator_property, is_async, is_export_default) {\n        var in_statement = ctor === AST_Defun;\n        var is_generator = is(\"operator\", \"*\");\n        if (is_generator) {\n            next();\n        }\n\n        var name = is(\"name\") ? as_symbol(in_statement ? AST_SymbolDefun : AST_SymbolLambda) : null;\n        if (in_statement && !name) {\n            if (is_export_default) {\n                ctor = AST_Function;\n            } else {\n                unexpected();\n            }\n        }\n\n        if (name && ctor !== AST_Accessor && !(name instanceof AST_SymbolDeclaration))\n            unexpected(prev());\n\n        var args = [];\n        var body = _function_body(true, is_generator || is_generator_property, is_async, name, args);\n        return new ctor({\n            start : args.start,\n            end   : body.end,\n            is_generator: is_generator,\n            async : is_async,\n            name  : name,\n            argnames: args,\n            body  : body\n        });\n    };\n\n    function track_used_binding_identifiers(is_parameter, strict) {\n        var parameters = new Set();\n        var duplicate = false;\n        var default_assignment = false;\n        var spread = false;\n        var strict_mode = !!strict;\n        var tracker = {\n            add_parameter: function(token) {\n                if (parameters.has(token.value)) {\n                    if (duplicate === false) {\n                        duplicate = token;\n                    }\n                    tracker.check_strict();\n                } else {\n                    parameters.add(token.value);\n                    if (is_parameter) {\n                        switch (token.value) {\n                          case \"arguments\":\n                          case \"eval\":\n                          case \"yield\":\n                            if (strict_mode) {\n                                token_error(token, \"Unexpected \" + token.value + \" identifier as parameter inside strict mode\");\n                            }\n                            break;\n                          default:\n                            if (RESERVED_WORDS.has(token.value)) {\n                                unexpected();\n                            }\n                        }\n                    }\n                }\n            },\n            mark_default_assignment: function(token) {\n                if (default_assignment === false) {\n                    default_assignment = token;\n                }\n            },\n            mark_spread: function(token) {\n                if (spread === false) {\n                    spread = token;\n                }\n            },\n            mark_strict_mode: function() {\n                strict_mode = true;\n            },\n            is_strict: function() {\n                return default_assignment !== false || spread !== false || strict_mode;\n            },\n            check_strict: function() {\n                if (tracker.is_strict() && duplicate !== false) {\n                    token_error(duplicate, \"Parameter \" + duplicate.value + \" was used already\");\n                }\n            }\n        };\n\n        return tracker;\n    }\n\n    function parameters(params) {\n        var used_parameters = track_used_binding_identifiers(true, S.input.has_directive(\"use strict\"));\n\n        expect(\"(\");\n\n        while (!is(\"punc\", \")\")) {\n            var param = parameter(used_parameters);\n            params.push(param);\n\n            if (!is(\"punc\", \")\")) {\n                expect(\",\");\n            }\n\n            if (param instanceof AST_Expansion) {\n                break;\n            }\n        }\n\n        next();\n    }\n\n    function parameter(used_parameters, symbol_type) {\n        var param;\n        var expand = false;\n        if (used_parameters === undefined) {\n            used_parameters = track_used_binding_identifiers(true, S.input.has_directive(\"use strict\"));\n        }\n        if (is(\"expand\", \"...\")) {\n            expand = S.token;\n            used_parameters.mark_spread(S.token);\n            next();\n        }\n        param = binding_element(used_parameters, symbol_type);\n\n        if (is(\"operator\", \"=\") && expand === false) {\n            used_parameters.mark_default_assignment(S.token);\n            next();\n            param = new AST_DefaultAssign({\n                start: param.start,\n                left: param,\n                operator: \"=\",\n                right: expression(false),\n                end: S.token\n            });\n        }\n\n        if (expand !== false) {\n            if (!is(\"punc\", \")\")) {\n                unexpected();\n            }\n            param = new AST_Expansion({\n                start: expand,\n                expression: param,\n                end: expand\n            });\n        }\n        used_parameters.check_strict();\n\n        return param;\n    }\n\n    function binding_element(used_parameters, symbol_type) {\n        var elements = [];\n        var first = true;\n        var is_expand = false;\n        var expand_token;\n        var first_token = S.token;\n        if (used_parameters === undefined) {\n            used_parameters = track_used_binding_identifiers(false, S.input.has_directive(\"use strict\"));\n        }\n        symbol_type = symbol_type === undefined ? AST_SymbolFunarg : symbol_type;\n        if (is(\"punc\", \"[\")) {\n            next();\n            while (!is(\"punc\", \"]\")) {\n                if (first) {\n                    first = false;\n                } else {\n                    expect(\",\");\n                }\n\n                if (is(\"expand\", \"...\")) {\n                    is_expand = true;\n                    expand_token = S.token;\n                    used_parameters.mark_spread(S.token);\n                    next();\n                }\n                if (is(\"punc\")) {\n                    switch (S.token.value) {\n                      case \",\":\n                        elements.push(new AST_Hole({\n                            start: S.token,\n                            end: S.token\n                        }));\n                        continue;\n                      case \"]\": // Trailing comma after last element\n                        break;\n                      case \"[\":\n                      case \"{\":\n                        elements.push(binding_element(used_parameters, symbol_type));\n                        break;\n                      default:\n                        unexpected();\n                    }\n                } else if (is(\"name\")) {\n                    used_parameters.add_parameter(S.token);\n                    elements.push(as_symbol(symbol_type));\n                } else {\n                    croak(\"Invalid function parameter\");\n                }\n                if (is(\"operator\", \"=\") && is_expand === false) {\n                    used_parameters.mark_default_assignment(S.token);\n                    next();\n                    elements[elements.length - 1] = new AST_DefaultAssign({\n                        start: elements[elements.length - 1].start,\n                        left: elements[elements.length - 1],\n                        operator: \"=\",\n                        right: expression(false),\n                        end: S.token\n                    });\n                }\n                if (is_expand) {\n                    if (!is(\"punc\", \"]\")) {\n                        croak(\"Rest element must be last element\");\n                    }\n                    elements[elements.length - 1] = new AST_Expansion({\n                        start: expand_token,\n                        expression: elements[elements.length - 1],\n                        end: expand_token\n                    });\n                }\n            }\n            expect(\"]\");\n            used_parameters.check_strict();\n            return new AST_Destructuring({\n                start: first_token,\n                names: elements,\n                is_array: true,\n                end: prev()\n            });\n        } else if (is(\"punc\", \"{\")) {\n            next();\n            while (!is(\"punc\", \"}\")) {\n                if (first) {\n                    first = false;\n                } else {\n                    expect(\",\");\n                }\n                if (is(\"expand\", \"...\")) {\n                    is_expand = true;\n                    expand_token = S.token;\n                    used_parameters.mark_spread(S.token);\n                    next();\n                }\n                if (is(\"name\") && (is_token(peek(), \"punc\") || is_token(peek(), \"operator\")) && [\",\", \"}\", \"=\"].includes(peek().value)) {\n                    used_parameters.add_parameter(S.token);\n                    var start = prev();\n                    var value = as_symbol(symbol_type);\n                    if (is_expand) {\n                        elements.push(new AST_Expansion({\n                            start: expand_token,\n                            expression: value,\n                            end: value.end,\n                        }));\n                    } else {\n                        elements.push(new AST_ObjectKeyVal({\n                            start: start,\n                            key: value.name,\n                            value: value,\n                            end: value.end,\n                        }));\n                    }\n                } else if (is(\"punc\", \"}\")) {\n                    continue; // Allow trailing hole\n                } else {\n                    var property_token = S.token;\n                    var property = as_property_name();\n                    if (property === null) {\n                        unexpected(prev());\n                    } else if (prev().type === \"name\" && !is(\"punc\", \":\")) {\n                        elements.push(new AST_ObjectKeyVal({\n                            start: prev(),\n                            key: property,\n                            value: new symbol_type({\n                                start: prev(),\n                                name: property,\n                                end: prev()\n                            }),\n                            end: prev()\n                        }));\n                    } else {\n                        expect(\":\");\n                        elements.push(new AST_ObjectKeyVal({\n                            start: property_token,\n                            quote: property_token.quote,\n                            key: property,\n                            value: binding_element(used_parameters, symbol_type),\n                            end: prev()\n                        }));\n                    }\n                }\n                if (is_expand) {\n                    if (!is(\"punc\", \"}\")) {\n                        croak(\"Rest element must be last element\");\n                    }\n                } else if (is(\"operator\", \"=\")) {\n                    used_parameters.mark_default_assignment(S.token);\n                    next();\n                    elements[elements.length - 1].value = new AST_DefaultAssign({\n                        start: elements[elements.length - 1].value.start,\n                        left: elements[elements.length - 1].value,\n                        operator: \"=\",\n                        right: expression(false),\n                        end: S.token\n                    });\n                }\n            }\n            expect(\"}\");\n            used_parameters.check_strict();\n            return new AST_Destructuring({\n                start: first_token,\n                names: elements,\n                is_array: false,\n                end: prev()\n            });\n        } else if (is(\"name\")) {\n            used_parameters.add_parameter(S.token);\n            return as_symbol(symbol_type);\n        } else {\n            croak(\"Invalid function parameter\");\n        }\n    }\n\n    function params_or_seq_(allow_arrows, maybe_sequence) {\n        var spread_token;\n        var invalid_sequence;\n        var trailing_comma;\n        var a = [];\n        expect(\"(\");\n        while (!is(\"punc\", \")\")) {\n            if (spread_token) unexpected(spread_token);\n            if (is(\"expand\", \"...\")) {\n                spread_token = S.token;\n                if (maybe_sequence) invalid_sequence = S.token;\n                next();\n                a.push(new AST_Expansion({\n                    start: prev(),\n                    expression: expression(),\n                    end: S.token,\n                }));\n            } else {\n                a.push(expression());\n            }\n            if (!is(\"punc\", \")\")) {\n                expect(\",\");\n                if (is(\"punc\", \")\")) {\n                    trailing_comma = prev();\n                    if (maybe_sequence) invalid_sequence = trailing_comma;\n                }\n            }\n        }\n        expect(\")\");\n        if (allow_arrows && is(\"arrow\", \"=>\")) {\n            if (spread_token && trailing_comma) unexpected(trailing_comma);\n        } else if (invalid_sequence) {\n            unexpected(invalid_sequence);\n        }\n        return a;\n    }\n\n    function _function_body(block, generator, is_async, name, args) {\n        var loop = S.in_loop;\n        var labels = S.labels;\n        var current_generator = S.in_generator;\n        var current_async = S.in_async;\n        ++S.in_function;\n        if (generator)\n            S.in_generator = S.in_function;\n        if (is_async)\n            S.in_async = S.in_function;\n        if (args) parameters(args);\n        if (block)\n            S.in_directives = true;\n        S.in_loop = 0;\n        S.labels = [];\n        if (block) {\n            S.input.push_directives_stack();\n            var a = block_();\n            if (name) _verify_symbol(name);\n            if (args) args.forEach(_verify_symbol);\n            S.input.pop_directives_stack();\n        } else {\n            var a = [new AST_Return({\n                start: S.token,\n                value: expression(false),\n                end: S.token\n            })];\n        }\n        --S.in_function;\n        S.in_loop = loop;\n        S.labels = labels;\n        S.in_generator = current_generator;\n        S.in_async = current_async;\n        return a;\n    }\n\n    function _await_expression() {\n        // Previous token must be \"await\" and not be interpreted as an identifier\n        if (!can_await()) {\n            croak(\"Unexpected await expression outside async function\",\n                S.prev.line, S.prev.col, S.prev.pos);\n        }\n        // the await expression is parsed as a unary expression in Babel\n        return new AST_Await({\n            start: prev(),\n            end: S.token,\n            expression : maybe_unary(true),\n        });\n    }\n\n    function _yield_expression() {\n        // Previous token must be keyword yield and not be interpret as an identifier\n        if (!is_in_generator()) {\n            croak(\"Unexpected yield expression outside generator function\",\n                S.prev.line, S.prev.col, S.prev.pos);\n        }\n        var start = S.token;\n        var star = false;\n        var has_expression = true;\n\n        // Attempt to get expression or star (and then the mandatory expression)\n        // behind yield on the same line.\n        //\n        // If nothing follows on the same line of the yieldExpression,\n        // it should default to the value `undefined` for yield to return.\n        // In that case, the `undefined` stored as `null` in ast.\n        //\n        // Note 1: It isn't allowed for yield* to close without an expression\n        // Note 2: If there is a nlb between yield and star, it is interpret as\n        //         yield <explicit undefined> <inserted automatic semicolon> *\n        if (can_insert_semicolon() ||\n            (is(\"punc\") && PUNC_AFTER_EXPRESSION.has(S.token.value))) {\n            has_expression = false;\n\n        } else if (is(\"operator\", \"*\")) {\n            star = true;\n            next();\n        }\n\n        return new AST_Yield({\n            start      : start,\n            is_star    : star,\n            expression : has_expression ? expression() : null,\n            end        : prev()\n        });\n    }\n\n    function if_() {\n        var cond = parenthesised(), body = statement(false, false, true), belse = null;\n        if (is(\"keyword\", \"else\")) {\n            next();\n            belse = statement(false, false, true);\n        }\n        return new AST_If({\n            condition   : cond,\n            body        : body,\n            alternative : belse\n        });\n    }\n\n    function block_() {\n        expect(\"{\");\n        var a = [];\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) unexpected();\n            a.push(statement());\n        }\n        next();\n        return a;\n    }\n\n    function switch_body_() {\n        expect(\"{\");\n        var a = [], cur = null, branch = null, tmp;\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) unexpected();\n            if (is(\"keyword\", \"case\")) {\n                if (branch) branch.end = prev();\n                cur = [];\n                branch = new AST_Case({\n                    start      : (tmp = S.token, next(), tmp),\n                    expression : expression(true),\n                    body       : cur\n                });\n                a.push(branch);\n                expect(\":\");\n            } else if (is(\"keyword\", \"default\")) {\n                if (branch) branch.end = prev();\n                cur = [];\n                branch = new AST_Default({\n                    start : (tmp = S.token, next(), expect(\":\"), tmp),\n                    body  : cur\n                });\n                a.push(branch);\n            } else {\n                if (!cur) unexpected();\n                cur.push(statement());\n            }\n        }\n        if (branch) branch.end = prev();\n        next();\n        return a;\n    }\n\n    function try_() {\n        var body = block_(), bcatch = null, bfinally = null;\n        if (is(\"keyword\", \"catch\")) {\n            var start = S.token;\n            next();\n            if (is(\"punc\", \"{\")) {\n                var name = null;\n            } else {\n                expect(\"(\");\n                var name = parameter(undefined, AST_SymbolCatch);\n                expect(\")\");\n            }\n            bcatch = new AST_Catch({\n                start   : start,\n                argname : name,\n                body    : block_(),\n                end     : prev()\n            });\n        }\n        if (is(\"keyword\", \"finally\")) {\n            var start = S.token;\n            next();\n            bfinally = new AST_Finally({\n                start : start,\n                body  : block_(),\n                end   : prev()\n            });\n        }\n        if (!bcatch && !bfinally)\n            croak(\"Missing catch/finally blocks\");\n        return new AST_Try({\n            body     : body,\n            bcatch   : bcatch,\n            bfinally : bfinally\n        });\n    }\n\n    function vardefs(no_in, kind) {\n        var a = [];\n        var def;\n        for (;;) {\n            var sym_type =\n                kind === \"var\" ? AST_SymbolVar :\n                kind === \"const\" ? AST_SymbolConst :\n                kind === \"let\" ? AST_SymbolLet : null;\n            if (is(\"punc\", \"{\") || is(\"punc\", \"[\")) {\n                def = new AST_VarDef({\n                    start: S.token,\n                    name: binding_element(undefined ,sym_type),\n                    value: is(\"operator\", \"=\") ? (expect_token(\"operator\", \"=\"), expression(false, no_in)) : null,\n                    end: prev()\n                });\n            } else {\n                def = new AST_VarDef({\n                    start : S.token,\n                    name  : as_symbol(sym_type),\n                    value : is(\"operator\", \"=\")\n                        ? (next(), expression(false, no_in))\n                        : !no_in && kind === \"const\"\n                            ? croak(\"Missing initializer in const declaration\") : null,\n                    end   : prev()\n                });\n                if (def.name.name == \"import\") croak(\"Unexpected token: import\");\n            }\n            a.push(def);\n            if (!is(\"punc\", \",\"))\n                break;\n            next();\n        }\n        return a;\n    }\n\n    var var_ = function(no_in) {\n        return new AST_Var({\n            start       : prev(),\n            definitions : vardefs(no_in, \"var\"),\n            end         : prev()\n        });\n    };\n\n    var let_ = function(no_in) {\n        return new AST_Let({\n            start       : prev(),\n            definitions : vardefs(no_in, \"let\"),\n            end         : prev()\n        });\n    };\n\n    var const_ = function(no_in) {\n        return new AST_Const({\n            start       : prev(),\n            definitions : vardefs(no_in, \"const\"),\n            end         : prev()\n        });\n    };\n\n    var new_ = function(allow_calls) {\n        var start = S.token;\n        expect_token(\"operator\", \"new\");\n        if (is(\"punc\", \".\")) {\n            next();\n            expect_token(\"name\", \"target\");\n            return subscripts(new AST_NewTarget({\n                start : start,\n                end   : prev()\n            }), allow_calls);\n        }\n        var newexp = expr_atom(false), args;\n        if (is(\"punc\", \"(\")) {\n            next();\n            args = expr_list(\")\", true);\n        } else {\n            args = [];\n        }\n        var call = new AST_New({\n            start      : start,\n            expression : newexp,\n            args       : args,\n            end        : prev()\n        });\n        annotate(call);\n        return subscripts(call, allow_calls);\n    };\n\n    function as_atom_node() {\n        var tok = S.token, ret;\n        switch (tok.type) {\n          case \"name\":\n            ret = _make_symbol(AST_SymbolRef);\n            break;\n          case \"num\":\n            ret = new AST_Number({\n                start: tok,\n                end: tok,\n                value: tok.value,\n                raw: LATEST_RAW\n            });\n            break;\n          case \"big_int\":\n            ret = new AST_BigInt({ start: tok, end: tok, value: tok.value });\n            break;\n          case \"string\":\n            ret = new AST_String({\n                start : tok,\n                end   : tok,\n                value : tok.value,\n                quote : tok.quote\n            });\n            break;\n          case \"regexp\":\n            const [_, source, flags] = tok.value.match(/^\\/(.*)\\/(\\w*)$/);\n\n            ret = new AST_RegExp({ start: tok, end: tok, value: { source, flags } });\n            break;\n          case \"atom\":\n            switch (tok.value) {\n              case \"false\":\n                ret = new AST_False({ start: tok, end: tok });\n                break;\n              case \"true\":\n                ret = new AST_True({ start: tok, end: tok });\n                break;\n              case \"null\":\n                ret = new AST_Null({ start: tok, end: tok });\n                break;\n            }\n            break;\n        }\n        next();\n        return ret;\n    }\n\n    function to_fun_args(ex, default_seen_above) {\n        var insert_default = function(ex, default_value) {\n            if (default_value) {\n                return new AST_DefaultAssign({\n                    start: ex.start,\n                    left: ex,\n                    operator: \"=\",\n                    right: default_value,\n                    end: default_value.end\n                });\n            }\n            return ex;\n        };\n        if (ex instanceof AST_Object) {\n            return insert_default(new AST_Destructuring({\n                start: ex.start,\n                end: ex.end,\n                is_array: false,\n                names: ex.properties.map(prop => to_fun_args(prop))\n            }), default_seen_above);\n        } else if (ex instanceof AST_ObjectKeyVal) {\n            ex.value = to_fun_args(ex.value);\n            return insert_default(ex, default_seen_above);\n        } else if (ex instanceof AST_Hole) {\n            return ex;\n        } else if (ex instanceof AST_Destructuring) {\n            ex.names = ex.names.map(name => to_fun_args(name));\n            return insert_default(ex, default_seen_above);\n        } else if (ex instanceof AST_SymbolRef) {\n            return insert_default(new AST_SymbolFunarg({\n                name: ex.name,\n                start: ex.start,\n                end: ex.end\n            }), default_seen_above);\n        } else if (ex instanceof AST_Expansion) {\n            ex.expression = to_fun_args(ex.expression);\n            return insert_default(ex, default_seen_above);\n        } else if (ex instanceof AST_Array) {\n            return insert_default(new AST_Destructuring({\n                start: ex.start,\n                end: ex.end,\n                is_array: true,\n                names: ex.elements.map(elm => to_fun_args(elm))\n            }), default_seen_above);\n        } else if (ex instanceof AST_Assign) {\n            return insert_default(to_fun_args(ex.left, ex.right), default_seen_above);\n        } else if (ex instanceof AST_DefaultAssign) {\n            ex.left = to_fun_args(ex.left);\n            return ex;\n        } else {\n            croak(\"Invalid function parameter\", ex.start.line, ex.start.col);\n        }\n    }\n\n    var expr_atom = function(allow_calls, allow_arrows) {\n        if (is(\"operator\", \"new\")) {\n            return new_(allow_calls);\n        }\n        if (is(\"operator\", \"import\")) {\n            return import_meta();\n        }\n        var start = S.token;\n        var peeked;\n        var async = is(\"name\", \"async\")\n            && (peeked = peek()).value != \"[\"\n            && peeked.type != \"arrow\"\n            && as_atom_node();\n        if (is(\"punc\")) {\n            switch (S.token.value) {\n              case \"(\":\n                if (async && !allow_calls) break;\n                var exprs = params_or_seq_(allow_arrows, !async);\n                if (allow_arrows && is(\"arrow\", \"=>\")) {\n                    return arrow_function(start, exprs.map(e => to_fun_args(e)), !!async);\n                }\n                var ex = async ? new AST_Call({\n                    expression: async,\n                    args: exprs\n                }) : exprs.length == 1 ? exprs[0] : new AST_Sequence({\n                    expressions: exprs\n                });\n                if (ex.start) {\n                    const outer_comments_before = start.comments_before.length;\n                    outer_comments_before_counts.set(start, outer_comments_before);\n                    ex.start.comments_before.unshift(...start.comments_before);\n                    start.comments_before = ex.start.comments_before;\n                    if (outer_comments_before == 0 && start.comments_before.length > 0) {\n                        var comment = start.comments_before[0];\n                        if (!comment.nlb) {\n                            comment.nlb = start.nlb;\n                            start.nlb = false;\n                        }\n                    }\n                    start.comments_after = ex.start.comments_after;\n                }\n                ex.start = start;\n                var end = prev();\n                if (ex.end) {\n                    end.comments_before = ex.end.comments_before;\n                    ex.end.comments_after.push(...end.comments_after);\n                    end.comments_after = ex.end.comments_after;\n                }\n                ex.end = end;\n                if (ex instanceof AST_Call) annotate(ex);\n                return subscripts(ex, allow_calls);\n              case \"[\":\n                return subscripts(array_(), allow_calls);\n              case \"{\":\n                return subscripts(object_or_destructuring_(), allow_calls);\n            }\n            if (!async) unexpected();\n        }\n        if (allow_arrows && is(\"name\") && is_token(peek(), \"arrow\")) {\n            var param = new AST_SymbolFunarg({\n                name: S.token.value,\n                start: start,\n                end: start,\n            });\n            next();\n            return arrow_function(start, [param], !!async);\n        }\n        if (is(\"keyword\", \"function\")) {\n            next();\n            var func = function_(AST_Function, false, !!async);\n            func.start = start;\n            func.end = prev();\n            return subscripts(func, allow_calls);\n        }\n        if (async) return subscripts(async, allow_calls);\n        if (is(\"keyword\", \"class\")) {\n            next();\n            var cls = class_(AST_ClassExpression);\n            cls.start = start;\n            cls.end = prev();\n            return subscripts(cls, allow_calls);\n        }\n        if (is(\"template_head\")) {\n            return subscripts(template_string(), allow_calls);\n        }\n        if (ATOMIC_START_TOKEN.has(S.token.type)) {\n            return subscripts(as_atom_node(), allow_calls);\n        }\n        unexpected();\n    };\n\n    function template_string() {\n        var segments = [], start = S.token;\n\n        segments.push(new AST_TemplateSegment({\n            start: S.token,\n            raw: LATEST_RAW,\n            value: S.token.value,\n            end: S.token\n        }));\n\n        while (!LATEST_TEMPLATE_END) {\n            next();\n            handle_regexp();\n            segments.push(expression(true));\n\n            segments.push(new AST_TemplateSegment({\n                start: S.token,\n                raw: LATEST_RAW,\n                value: S.token.value,\n                end: S.token\n            }));\n        }\n        next();\n\n        return new AST_TemplateString({\n            start: start,\n            segments: segments,\n            end: S.token\n        });\n    }\n\n    function expr_list(closing, allow_trailing_comma, allow_empty) {\n        var first = true, a = [];\n        while (!is(\"punc\", closing)) {\n            if (first) first = false; else expect(\",\");\n            if (allow_trailing_comma && is(\"punc\", closing)) break;\n            if (is(\"punc\", \",\") && allow_empty) {\n                a.push(new AST_Hole({ start: S.token, end: S.token }));\n            } else if (is(\"expand\", \"...\")) {\n                next();\n                a.push(new AST_Expansion({start: prev(), expression: expression(),end: S.token}));\n            } else {\n                a.push(expression(false));\n            }\n        }\n        next();\n        return a;\n    }\n\n    var array_ = embed_tokens(function() {\n        expect(\"[\");\n        return new AST_Array({\n            elements: expr_list(\"]\", !options.strict, true)\n        });\n    });\n\n    var create_accessor = embed_tokens((is_generator, is_async) => {\n        return function_(AST_Accessor, is_generator, is_async);\n    });\n\n    var object_or_destructuring_ = embed_tokens(function object_or_destructuring_() {\n        var start = S.token, first = true, a = [];\n        expect(\"{\");\n        while (!is(\"punc\", \"}\")) {\n            if (first) first = false; else expect(\",\");\n            if (!options.strict && is(\"punc\", \"}\"))\n                // allow trailing comma\n                break;\n\n            start = S.token;\n            if (start.type == \"expand\") {\n                next();\n                a.push(new AST_Expansion({\n                    start: start,\n                    expression: expression(false),\n                    end: prev(),\n                }));\n                continue;\n            }\n\n            var name = as_property_name();\n            var value;\n\n            // Check property and fetch value\n            if (!is(\"punc\", \":\")) {\n                var concise = concise_method_or_getset(name, start);\n                if (concise) {\n                    a.push(concise);\n                    continue;\n                }\n\n                value = new AST_SymbolRef({\n                    start: prev(),\n                    name: name,\n                    end: prev()\n                });\n            } else if (name === null) {\n                unexpected(prev());\n            } else {\n                next(); // `:` - see first condition\n                value = expression(false);\n            }\n\n            // Check for default value and alter value accordingly if necessary\n            if (is(\"operator\", \"=\")) {\n                next();\n                value = new AST_Assign({\n                    start: start,\n                    left: value,\n                    operator: \"=\",\n                    right: expression(false),\n                    logical: false,\n                    end: prev()\n                });\n            }\n\n            // Create property\n            a.push(new AST_ObjectKeyVal({\n                start: start,\n                quote: start.quote,\n                key: name instanceof AST_Node ? name : \"\" + name,\n                value: value,\n                end: prev()\n            }));\n        }\n        next();\n        return new AST_Object({ properties: a });\n    });\n\n    function class_(KindOfClass, is_export_default) {\n        var start, method, class_name, extends_, a = [];\n\n        S.input.push_directives_stack(); // Push directive stack, but not scope stack\n        S.input.add_directive(\"use strict\");\n\n        if (S.token.type == \"name\" && S.token.value != \"extends\") {\n            class_name = as_symbol(KindOfClass === AST_DefClass ? AST_SymbolDefClass : AST_SymbolClass);\n        }\n\n        if (KindOfClass === AST_DefClass && !class_name) {\n            if (is_export_default) {\n                KindOfClass = AST_ClassExpression;\n            } else {\n                unexpected();\n            }\n        }\n\n        if (S.token.value == \"extends\") {\n            next();\n            extends_ = expression(true);\n        }\n\n        expect(\"{\");\n\n        while (is(\"punc\", \";\")) { next(); }  // Leading semicolons are okay in class bodies.\n        while (!is(\"punc\", \"}\")) {\n            start = S.token;\n            method = concise_method_or_getset(as_property_name(), start, true);\n            if (!method) { unexpected(); }\n            a.push(method);\n            while (is(\"punc\", \";\")) { next(); }\n        }\n\n        S.input.pop_directives_stack();\n\n        next();\n\n        return new KindOfClass({\n            start: start,\n            name: class_name,\n            extends: extends_,\n            properties: a,\n            end: prev(),\n        });\n    }\n\n    function concise_method_or_getset(name, start, is_class) {\n        const get_symbol_ast = (name, SymbolClass = AST_SymbolMethod) => {\n            if (typeof name === \"string\" || typeof name === \"number\") {\n                return new SymbolClass({\n                    start,\n                    name: \"\" + name,\n                    end: prev()\n                });\n            } else if (name === null) {\n                unexpected();\n            }\n            return name;\n        };\n\n        const is_not_method_start = () =>\n            !is(\"punc\", \"(\") && !is(\"punc\", \",\") && !is(\"punc\", \"}\") && !is(\"operator\", \"=\");\n\n        var is_async = false;\n        var is_static = false;\n        var is_generator = false;\n        var is_private = false;\n        var accessor_type = null;\n\n        if (is_class && name === \"static\" && is_not_method_start()) {\n            is_static = true;\n            name = as_property_name();\n        }\n        if (name === \"async\" && is_not_method_start()) {\n            is_async = true;\n            name = as_property_name();\n        }\n        if (prev().type === \"operator\" && prev().value === \"*\") {\n            is_generator = true;\n            name = as_property_name();\n        }\n        if ((name === \"get\" || name === \"set\") && is_not_method_start()) {\n            accessor_type = name;\n            name = as_property_name();\n        }\n        if (prev().type === \"privatename\") {\n            is_private = true;\n        }\n\n        const property_token = prev();\n\n        if (accessor_type != null) {\n            if (!is_private) {\n                const AccessorClass = accessor_type === \"get\"\n                    ? AST_ObjectGetter\n                    : AST_ObjectSetter;\n\n                name = get_symbol_ast(name);\n                return new AccessorClass({\n                    start,\n                    static: is_static,\n                    key: name,\n                    quote: name instanceof AST_SymbolMethod ? property_token.quote : undefined,\n                    value: create_accessor(),\n                    end: prev()\n                });\n            } else {\n                const AccessorClass = accessor_type === \"get\"\n                    ? AST_PrivateGetter\n                    : AST_PrivateSetter;\n\n                return new AccessorClass({\n                    start,\n                    static: is_static,\n                    key: get_symbol_ast(name),\n                    value: create_accessor(),\n                    end: prev(),\n                });\n            }\n        }\n\n        if (is(\"punc\", \"(\")) {\n            name = get_symbol_ast(name);\n            const AST_MethodVariant = is_private\n                ? AST_PrivateMethod\n                : AST_ConciseMethod;\n            var node = new AST_MethodVariant({\n                start       : start,\n                static      : is_static,\n                is_generator: is_generator,\n                async       : is_async,\n                key         : name,\n                quote       : name instanceof AST_SymbolMethod ?\n                              property_token.quote : undefined,\n                value       : create_accessor(is_generator, is_async),\n                end         : prev()\n            });\n            return node;\n        }\n\n        if (is_class) {\n            const key = get_symbol_ast(name, AST_SymbolClassProperty);\n            const quote = key instanceof AST_SymbolClassProperty\n                ? property_token.quote\n                : undefined;\n            const AST_ClassPropertyVariant = is_private\n                ? AST_ClassPrivateProperty\n                : AST_ClassProperty;\n            if (is(\"operator\", \"=\")) {\n                next();\n                return new AST_ClassPropertyVariant({\n                    start,\n                    static: is_static,\n                    quote,\n                    key,\n                    value: expression(false),\n                    end: prev()\n                });\n            } else if (\n                is(\"name\")\n                || is(\"privatename\")\n                || is(\"operator\", \"*\")\n                || is(\"punc\", \";\")\n                || is(\"punc\", \"}\")\n            ) {\n                return new AST_ClassPropertyVariant({\n                    start,\n                    static: is_static,\n                    quote,\n                    key,\n                    end: prev()\n                });\n            }\n        }\n    }\n\n    function import_() {\n        var start = prev();\n\n        var imported_name;\n        var imported_names;\n        if (is(\"name\")) {\n            imported_name = as_symbol(AST_SymbolImport);\n        }\n\n        if (is(\"punc\", \",\")) {\n            next();\n        }\n\n        imported_names = map_names(true);\n\n        if (imported_names || imported_name) {\n            expect_token(\"name\", \"from\");\n        }\n        var mod_str = S.token;\n        if (mod_str.type !== \"string\") {\n            unexpected();\n        }\n        next();\n        return new AST_Import({\n            start: start,\n            imported_name: imported_name,\n            imported_names: imported_names,\n            module_name: new AST_String({\n                start: mod_str,\n                value: mod_str.value,\n                quote: mod_str.quote,\n                end: mod_str,\n            }),\n            end: S.token,\n        });\n    }\n\n    function import_meta() {\n        var start = S.token;\n        expect_token(\"operator\", \"import\");\n        expect_token(\"punc\", \".\");\n        expect_token(\"name\", \"meta\");\n        return subscripts(new AST_ImportMeta({\n            start: start,\n            end: prev()\n        }), false);\n    }\n\n    function map_name(is_import) {\n        function make_symbol(type) {\n            return new type({\n                name: as_property_name(),\n                start: prev(),\n                end: prev()\n            });\n        }\n\n        var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;\n        var type = is_import ? AST_SymbolImport : AST_SymbolExport;\n        var start = S.token;\n        var foreign_name;\n        var name;\n\n        if (is_import) {\n            foreign_name = make_symbol(foreign_type);\n        } else {\n            name = make_symbol(type);\n        }\n        if (is(\"name\", \"as\")) {\n            next();  // The \"as\" word\n            if (is_import) {\n                name = make_symbol(type);\n            } else {\n                foreign_name = make_symbol(foreign_type);\n            }\n        } else if (is_import) {\n            name = new type(foreign_name);\n        } else {\n            foreign_name = new foreign_type(name);\n        }\n\n        return new AST_NameMapping({\n            start: start,\n            foreign_name: foreign_name,\n            name: name,\n            end: prev(),\n        });\n    }\n\n    function map_nameAsterisk(is_import, name) {\n        var foreign_type = is_import ? AST_SymbolImportForeign : AST_SymbolExportForeign;\n        var type = is_import ? AST_SymbolImport : AST_SymbolExport;\n        var start = S.token;\n        var foreign_name;\n        var end = prev();\n\n        name = name || new type({\n            name: \"*\",\n            start: start,\n            end: end,\n        });\n\n        foreign_name = new foreign_type({\n            name: \"*\",\n            start: start,\n            end: end,\n        });\n\n        return new AST_NameMapping({\n            start: start,\n            foreign_name: foreign_name,\n            name: name,\n            end: end,\n        });\n    }\n\n    function map_names(is_import) {\n        var names;\n        if (is(\"punc\", \"{\")) {\n            next();\n            names = [];\n            while (!is(\"punc\", \"}\")) {\n                names.push(map_name(is_import));\n                if (is(\"punc\", \",\")) {\n                    next();\n                }\n            }\n            next();\n        } else if (is(\"operator\", \"*\")) {\n            var name;\n            next();\n            if (is_import && is(\"name\", \"as\")) {\n                next();  // The \"as\" word\n                name = as_symbol(is_import ? AST_SymbolImport : AST_SymbolExportForeign);\n            }\n            names = [map_nameAsterisk(is_import, name)];\n        }\n        return names;\n    }\n\n    function export_() {\n        var start = S.token;\n        var is_default;\n        var exported_names;\n\n        if (is(\"keyword\", \"default\")) {\n            is_default = true;\n            next();\n        } else if (exported_names = map_names(false)) {\n            if (is(\"name\", \"from\")) {\n                next();\n\n                var mod_str = S.token;\n                if (mod_str.type !== \"string\") {\n                    unexpected();\n                }\n                next();\n\n                return new AST_Export({\n                    start: start,\n                    is_default: is_default,\n                    exported_names: exported_names,\n                    module_name: new AST_String({\n                        start: mod_str,\n                        value: mod_str.value,\n                        quote: mod_str.quote,\n                        end: mod_str,\n                    }),\n                    end: prev(),\n                });\n            } else {\n                return new AST_Export({\n                    start: start,\n                    is_default: is_default,\n                    exported_names: exported_names,\n                    end: prev(),\n                });\n            }\n        }\n\n        var node;\n        var exported_value;\n        var exported_definition;\n        if (is(\"punc\", \"{\")\n            || is_default\n                && (is(\"keyword\", \"class\") || is(\"keyword\", \"function\"))\n                && is_token(peek(), \"punc\")) {\n            exported_value = expression(false);\n            semicolon();\n        } else if ((node = statement(is_default)) instanceof AST_Definitions && is_default) {\n            unexpected(node.start);\n        } else if (\n            node instanceof AST_Definitions\n            || node instanceof AST_Defun\n            || node instanceof AST_DefClass\n        ) {\n            exported_definition = node;\n        } else if (\n            node instanceof AST_ClassExpression\n            || node instanceof AST_Function\n        ) {\n            exported_value = node;\n        } else if (node instanceof AST_SimpleStatement) {\n            exported_value = node.body;\n        } else {\n            unexpected(node.start);\n        }\n\n        return new AST_Export({\n            start: start,\n            is_default: is_default,\n            exported_value: exported_value,\n            exported_definition: exported_definition,\n            end: prev(),\n        });\n    }\n\n    function as_property_name() {\n        var tmp = S.token;\n        switch (tmp.type) {\n          case \"punc\":\n            if (tmp.value === \"[\") {\n                next();\n                var ex = expression(false);\n                expect(\"]\");\n                return ex;\n            } else unexpected(tmp);\n          case \"operator\":\n            if (tmp.value === \"*\") {\n                next();\n                return null;\n            }\n            if (![\"delete\", \"in\", \"instanceof\", \"new\", \"typeof\", \"void\"].includes(tmp.value)) {\n                unexpected(tmp);\n            }\n            /* falls through */\n          case \"name\":\n          case \"privatename\":\n          case \"string\":\n          case \"num\":\n          case \"big_int\":\n          case \"keyword\":\n          case \"atom\":\n            next();\n            return tmp.value;\n          default:\n            unexpected(tmp);\n        }\n    }\n\n    function as_name() {\n        var tmp = S.token;\n        if (tmp.type != \"name\" && tmp.type != \"privatename\") unexpected();\n        next();\n        return tmp.value;\n    }\n\n    function _make_symbol(type) {\n        var name = S.token.value;\n        return new (name == \"this\" ? AST_This :\n                    name == \"super\" ? AST_Super :\n                    type)({\n            name  : String(name),\n            start : S.token,\n            end   : S.token\n        });\n    }\n\n    function _verify_symbol(sym) {\n        var name = sym.name;\n        if (is_in_generator() && name == \"yield\") {\n            token_error(sym.start, \"Yield cannot be used as identifier inside generators\");\n        }\n        if (S.input.has_directive(\"use strict\")) {\n            if (name == \"yield\") {\n                token_error(sym.start, \"Unexpected yield identifier inside strict mode\");\n            }\n            if (sym instanceof AST_SymbolDeclaration && (name == \"arguments\" || name == \"eval\")) {\n                token_error(sym.start, \"Unexpected \" + name + \" in strict mode\");\n            }\n        }\n    }\n\n    function as_symbol(type, noerror) {\n        if (!is(\"name\")) {\n            if (!noerror) croak(\"Name expected\");\n            return null;\n        }\n        var sym = _make_symbol(type);\n        _verify_symbol(sym);\n        next();\n        return sym;\n    }\n\n    // Annotate AST_Call, AST_Lambda or AST_New with the special comments\n    function annotate(node) {\n        var start = node.start;\n        var comments = start.comments_before;\n        const comments_outside_parens = outer_comments_before_counts.get(start);\n        var i = comments_outside_parens != null ? comments_outside_parens : comments.length;\n        while (--i >= 0) {\n            var comment = comments[i];\n            if (/[@#]__/.test(comment.value)) {\n                if (/[@#]__PURE__/.test(comment.value)) {\n                    set_annotation(node, _PURE);\n                    break;\n                }\n                if (/[@#]__INLINE__/.test(comment.value)) {\n                    set_annotation(node, _INLINE);\n                    break;\n                }\n                if (/[@#]__NOINLINE__/.test(comment.value)) {\n                    set_annotation(node, _NOINLINE);\n                    break;\n                }\n            }\n        }\n    }\n\n    var subscripts = function(expr, allow_calls, is_chain) {\n        var start = expr.start;\n        if (is(\"punc\", \".\")) {\n            next();\n            const AST_DotVariant = is(\"privatename\") ? AST_DotHash : AST_Dot;\n            return subscripts(new AST_DotVariant({\n                start      : start,\n                expression : expr,\n                optional   : false,\n                property   : as_name(),\n                end        : prev()\n            }), allow_calls, is_chain);\n        }\n        if (is(\"punc\", \"[\")) {\n            next();\n            var prop = expression(true);\n            expect(\"]\");\n            return subscripts(new AST_Sub({\n                start      : start,\n                expression : expr,\n                optional   : false,\n                property   : prop,\n                end        : prev()\n            }), allow_calls, is_chain);\n        }\n        if (allow_calls && is(\"punc\", \"(\")) {\n            next();\n            var call = new AST_Call({\n                start      : start,\n                expression : expr,\n                optional   : false,\n                args       : call_args(),\n                end        : prev()\n            });\n            annotate(call);\n            return subscripts(call, true, is_chain);\n        }\n\n        if (is(\"punc\", \"?.\")) {\n            next();\n\n            let chain_contents;\n\n            if (allow_calls && is(\"punc\", \"(\")) {\n                next();\n\n                const call = new AST_Call({\n                    start,\n                    optional: true,\n                    expression: expr,\n                    args: call_args(),\n                    end: prev()\n                });\n                annotate(call);\n\n                chain_contents = subscripts(call, true, true);\n            } else if (is(\"name\") || is(\"privatename\")) {\n                const AST_DotVariant = is(\"privatename\") ? AST_DotHash : AST_Dot;\n                chain_contents = subscripts(new AST_DotVariant({\n                    start,\n                    expression: expr,\n                    optional: true,\n                    property: as_name(),\n                    end: prev()\n                }), allow_calls, true);\n            } else if (is(\"punc\", \"[\")) {\n                next();\n                const property = expression(true);\n                expect(\"]\");\n                chain_contents = subscripts(new AST_Sub({\n                    start,\n                    expression: expr,\n                    optional: true,\n                    property,\n                    end: prev()\n                }), allow_calls, true);\n            }\n\n            if (!chain_contents) unexpected();\n\n            if (chain_contents instanceof AST_Chain) return chain_contents;\n\n            return new AST_Chain({\n                start,\n                expression: chain_contents,\n                end: prev()\n            });\n        }\n\n        if (is(\"template_head\")) {\n            if (is_chain) {\n                // a?.b`c` is a syntax error\n                unexpected();\n            }\n\n            return subscripts(new AST_PrefixedTemplateString({\n                start: start,\n                prefix: expr,\n                template_string: template_string(),\n                end: prev()\n            }), allow_calls);\n        }\n\n        return expr;\n    };\n\n    function call_args() {\n        var args = [];\n        while (!is(\"punc\", \")\")) {\n            if (is(\"expand\", \"...\")) {\n                next();\n                args.push(new AST_Expansion({\n                    start: prev(),\n                    expression: expression(false),\n                    end: prev()\n                }));\n            } else {\n                args.push(expression(false));\n            }\n            if (!is(\"punc\", \")\")) {\n                expect(\",\");\n            }\n        }\n        next();\n        return args;\n    }\n\n    var maybe_unary = function(allow_calls, allow_arrows) {\n        var start = S.token;\n        if (start.type == \"name\" && start.value == \"await\" && can_await()) {\n            next();\n            return _await_expression();\n        }\n        if (is(\"operator\") && UNARY_PREFIX.has(start.value)) {\n            next();\n            handle_regexp();\n            var ex = make_unary(AST_UnaryPrefix, start, maybe_unary(allow_calls));\n            ex.start = start;\n            ex.end = prev();\n            return ex;\n        }\n        var val = expr_atom(allow_calls, allow_arrows);\n        while (is(\"operator\") && UNARY_POSTFIX.has(S.token.value) && !has_newline_before(S.token)) {\n            if (val instanceof AST_Arrow) unexpected();\n            val = make_unary(AST_UnaryPostfix, S.token, val);\n            val.start = start;\n            val.end = S.token;\n            next();\n        }\n        return val;\n    };\n\n    function make_unary(ctor, token, expr) {\n        var op = token.value;\n        switch (op) {\n          case \"++\":\n          case \"--\":\n            if (!is_assignable(expr))\n                croak(\"Invalid use of \" + op + \" operator\", token.line, token.col, token.pos);\n            break;\n          case \"delete\":\n            if (expr instanceof AST_SymbolRef && S.input.has_directive(\"use strict\"))\n                croak(\"Calling delete on expression not allowed in strict mode\", expr.start.line, expr.start.col, expr.start.pos);\n            break;\n        }\n        return new ctor({ operator: op, expression: expr });\n    }\n\n    var expr_op = function(left, min_prec, no_in) {\n        var op = is(\"operator\") ? S.token.value : null;\n        if (op == \"in\" && no_in) op = null;\n        if (op == \"**\" && left instanceof AST_UnaryPrefix\n            /* unary token in front not allowed - parenthesis required */\n            && !is_token(left.start, \"punc\", \"(\")\n            && left.operator !== \"--\" && left.operator !== \"++\")\n                unexpected(left.start);\n        var prec = op != null ? PRECEDENCE[op] : null;\n        if (prec != null && (prec > min_prec || (op === \"**\" && min_prec === prec))) {\n            next();\n            var right = expr_op(maybe_unary(true), prec, no_in);\n            return expr_op(new AST_Binary({\n                start    : left.start,\n                left     : left,\n                operator : op,\n                right    : right,\n                end      : right.end\n            }), min_prec, no_in);\n        }\n        return left;\n    };\n\n    function expr_ops(no_in) {\n        return expr_op(maybe_unary(true, true), 0, no_in);\n    }\n\n    var maybe_conditional = function(no_in) {\n        var start = S.token;\n        var expr = expr_ops(no_in);\n        if (is(\"operator\", \"?\")) {\n            next();\n            var yes = expression(false);\n            expect(\":\");\n            return new AST_Conditional({\n                start       : start,\n                condition   : expr,\n                consequent  : yes,\n                alternative : expression(false, no_in),\n                end         : prev()\n            });\n        }\n        return expr;\n    };\n\n    function is_assignable(expr) {\n        return expr instanceof AST_PropAccess || expr instanceof AST_SymbolRef;\n    }\n\n    function to_destructuring(node) {\n        if (node instanceof AST_Object) {\n            node = new AST_Destructuring({\n                start: node.start,\n                names: node.properties.map(to_destructuring),\n                is_array: false,\n                end: node.end\n            });\n        } else if (node instanceof AST_Array) {\n            var names = [];\n\n            for (var i = 0; i < node.elements.length; i++) {\n                // Only allow expansion as last element\n                if (node.elements[i] instanceof AST_Expansion) {\n                    if (i + 1 !== node.elements.length) {\n                        token_error(node.elements[i].start, \"Spread must the be last element in destructuring array\");\n                    }\n                    node.elements[i].expression = to_destructuring(node.elements[i].expression);\n                }\n\n                names.push(to_destructuring(node.elements[i]));\n            }\n\n            node = new AST_Destructuring({\n                start: node.start,\n                names: names,\n                is_array: true,\n                end: node.end\n            });\n        } else if (node instanceof AST_ObjectProperty) {\n            node.value = to_destructuring(node.value);\n        } else if (node instanceof AST_Assign) {\n            node = new AST_DefaultAssign({\n                start: node.start,\n                left: node.left,\n                operator: \"=\",\n                right: node.right,\n                end: node.end\n            });\n        }\n        return node;\n    }\n\n    // In ES6, AssignmentExpression can also be an ArrowFunction\n    var maybe_assign = function(no_in) {\n        handle_regexp();\n        var start = S.token;\n\n        if (start.type == \"name\" && start.value == \"yield\") {\n            if (is_in_generator()) {\n                next();\n                return _yield_expression();\n            } else if (S.input.has_directive(\"use strict\")) {\n                token_error(S.token, \"Unexpected yield identifier inside strict mode\");\n            }\n        }\n\n        var left = maybe_conditional(no_in);\n        var val = S.token.value;\n\n        if (is(\"operator\") && ASSIGNMENT.has(val)) {\n            if (is_assignable(left) || (left = to_destructuring(left)) instanceof AST_Destructuring) {\n                next();\n\n                return new AST_Assign({\n                    start    : start,\n                    left     : left,\n                    operator : val,\n                    right    : maybe_assign(no_in),\n                    logical  : LOGICAL_ASSIGNMENT.has(val),\n                    end      : prev()\n                });\n            }\n            croak(\"Invalid assignment\");\n        }\n        return left;\n    };\n\n    var expression = function(commas, no_in) {\n        var start = S.token;\n        var exprs = [];\n        while (true) {\n            exprs.push(maybe_assign(no_in));\n            if (!commas || !is(\"punc\", \",\")) break;\n            next();\n            commas = true;\n        }\n        return exprs.length == 1 ? exprs[0] : new AST_Sequence({\n            start       : start,\n            expressions : exprs,\n            end         : peek()\n        });\n    };\n\n    function in_loop(cont) {\n        ++S.in_loop;\n        var ret = cont();\n        --S.in_loop;\n        return ret;\n    }\n\n    if (options.expression) {\n        return expression(true);\n    }\n\n    return (function parse_toplevel() {\n        var start = S.token;\n        var body = [];\n        S.input.push_directives_stack();\n        if (options.module) S.input.add_directive(\"use strict\");\n        while (!is(\"eof\")) {\n            body.push(statement());\n        }\n        S.input.pop_directives_stack();\n        var end = prev();\n        var toplevel = options.toplevel;\n        if (toplevel) {\n            toplevel.body = toplevel.body.concat(body);\n            toplevel.end = end;\n        } else {\n            toplevel = new AST_Toplevel({ start: start, body: body, end: end });\n        }\n        return toplevel;\n    })();\n\n}\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nfunction DEFNODE(type, props, methods, base = AST_Node) {\n    if (!props) props = [];\n    else props = props.split(/\\s+/);\n    var self_props = props;\n    if (base && base.PROPS)\n        props = props.concat(base.PROPS);\n    var code = \"return function AST_\" + type + \"(props){ if (props) { \";\n    for (var i = props.length; --i >= 0;) {\n        code += \"this.\" + props[i] + \" = props.\" + props[i] + \";\";\n    }\n    const proto = base && Object.create(base.prototype);\n    if (proto && proto.initialize || (methods && methods.initialize))\n        code += \"this.initialize();\";\n    code += \"}\";\n    code += \"this.flags = 0;\";\n    code += \"}\";\n    var ctor = new Function(code)();\n    if (proto) {\n        ctor.prototype = proto;\n        ctor.BASE = base;\n    }\n    if (base) base.SUBCLASSES.push(ctor);\n    ctor.prototype.CTOR = ctor;\n    ctor.prototype.constructor = ctor;\n    ctor.PROPS = props || null;\n    ctor.SELF_PROPS = self_props;\n    ctor.SUBCLASSES = [];\n    if (type) {\n        ctor.prototype.TYPE = ctor.TYPE = type;\n    }\n    if (methods) for (i in methods) if (HOP(methods, i)) {\n        if (i[0] === \"$\") {\n            ctor[i.substr(1)] = methods[i];\n        } else {\n            ctor.prototype[i] = methods[i];\n        }\n    }\n    ctor.DEFMETHOD = function(name, method) {\n        this.prototype[name] = method;\n    };\n    return ctor;\n}\n\nconst has_tok_flag = (tok, flag) => Boolean(tok.flags & flag);\nconst set_tok_flag = (tok, flag, truth) => {\n    if (truth) {\n        tok.flags |= flag;\n    } else {\n        tok.flags &= ~flag;\n    }\n};\n\nconst TOK_FLAG_NLB          = 0b0001;\nconst TOK_FLAG_QUOTE_SINGLE = 0b0010;\nconst TOK_FLAG_QUOTE_EXISTS = 0b0100;\n\nclass AST_Token {\n    constructor(type, value, line, col, pos, nlb, comments_before, comments_after, file) {\n        this.flags = (nlb ? 1 : 0);\n\n        this.type = type;\n        this.value = value;\n        this.line = line;\n        this.col = col;\n        this.pos = pos;\n        this.comments_before = comments_before;\n        this.comments_after = comments_after;\n        this.file = file;\n\n        Object.seal(this);\n    }\n\n    get nlb() {\n        return has_tok_flag(this, TOK_FLAG_NLB);\n    }\n\n    set nlb(new_nlb) {\n        set_tok_flag(this, TOK_FLAG_NLB, new_nlb);\n    }\n\n    get quote() {\n        return !has_tok_flag(this, TOK_FLAG_QUOTE_EXISTS)\n            ? \"\"\n            : (has_tok_flag(this, TOK_FLAG_QUOTE_SINGLE) ? \"'\" : '\"');\n    }\n\n    set quote(quote_type) {\n        set_tok_flag(this, TOK_FLAG_QUOTE_SINGLE, quote_type === \"'\");\n        set_tok_flag(this, TOK_FLAG_QUOTE_EXISTS, !!quote_type);\n    }\n}\n\nvar AST_Node = DEFNODE(\"Node\", \"start end\", {\n    _clone: function(deep) {\n        if (deep) {\n            var self = this.clone();\n            return self.transform(new TreeTransformer(function(node) {\n                if (node !== self) {\n                    return node.clone(true);\n                }\n            }));\n        }\n        return new this.CTOR(this);\n    },\n    clone: function(deep) {\n        return this._clone(deep);\n    },\n    $documentation: \"Base class of all AST nodes\",\n    $propdoc: {\n        start: \"[AST_Token] The first token of this node\",\n        end: \"[AST_Token] The last token of this node\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this);\n    },\n    walk: function(visitor) {\n        return this._walk(visitor); // not sure the indirection will be any help\n    },\n    _children_backwards: () => {}\n}, null);\n\n/* -----[ statements ]----- */\n\nvar AST_Statement = DEFNODE(\"Statement\", null, {\n    $documentation: \"Base class of all statements\",\n});\n\nvar AST_Debugger = DEFNODE(\"Debugger\", null, {\n    $documentation: \"Represents a debugger statement\",\n}, AST_Statement);\n\nvar AST_Directive = DEFNODE(\"Directive\", \"value quote\", {\n    $documentation: \"Represents a directive, like \\\"use strict\\\";\",\n    $propdoc: {\n        value: \"[string] The value of this directive as a plain string (it's not an AST_String!)\",\n        quote: \"[string] the original quote character\"\n    },\n}, AST_Statement);\n\nvar AST_SimpleStatement = DEFNODE(\"SimpleStatement\", \"body\", {\n    $documentation: \"A statement consisting of an expression, i.e. a = 1 + 2\",\n    $propdoc: {\n        body: \"[AST_Node] an expression node (should not be instanceof AST_Statement)\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.body._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.body);\n    }\n}, AST_Statement);\n\nfunction walk_body(node, visitor) {\n    const body = node.body;\n    for (var i = 0, len = body.length; i < len; i++) {\n        body[i]._walk(visitor);\n    }\n}\n\nfunction clone_block_scope(deep) {\n    var clone = this._clone(deep);\n    if (this.block_scope) {\n        clone.block_scope = this.block_scope.clone();\n    }\n    return clone;\n}\n\nvar AST_Block = DEFNODE(\"Block\", \"body block_scope\", {\n    $documentation: \"A body of statements (usually braced)\",\n    $propdoc: {\n        body: \"[AST_Statement*] an array of statements\",\n        block_scope: \"[AST_Scope] the block scope\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            walk_body(this, visitor);\n        });\n    },\n    _children_backwards(push) {\n        let i = this.body.length;\n        while (i--) push(this.body[i]);\n    },\n    clone: clone_block_scope\n}, AST_Statement);\n\nvar AST_BlockStatement = DEFNODE(\"BlockStatement\", null, {\n    $documentation: \"A block statement\",\n}, AST_Block);\n\nvar AST_EmptyStatement = DEFNODE(\"EmptyStatement\", null, {\n    $documentation: \"The empty statement (empty block or simply a semicolon)\"\n}, AST_Statement);\n\nvar AST_StatementWithBody = DEFNODE(\"StatementWithBody\", \"body\", {\n    $documentation: \"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`\",\n    $propdoc: {\n        body: \"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement\"\n    }\n}, AST_Statement);\n\nvar AST_LabeledStatement = DEFNODE(\"LabeledStatement\", \"label\", {\n    $documentation: \"Statement with a label\",\n    $propdoc: {\n        label: \"[AST_Label] a label definition\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.label._walk(visitor);\n            this.body._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.body);\n        push(this.label);\n    },\n    clone: function(deep) {\n        var node = this._clone(deep);\n        if (deep) {\n            var label = node.label;\n            var def = this.label;\n            node.walk(new TreeWalker(function(node) {\n                if (node instanceof AST_LoopControl\n                    && node.label && node.label.thedef === def) {\n                    node.label.thedef = label;\n                    label.references.push(node);\n                }\n            }));\n        }\n        return node;\n    }\n}, AST_StatementWithBody);\n\nvar AST_IterationStatement = DEFNODE(\"IterationStatement\", \"block_scope\", {\n    $documentation: \"Internal class.  All loops inherit from it.\",\n    $propdoc: {\n        block_scope: \"[AST_Scope] the block scope for this iteration statement.\"\n    },\n    clone: clone_block_scope\n}, AST_StatementWithBody);\n\nvar AST_DWLoop = DEFNODE(\"DWLoop\", \"condition\", {\n    $documentation: \"Base class for do/while statements\",\n    $propdoc: {\n        condition: \"[AST_Node] the loop condition.  Should not be instanceof AST_Statement\"\n    }\n}, AST_IterationStatement);\n\nvar AST_Do = DEFNODE(\"Do\", null, {\n    $documentation: \"A `do` statement\",\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.body._walk(visitor);\n            this.condition._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.condition);\n        push(this.body);\n    }\n}, AST_DWLoop);\n\nvar AST_While = DEFNODE(\"While\", null, {\n    $documentation: \"A `while` statement\",\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.condition._walk(visitor);\n            this.body._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.body);\n        push(this.condition);\n    },\n}, AST_DWLoop);\n\nvar AST_For = DEFNODE(\"For\", \"init condition step\", {\n    $documentation: \"A `for` statement\",\n    $propdoc: {\n        init: \"[AST_Node?] the `for` initialization code, or null if empty\",\n        condition: \"[AST_Node?] the `for` termination clause, or null if empty\",\n        step: \"[AST_Node?] the `for` update clause, or null if empty\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            if (this.init) this.init._walk(visitor);\n            if (this.condition) this.condition._walk(visitor);\n            if (this.step) this.step._walk(visitor);\n            this.body._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.body);\n        if (this.step) push(this.step);\n        if (this.condition) push(this.condition);\n        if (this.init) push(this.init);\n    },\n}, AST_IterationStatement);\n\nvar AST_ForIn = DEFNODE(\"ForIn\", \"init object\", {\n    $documentation: \"A `for ... in` statement\",\n    $propdoc: {\n        init: \"[AST_Node] the `for/in` initialization code\",\n        object: \"[AST_Node] the object that we're looping through\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.init._walk(visitor);\n            this.object._walk(visitor);\n            this.body._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.body);\n        if (this.object) push(this.object);\n        if (this.init) push(this.init);\n    },\n}, AST_IterationStatement);\n\nvar AST_ForOf = DEFNODE(\"ForOf\", \"await\", {\n    $documentation: \"A `for ... of` statement\",\n}, AST_ForIn);\n\nvar AST_With = DEFNODE(\"With\", \"expression\", {\n    $documentation: \"A `with` statement\",\n    $propdoc: {\n        expression: \"[AST_Node] the `with` expression\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n            this.body._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.body);\n        push(this.expression);\n    },\n}, AST_StatementWithBody);\n\n/* -----[ scope and functions ]----- */\n\nvar AST_Scope = DEFNODE(\"Scope\", \"variables functions uses_with uses_eval parent_scope enclosed cname\", {\n    $documentation: \"Base class for all statements introducing a lexical scope\",\n    $propdoc: {\n        variables: \"[Map/S] a map of name -> SymbolDef for all variables/functions defined in this scope\",\n        uses_with: \"[boolean/S] tells whether this scope uses the `with` statement\",\n        uses_eval: \"[boolean/S] tells whether this scope contains a direct call to the global `eval`\",\n        parent_scope: \"[AST_Scope?/S] link to the parent scope\",\n        enclosed: \"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes\",\n        cname: \"[integer/S] current index for mangling variables (used internally by the mangler)\",\n    },\n    get_defun_scope: function() {\n        var self = this;\n        while (self.is_block_scope()) {\n            self = self.parent_scope;\n        }\n        return self;\n    },\n    clone: function(deep, toplevel) {\n        var node = this._clone(deep);\n        if (deep && this.variables && toplevel && !this._block_scope) {\n            node.figure_out_scope({}, {\n                toplevel: toplevel,\n                parent_scope: this.parent_scope\n            });\n        } else {\n            if (this.variables) node.variables = new Map(this.variables);\n            if (this.enclosed) node.enclosed = this.enclosed.slice();\n            if (this._block_scope) node._block_scope = this._block_scope;\n        }\n        return node;\n    },\n    pinned: function() {\n        return this.uses_eval || this.uses_with;\n    }\n}, AST_Block);\n\nvar AST_Toplevel = DEFNODE(\"Toplevel\", \"globals\", {\n    $documentation: \"The toplevel scope\",\n    $propdoc: {\n        globals: \"[Map/S] a map of name -> SymbolDef for all undeclared names\",\n    },\n    wrap_commonjs: function(name) {\n        var body = this.body;\n        var wrapped_tl = \"(function(exports){'$ORIG';})(typeof \" + name + \"=='undefined'?(\" + name + \"={}):\" + name + \");\";\n        wrapped_tl = parse(wrapped_tl);\n        wrapped_tl = wrapped_tl.transform(new TreeTransformer(function(node) {\n            if (node instanceof AST_Directive && node.value == \"$ORIG\") {\n                return MAP.splice(body);\n            }\n        }));\n        return wrapped_tl;\n    },\n    wrap_enclose: function(args_values) {\n        if (typeof args_values != \"string\") args_values = \"\";\n        var index = args_values.indexOf(\":\");\n        if (index < 0) index = args_values.length;\n        var body = this.body;\n        return parse([\n            \"(function(\",\n            args_values.slice(0, index),\n            '){\"$ORIG\"})(',\n            args_values.slice(index + 1),\n            \")\"\n        ].join(\"\")).transform(new TreeTransformer(function(node) {\n            if (node instanceof AST_Directive && node.value == \"$ORIG\") {\n                return MAP.splice(body);\n            }\n        }));\n    }\n}, AST_Scope);\n\nvar AST_Expansion = DEFNODE(\"Expansion\", \"expression\", {\n    $documentation: \"An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such as var [first, ...rest] = list\",\n    $propdoc: {\n        expression: \"[AST_Node] the thing to be expanded\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression.walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.expression);\n    },\n});\n\nvar AST_Lambda = DEFNODE(\"Lambda\", \"name argnames uses_arguments is_generator async\", {\n    $documentation: \"Base class for functions\",\n    $propdoc: {\n        name: \"[AST_SymbolDeclaration?] the name of this function\",\n        argnames: \"[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or expanding arguments\",\n        uses_arguments: \"[boolean/S] tells whether this function accesses the arguments array\",\n        is_generator: \"[boolean] is this a generator method\",\n        async: \"[boolean] is this method async\",\n    },\n    args_as_names: function () {\n        var out = [];\n        for (var i = 0; i < this.argnames.length; i++) {\n            if (this.argnames[i] instanceof AST_Destructuring) {\n                out.push(...this.argnames[i].all_symbols());\n            } else {\n                out.push(this.argnames[i]);\n            }\n        }\n        return out;\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            if (this.name) this.name._walk(visitor);\n            var argnames = this.argnames;\n            for (var i = 0, len = argnames.length; i < len; i++) {\n                argnames[i]._walk(visitor);\n            }\n            walk_body(this, visitor);\n        });\n    },\n    _children_backwards(push) {\n        let i = this.body.length;\n        while (i--) push(this.body[i]);\n\n        i = this.argnames.length;\n        while (i--) push(this.argnames[i]);\n\n        if (this.name) push(this.name);\n    },\n    is_braceless() {\n        return this.body[0] instanceof AST_Return && this.body[0].value;\n    },\n    // Default args and expansion don't count, so .argnames.length doesn't cut it\n    length_property() {\n        let length = 0;\n\n        for (const arg of this.argnames) {\n            if (arg instanceof AST_SymbolFunarg || arg instanceof AST_Destructuring) {\n                length++;\n            }\n        }\n\n        return length;\n    }\n}, AST_Scope);\n\nvar AST_Accessor = DEFNODE(\"Accessor\", null, {\n    $documentation: \"A setter/getter function.  The `name` property is always null.\"\n}, AST_Lambda);\n\nvar AST_Function = DEFNODE(\"Function\", null, {\n    $documentation: \"A function expression\"\n}, AST_Lambda);\n\nvar AST_Arrow = DEFNODE(\"Arrow\", null, {\n    $documentation: \"An ES6 Arrow function ((a) => b)\"\n}, AST_Lambda);\n\nvar AST_Defun = DEFNODE(\"Defun\", null, {\n    $documentation: \"A function definition\"\n}, AST_Lambda);\n\n/* -----[ DESTRUCTURING ]----- */\nvar AST_Destructuring = DEFNODE(\"Destructuring\", \"names is_array\", {\n    $documentation: \"A destructuring of several names. Used in destructuring assignment and with destructuring function argument names\",\n    $propdoc: {\n        \"names\": \"[AST_Node*] Array of properties or elements\",\n        \"is_array\": \"[Boolean] Whether the destructuring represents an object or array\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.names.forEach(function(name) {\n                name._walk(visitor);\n            });\n        });\n    },\n    _children_backwards(push) {\n        let i = this.names.length;\n        while (i--) push(this.names[i]);\n    },\n    all_symbols: function() {\n        var out = [];\n        this.walk(new TreeWalker(function (node) {\n            if (node instanceof AST_Symbol) {\n                out.push(node);\n            }\n        }));\n        return out;\n    }\n});\n\nvar AST_PrefixedTemplateString = DEFNODE(\"PrefixedTemplateString\", \"template_string prefix\", {\n    $documentation: \"A templatestring with a prefix, such as String.raw`foobarbaz`\",\n    $propdoc: {\n        template_string: \"[AST_TemplateString] The template string\",\n        prefix: \"[AST_Node] The prefix, which will get called.\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function () {\n            this.prefix._walk(visitor);\n            this.template_string._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.template_string);\n        push(this.prefix);\n    },\n});\n\nvar AST_TemplateString = DEFNODE(\"TemplateString\", \"segments\", {\n    $documentation: \"A template string literal\",\n    $propdoc: {\n        segments: \"[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_Node must be followed by AST_TemplateSegment.\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.segments.forEach(function(seg) {\n                seg._walk(visitor);\n            });\n        });\n    },\n    _children_backwards(push) {\n        let i = this.segments.length;\n        while (i--) push(this.segments[i]);\n    }\n});\n\nvar AST_TemplateSegment = DEFNODE(\"TemplateSegment\", \"value raw\", {\n    $documentation: \"A segment of a template string literal\",\n    $propdoc: {\n        value: \"Content of the segment\",\n        raw: \"Raw source of the segment\",\n    }\n});\n\n/* -----[ JUMPS ]----- */\n\nvar AST_Jump = DEFNODE(\"Jump\", null, {\n    $documentation: \"Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)\"\n}, AST_Statement);\n\nvar AST_Exit = DEFNODE(\"Exit\", \"value\", {\n    $documentation: \"Base class for “exits” (`return` and `throw`)\",\n    $propdoc: {\n        value: \"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, this.value && function() {\n            this.value._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.value) push(this.value);\n    },\n}, AST_Jump);\n\nvar AST_Return = DEFNODE(\"Return\", null, {\n    $documentation: \"A `return` statement\"\n}, AST_Exit);\n\nvar AST_Throw = DEFNODE(\"Throw\", null, {\n    $documentation: \"A `throw` statement\"\n}, AST_Exit);\n\nvar AST_LoopControl = DEFNODE(\"LoopControl\", \"label\", {\n    $documentation: \"Base class for loop control statements (`break` and `continue`)\",\n    $propdoc: {\n        label: \"[AST_LabelRef?] the label, or null if none\",\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, this.label && function() {\n            this.label._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.label) push(this.label);\n    },\n}, AST_Jump);\n\nvar AST_Break = DEFNODE(\"Break\", null, {\n    $documentation: \"A `break` statement\"\n}, AST_LoopControl);\n\nvar AST_Continue = DEFNODE(\"Continue\", null, {\n    $documentation: \"A `continue` statement\"\n}, AST_LoopControl);\n\nvar AST_Await = DEFNODE(\"Await\", \"expression\", {\n    $documentation: \"An `await` statement\",\n    $propdoc: {\n        expression: \"[AST_Node] the mandatory expression being awaited\",\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.expression);\n    },\n});\n\nvar AST_Yield = DEFNODE(\"Yield\", \"expression is_star\", {\n    $documentation: \"A `yield` statement\",\n    $propdoc: {\n        expression: \"[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star is set to false\",\n        is_star: \"[Boolean] Whether this is a yield or yield* statement\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, this.expression && function() {\n            this.expression._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.expression) push(this.expression);\n    }\n});\n\n/* -----[ IF ]----- */\n\nvar AST_If = DEFNODE(\"If\", \"condition alternative\", {\n    $documentation: \"A `if` statement\",\n    $propdoc: {\n        condition: \"[AST_Node] the `if` condition\",\n        alternative: \"[AST_Statement?] the `else` part, or null if not present\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.condition._walk(visitor);\n            this.body._walk(visitor);\n            if (this.alternative) this.alternative._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.alternative) {\n            push(this.alternative);\n        }\n        push(this.body);\n        push(this.condition);\n    }\n}, AST_StatementWithBody);\n\n/* -----[ SWITCH ]----- */\n\nvar AST_Switch = DEFNODE(\"Switch\", \"expression\", {\n    $documentation: \"A `switch` statement\",\n    $propdoc: {\n        expression: \"[AST_Node] the `switch` “discriminant”\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n            walk_body(this, visitor);\n        });\n    },\n    _children_backwards(push) {\n        let i = this.body.length;\n        while (i--) push(this.body[i]);\n        push(this.expression);\n    }\n}, AST_Block);\n\nvar AST_SwitchBranch = DEFNODE(\"SwitchBranch\", null, {\n    $documentation: \"Base class for `switch` branches\",\n}, AST_Block);\n\nvar AST_Default = DEFNODE(\"Default\", null, {\n    $documentation: \"A `default` switch branch\",\n}, AST_SwitchBranch);\n\nvar AST_Case = DEFNODE(\"Case\", \"expression\", {\n    $documentation: \"A `case` switch branch\",\n    $propdoc: {\n        expression: \"[AST_Node] the `case` expression\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n            walk_body(this, visitor);\n        });\n    },\n    _children_backwards(push) {\n        let i = this.body.length;\n        while (i--) push(this.body[i]);\n        push(this.expression);\n    },\n}, AST_SwitchBranch);\n\n/* -----[ EXCEPTIONS ]----- */\n\nvar AST_Try = DEFNODE(\"Try\", \"bcatch bfinally\", {\n    $documentation: \"A `try` statement\",\n    $propdoc: {\n        bcatch: \"[AST_Catch?] the catch block, or null if not present\",\n        bfinally: \"[AST_Finally?] the finally block, or null if not present\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            walk_body(this, visitor);\n            if (this.bcatch) this.bcatch._walk(visitor);\n            if (this.bfinally) this.bfinally._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.bfinally) push(this.bfinally);\n        if (this.bcatch) push(this.bcatch);\n        let i = this.body.length;\n        while (i--) push(this.body[i]);\n    },\n}, AST_Block);\n\nvar AST_Catch = DEFNODE(\"Catch\", \"argname\", {\n    $documentation: \"A `catch` node; only makes sense as part of a `try` statement\",\n    $propdoc: {\n        argname: \"[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            if (this.argname) this.argname._walk(visitor);\n            walk_body(this, visitor);\n        });\n    },\n    _children_backwards(push) {\n        let i = this.body.length;\n        while (i--) push(this.body[i]);\n        if (this.argname) push(this.argname);\n    },\n}, AST_Block);\n\nvar AST_Finally = DEFNODE(\"Finally\", null, {\n    $documentation: \"A `finally` node; only makes sense as part of a `try` statement\"\n}, AST_Block);\n\n/* -----[ VAR/CONST ]----- */\n\nvar AST_Definitions = DEFNODE(\"Definitions\", \"definitions\", {\n    $documentation: \"Base class for `var` or `const` nodes (variable declarations/initializations)\",\n    $propdoc: {\n        definitions: \"[AST_VarDef*] array of variable definitions\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            var definitions = this.definitions;\n            for (var i = 0, len = definitions.length; i < len; i++) {\n                definitions[i]._walk(visitor);\n            }\n        });\n    },\n    _children_backwards(push) {\n        let i = this.definitions.length;\n        while (i--) push(this.definitions[i]);\n    },\n}, AST_Statement);\n\nvar AST_Var = DEFNODE(\"Var\", null, {\n    $documentation: \"A `var` statement\"\n}, AST_Definitions);\n\nvar AST_Let = DEFNODE(\"Let\", null, {\n    $documentation: \"A `let` statement\"\n}, AST_Definitions);\n\nvar AST_Const = DEFNODE(\"Const\", null, {\n    $documentation: \"A `const` statement\"\n}, AST_Definitions);\n\nvar AST_VarDef = DEFNODE(\"VarDef\", \"name value\", {\n    $documentation: \"A variable declaration; only appears in a AST_Definitions node\",\n    $propdoc: {\n        name: \"[AST_Destructuring|AST_SymbolConst|AST_SymbolLet|AST_SymbolVar] name of the variable\",\n        value: \"[AST_Node?] initializer, or null of there's no initializer\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.name._walk(visitor);\n            if (this.value) this.value._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.value) push(this.value);\n        push(this.name);\n    },\n});\n\nvar AST_NameMapping = DEFNODE(\"NameMapping\", \"foreign_name name\", {\n    $documentation: \"The part of the export/import statement that declare names from a module.\",\n    $propdoc: {\n        foreign_name: \"[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)\",\n        name: \"[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module.\"\n    },\n    _walk: function (visitor) {\n        return visitor._visit(this, function() {\n            this.foreign_name._walk(visitor);\n            this.name._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.name);\n        push(this.foreign_name);\n    },\n});\n\nvar AST_Import = DEFNODE(\"Import\", \"imported_name imported_names module_name\", {\n    $documentation: \"An `import` statement\",\n    $propdoc: {\n        imported_name: \"[AST_SymbolImport] The name of the variable holding the module's default export.\",\n        imported_names: \"[AST_NameMapping*] The names of non-default imported variables\",\n        module_name: \"[AST_String] String literal describing where this module came from\",\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            if (this.imported_name) {\n                this.imported_name._walk(visitor);\n            }\n            if (this.imported_names) {\n                this.imported_names.forEach(function(name_import) {\n                    name_import._walk(visitor);\n                });\n            }\n            this.module_name._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.module_name);\n        if (this.imported_names) {\n            let i = this.imported_names.length;\n            while (i--) push(this.imported_names[i]);\n        }\n        if (this.imported_name) push(this.imported_name);\n    },\n});\n\nvar AST_ImportMeta = DEFNODE(\"ImportMeta\", null, {\n    $documentation: \"A reference to import.meta\",\n});\n\nvar AST_Export = DEFNODE(\"Export\", \"exported_definition exported_value is_default exported_names module_name\", {\n    $documentation: \"An `export` statement\",\n    $propdoc: {\n        exported_definition: \"[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition\",\n        exported_value: \"[AST_Node?] An exported value\",\n        exported_names: \"[AST_NameMapping*?] List of exported names\",\n        module_name: \"[AST_String?] Name of the file to load exports from\",\n        is_default: \"[Boolean] Whether this is the default exported value of this module\"\n    },\n    _walk: function (visitor) {\n        return visitor._visit(this, function () {\n            if (this.exported_definition) {\n                this.exported_definition._walk(visitor);\n            }\n            if (this.exported_value) {\n                this.exported_value._walk(visitor);\n            }\n            if (this.exported_names) {\n                this.exported_names.forEach(function(name_export) {\n                    name_export._walk(visitor);\n                });\n            }\n            if (this.module_name) {\n                this.module_name._walk(visitor);\n            }\n        });\n    },\n    _children_backwards(push) {\n        if (this.module_name) push(this.module_name);\n        if (this.exported_names) {\n            let i = this.exported_names.length;\n            while (i--) push(this.exported_names[i]);\n        }\n        if (this.exported_value) push(this.exported_value);\n        if (this.exported_definition) push(this.exported_definition);\n    }\n}, AST_Statement);\n\n/* -----[ OTHER ]----- */\n\nvar AST_Call = DEFNODE(\"Call\", \"expression args optional _annotations\", {\n    $documentation: \"A function call expression\",\n    $propdoc: {\n        expression: \"[AST_Node] expression to invoke as function\",\n        args: \"[AST_Node*] array of arguments\",\n        optional: \"[boolean] whether this is an optional call (IE ?.() )\",\n        _annotations: \"[number] bitfield containing information about the call\"\n    },\n    initialize() {\n        if (this._annotations == null) this._annotations = 0;\n    },\n    _walk(visitor) {\n        return visitor._visit(this, function() {\n            var args = this.args;\n            for (var i = 0, len = args.length; i < len; i++) {\n                args[i]._walk(visitor);\n            }\n            this.expression._walk(visitor);  // TODO why do we need to crawl this last?\n        });\n    },\n    _children_backwards(push) {\n        let i = this.args.length;\n        while (i--) push(this.args[i]);\n        push(this.expression);\n    },\n});\n\nvar AST_New = DEFNODE(\"New\", null, {\n    $documentation: \"An object instantiation.  Derives from a function call since it has exactly the same properties\"\n}, AST_Call);\n\nvar AST_Sequence = DEFNODE(\"Sequence\", \"expressions\", {\n    $documentation: \"A sequence expression (comma-separated expressions)\",\n    $propdoc: {\n        expressions: \"[AST_Node*] array of expressions (at least two)\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expressions.forEach(function(node) {\n                node._walk(visitor);\n            });\n        });\n    },\n    _children_backwards(push) {\n        let i = this.expressions.length;\n        while (i--) push(this.expressions[i]);\n    },\n});\n\nvar AST_PropAccess = DEFNODE(\"PropAccess\", \"expression property optional\", {\n    $documentation: \"Base class for property access expressions, i.e. `a.foo` or `a[\\\"foo\\\"]`\",\n    $propdoc: {\n        expression: \"[AST_Node] the “container” expression\",\n        property: \"[AST_Node|string] the property to access.  For AST_Dot & AST_DotHash this is always a plain string, while for AST_Sub it's an arbitrary AST_Node\",\n\n        optional: \"[boolean] whether this is an optional property access (IE ?.)\"\n    }\n});\n\nvar AST_Dot = DEFNODE(\"Dot\", \"quote\", {\n    $documentation: \"A dotted property access expression\",\n    $propdoc: {\n        quote: \"[string] the original quote character when transformed from AST_Sub\",\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.expression);\n    },\n}, AST_PropAccess);\n\nvar AST_DotHash = DEFNODE(\"DotHash\", \"\", {\n    $documentation: \"A dotted property access to a private property\",\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.expression);\n    },\n}, AST_PropAccess);\n\nvar AST_Sub = DEFNODE(\"Sub\", null, {\n    $documentation: \"Index-style property access, i.e. `a[\\\"foo\\\"]`\",\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n            this.property._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.property);\n        push(this.expression);\n    },\n}, AST_PropAccess);\n\nvar AST_Chain = DEFNODE(\"Chain\", \"expression\", {\n    $documentation: \"A chain expression like a?.b?.(c)?.[d]\",\n    $propdoc: {\n        expression: \"[AST_Call|AST_Dot|AST_DotHash|AST_Sub] chain element.\"\n    },\n    _walk: function (visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.expression);\n    },\n});\n\nvar AST_Unary = DEFNODE(\"Unary\", \"operator expression\", {\n    $documentation: \"Base class for unary expressions\",\n    $propdoc: {\n        operator: \"[string] the operator\",\n        expression: \"[AST_Node] expression that this unary operator applies to\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.expression._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.expression);\n    },\n});\n\nvar AST_UnaryPrefix = DEFNODE(\"UnaryPrefix\", null, {\n    $documentation: \"Unary prefix expression, i.e. `typeof i` or `++i`\"\n}, AST_Unary);\n\nvar AST_UnaryPostfix = DEFNODE(\"UnaryPostfix\", null, {\n    $documentation: \"Unary postfix expression, i.e. `i++`\"\n}, AST_Unary);\n\nvar AST_Binary = DEFNODE(\"Binary\", \"operator left right\", {\n    $documentation: \"Binary expression, i.e. `a + b`\",\n    $propdoc: {\n        left: \"[AST_Node] left-hand side expression\",\n        operator: \"[string] the operator\",\n        right: \"[AST_Node] right-hand side expression\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.left._walk(visitor);\n            this.right._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.right);\n        push(this.left);\n    },\n});\n\nvar AST_Conditional = DEFNODE(\"Conditional\", \"condition consequent alternative\", {\n    $documentation: \"Conditional expression using the ternary operator, i.e. `a ? b : c`\",\n    $propdoc: {\n        condition: \"[AST_Node]\",\n        consequent: \"[AST_Node]\",\n        alternative: \"[AST_Node]\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            this.condition._walk(visitor);\n            this.consequent._walk(visitor);\n            this.alternative._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.alternative);\n        push(this.consequent);\n        push(this.condition);\n    },\n});\n\nvar AST_Assign = DEFNODE(\"Assign\", \"logical\", {\n    $documentation: \"An assignment expression — `a = b + 5`\",\n    $propdoc: {\n        logical: \"Whether it's a logical assignment\"\n    }\n}, AST_Binary);\n\nvar AST_DefaultAssign = DEFNODE(\"DefaultAssign\", null, {\n    $documentation: \"A default assignment expression like in `(a = 3) => a`\"\n}, AST_Binary);\n\n/* -----[ LITERALS ]----- */\n\nvar AST_Array = DEFNODE(\"Array\", \"elements\", {\n    $documentation: \"An array literal\",\n    $propdoc: {\n        elements: \"[AST_Node*] array of elements\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            var elements = this.elements;\n            for (var i = 0, len = elements.length; i < len; i++) {\n                elements[i]._walk(visitor);\n            }\n        });\n    },\n    _children_backwards(push) {\n        let i = this.elements.length;\n        while (i--) push(this.elements[i]);\n    },\n});\n\nvar AST_Object = DEFNODE(\"Object\", \"properties\", {\n    $documentation: \"An object literal\",\n    $propdoc: {\n        properties: \"[AST_ObjectProperty*] array of properties\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            var properties = this.properties;\n            for (var i = 0, len = properties.length; i < len; i++) {\n                properties[i]._walk(visitor);\n            }\n        });\n    },\n    _children_backwards(push) {\n        let i = this.properties.length;\n        while (i--) push(this.properties[i]);\n    },\n});\n\nvar AST_ObjectProperty = DEFNODE(\"ObjectProperty\", \"key value\", {\n    $documentation: \"Base class for literal object properties\",\n    $propdoc: {\n        key: \"[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_Node.\",\n        value: \"[AST_Node] property value.  For getters and setters this is an AST_Accessor.\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            if (this.key instanceof AST_Node)\n                this.key._walk(visitor);\n            this.value._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        push(this.value);\n        if (this.key instanceof AST_Node) push(this.key);\n    }\n});\n\nvar AST_ObjectKeyVal = DEFNODE(\"ObjectKeyVal\", \"quote\", {\n    $documentation: \"A key: value object property\",\n    $propdoc: {\n        quote: \"[string] the original quote character\"\n    },\n    computed_key() {\n        return this.key instanceof AST_Node;\n    }\n}, AST_ObjectProperty);\n\nvar AST_PrivateSetter = DEFNODE(\"PrivateSetter\", \"static\", {\n    $propdoc: {\n        static: \"[boolean] whether this is a static private setter\"\n    },\n    $documentation: \"A private setter property\",\n    computed_key() {\n        return false;\n    }\n}, AST_ObjectProperty);\n\nvar AST_PrivateGetter = DEFNODE(\"PrivateGetter\", \"static\", {\n    $propdoc: {\n        static: \"[boolean] whether this is a static private getter\"\n    },\n    $documentation: \"A private getter property\",\n    computed_key() {\n        return false;\n    }\n}, AST_ObjectProperty);\n\nvar AST_ObjectSetter = DEFNODE(\"ObjectSetter\", \"quote static\", {\n    $propdoc: {\n        quote: \"[string|undefined] the original quote character, if any\",\n        static: \"[boolean] whether this is a static setter (classes only)\"\n    },\n    $documentation: \"An object setter property\",\n    computed_key() {\n        return !(this.key instanceof AST_SymbolMethod);\n    }\n}, AST_ObjectProperty);\n\nvar AST_ObjectGetter = DEFNODE(\"ObjectGetter\", \"quote static\", {\n    $propdoc: {\n        quote: \"[string|undefined] the original quote character, if any\",\n        static: \"[boolean] whether this is a static getter (classes only)\"\n    },\n    $documentation: \"An object getter property\",\n    computed_key() {\n        return !(this.key instanceof AST_SymbolMethod);\n    }\n}, AST_ObjectProperty);\n\nvar AST_ConciseMethod = DEFNODE(\"ConciseMethod\", \"quote static is_generator async\", {\n    $propdoc: {\n        quote: \"[string|undefined] the original quote character, if any\",\n        static: \"[boolean] is this method static (classes only)\",\n        is_generator: \"[boolean] is this a generator method\",\n        async: \"[boolean] is this method async\",\n    },\n    $documentation: \"An ES6 concise method inside an object or class\",\n    computed_key() {\n        return !(this.key instanceof AST_SymbolMethod);\n    }\n}, AST_ObjectProperty);\n\nvar AST_PrivateMethod = DEFNODE(\"PrivateMethod\", \"\", {\n    $documentation: \"A private class method inside a class\",\n}, AST_ConciseMethod);\n\nvar AST_Class = DEFNODE(\"Class\", \"name extends properties\", {\n    $propdoc: {\n        name: \"[AST_SymbolClass|AST_SymbolDefClass?] optional class name.\",\n        extends: \"[AST_Node]? optional parent class\",\n        properties: \"[AST_ObjectProperty*] array of properties\"\n    },\n    $documentation: \"An ES6 class\",\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            if (this.name) {\n                this.name._walk(visitor);\n            }\n            if (this.extends) {\n                this.extends._walk(visitor);\n            }\n            this.properties.forEach((prop) => prop._walk(visitor));\n        });\n    },\n    _children_backwards(push) {\n        let i = this.properties.length;\n        while (i--) push(this.properties[i]);\n        if (this.extends) push(this.extends);\n        if (this.name) push(this.name);\n    },\n}, AST_Scope /* TODO a class might have a scope but it's not a scope */);\n\nvar AST_ClassProperty = DEFNODE(\"ClassProperty\", \"static quote\", {\n    $documentation: \"A class property\",\n    $propdoc: {\n        static: \"[boolean] whether this is a static key\",\n        quote: \"[string] which quote is being used\"\n    },\n    _walk: function(visitor) {\n        return visitor._visit(this, function() {\n            if (this.key instanceof AST_Node)\n                this.key._walk(visitor);\n            if (this.value instanceof AST_Node)\n                this.value._walk(visitor);\n        });\n    },\n    _children_backwards(push) {\n        if (this.value instanceof AST_Node) push(this.value);\n        if (this.key instanceof AST_Node) push(this.key);\n    },\n    computed_key() {\n        return !(this.key instanceof AST_SymbolClassProperty);\n    }\n}, AST_ObjectProperty);\n\nvar AST_ClassPrivateProperty = DEFNODE(\"ClassProperty\", \"\", {\n    $documentation: \"A class property for a private property\",\n}, AST_ClassProperty);\n\nvar AST_DefClass = DEFNODE(\"DefClass\", null, {\n    $documentation: \"A class definition\",\n}, AST_Class);\n\nvar AST_ClassExpression = DEFNODE(\"ClassExpression\", null, {\n    $documentation: \"A class expression.\"\n}, AST_Class);\n\nvar AST_Symbol = DEFNODE(\"Symbol\", \"scope name thedef\", {\n    $propdoc: {\n        name: \"[string] name of this symbol\",\n        scope: \"[AST_Scope/S] the current scope (not necessarily the definition scope)\",\n        thedef: \"[SymbolDef/S] the definition of this symbol\"\n    },\n    $documentation: \"Base class for all symbols\"\n});\n\nvar AST_NewTarget = DEFNODE(\"NewTarget\", null, {\n    $documentation: \"A reference to new.target\"\n});\n\nvar AST_SymbolDeclaration = DEFNODE(\"SymbolDeclaration\", \"init\", {\n    $documentation: \"A declaration symbol (symbol in var/const, function name or argument, symbol in catch)\",\n}, AST_Symbol);\n\nvar AST_SymbolVar = DEFNODE(\"SymbolVar\", null, {\n    $documentation: \"Symbol defining a variable\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolBlockDeclaration = DEFNODE(\"SymbolBlockDeclaration\", null, {\n    $documentation: \"Base class for block-scoped declaration symbols\"\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolConst = DEFNODE(\"SymbolConst\", null, {\n    $documentation: \"A constant declaration\"\n}, AST_SymbolBlockDeclaration);\n\nvar AST_SymbolLet = DEFNODE(\"SymbolLet\", null, {\n    $documentation: \"A block-scoped `let` declaration\"\n}, AST_SymbolBlockDeclaration);\n\nvar AST_SymbolFunarg = DEFNODE(\"SymbolFunarg\", null, {\n    $documentation: \"Symbol naming a function argument\",\n}, AST_SymbolVar);\n\nvar AST_SymbolDefun = DEFNODE(\"SymbolDefun\", null, {\n    $documentation: \"Symbol defining a function\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolMethod = DEFNODE(\"SymbolMethod\", null, {\n    $documentation: \"Symbol in an object defining a method\",\n}, AST_Symbol);\n\nvar AST_SymbolClassProperty = DEFNODE(\"SymbolClassProperty\", null, {\n    $documentation: \"Symbol for a class property\",\n}, AST_Symbol);\n\nvar AST_SymbolLambda = DEFNODE(\"SymbolLambda\", null, {\n    $documentation: \"Symbol naming a function expression\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolDefClass = DEFNODE(\"SymbolDefClass\", null, {\n    $documentation: \"Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within the class.\"\n}, AST_SymbolBlockDeclaration);\n\nvar AST_SymbolClass = DEFNODE(\"SymbolClass\", null, {\n    $documentation: \"Symbol naming a class's name. Lexically scoped to the class.\"\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolCatch = DEFNODE(\"SymbolCatch\", null, {\n    $documentation: \"Symbol naming the exception in catch\",\n}, AST_SymbolBlockDeclaration);\n\nvar AST_SymbolImport = DEFNODE(\"SymbolImport\", null, {\n    $documentation: \"Symbol referring to an imported name\",\n}, AST_SymbolBlockDeclaration);\n\nvar AST_SymbolImportForeign = DEFNODE(\"SymbolImportForeign\", null, {\n    $documentation: \"A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module's purposes\",\n}, AST_Symbol);\n\nvar AST_Label = DEFNODE(\"Label\", \"references\", {\n    $documentation: \"Symbol naming a label (declaration)\",\n    $propdoc: {\n        references: \"[AST_LoopControl*] a list of nodes referring to this label\"\n    },\n    initialize: function() {\n        this.references = [];\n        this.thedef = this;\n    }\n}, AST_Symbol);\n\nvar AST_SymbolRef = DEFNODE(\"SymbolRef\", null, {\n    $documentation: \"Reference to some symbol (not definition/declaration)\",\n}, AST_Symbol);\n\nvar AST_SymbolExport = DEFNODE(\"SymbolExport\", null, {\n    $documentation: \"Symbol referring to a name to export\",\n}, AST_SymbolRef);\n\nvar AST_SymbolExportForeign = DEFNODE(\"SymbolExportForeign\", null, {\n    $documentation: \"A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module's purposes\",\n}, AST_Symbol);\n\nvar AST_LabelRef = DEFNODE(\"LabelRef\", null, {\n    $documentation: \"Reference to a label symbol\",\n}, AST_Symbol);\n\nvar AST_This = DEFNODE(\"This\", null, {\n    $documentation: \"The `this` symbol\",\n}, AST_Symbol);\n\nvar AST_Super = DEFNODE(\"Super\", null, {\n    $documentation: \"The `super` symbol\",\n}, AST_This);\n\nvar AST_Constant = DEFNODE(\"Constant\", null, {\n    $documentation: \"Base class for all constants\",\n    getValue: function() {\n        return this.value;\n    }\n});\n\nvar AST_String = DEFNODE(\"String\", \"value quote\", {\n    $documentation: \"A string literal\",\n    $propdoc: {\n        value: \"[string] the contents of this string\",\n        quote: \"[string] the original quote character\"\n    }\n}, AST_Constant);\n\nvar AST_Number = DEFNODE(\"Number\", \"value raw\", {\n    $documentation: \"A number literal\",\n    $propdoc: {\n        value: \"[number] the numeric value\",\n        raw: \"[string] numeric value as string\"\n    }\n}, AST_Constant);\n\nvar AST_BigInt = DEFNODE(\"BigInt\", \"value\", {\n    $documentation: \"A big int literal\",\n    $propdoc: {\n        value: \"[string] big int value\"\n    }\n}, AST_Constant);\n\nvar AST_RegExp = DEFNODE(\"RegExp\", \"value\", {\n    $documentation: \"A regexp literal\",\n    $propdoc: {\n        value: \"[RegExp] the actual regexp\",\n    }\n}, AST_Constant);\n\nvar AST_Atom = DEFNODE(\"Atom\", null, {\n    $documentation: \"Base class for atoms\",\n}, AST_Constant);\n\nvar AST_Null = DEFNODE(\"Null\", null, {\n    $documentation: \"The `null` atom\",\n    value: null\n}, AST_Atom);\n\nvar AST_NaN = DEFNODE(\"NaN\", null, {\n    $documentation: \"The impossible value\",\n    value: 0/0\n}, AST_Atom);\n\nvar AST_Undefined = DEFNODE(\"Undefined\", null, {\n    $documentation: \"The `undefined` value\",\n    value: (function() {}())\n}, AST_Atom);\n\nvar AST_Hole = DEFNODE(\"Hole\", null, {\n    $documentation: \"A hole in an array\",\n    value: (function() {}())\n}, AST_Atom);\n\nvar AST_Infinity = DEFNODE(\"Infinity\", null, {\n    $documentation: \"The `Infinity` value\",\n    value: 1/0\n}, AST_Atom);\n\nvar AST_Boolean = DEFNODE(\"Boolean\", null, {\n    $documentation: \"Base class for booleans\",\n}, AST_Atom);\n\nvar AST_False = DEFNODE(\"False\", null, {\n    $documentation: \"The `false` atom\",\n    value: false\n}, AST_Boolean);\n\nvar AST_True = DEFNODE(\"True\", null, {\n    $documentation: \"The `true` atom\",\n    value: true\n}, AST_Boolean);\n\n/* -----[ Walk function ]---- */\n\n/**\n * Walk nodes in depth-first search fashion.\n * Callback can return `walk_abort` symbol to stop iteration.\n * It can also return `true` to stop iteration just for child nodes.\n * Iteration can be stopped and continued by passing the `to_visit` argument,\n * which is given to the callback in the second argument.\n **/\nfunction walk(node, cb, to_visit = [node]) {\n    const push = to_visit.push.bind(to_visit);\n    while (to_visit.length) {\n        const node = to_visit.pop();\n        const ret = cb(node, to_visit);\n\n        if (ret) {\n            if (ret === walk_abort) return true;\n            continue;\n        }\n\n        node._children_backwards(push);\n    }\n    return false;\n}\n\nfunction walk_parent(node, cb, initial_stack) {\n    const to_visit = [node];\n    const push = to_visit.push.bind(to_visit);\n    const stack = initial_stack ? initial_stack.slice() : [];\n    const parent_pop_indices = [];\n\n    let current;\n\n    const info = {\n        parent: (n = 0) => {\n            if (n === -1) {\n                return current;\n            }\n\n            // [ p1 p0 ] [ 1 0 ]\n            if (initial_stack && n >= stack.length) {\n                n -= stack.length;\n                return initial_stack[\n                    initial_stack.length - (n + 1)\n                ];\n            }\n\n            return stack[stack.length - (1 + n)];\n        },\n    };\n\n    while (to_visit.length) {\n        current = to_visit.pop();\n\n        while (\n            parent_pop_indices.length &&\n            to_visit.length == parent_pop_indices[parent_pop_indices.length - 1]\n        ) {\n            stack.pop();\n            parent_pop_indices.pop();\n        }\n\n        const ret = cb(current, info);\n\n        if (ret) {\n            if (ret === walk_abort) return true;\n            continue;\n        }\n\n        const visit_length = to_visit.length;\n\n        current._children_backwards(push);\n\n        // Push only if we're going to traverse the children\n        if (to_visit.length > visit_length) {\n            stack.push(current);\n            parent_pop_indices.push(visit_length - 1);\n        }\n    }\n\n    return false;\n}\n\nconst walk_abort = Symbol(\"abort walk\");\n\n/* -----[ TreeWalker ]----- */\n\nclass TreeWalker {\n    constructor(callback) {\n        this.visit = callback;\n        this.stack = [];\n        this.directives = Object.create(null);\n    }\n\n    _visit(node, descend) {\n        this.push(node);\n        var ret = this.visit(node, descend ? function() {\n            descend.call(node);\n        } : noop);\n        if (!ret && descend) {\n            descend.call(node);\n        }\n        this.pop();\n        return ret;\n    }\n\n    parent(n) {\n        return this.stack[this.stack.length - 2 - (n || 0)];\n    }\n\n    push(node) {\n        if (node instanceof AST_Lambda) {\n            this.directives = Object.create(this.directives);\n        } else if (node instanceof AST_Directive && !this.directives[node.value]) {\n            this.directives[node.value] = node;\n        } else if (node instanceof AST_Class) {\n            this.directives = Object.create(this.directives);\n            if (!this.directives[\"use strict\"]) {\n                this.directives[\"use strict\"] = node;\n            }\n        }\n        this.stack.push(node);\n    }\n\n    pop() {\n        var node = this.stack.pop();\n        if (node instanceof AST_Lambda || node instanceof AST_Class) {\n            this.directives = Object.getPrototypeOf(this.directives);\n        }\n    }\n\n    self() {\n        return this.stack[this.stack.length - 1];\n    }\n\n    find_parent(type) {\n        var stack = this.stack;\n        for (var i = stack.length; --i >= 0;) {\n            var x = stack[i];\n            if (x instanceof type) return x;\n        }\n    }\n\n    has_directive(type) {\n        var dir = this.directives[type];\n        if (dir) return dir;\n        var node = this.stack[this.stack.length - 1];\n        if (node instanceof AST_Scope && node.body) {\n            for (var i = 0; i < node.body.length; ++i) {\n                var st = node.body[i];\n                if (!(st instanceof AST_Directive)) break;\n                if (st.value == type) return st;\n            }\n        }\n    }\n\n    loopcontrol_target(node) {\n        var stack = this.stack;\n        if (node.label) for (var i = stack.length; --i >= 0;) {\n            var x = stack[i];\n            if (x instanceof AST_LabeledStatement && x.label.name == node.label.name)\n                return x.body;\n        } else for (var i = stack.length; --i >= 0;) {\n            var x = stack[i];\n            if (x instanceof AST_IterationStatement\n                || node instanceof AST_Break && x instanceof AST_Switch)\n                return x;\n        }\n    }\n}\n\n// Tree transformer helpers.\nclass TreeTransformer extends TreeWalker {\n    constructor(before, after) {\n        super();\n        this.before = before;\n        this.after = after;\n    }\n}\n\nconst _PURE     = 0b00000001;\nconst _INLINE   = 0b00000010;\nconst _NOINLINE = 0b00000100;\n\nvar ast = /*#__PURE__*/Object.freeze({\n__proto__: null,\nAST_Accessor: AST_Accessor,\nAST_Array: AST_Array,\nAST_Arrow: AST_Arrow,\nAST_Assign: AST_Assign,\nAST_Atom: AST_Atom,\nAST_Await: AST_Await,\nAST_BigInt: AST_BigInt,\nAST_Binary: AST_Binary,\nAST_Block: AST_Block,\nAST_BlockStatement: AST_BlockStatement,\nAST_Boolean: AST_Boolean,\nAST_Break: AST_Break,\nAST_Call: AST_Call,\nAST_Case: AST_Case,\nAST_Catch: AST_Catch,\nAST_Chain: AST_Chain,\nAST_Class: AST_Class,\nAST_ClassExpression: AST_ClassExpression,\nAST_ClassPrivateProperty: AST_ClassPrivateProperty,\nAST_ClassProperty: AST_ClassProperty,\nAST_ConciseMethod: AST_ConciseMethod,\nAST_Conditional: AST_Conditional,\nAST_Const: AST_Const,\nAST_Constant: AST_Constant,\nAST_Continue: AST_Continue,\nAST_Debugger: AST_Debugger,\nAST_Default: AST_Default,\nAST_DefaultAssign: AST_DefaultAssign,\nAST_DefClass: AST_DefClass,\nAST_Definitions: AST_Definitions,\nAST_Defun: AST_Defun,\nAST_Destructuring: AST_Destructuring,\nAST_Directive: AST_Directive,\nAST_Do: AST_Do,\nAST_Dot: AST_Dot,\nAST_DotHash: AST_DotHash,\nAST_DWLoop: AST_DWLoop,\nAST_EmptyStatement: AST_EmptyStatement,\nAST_Exit: AST_Exit,\nAST_Expansion: AST_Expansion,\nAST_Export: AST_Export,\nAST_False: AST_False,\nAST_Finally: AST_Finally,\nAST_For: AST_For,\nAST_ForIn: AST_ForIn,\nAST_ForOf: AST_ForOf,\nAST_Function: AST_Function,\nAST_Hole: AST_Hole,\nAST_If: AST_If,\nAST_Import: AST_Import,\nAST_ImportMeta: AST_ImportMeta,\nAST_Infinity: AST_Infinity,\nAST_IterationStatement: AST_IterationStatement,\nAST_Jump: AST_Jump,\nAST_Label: AST_Label,\nAST_LabeledStatement: AST_LabeledStatement,\nAST_LabelRef: AST_LabelRef,\nAST_Lambda: AST_Lambda,\nAST_Let: AST_Let,\nAST_LoopControl: AST_LoopControl,\nAST_NameMapping: AST_NameMapping,\nAST_NaN: AST_NaN,\nAST_New: AST_New,\nAST_NewTarget: AST_NewTarget,\nAST_Node: AST_Node,\nAST_Null: AST_Null,\nAST_Number: AST_Number,\nAST_Object: AST_Object,\nAST_ObjectGetter: AST_ObjectGetter,\nAST_ObjectKeyVal: AST_ObjectKeyVal,\nAST_ObjectProperty: AST_ObjectProperty,\nAST_ObjectSetter: AST_ObjectSetter,\nAST_PrefixedTemplateString: AST_PrefixedTemplateString,\nAST_PrivateGetter: AST_PrivateGetter,\nAST_PrivateMethod: AST_PrivateMethod,\nAST_PrivateSetter: AST_PrivateSetter,\nAST_PropAccess: AST_PropAccess,\nAST_RegExp: AST_RegExp,\nAST_Return: AST_Return,\nAST_Scope: AST_Scope,\nAST_Sequence: AST_Sequence,\nAST_SimpleStatement: AST_SimpleStatement,\nAST_Statement: AST_Statement,\nAST_StatementWithBody: AST_StatementWithBody,\nAST_String: AST_String,\nAST_Sub: AST_Sub,\nAST_Super: AST_Super,\nAST_Switch: AST_Switch,\nAST_SwitchBranch: AST_SwitchBranch,\nAST_Symbol: AST_Symbol,\nAST_SymbolBlockDeclaration: AST_SymbolBlockDeclaration,\nAST_SymbolCatch: AST_SymbolCatch,\nAST_SymbolClass: AST_SymbolClass,\nAST_SymbolClassProperty: AST_SymbolClassProperty,\nAST_SymbolConst: AST_SymbolConst,\nAST_SymbolDeclaration: AST_SymbolDeclaration,\nAST_SymbolDefClass: AST_SymbolDefClass,\nAST_SymbolDefun: AST_SymbolDefun,\nAST_SymbolExport: AST_SymbolExport,\nAST_SymbolExportForeign: AST_SymbolExportForeign,\nAST_SymbolFunarg: AST_SymbolFunarg,\nAST_SymbolImport: AST_SymbolImport,\nAST_SymbolImportForeign: AST_SymbolImportForeign,\nAST_SymbolLambda: AST_SymbolLambda,\nAST_SymbolLet: AST_SymbolLet,\nAST_SymbolMethod: AST_SymbolMethod,\nAST_SymbolRef: AST_SymbolRef,\nAST_SymbolVar: AST_SymbolVar,\nAST_TemplateSegment: AST_TemplateSegment,\nAST_TemplateString: AST_TemplateString,\nAST_This: AST_This,\nAST_Throw: AST_Throw,\nAST_Token: AST_Token,\nAST_Toplevel: AST_Toplevel,\nAST_True: AST_True,\nAST_Try: AST_Try,\nAST_Unary: AST_Unary,\nAST_UnaryPostfix: AST_UnaryPostfix,\nAST_UnaryPrefix: AST_UnaryPrefix,\nAST_Undefined: AST_Undefined,\nAST_Var: AST_Var,\nAST_VarDef: AST_VarDef,\nAST_While: AST_While,\nAST_With: AST_With,\nAST_Yield: AST_Yield,\nTreeTransformer: TreeTransformer,\nTreeWalker: TreeWalker,\nwalk: walk,\nwalk_abort: walk_abort,\nwalk_body: walk_body,\nwalk_parent: walk_parent,\n_INLINE: _INLINE,\n_NOINLINE: _NOINLINE,\n_PURE: _PURE\n});\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nfunction def_transform(node, descend) {\n    node.DEFMETHOD(\"transform\", function(tw, in_list) {\n        let transformed = undefined;\n        tw.push(this);\n        if (tw.before) transformed = tw.before(this, descend, in_list);\n        if (transformed === undefined) {\n            transformed = this;\n            descend(transformed, tw);\n            if (tw.after) {\n                const after_ret = tw.after(transformed, in_list);\n                if (after_ret !== undefined) transformed = after_ret;\n            }\n        }\n        tw.pop();\n        return transformed;\n    });\n}\n\nfunction do_list(list, tw) {\n    return MAP(list, function(node) {\n        return node.transform(tw, true);\n    });\n}\n\ndef_transform(AST_Node, noop);\n\ndef_transform(AST_LabeledStatement, function(self, tw) {\n    self.label = self.label.transform(tw);\n    self.body = self.body.transform(tw);\n});\n\ndef_transform(AST_SimpleStatement, function(self, tw) {\n    self.body = self.body.transform(tw);\n});\n\ndef_transform(AST_Block, function(self, tw) {\n    self.body = do_list(self.body, tw);\n});\n\ndef_transform(AST_Do, function(self, tw) {\n    self.body = self.body.transform(tw);\n    self.condition = self.condition.transform(tw);\n});\n\ndef_transform(AST_While, function(self, tw) {\n    self.condition = self.condition.transform(tw);\n    self.body = self.body.transform(tw);\n});\n\ndef_transform(AST_For, function(self, tw) {\n    if (self.init) self.init = self.init.transform(tw);\n    if (self.condition) self.condition = self.condition.transform(tw);\n    if (self.step) self.step = self.step.transform(tw);\n    self.body = self.body.transform(tw);\n});\n\ndef_transform(AST_ForIn, function(self, tw) {\n    self.init = self.init.transform(tw);\n    self.object = self.object.transform(tw);\n    self.body = self.body.transform(tw);\n});\n\ndef_transform(AST_With, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n    self.body = self.body.transform(tw);\n});\n\ndef_transform(AST_Exit, function(self, tw) {\n    if (self.value) self.value = self.value.transform(tw);\n});\n\ndef_transform(AST_LoopControl, function(self, tw) {\n    if (self.label) self.label = self.label.transform(tw);\n});\n\ndef_transform(AST_If, function(self, tw) {\n    self.condition = self.condition.transform(tw);\n    self.body = self.body.transform(tw);\n    if (self.alternative) self.alternative = self.alternative.transform(tw);\n});\n\ndef_transform(AST_Switch, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n    self.body = do_list(self.body, tw);\n});\n\ndef_transform(AST_Case, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n    self.body = do_list(self.body, tw);\n});\n\ndef_transform(AST_Try, function(self, tw) {\n    self.body = do_list(self.body, tw);\n    if (self.bcatch) self.bcatch = self.bcatch.transform(tw);\n    if (self.bfinally) self.bfinally = self.bfinally.transform(tw);\n});\n\ndef_transform(AST_Catch, function(self, tw) {\n    if (self.argname) self.argname = self.argname.transform(tw);\n    self.body = do_list(self.body, tw);\n});\n\ndef_transform(AST_Definitions, function(self, tw) {\n    self.definitions = do_list(self.definitions, tw);\n});\n\ndef_transform(AST_VarDef, function(self, tw) {\n    self.name = self.name.transform(tw);\n    if (self.value) self.value = self.value.transform(tw);\n});\n\ndef_transform(AST_Destructuring, function(self, tw) {\n    self.names = do_list(self.names, tw);\n});\n\ndef_transform(AST_Lambda, function(self, tw) {\n    if (self.name) self.name = self.name.transform(tw);\n    self.argnames = do_list(self.argnames, tw);\n    if (self.body instanceof AST_Node) {\n        self.body = self.body.transform(tw);\n    } else {\n        self.body = do_list(self.body, tw);\n    }\n});\n\ndef_transform(AST_Call, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n    self.args = do_list(self.args, tw);\n});\n\ndef_transform(AST_Sequence, function(self, tw) {\n    const result = do_list(self.expressions, tw);\n    self.expressions = result.length\n        ? result\n        : [new AST_Number({ value: 0 })];\n});\n\ndef_transform(AST_Dot, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n});\n\ndef_transform(AST_Sub, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n    self.property = self.property.transform(tw);\n});\n\ndef_transform(AST_Chain, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n});\n\ndef_transform(AST_Yield, function(self, tw) {\n    if (self.expression) self.expression = self.expression.transform(tw);\n});\n\ndef_transform(AST_Await, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n});\n\ndef_transform(AST_Unary, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n});\n\ndef_transform(AST_Binary, function(self, tw) {\n    self.left = self.left.transform(tw);\n    self.right = self.right.transform(tw);\n});\n\ndef_transform(AST_Conditional, function(self, tw) {\n    self.condition = self.condition.transform(tw);\n    self.consequent = self.consequent.transform(tw);\n    self.alternative = self.alternative.transform(tw);\n});\n\ndef_transform(AST_Array, function(self, tw) {\n    self.elements = do_list(self.elements, tw);\n});\n\ndef_transform(AST_Object, function(self, tw) {\n    self.properties = do_list(self.properties, tw);\n});\n\ndef_transform(AST_ObjectProperty, function(self, tw) {\n    if (self.key instanceof AST_Node) {\n        self.key = self.key.transform(tw);\n    }\n    if (self.value) self.value = self.value.transform(tw);\n});\n\ndef_transform(AST_Class, function(self, tw) {\n    if (self.name) self.name = self.name.transform(tw);\n    if (self.extends) self.extends = self.extends.transform(tw);\n    self.properties = do_list(self.properties, tw);\n});\n\ndef_transform(AST_Expansion, function(self, tw) {\n    self.expression = self.expression.transform(tw);\n});\n\ndef_transform(AST_NameMapping, function(self, tw) {\n    self.foreign_name = self.foreign_name.transform(tw);\n    self.name = self.name.transform(tw);\n});\n\ndef_transform(AST_Import, function(self, tw) {\n    if (self.imported_name) self.imported_name = self.imported_name.transform(tw);\n    if (self.imported_names) do_list(self.imported_names, tw);\n    self.module_name = self.module_name.transform(tw);\n});\n\ndef_transform(AST_Export, function(self, tw) {\n    if (self.exported_definition) self.exported_definition = self.exported_definition.transform(tw);\n    if (self.exported_value) self.exported_value = self.exported_value.transform(tw);\n    if (self.exported_names) do_list(self.exported_names, tw);\n    if (self.module_name) self.module_name = self.module_name.transform(tw);\n});\n\ndef_transform(AST_TemplateString, function(self, tw) {\n    self.segments = do_list(self.segments, tw);\n});\n\ndef_transform(AST_PrefixedTemplateString, function(self, tw) {\n    self.prefix = self.prefix.transform(tw);\n    self.template_string = self.template_string.transform(tw);\n});\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n(function() {\n\n    var normalize_directives = function(body) {\n        var in_directive = true;\n\n        for (var i = 0; i < body.length; i++) {\n            if (in_directive && body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {\n                body[i] = new AST_Directive({\n                    start: body[i].start,\n                    end: body[i].end,\n                    value: body[i].body.value\n                });\n            } else if (in_directive && !(body[i] instanceof AST_Statement && body[i].body instanceof AST_String)) {\n                in_directive = false;\n            }\n        }\n\n        return body;\n    };\n\n    var MOZ_TO_ME = {\n        Program: function(M) {\n            return new AST_Toplevel({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: normalize_directives(M.body.map(from_moz))\n            });\n        },\n        ArrayPattern: function(M) {\n            return new AST_Destructuring({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                names: M.elements.map(function(elm) {\n                    if (elm === null) {\n                        return new AST_Hole();\n                    }\n                    return from_moz(elm);\n                }),\n                is_array: true\n            });\n        },\n        ObjectPattern: function(M) {\n            return new AST_Destructuring({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                names: M.properties.map(from_moz),\n                is_array: false\n            });\n        },\n        AssignmentPattern: function(M) {\n            return new AST_DefaultAssign({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                left: from_moz(M.left),\n                operator: \"=\",\n                right: from_moz(M.right)\n            });\n        },\n        SpreadElement: function(M) {\n            return new AST_Expansion({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n        RestElement: function(M) {\n            return new AST_Expansion({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n        TemplateElement: function(M) {\n            return new AST_TemplateSegment({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                value: M.value.cooked,\n                raw: M.value.raw\n            });\n        },\n        TemplateLiteral: function(M) {\n            var segments = [];\n            for (var i = 0; i < M.quasis.length; i++) {\n                segments.push(from_moz(M.quasis[i]));\n                if (M.expressions[i]) {\n                    segments.push(from_moz(M.expressions[i]));\n                }\n            }\n            return new AST_TemplateString({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                segments: segments\n            });\n        },\n        TaggedTemplateExpression: function(M) {\n            return new AST_PrefixedTemplateString({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                template_string: from_moz(M.quasi),\n                prefix: from_moz(M.tag)\n            });\n        },\n        FunctionDeclaration: function(M) {\n            return new AST_Defun({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: M.params.map(from_moz),\n                is_generator: M.generator,\n                async: M.async,\n                body: normalize_directives(from_moz(M.body).body)\n            });\n        },\n        FunctionExpression: function(M) {\n            return new AST_Function({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: M.params.map(from_moz),\n                is_generator: M.generator,\n                async: M.async,\n                body: normalize_directives(from_moz(M.body).body)\n            });\n        },\n        ArrowFunctionExpression: function(M) {\n            const body = M.body.type === \"BlockStatement\"\n                ? from_moz(M.body).body\n                : [make_node(AST_Return, {}, { value: from_moz(M.body) })];\n            return new AST_Arrow({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argnames: M.params.map(from_moz),\n                body,\n                async: M.async,\n            });\n        },\n        ExpressionStatement: function(M) {\n            return new AST_SimpleStatement({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: from_moz(M.expression)\n            });\n        },\n        TryStatement: function(M) {\n            var handlers = M.handlers || [M.handler];\n            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                throw new Error(\"Multiple catch clauses are not supported.\");\n            }\n            return new AST_Try({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                body     : from_moz(M.block).body,\n                bcatch   : from_moz(handlers[0]),\n                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n            });\n        },\n        Property: function(M) {\n            var key = M.key;\n            var args = {\n                start    : my_start_token(key || M.value),\n                end      : my_end_token(M.value),\n                key      : key.type == \"Identifier\" ? key.name : key.value,\n                value    : from_moz(M.value)\n            };\n            if (M.computed) {\n                args.key = from_moz(M.key);\n            }\n            if (M.method) {\n                args.is_generator = M.value.generator;\n                args.async = M.value.async;\n                if (!M.computed) {\n                    args.key = new AST_SymbolMethod({ name: args.key });\n                } else {\n                    args.key = from_moz(M.key);\n                }\n                return new AST_ConciseMethod(args);\n            }\n            if (M.kind == \"init\") {\n                if (key.type != \"Identifier\" && key.type != \"Literal\") {\n                    args.key = from_moz(key);\n                }\n                return new AST_ObjectKeyVal(args);\n            }\n            if (typeof args.key === \"string\" || typeof args.key === \"number\") {\n                args.key = new AST_SymbolMethod({\n                    name: args.key\n                });\n            }\n            args.value = new AST_Accessor(args.value);\n            if (M.kind == \"get\") return new AST_ObjectGetter(args);\n            if (M.kind == \"set\") return new AST_ObjectSetter(args);\n            if (M.kind == \"method\") {\n                args.async = M.value.async;\n                args.is_generator = M.value.generator;\n                args.quote = M.computed ? \"\\\"\" : null;\n                return new AST_ConciseMethod(args);\n            }\n        },\n        MethodDefinition: function(M) {\n            var args = {\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                key      : M.computed ? from_moz(M.key) : new AST_SymbolMethod({ name: M.key.name || M.key.value }),\n                value    : from_moz(M.value),\n                static   : M.static,\n            };\n            if (M.kind == \"get\") {\n                return new AST_ObjectGetter(args);\n            }\n            if (M.kind == \"set\") {\n                return new AST_ObjectSetter(args);\n            }\n            args.is_generator = M.value.generator;\n            args.async = M.value.async;\n            return new AST_ConciseMethod(args);\n        },\n        FieldDefinition: function(M) {\n            let key;\n            if (M.computed) {\n                key = from_moz(M.key);\n            } else {\n                if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in FieldDefinition\");\n                key = from_moz(M.key);\n            }\n            return new AST_ClassProperty({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                key,\n                value    : from_moz(M.value),\n                static   : M.static,\n            });\n        },\n        PropertyDefinition: function(M) {\n            let key;\n            if (M.computed) {\n                key = from_moz(M.key);\n            } else {\n                if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in PropertyDefinition\");\n                key = from_moz(M.key);\n            }\n\n            return new AST_ClassProperty({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                key,\n                value    : from_moz(M.value),\n                static   : M.static,\n            });\n        },\n        ArrayExpression: function(M) {\n            return new AST_Array({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                elements : M.elements.map(function(elem) {\n                    return elem === null ? new AST_Hole() : from_moz(elem);\n                })\n            });\n        },\n        ObjectExpression: function(M) {\n            return new AST_Object({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                properties : M.properties.map(function(prop) {\n                    if (prop.type === \"SpreadElement\") {\n                        return from_moz(prop);\n                    }\n                    prop.type = \"Property\";\n                    return from_moz(prop);\n                })\n            });\n        },\n        SequenceExpression: function(M) {\n            return new AST_Sequence({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expressions: M.expressions.map(from_moz)\n            });\n        },\n        MemberExpression: function(M) {\n            return new (M.computed ? AST_Sub : AST_Dot)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                property   : M.computed ? from_moz(M.property) : M.property.name,\n                expression : from_moz(M.object),\n                optional   : M.optional || false\n            });\n        },\n        ChainExpression: function(M) {\n            return new AST_Chain({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.expression)\n            });\n        },\n        SwitchCase: function(M) {\n            return new (M.test ? AST_Case : AST_Default)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.test),\n                body       : M.consequent.map(from_moz)\n            });\n        },\n        VariableDeclaration: function(M) {\n            return new (M.kind === \"const\" ? AST_Const :\n                        M.kind === \"let\" ? AST_Let : AST_Var)({\n                start       : my_start_token(M),\n                end         : my_end_token(M),\n                definitions : M.declarations.map(from_moz)\n            });\n        },\n\n        ImportDeclaration: function(M) {\n            var imported_name = null;\n            var imported_names = null;\n            M.specifiers.forEach(function (specifier) {\n                if (specifier.type === \"ImportSpecifier\") {\n                    if (!imported_names) { imported_names = []; }\n                    imported_names.push(new AST_NameMapping({\n                        start: my_start_token(specifier),\n                        end: my_end_token(specifier),\n                        foreign_name: from_moz(specifier.imported),\n                        name: from_moz(specifier.local)\n                    }));\n                } else if (specifier.type === \"ImportDefaultSpecifier\") {\n                    imported_name = from_moz(specifier.local);\n                } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                    if (!imported_names) { imported_names = []; }\n                    imported_names.push(new AST_NameMapping({\n                        start: my_start_token(specifier),\n                        end: my_end_token(specifier),\n                        foreign_name: new AST_SymbolImportForeign({ name: \"*\" }),\n                        name: from_moz(specifier.local)\n                    }));\n                }\n            });\n            return new AST_Import({\n                start       : my_start_token(M),\n                end         : my_end_token(M),\n                imported_name: imported_name,\n                imported_names : imported_names,\n                module_name : from_moz(M.source)\n            });\n        },\n        ExportAllDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_names: [\n                    new AST_NameMapping({\n                        name: new AST_SymbolExportForeign({ name: \"*\" }),\n                        foreign_name: new AST_SymbolExportForeign({ name: \"*\" })\n                    })\n                ],\n                module_name: from_moz(M.source)\n            });\n        },\n        ExportNamedDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_definition: from_moz(M.declaration),\n                exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(function (specifier) {\n                    return new AST_NameMapping({\n                        foreign_name: from_moz(specifier.exported),\n                        name: from_moz(specifier.local)\n                    });\n                }) : null,\n                module_name: from_moz(M.source)\n            });\n        },\n        ExportDefaultDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_value: from_moz(M.declaration),\n                is_default: true\n            });\n        },\n        Literal: function(M) {\n            var val = M.value, args = {\n                start  : my_start_token(M),\n                end    : my_end_token(M)\n            };\n            var rx = M.regex;\n            if (rx && rx.pattern) {\n                // RegExpLiteral as per ESTree AST spec\n                args.value = {\n                    source: rx.pattern,\n                    flags: rx.flags\n                };\n                return new AST_RegExp(args);\n            } else if (rx) {\n                // support legacy RegExp\n                const rx_source = M.raw || val;\n                const match = rx_source.match(/^\\/(.*)\\/(\\w*)$/);\n                if (!match) throw new Error(\"Invalid regex source \" + rx_source);\n                const [_, source, flags] = match;\n                args.value = { source, flags };\n                return new AST_RegExp(args);\n            }\n            if (val === null) return new AST_Null(args);\n            switch (typeof val) {\n              case \"string\":\n                args.value = val;\n                return new AST_String(args);\n              case \"number\":\n                args.value = val;\n                args.raw = M.raw || val.toString();\n                return new AST_Number(args);\n              case \"boolean\":\n                return new (val ? AST_True : AST_False)(args);\n            }\n        },\n        MetaProperty: function(M) {\n            if (M.meta.name === \"new\" && M.property.name === \"target\") {\n                return new AST_NewTarget({\n                    start: my_start_token(M),\n                    end: my_end_token(M)\n                });\n            } else if (M.meta.name === \"import\" && M.property.name === \"meta\") {\n                return new AST_ImportMeta({\n                    start: my_start_token(M),\n                    end: my_end_token(M)\n                });\n            }\n        },\n        Identifier: function(M) {\n            var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];\n            return new (  p.type == \"LabeledStatement\" ? AST_Label\n                        : p.type == \"VariableDeclarator\" && p.id === M ? (p.kind == \"const\" ? AST_SymbolConst : p.kind == \"let\" ? AST_SymbolLet : AST_SymbolVar)\n                        : /Import.*Specifier/.test(p.type) ? (p.local === M ? AST_SymbolImport : AST_SymbolImportForeign)\n                        : p.type == \"ExportSpecifier\" ? (p.local === M ? AST_SymbolExport : AST_SymbolExportForeign)\n                        : p.type == \"FunctionExpression\" ? (p.id === M ? AST_SymbolLambda : AST_SymbolFunarg)\n                        : p.type == \"FunctionDeclaration\" ? (p.id === M ? AST_SymbolDefun : AST_SymbolFunarg)\n                        : p.type == \"ArrowFunctionExpression\" ? (p.params.includes(M)) ? AST_SymbolFunarg : AST_SymbolRef\n                        : p.type == \"ClassExpression\" ? (p.id === M ? AST_SymbolClass : AST_SymbolRef)\n                        : p.type == \"Property\" ? (p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolMethod)\n                        : p.type == \"PropertyDefinition\" || p.type === \"FieldDefinition\" ? (p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolClassProperty)\n                        : p.type == \"ClassDeclaration\" ? (p.id === M ? AST_SymbolDefClass : AST_SymbolRef)\n                        : p.type == \"MethodDefinition\" ? (p.computed ? AST_SymbolRef : AST_SymbolMethod)\n                        : p.type == \"CatchClause\" ? AST_SymbolCatch\n                        : p.type == \"BreakStatement\" || p.type == \"ContinueStatement\" ? AST_LabelRef\n                        : AST_SymbolRef)({\n                            start : my_start_token(M),\n                            end   : my_end_token(M),\n                            name  : M.name\n                        });\n        },\n        BigIntLiteral(M) {\n            return new AST_BigInt({\n                start : my_start_token(M),\n                end   : my_end_token(M),\n                value : M.value\n            });\n        }\n    };\n\n    MOZ_TO_ME.UpdateExpression =\n    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n        var prefix = \"prefix\" in M ? M.prefix\n            : M.type == \"UnaryExpression\" ? true : false;\n        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n            start      : my_start_token(M),\n            end        : my_end_token(M),\n            operator   : M.operator,\n            expression : from_moz(M.argument)\n        });\n    };\n\n    MOZ_TO_ME.ClassDeclaration =\n    MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {\n        return new (M.type === \"ClassDeclaration\" ? AST_DefClass : AST_ClassExpression)({\n            start    : my_start_token(M),\n            end      : my_end_token(M),\n            name     : from_moz(M.id),\n            extends  : from_moz(M.superClass),\n            properties: M.body.body.map(from_moz)\n        });\n    };\n\n    map(\"EmptyStatement\", AST_EmptyStatement);\n    map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n    map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n    map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n    map(\"BreakStatement\", AST_Break, \"label>label\");\n    map(\"ContinueStatement\", AST_Continue, \"label>label\");\n    map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n    map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n    map(\"ReturnStatement\", AST_Return, \"argument>value\");\n    map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n    map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n    map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n    map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n    map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n    map(\"ForOfStatement\", AST_ForOf, \"left>init, right>object, body>body, await=await\");\n    map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n    map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=is_star\");\n    map(\"DebuggerStatement\", AST_Debugger);\n    map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n    map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n    map(\"ThisExpression\", AST_This);\n    map(\"Super\", AST_Super);\n    map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n    map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n    map(\"NewExpression\", AST_New, \"callee>expression, arguments@args\");\n    map(\"CallExpression\", AST_Call, \"callee>expression, optional=optional, arguments@args\");\n\n    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n        return to_moz_scope(\"Program\", M);\n    });\n\n    def_to_moz(AST_Expansion, function To_Moz_Spread(M) {\n        return {\n            type: to_moz_in_destructuring() ? \"RestElement\" : \"SpreadElement\",\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {\n        return {\n            type: \"TaggedTemplateExpression\",\n            tag: to_moz(M.prefix),\n            quasi: to_moz(M.template_string)\n        };\n    });\n\n    def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {\n        var quasis = [];\n        var expressions = [];\n        for (var i = 0; i < M.segments.length; i++) {\n            if (i % 2 !== 0) {\n                expressions.push(to_moz(M.segments[i]));\n            } else {\n                quasis.push({\n                    type: \"TemplateElement\",\n                    value: {\n                        raw: M.segments[i].raw,\n                        cooked: M.segments[i].value\n                    },\n                    tail: i === M.segments.length - 1\n                });\n            }\n        }\n        return {\n            type: \"TemplateLiteral\",\n            quasis: quasis,\n            expressions: expressions\n        };\n    });\n\n    def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {\n        return {\n            type: \"FunctionDeclaration\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz),\n            generator: M.is_generator,\n            async: M.async,\n            body: to_moz_scope(\"BlockStatement\", M)\n        };\n    });\n\n    def_to_moz(AST_Function, function To_Moz_FunctionExpression(M, parent) {\n        var is_generator = parent.is_generator !== undefined ?\n            parent.is_generator : M.is_generator;\n        return {\n            type: \"FunctionExpression\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz),\n            generator: is_generator,\n            async: M.async,\n            body: to_moz_scope(\"BlockStatement\", M)\n        };\n    });\n\n    def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {\n        var body = {\n            type: \"BlockStatement\",\n            body: M.body.map(to_moz)\n        };\n        return {\n            type: \"ArrowFunctionExpression\",\n            params: M.argnames.map(to_moz),\n            async: M.async,\n            body: body\n        };\n    });\n\n    def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {\n        if (M.is_array) {\n            return {\n                type: \"ArrayPattern\",\n                elements: M.names.map(to_moz)\n            };\n        }\n        return {\n            type: \"ObjectPattern\",\n            properties: M.names.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: {\n                type: \"Literal\",\n                value: M.value,\n                raw: M.print_to_string()\n            },\n            directive: M.value\n        };\n    });\n\n    def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: to_moz(M.body)\n        };\n    });\n\n    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n        return {\n            type: \"SwitchCase\",\n            test: to_moz(M.expression),\n            consequent: M.body.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n        return {\n            type: \"TryStatement\",\n            block: to_moz_block(M),\n            handler: to_moz(M.bcatch),\n            guardedHandlers: [],\n            finalizer: to_moz(M.bfinally)\n        };\n    });\n\n    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n        return {\n            type: \"CatchClause\",\n            param: to_moz(M.argname),\n            guard: null,\n            body: to_moz_block(M)\n        };\n    });\n\n    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n        return {\n            type: \"VariableDeclaration\",\n            kind:\n                M instanceof AST_Const ? \"const\" :\n                M instanceof AST_Let ? \"let\" : \"var\",\n            declarations: M.definitions.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {\n        if (M.exported_names) {\n            if (M.exported_names[0].name.name === \"*\") {\n                return {\n                    type: \"ExportAllDeclaration\",\n                    source: to_moz(M.module_name)\n                };\n            }\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: M.exported_names.map(function (name_mapping) {\n                    return {\n                        type: \"ExportSpecifier\",\n                        exported: to_moz(name_mapping.foreign_name),\n                        local: to_moz(name_mapping.name)\n                    };\n                }),\n                declaration: to_moz(M.exported_definition),\n                source: to_moz(M.module_name)\n            };\n        }\n        return {\n            type: M.is_default ? \"ExportDefaultDeclaration\" : \"ExportNamedDeclaration\",\n            declaration: to_moz(M.exported_value || M.exported_definition)\n        };\n    });\n\n    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n        var specifiers = [];\n        if (M.imported_name) {\n            specifiers.push({\n                type: \"ImportDefaultSpecifier\",\n                local: to_moz(M.imported_name)\n            });\n        }\n        if (M.imported_names && M.imported_names[0].foreign_name.name === \"*\") {\n            specifiers.push({\n                type: \"ImportNamespaceSpecifier\",\n                local: to_moz(M.imported_names[0].name)\n            });\n        } else if (M.imported_names) {\n            M.imported_names.forEach(function(name_mapping) {\n                specifiers.push({\n                    type: \"ImportSpecifier\",\n                    local: to_moz(name_mapping.name),\n                    imported: to_moz(name_mapping.foreign_name)\n                });\n            });\n        }\n        return {\n            type: \"ImportDeclaration\",\n            specifiers: specifiers,\n            source: to_moz(M.module_name)\n        };\n    });\n\n    def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"import\"\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"meta\"\n            }\n        };\n    });\n\n    def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {\n        return {\n            type: \"SequenceExpression\",\n            expressions: M.expressions.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_DotHash, function To_Moz_PrivateMemberExpression(M) {\n        return {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: false,\n            property: {\n                type: \"PrivateIdentifier\",\n                name: M.property\n            },\n            optional: M.optional\n        };\n    });\n\n    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n        var isComputed = M instanceof AST_Sub;\n        return {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: isComputed,\n            property: isComputed ? to_moz(M.property) : {type: \"Identifier\", name: M.property},\n            optional: M.optional\n        };\n    });\n\n    def_to_moz(AST_Chain, function To_Moz_ChainExpression(M) {\n        return {\n            type: \"ChainExpression\",\n            expression: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n        return {\n            type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n            operator: M.operator,\n            prefix: M instanceof AST_UnaryPrefix,\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n        if (M.operator == \"=\" && to_moz_in_destructuring()) {\n            return {\n                type: \"AssignmentPattern\",\n                left: to_moz(M.left),\n                right: to_moz(M.right)\n            };\n        }\n\n        const type = M.operator == \"&&\" || M.operator == \"||\" || M.operator === \"??\"\n            ? \"LogicalExpression\"\n            : \"BinaryExpression\";\n\n        return {\n            type,\n            left: to_moz(M.left),\n            operator: M.operator,\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n        return {\n            type: \"ArrayExpression\",\n            elements: M.elements.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {\n        return {\n            type: \"ObjectExpression\",\n            properties: M.properties.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {\n        var key = M.key instanceof AST_Node ? to_moz(M.key) : {\n            type: \"Identifier\",\n            value: M.key\n        };\n        if (typeof M.key === \"number\") {\n            key = {\n                type: \"Literal\",\n                value: Number(M.key)\n            };\n        }\n        if (typeof M.key === \"string\") {\n            key = {\n                type: \"Identifier\",\n                name: M.key\n            };\n        }\n        var kind;\n        var string_or_num = typeof M.key === \"string\" || typeof M.key === \"number\";\n        var computed = string_or_num ? false : !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef;\n        if (M instanceof AST_ObjectKeyVal) {\n            kind = \"init\";\n            computed = !string_or_num;\n        } else\n        if (M instanceof AST_ObjectGetter) {\n            kind = \"get\";\n        } else\n        if (M instanceof AST_ObjectSetter) {\n            kind = \"set\";\n        }\n        if (M instanceof AST_PrivateGetter || M instanceof AST_PrivateSetter) {\n            const kind = M instanceof AST_PrivateGetter ? \"get\" : \"set\";\n            return {\n                type: \"MethodDefinition\",\n                computed: false,\n                kind: kind,\n                static: M.static,\n                key: {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.name\n                },\n                value: to_moz(M.value)\n            };\n        }\n        if (M instanceof AST_ClassPrivateProperty) {\n            return {\n                type: \"PropertyDefinition\",\n                key: {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.name\n                },\n                value: to_moz(M.value),\n                computed: false,\n                static: M.static\n            };\n        }\n        if (M instanceof AST_ClassProperty) {\n            return {\n                type: \"PropertyDefinition\",\n                key,\n                value: to_moz(M.value),\n                computed,\n                static: M.static\n            };\n        }\n        if (parent instanceof AST_Class) {\n            return {\n                type: \"MethodDefinition\",\n                computed: computed,\n                kind: kind,\n                static: M.static,\n                key: to_moz(M.key),\n                value: to_moz(M.value)\n            };\n        }\n        return {\n            type: \"Property\",\n            computed: computed,\n            kind: kind,\n            key: key,\n            value: to_moz(M.value)\n        };\n    });\n\n    def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {\n        if (parent instanceof AST_Object) {\n            return {\n                type: \"Property\",\n                computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n                kind: \"init\",\n                method: true,\n                shorthand: false,\n                key: to_moz(M.key),\n                value: to_moz(M.value)\n            };\n        }\n\n        const key = M instanceof AST_PrivateMethod\n            ? {\n                type: \"PrivateIdentifier\",\n                name: M.key.name\n            }\n            : to_moz(M.key);\n\n        return {\n            type: \"MethodDefinition\",\n            kind: M.key === \"constructor\" ? \"constructor\" : \"method\",\n            key,\n            value: to_moz(M.value),\n            computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n            static: M.static,\n        };\n    });\n\n    def_to_moz(AST_Class, function To_Moz_Class(M) {\n        var type = M instanceof AST_ClassExpression ? \"ClassExpression\" : \"ClassDeclaration\";\n        return {\n            type: type,\n            superClass: to_moz(M.extends),\n            id: M.name ? to_moz(M.name) : null,\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz)\n            }\n        };\n    });\n\n    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"new\"\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"target\"\n            }\n        };\n    });\n\n    def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {\n        if (M instanceof AST_SymbolMethod && parent.quote) {\n            return {\n                type: \"Literal\",\n                value: M.name\n            };\n        }\n        var def = M.definition();\n        return {\n            type: \"Identifier\",\n            name: def ? def.mangled_name || def.name : M.name\n        };\n    });\n\n    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n        const pattern = M.value.source;\n        const flags = M.value.flags;\n        return {\n            type: \"Literal\",\n            value: null,\n            raw: M.print_to_string(),\n            regex: { pattern, flags }\n        };\n    });\n\n    def_to_moz(AST_Constant, function To_Moz_Literal(M) {\n        var value = M.value;\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: M.raw || M.print_to_string()\n        };\n    });\n\n    def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n        return {\n            type: \"Identifier\",\n            name: String(M.value)\n        };\n    });\n\n    def_to_moz(AST_BigInt, M => ({\n        type: \"BigIntLiteral\",\n        value: M.value\n    }));\n\n    AST_Boolean.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Null.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Hole.DEFMETHOD(\"to_mozilla_ast\", function To_Moz_ArrayHole() { return null; });\n\n    AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n    AST_Lambda.DEFMETHOD(\"to_mozilla_ast\", AST_Function.prototype.to_mozilla_ast);\n\n    /* -----[ tools ]----- */\n\n    function my_start_token(moznode) {\n        var loc = moznode.loc, start = loc && loc.start;\n        var range = moznode.range;\n        return new AST_Token(\n            \"\",\n            \"\",\n            start && start.line || 0,\n            start && start.column || 0,\n            range ? range [0] : moznode.start,\n            false,\n            [],\n            [],\n            loc && loc.source,\n        );\n    }\n\n    function my_end_token(moznode) {\n        var loc = moznode.loc, end = loc && loc.end;\n        var range = moznode.range;\n        return new AST_Token(\n            \"\",\n            \"\",\n            end && end.line || 0,\n            end && end.column || 0,\n            range ? range [0] : moznode.end,\n            false,\n            [],\n            [],\n            loc && loc.source,\n        );\n    }\n\n    function map(moztype, mytype, propmap) {\n        var moz_to_me = \"function From_Moz_\" + moztype + \"(M){\\n\";\n        moz_to_me += \"return new U2.\" + mytype.name + \"({\\n\" +\n            \"start: my_start_token(M),\\n\" +\n            \"end: my_end_token(M)\";\n\n        var me_to_moz = \"function To_Moz_\" + moztype + \"(M){\\n\";\n        me_to_moz += \"return {\\n\" +\n            \"type: \" + JSON.stringify(moztype);\n\n        if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n            var m = /([a-z0-9$_]+)([=@>%])([a-z0-9$_]+)/i.exec(prop);\n            if (!m) throw new Error(\"Can't understand property map: \" + prop);\n            var moz = m[1], how = m[2], my = m[3];\n            moz_to_me += \",\\n\" + my + \": \";\n            me_to_moz += \",\\n\" + moz + \": \";\n            switch (how) {\n                case \"@\":\n                    moz_to_me += \"M.\" + moz + \".map(from_moz)\";\n                    me_to_moz += \"M.\" +  my + \".map(to_moz)\";\n                    break;\n                case \">\":\n                    moz_to_me += \"from_moz(M.\" + moz + \")\";\n                    me_to_moz += \"to_moz(M.\" + my + \")\";\n                    break;\n                case \"=\":\n                    moz_to_me += \"M.\" + moz;\n                    me_to_moz += \"M.\" + my;\n                    break;\n                case \"%\":\n                    moz_to_me += \"from_moz(M.\" + moz + \").body\";\n                    me_to_moz += \"to_moz_block(M)\";\n                    break;\n                default:\n                    throw new Error(\"Can't understand operator in propmap: \" + prop);\n            }\n        });\n\n        moz_to_me += \"\\n})\\n}\";\n        me_to_moz += \"\\n}\\n}\";\n\n        moz_to_me = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", \"return(\" + moz_to_me + \")\")(\n            ast, my_start_token, my_end_token, from_moz\n        );\n        me_to_moz = new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", \"return(\" + me_to_moz + \")\")(\n            to_moz, to_moz_block, to_moz_scope\n        );\n        MOZ_TO_ME[moztype] = moz_to_me;\n        def_to_moz(mytype, me_to_moz);\n    }\n\n    var FROM_MOZ_STACK = null;\n\n    function from_moz(node) {\n        FROM_MOZ_STACK.push(node);\n        var ret = node != null ? MOZ_TO_ME[node.type](node) : null;\n        FROM_MOZ_STACK.pop();\n        return ret;\n    }\n\n    AST_Node.from_mozilla_ast = function(node) {\n        var save_stack = FROM_MOZ_STACK;\n        FROM_MOZ_STACK = [];\n        var ast = from_moz(node);\n        FROM_MOZ_STACK = save_stack;\n        return ast;\n    };\n\n    function set_moz_loc(mynode, moznode) {\n        var start = mynode.start;\n        var end = mynode.end;\n        if (!(start && end)) {\n            return moznode;\n        }\n        if (start.pos != null && end.endpos != null) {\n            moznode.range = [start.pos, end.endpos];\n        }\n        if (start.line) {\n            moznode.loc = {\n                start: {line: start.line, column: start.col},\n                end: end.endline ? {line: end.endline, column: end.endcol} : null\n            };\n            if (start.file) {\n                moznode.loc.source = start.file;\n            }\n        }\n        return moznode;\n    }\n\n    function def_to_moz(mytype, handler) {\n        mytype.DEFMETHOD(\"to_mozilla_ast\", function(parent) {\n            return set_moz_loc(this, handler(this, parent));\n        });\n    }\n\n    var TO_MOZ_STACK = null;\n\n    function to_moz(node) {\n        if (TO_MOZ_STACK === null) { TO_MOZ_STACK = []; }\n        TO_MOZ_STACK.push(node);\n        var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;\n        TO_MOZ_STACK.pop();\n        if (TO_MOZ_STACK.length === 0) { TO_MOZ_STACK = null; }\n        return ast;\n    }\n\n    function to_moz_in_destructuring() {\n        var i = TO_MOZ_STACK.length;\n        while (i--) {\n            if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function to_moz_block(node) {\n        return {\n            type: \"BlockStatement\",\n            body: node.body.map(to_moz)\n        };\n    }\n\n    function to_moz_scope(type, node) {\n        var body = node.body.map(to_moz);\n        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n        }\n        return {\n            type: type,\n            body: body\n        };\n    }\n})();\n\n// return true if the node at the top of the stack (that means the\n// innermost node in the current output) is lexically the first in\n// a statement.\nfunction first_in_statement(stack) {\n    let node = stack.parent(-1);\n    for (let i = 0, p; p = stack.parent(i); i++) {\n        if (p instanceof AST_Statement && p.body === node)\n            return true;\n        if ((p instanceof AST_Sequence && p.expressions[0] === node) ||\n            (p.TYPE === \"Call\" && p.expression === node) ||\n            (p instanceof AST_PrefixedTemplateString && p.prefix === node) ||\n            (p instanceof AST_Dot && p.expression === node) ||\n            (p instanceof AST_Sub && p.expression === node) ||\n            (p instanceof AST_Conditional && p.condition === node) ||\n            (p instanceof AST_Binary && p.left === node) ||\n            (p instanceof AST_UnaryPostfix && p.expression === node)\n        ) {\n            node = p;\n        } else {\n            return false;\n        }\n    }\n}\n\n// Returns whether the leftmost item in the expression is an object\nfunction left_is_object(node) {\n    if (node instanceof AST_Object) return true;\n    if (node instanceof AST_Sequence) return left_is_object(node.expressions[0]);\n    if (node.TYPE === \"Call\") return left_is_object(node.expression);\n    if (node instanceof AST_PrefixedTemplateString) return left_is_object(node.prefix);\n    if (node instanceof AST_Dot || node instanceof AST_Sub) return left_is_object(node.expression);\n    if (node instanceof AST_Conditional) return left_is_object(node.condition);\n    if (node instanceof AST_Binary) return left_is_object(node.left);\n    if (node instanceof AST_UnaryPostfix) return left_is_object(node.expression);\n    return false;\n}\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nconst EXPECT_DIRECTIVE = /^$|[;{][\\s\\n]*$/;\nconst CODE_LINE_BREAK = 10;\nconst CODE_SPACE = 32;\n\nconst r_annotation = /[@#]__(PURE|INLINE|NOINLINE)__/g;\n\nfunction is_some_comments(comment) {\n    // multiline comment\n    return (\n        (comment.type === \"comment2\" || comment.type === \"comment1\")\n        && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value)\n    );\n}\n\nfunction OutputStream(options) {\n\n    var readonly = !options;\n    options = defaults(options, {\n        ascii_only           : false,\n        beautify             : false,\n        braces               : false,\n        comments             : \"some\",\n        ecma                 : 5,\n        ie8                  : false,\n        indent_level         : 4,\n        indent_start         : 0,\n        inline_script        : true,\n        keep_numbers         : false,\n        keep_quoted_props    : false,\n        max_line_len         : false,\n        preamble             : null,\n        preserve_annotations : false,\n        quote_keys           : false,\n        quote_style          : 0,\n        safari10             : false,\n        semicolons           : true,\n        shebang              : true,\n        shorthand            : undefined,\n        source_map           : null,\n        webkit               : false,\n        width                : 80,\n        wrap_iife            : false,\n        wrap_func_args       : true,\n    }, true);\n\n    if (options.shorthand === undefined)\n        options.shorthand = options.ecma > 5;\n\n    // Convert comment option to RegExp if neccessary and set up comments filter\n    var comment_filter = return_false; // Default case, throw all comments away\n    if (options.comments) {\n        let comments = options.comments;\n        if (typeof options.comments === \"string\" && /^\\/.*\\/[a-zA-Z]*$/.test(options.comments)) {\n            var regex_pos = options.comments.lastIndexOf(\"/\");\n            comments = new RegExp(\n                options.comments.substr(1, regex_pos - 1),\n                options.comments.substr(regex_pos + 1)\n            );\n        }\n        if (comments instanceof RegExp) {\n            comment_filter = function(comment) {\n                return comment.type != \"comment5\" && comments.test(comment.value);\n            };\n        } else if (typeof comments === \"function\") {\n            comment_filter = function(comment) {\n                return comment.type != \"comment5\" && comments(this, comment);\n            };\n        } else if (comments === \"some\") {\n            comment_filter = is_some_comments;\n        } else { // NOTE includes \"all\" option\n            comment_filter = return_true;\n        }\n    }\n\n    var indentation = 0;\n    var current_col = 0;\n    var current_line = 1;\n    var current_pos = 0;\n    var OUTPUT = \"\";\n    let printed_comments = new Set();\n\n    var to_utf8 = options.ascii_only ? function(str, identifier) {\n        if (options.ecma >= 2015 && !options.safari10) {\n            str = str.replace(/[\\ud800-\\udbff][\\udc00-\\udfff]/g, function(ch) {\n                var code = get_full_char_code(ch, 0).toString(16);\n                return \"\\\\u{\" + code + \"}\";\n            });\n        }\n        return str.replace(/[\\u0000-\\u001f\\u007f-\\uffff]/g, function(ch) {\n            var code = ch.charCodeAt(0).toString(16);\n            if (code.length <= 2 && !identifier) {\n                while (code.length < 2) code = \"0\" + code;\n                return \"\\\\x\" + code;\n            } else {\n                while (code.length < 4) code = \"0\" + code;\n                return \"\\\\u\" + code;\n            }\n        });\n    } : function(str) {\n        return str.replace(/[\\ud800-\\udbff][\\udc00-\\udfff]|([\\ud800-\\udbff]|[\\udc00-\\udfff])/g, function(match, lone) {\n            if (lone) {\n                return \"\\\\u\" + lone.charCodeAt(0).toString(16);\n            }\n            return match;\n        });\n    };\n\n    function make_string(str, quote) {\n        var dq = 0, sq = 0;\n        str = str.replace(/[\\\\\\b\\f\\n\\r\\v\\t\\x22\\x27\\u2028\\u2029\\0\\ufeff]/g,\n          function(s, i) {\n            switch (s) {\n              case '\"': ++dq; return '\"';\n              case \"'\": ++sq; return \"'\";\n              case \"\\\\\": return \"\\\\\\\\\";\n              case \"\\n\": return \"\\\\n\";\n              case \"\\r\": return \"\\\\r\";\n              case \"\\t\": return \"\\\\t\";\n              case \"\\b\": return \"\\\\b\";\n              case \"\\f\": return \"\\\\f\";\n              case \"\\x0B\": return options.ie8 ? \"\\\\x0B\" : \"\\\\v\";\n              case \"\\u2028\": return \"\\\\u2028\";\n              case \"\\u2029\": return \"\\\\u2029\";\n              case \"\\ufeff\": return \"\\\\ufeff\";\n              case \"\\0\":\n                  return /[0-9]/.test(get_full_char(str, i+1)) ? \"\\\\x00\" : \"\\\\0\";\n            }\n            return s;\n        });\n        function quote_single() {\n            return \"'\" + str.replace(/\\x27/g, \"\\\\'\") + \"'\";\n        }\n        function quote_double() {\n            return '\"' + str.replace(/\\x22/g, '\\\\\"') + '\"';\n        }\n        function quote_template() {\n            return \"`\" + str.replace(/`/g, \"\\\\`\") + \"`\";\n        }\n        str = to_utf8(str);\n        if (quote === \"`\") return quote_template();\n        switch (options.quote_style) {\n          case 1:\n            return quote_single();\n          case 2:\n            return quote_double();\n          case 3:\n            return quote == \"'\" ? quote_single() : quote_double();\n          default:\n            return dq > sq ? quote_single() : quote_double();\n        }\n    }\n\n    function encode_string(str, quote) {\n        var ret = make_string(str, quote);\n        if (options.inline_script) {\n            ret = ret.replace(/<\\x2f(script)([>\\/\\t\\n\\f\\r ])/gi, \"<\\\\/$1$2\");\n            ret = ret.replace(/\\x3c!--/g, \"\\\\x3c!--\");\n            ret = ret.replace(/--\\x3e/g, \"--\\\\x3e\");\n        }\n        return ret;\n    }\n\n    function make_name(name) {\n        name = name.toString();\n        name = to_utf8(name, true);\n        return name;\n    }\n\n    function make_indent(back) {\n        return \" \".repeat(options.indent_start + indentation - back * options.indent_level);\n    }\n\n    /* -----[ beautification/minification ]----- */\n\n    var has_parens = false;\n    var might_need_space = false;\n    var might_need_semicolon = false;\n    var might_add_newline = 0;\n    var need_newline_indented = false;\n    var need_space = false;\n    var newline_insert = -1;\n    var last = \"\";\n    var mapping_token, mapping_name, mappings = options.source_map && [];\n\n    var do_add_mapping = mappings ? function() {\n        mappings.forEach(function(mapping) {\n            try {\n                let name = !mapping.name && mapping.token.type == \"name\" ? mapping.token.value : mapping.name;\n                if (name instanceof AST_Symbol) {\n                    name = name.name;\n                }\n                options.source_map.add(\n                    mapping.token.file,\n                    mapping.line, mapping.col,\n                    mapping.token.line, mapping.token.col,\n                    is_basic_identifier_string(name) ? name : undefined\n                );\n            } catch(ex) {\n                // Ignore bad mapping\n            }\n        });\n        mappings = [];\n    } : noop;\n\n    var ensure_line_len = options.max_line_len ? function() {\n        if (current_col > options.max_line_len) {\n            if (might_add_newline) {\n                var left = OUTPUT.slice(0, might_add_newline);\n                var right = OUTPUT.slice(might_add_newline);\n                if (mappings) {\n                    var delta = right.length - current_col;\n                    mappings.forEach(function(mapping) {\n                        mapping.line++;\n                        mapping.col += delta;\n                    });\n                }\n                OUTPUT = left + \"\\n\" + right;\n                current_line++;\n                current_pos++;\n                current_col = right.length;\n            }\n        }\n        if (might_add_newline) {\n            might_add_newline = 0;\n            do_add_mapping();\n        }\n    } : noop;\n\n    var requireSemicolonChars = makePredicate(\"( [ + * / - , . `\");\n\n    function print(str) {\n        str = String(str);\n        var ch = get_full_char(str, 0);\n        if (need_newline_indented && ch) {\n            need_newline_indented = false;\n            if (ch !== \"\\n\") {\n                print(\"\\n\");\n                indent();\n            }\n        }\n        if (need_space && ch) {\n            need_space = false;\n            if (!/[\\s;})]/.test(ch)) {\n                space();\n            }\n        }\n        newline_insert = -1;\n        var prev = last.charAt(last.length - 1);\n        if (might_need_semicolon) {\n            might_need_semicolon = false;\n\n            if (prev === \":\" && ch === \"}\" || (!ch || !\";}\".includes(ch)) && prev !== \";\") {\n                if (options.semicolons || requireSemicolonChars.has(ch)) {\n                    OUTPUT += \";\";\n                    current_col++;\n                    current_pos++;\n                } else {\n                    ensure_line_len();\n                    if (current_col > 0) {\n                        OUTPUT += \"\\n\";\n                        current_pos++;\n                        current_line++;\n                        current_col = 0;\n                    }\n\n                    if (/^\\s+$/.test(str)) {\n                        // reset the semicolon flag, since we didn't print one\n                        // now and might still have to later\n                        might_need_semicolon = true;\n                    }\n                }\n\n                if (!options.beautify)\n                    might_need_space = false;\n            }\n        }\n\n        if (might_need_space) {\n            if ((is_identifier_char(prev)\n                    && (is_identifier_char(ch) || ch == \"\\\\\"))\n                || (ch == \"/\" && ch == prev)\n                || ((ch == \"+\" || ch == \"-\") && ch == last)\n            ) {\n                OUTPUT += \" \";\n                current_col++;\n                current_pos++;\n            }\n            might_need_space = false;\n        }\n\n        if (mapping_token) {\n            mappings.push({\n                token: mapping_token,\n                name: mapping_name,\n                line: current_line,\n                col: current_col\n            });\n            mapping_token = false;\n            if (!might_add_newline) do_add_mapping();\n        }\n\n        OUTPUT += str;\n        has_parens = str[str.length - 1] == \"(\";\n        current_pos += str.length;\n        var a = str.split(/\\r?\\n/), n = a.length - 1;\n        current_line += n;\n        current_col += a[0].length;\n        if (n > 0) {\n            ensure_line_len();\n            current_col = a[n].length;\n        }\n        last = str;\n    }\n\n    var star = function() {\n        print(\"*\");\n    };\n\n    var space = options.beautify ? function() {\n        print(\" \");\n    } : function() {\n        might_need_space = true;\n    };\n\n    var indent = options.beautify ? function(half) {\n        if (options.beautify) {\n            print(make_indent(half ? 0.5 : 0));\n        }\n    } : noop;\n\n    var with_indent = options.beautify ? function(col, cont) {\n        if (col === true) col = next_indent();\n        var save_indentation = indentation;\n        indentation = col;\n        var ret = cont();\n        indentation = save_indentation;\n        return ret;\n    } : function(col, cont) { return cont(); };\n\n    var newline = options.beautify ? function() {\n        if (newline_insert < 0) return print(\"\\n\");\n        if (OUTPUT[newline_insert] != \"\\n\") {\n            OUTPUT = OUTPUT.slice(0, newline_insert) + \"\\n\" + OUTPUT.slice(newline_insert);\n            current_pos++;\n            current_line++;\n        }\n        newline_insert++;\n    } : options.max_line_len ? function() {\n        ensure_line_len();\n        might_add_newline = OUTPUT.length;\n    } : noop;\n\n    var semicolon = options.beautify ? function() {\n        print(\";\");\n    } : function() {\n        might_need_semicolon = true;\n    };\n\n    function force_semicolon() {\n        might_need_semicolon = false;\n        print(\";\");\n    }\n\n    function next_indent() {\n        return indentation + options.indent_level;\n    }\n\n    function with_block(cont) {\n        var ret;\n        print(\"{\");\n        newline();\n        with_indent(next_indent(), function() {\n            ret = cont();\n        });\n        indent();\n        print(\"}\");\n        return ret;\n    }\n\n    function with_parens(cont) {\n        print(\"(\");\n        //XXX: still nice to have that for argument lists\n        //var ret = with_indent(current_col, cont);\n        var ret = cont();\n        print(\")\");\n        return ret;\n    }\n\n    function with_square(cont) {\n        print(\"[\");\n        //var ret = with_indent(current_col, cont);\n        var ret = cont();\n        print(\"]\");\n        return ret;\n    }\n\n    function comma() {\n        print(\",\");\n        space();\n    }\n\n    function colon() {\n        print(\":\");\n        space();\n    }\n\n    var add_mapping = mappings ? function(token, name) {\n        mapping_token = token;\n        mapping_name = name;\n    } : noop;\n\n    function get() {\n        if (might_add_newline) {\n            ensure_line_len();\n        }\n        return OUTPUT;\n    }\n\n    function has_nlb() {\n        let n = OUTPUT.length - 1;\n        while (n >= 0) {\n            const code = OUTPUT.charCodeAt(n);\n            if (code === CODE_LINE_BREAK) {\n                return true;\n            }\n\n            if (code !== CODE_SPACE) {\n                return false;\n            }\n            n--;\n        }\n        return true;\n    }\n\n    function filter_comment(comment) {\n        if (!options.preserve_annotations) {\n            comment = comment.replace(r_annotation, \" \");\n        }\n        if (/^\\s*$/.test(comment)) {\n            return \"\";\n        }\n        return comment.replace(/(<\\s*\\/\\s*)(script)/i, \"<\\\\/$2\");\n    }\n\n    function prepend_comments(node) {\n        var self = this;\n        var start = node.start;\n        if (!start) return;\n        var printed_comments = self.printed_comments;\n\n        // There cannot be a newline between return and its value.\n        const return_with_value = node instanceof AST_Exit && node.value;\n\n        if (\n            start.comments_before\n            && printed_comments.has(start.comments_before)\n        ) {\n            if (return_with_value) {\n                start.comments_before = [];\n            } else {\n                return;\n            }\n        }\n\n        var comments = start.comments_before;\n        if (!comments) {\n            comments = start.comments_before = [];\n        }\n        printed_comments.add(comments);\n\n        if (return_with_value) {\n            var tw = new TreeWalker(function(node) {\n                var parent = tw.parent();\n                if (parent instanceof AST_Exit\n                    || parent instanceof AST_Binary && parent.left === node\n                    || parent.TYPE == \"Call\" && parent.expression === node\n                    || parent instanceof AST_Conditional && parent.condition === node\n                    || parent instanceof AST_Dot && parent.expression === node\n                    || parent instanceof AST_Sequence && parent.expressions[0] === node\n                    || parent instanceof AST_Sub && parent.expression === node\n                    || parent instanceof AST_UnaryPostfix) {\n                    if (!node.start) return;\n                    var text = node.start.comments_before;\n                    if (text && !printed_comments.has(text)) {\n                        printed_comments.add(text);\n                        comments = comments.concat(text);\n                    }\n                } else {\n                    return true;\n                }\n            });\n            tw.push(node);\n            node.value.walk(tw);\n        }\n\n        if (current_pos == 0) {\n            if (comments.length > 0 && options.shebang && comments[0].type === \"comment5\"\n                && !printed_comments.has(comments[0])) {\n                print(\"#!\" + comments.shift().value + \"\\n\");\n                indent();\n            }\n            var preamble = options.preamble;\n            if (preamble) {\n                print(preamble.replace(/\\r\\n?|[\\n\\u2028\\u2029]|\\s*$/g, \"\\n\"));\n            }\n        }\n\n        comments = comments.filter(comment_filter, node).filter(c => !printed_comments.has(c));\n        if (comments.length == 0) return;\n        var last_nlb = has_nlb();\n        comments.forEach(function(c, i) {\n            printed_comments.add(c);\n            if (!last_nlb) {\n                if (c.nlb) {\n                    print(\"\\n\");\n                    indent();\n                    last_nlb = true;\n                } else if (i > 0) {\n                    space();\n                }\n            }\n\n            if (/comment[134]/.test(c.type)) {\n                var value = filter_comment(c.value);\n                if (value) {\n                    print(\"//\" + value + \"\\n\");\n                    indent();\n                }\n                last_nlb = true;\n            } else if (c.type == \"comment2\") {\n                var value = filter_comment(c.value);\n                if (value) {\n                    print(\"/*\" + value + \"*/\");\n                }\n                last_nlb = false;\n            }\n        });\n        if (!last_nlb) {\n            if (start.nlb) {\n                print(\"\\n\");\n                indent();\n            } else {\n                space();\n            }\n        }\n    }\n\n    function append_comments(node, tail) {\n        var self = this;\n        var token = node.end;\n        if (!token) return;\n        var printed_comments = self.printed_comments;\n        var comments = token[tail ? \"comments_before\" : \"comments_after\"];\n        if (!comments || printed_comments.has(comments)) return;\n        if (!(node instanceof AST_Statement || comments.every((c) =>\n            !/comment[134]/.test(c.type)\n        ))) return;\n        printed_comments.add(comments);\n        var insert = OUTPUT.length;\n        comments.filter(comment_filter, node).forEach(function(c, i) {\n            if (printed_comments.has(c)) return;\n            printed_comments.add(c);\n            need_space = false;\n            if (need_newline_indented) {\n                print(\"\\n\");\n                indent();\n                need_newline_indented = false;\n            } else if (c.nlb && (i > 0 || !has_nlb())) {\n                print(\"\\n\");\n                indent();\n            } else if (i > 0 || !tail) {\n                space();\n            }\n            if (/comment[134]/.test(c.type)) {\n                const value = filter_comment(c.value);\n                if (value) {\n                    print(\"//\" + value);\n                }\n                need_newline_indented = true;\n            } else if (c.type == \"comment2\") {\n                const value = filter_comment(c.value);\n                if (value) {\n                    print(\"/*\" + value + \"*/\");\n                }\n                need_space = true;\n            }\n        });\n        if (OUTPUT.length > insert) newline_insert = insert;\n    }\n\n    var stack = [];\n    return {\n        get             : get,\n        toString        : get,\n        indent          : indent,\n        in_directive    : false,\n        use_asm         : null,\n        active_scope    : null,\n        indentation     : function() { return indentation; },\n        current_width   : function() { return current_col - indentation; },\n        should_break    : function() { return options.width && this.current_width() >= options.width; },\n        has_parens      : function() { return has_parens; },\n        newline         : newline,\n        print           : print,\n        star            : star,\n        space           : space,\n        comma           : comma,\n        colon           : colon,\n        last            : function() { return last; },\n        semicolon       : semicolon,\n        force_semicolon : force_semicolon,\n        to_utf8         : to_utf8,\n        print_name      : function(name) { print(make_name(name)); },\n        print_string    : function(str, quote, escape_directive) {\n            var encoded = encode_string(str, quote);\n            if (escape_directive === true && !encoded.includes(\"\\\\\")) {\n                // Insert semicolons to break directive prologue\n                if (!EXPECT_DIRECTIVE.test(OUTPUT)) {\n                    force_semicolon();\n                }\n                force_semicolon();\n            }\n            print(encoded);\n        },\n        print_template_string_chars: function(str) {\n            var encoded = encode_string(str, \"`\").replace(/\\${/g, \"\\\\${\");\n            return print(encoded.substr(1, encoded.length - 2));\n        },\n        encode_string   : encode_string,\n        next_indent     : next_indent,\n        with_indent     : with_indent,\n        with_block      : with_block,\n        with_parens     : with_parens,\n        with_square     : with_square,\n        add_mapping     : add_mapping,\n        option          : function(opt) { return options[opt]; },\n        printed_comments: printed_comments,\n        prepend_comments: readonly ? noop : prepend_comments,\n        append_comments : readonly || comment_filter === return_false ? noop : append_comments,\n        line            : function() { return current_line; },\n        col             : function() { return current_col; },\n        pos             : function() { return current_pos; },\n        push_node       : function(node) { stack.push(node); },\n        pop_node        : function() { return stack.pop(); },\n        parent          : function(n) {\n            return stack[stack.length - 2 - (n || 0)];\n        }\n    };\n\n}\n\n/* -----[ code generators ]----- */\n\n(function() {\n\n    /* -----[ utils ]----- */\n\n    function DEFPRINT(nodetype, generator) {\n        nodetype.DEFMETHOD(\"_codegen\", generator);\n    }\n\n    AST_Node.DEFMETHOD(\"print\", function(output, force_parens) {\n        var self = this, generator = self._codegen;\n        if (self instanceof AST_Scope) {\n            output.active_scope = self;\n        } else if (!output.use_asm && self instanceof AST_Directive && self.value == \"use asm\") {\n            output.use_asm = output.active_scope;\n        }\n        function doit() {\n            output.prepend_comments(self);\n            self.add_source_map(output);\n            generator(self, output);\n            output.append_comments(self);\n        }\n        output.push_node(self);\n        if (force_parens || self.needs_parens(output)) {\n            output.with_parens(doit);\n        } else {\n            doit();\n        }\n        output.pop_node();\n        if (self === output.use_asm) {\n            output.use_asm = null;\n        }\n    });\n    AST_Node.DEFMETHOD(\"_print\", AST_Node.prototype.print);\n\n    AST_Node.DEFMETHOD(\"print_to_string\", function(options) {\n        var output = OutputStream(options);\n        this.print(output);\n        return output.get();\n    });\n\n    /* -----[ PARENTHESES ]----- */\n\n    function PARENS(nodetype, func) {\n        if (Array.isArray(nodetype)) {\n            nodetype.forEach(function(nodetype) {\n                PARENS(nodetype, func);\n            });\n        } else {\n            nodetype.DEFMETHOD(\"needs_parens\", func);\n        }\n    }\n\n    PARENS(AST_Node, return_false);\n\n    // a function expression needs parens around it when it's provably\n    // the first token to appear in a statement.\n    PARENS(AST_Function, function(output) {\n        if (!output.has_parens() && first_in_statement(output)) {\n            return true;\n        }\n\n        if (output.option(\"webkit\")) {\n            var p = output.parent();\n            if (p instanceof AST_PropAccess && p.expression === this) {\n                return true;\n            }\n        }\n\n        if (output.option(\"wrap_iife\")) {\n            var p = output.parent();\n            if (p instanceof AST_Call && p.expression === this) {\n                return true;\n            }\n        }\n\n        if (output.option(\"wrap_func_args\")) {\n            var p = output.parent();\n            if (p instanceof AST_Call && p.args.includes(this)) {\n                return true;\n            }\n        }\n\n        return false;\n    });\n\n    PARENS(AST_Arrow, function(output) {\n        var p = output.parent();\n\n        if (\n            output.option(\"wrap_func_args\")\n            && p instanceof AST_Call\n            && p.args.includes(this)\n        ) {\n            return true;\n        }\n        return p instanceof AST_PropAccess && p.expression === this;\n    });\n\n    // same goes for an object literal (as in AST_Function), because\n    // otherwise {...} would be interpreted as a block of code.\n    PARENS(AST_Object, function(output) {\n        return !output.has_parens() && first_in_statement(output);\n    });\n\n    PARENS(AST_ClassExpression, first_in_statement);\n\n    PARENS(AST_Unary, function(output) {\n        var p = output.parent();\n        return p instanceof AST_PropAccess && p.expression === this\n            || p instanceof AST_Call && p.expression === this\n            || p instanceof AST_Binary\n                && p.operator === \"**\"\n                && this instanceof AST_UnaryPrefix\n                && p.left === this\n                && this.operator !== \"++\"\n                && this.operator !== \"--\";\n    });\n\n    PARENS(AST_Await, function(output) {\n        var p = output.parent();\n        return p instanceof AST_PropAccess && p.expression === this\n            || p instanceof AST_Call && p.expression === this\n            || p instanceof AST_Binary && p.operator === \"**\" && p.left === this\n            || output.option(\"safari10\") && p instanceof AST_UnaryPrefix;\n    });\n\n    PARENS(AST_Sequence, function(output) {\n        var p = output.parent();\n        return p instanceof AST_Call                          // (foo, bar)() or foo(1, (2, 3), 4)\n            || p instanceof AST_Unary                         // !(foo, bar, baz)\n            || p instanceof AST_Binary                        // 1 + (2, 3) + 4 ==> 8\n            || p instanceof AST_VarDef                        // var a = (1, 2), b = a + a; ==> b == 4\n            || p instanceof AST_PropAccess                    // (1, {foo:2}).foo or (1, {foo:2})[\"foo\"] ==> 2\n            || p instanceof AST_Array                         // [ 1, (2, 3), 4 ] ==> [ 1, 3, 4 ]\n            || p instanceof AST_ObjectProperty                // { foo: (1, 2) }.foo ==> 2\n            || p instanceof AST_Conditional                   /* (false, true) ? (a = 10, b = 20) : (c = 30)\n                                                               * ==> 20 (side effect, set a := 10 and b := 20) */\n            || p instanceof AST_Arrow                         // x => (x, x)\n            || p instanceof AST_DefaultAssign                 // x => (x = (0, function(){}))\n            || p instanceof AST_Expansion                     // [...(a, b)]\n            || p instanceof AST_ForOf && this === p.object    // for (e of (foo, bar)) {}\n            || p instanceof AST_Yield                         // yield (foo, bar)\n            || p instanceof AST_Export                        // export default (foo, bar)\n        ;\n    });\n\n    PARENS(AST_Binary, function(output) {\n        var p = output.parent();\n        // (foo && bar)()\n        if (p instanceof AST_Call && p.expression === this)\n            return true;\n        // typeof (foo && bar)\n        if (p instanceof AST_Unary)\n            return true;\n        // (foo && bar)[\"prop\"], (foo && bar).prop\n        if (p instanceof AST_PropAccess && p.expression === this)\n            return true;\n        // this deals with precedence: 3 * (2 + 1)\n        if (p instanceof AST_Binary) {\n            const po = p.operator;\n            const so = this.operator;\n\n            if (so === \"??\" && (po === \"||\" || po === \"&&\")) {\n                return true;\n            }\n\n            if (po === \"??\" && (so === \"||\" || so === \"&&\")) {\n                return true;\n            }\n\n            const pp = PRECEDENCE[po];\n            const sp = PRECEDENCE[so];\n            if (pp > sp\n                || (pp == sp\n                    && (this === p.right || po == \"**\"))) {\n                return true;\n            }\n        }\n    });\n\n    PARENS(AST_Yield, function(output) {\n        var p = output.parent();\n        // (yield 1) + (yield 2)\n        // a = yield 3\n        if (p instanceof AST_Binary && p.operator !== \"=\")\n            return true;\n        // (yield 1)()\n        // new (yield 1)()\n        if (p instanceof AST_Call && p.expression === this)\n            return true;\n        // (yield 1) ? yield 2 : yield 3\n        if (p instanceof AST_Conditional && p.condition === this)\n            return true;\n        // -(yield 4)\n        if (p instanceof AST_Unary)\n            return true;\n        // (yield x).foo\n        // (yield x)['foo']\n        if (p instanceof AST_PropAccess && p.expression === this)\n            return true;\n    });\n\n    PARENS(AST_PropAccess, function(output) {\n        var p = output.parent();\n        if (p instanceof AST_New && p.expression === this) {\n            // i.e. new (foo.bar().baz)\n            //\n            // if there's one call into this subtree, then we need\n            // parens around it too, otherwise the call will be\n            // interpreted as passing the arguments to the upper New\n            // expression.\n            return walk(this, node => {\n                if (node instanceof AST_Scope) return true;\n                if (node instanceof AST_Call) {\n                    return walk_abort;  // makes walk() return true.\n                }\n            });\n        }\n    });\n\n    PARENS(AST_Call, function(output) {\n        var p = output.parent(), p1;\n        if (p instanceof AST_New && p.expression === this\n            || p instanceof AST_Export && p.is_default && this.expression instanceof AST_Function)\n            return true;\n\n        // workaround for Safari bug.\n        // https://bugs.webkit.org/show_bug.cgi?id=123506\n        return this.expression instanceof AST_Function\n            && p instanceof AST_PropAccess\n            && p.expression === this\n            && (p1 = output.parent(1)) instanceof AST_Assign\n            && p1.left === p;\n    });\n\n    PARENS(AST_New, function(output) {\n        var p = output.parent();\n        if (this.args.length === 0\n            && (p instanceof AST_PropAccess // (new Date).getTime(), (new Date)[\"getTime\"]()\n                || p instanceof AST_Call && p.expression === this)) // (new foo)(bar)\n            return true;\n    });\n\n    PARENS(AST_Number, function(output) {\n        var p = output.parent();\n        if (p instanceof AST_PropAccess && p.expression === this) {\n            var value = this.getValue();\n            if (value < 0 || /^0/.test(make_num(value))) {\n                return true;\n            }\n        }\n    });\n\n    PARENS(AST_BigInt, function(output) {\n        var p = output.parent();\n        if (p instanceof AST_PropAccess && p.expression === this) {\n            var value = this.getValue();\n            if (value.startsWith(\"-\")) {\n                return true;\n            }\n        }\n    });\n\n    PARENS([ AST_Assign, AST_Conditional ], function(output) {\n        var p = output.parent();\n        // !(a = false) → true\n        if (p instanceof AST_Unary)\n            return true;\n        // 1 + (a = 2) + 3 → 6, side effect setting a = 2\n        if (p instanceof AST_Binary && !(p instanceof AST_Assign))\n            return true;\n        // (a = func)() —or— new (a = Object)()\n        if (p instanceof AST_Call && p.expression === this)\n            return true;\n        // (a = foo) ? bar : baz\n        if (p instanceof AST_Conditional && p.condition === this)\n            return true;\n        // (a = foo)[\"prop\"] —or— (a = foo).prop\n        if (p instanceof AST_PropAccess && p.expression === this)\n            return true;\n        // ({a, b} = {a: 1, b: 2}), a destructuring assignment\n        if (this instanceof AST_Assign && this.left instanceof AST_Destructuring && this.left.is_array === false)\n            return true;\n    });\n\n    /* -----[ PRINTERS ]----- */\n\n    DEFPRINT(AST_Directive, function(self, output) {\n        output.print_string(self.value, self.quote);\n        output.semicolon();\n    });\n\n    DEFPRINT(AST_Expansion, function (self, output) {\n        output.print(\"...\");\n        self.expression.print(output);\n    });\n\n    DEFPRINT(AST_Destructuring, function (self, output) {\n        output.print(self.is_array ? \"[\" : \"{\");\n        var len = self.names.length;\n        self.names.forEach(function (name, i) {\n            if (i > 0) output.comma();\n            name.print(output);\n            // If the final element is a hole, we need to make sure it\n            // doesn't look like a trailing comma, by inserting an actual\n            // trailing comma.\n            if (i == len - 1 && name instanceof AST_Hole) output.comma();\n        });\n        output.print(self.is_array ? \"]\" : \"}\");\n    });\n\n    DEFPRINT(AST_Debugger, function(self, output) {\n        output.print(\"debugger\");\n        output.semicolon();\n    });\n\n    /* -----[ statements ]----- */\n\n    function display_body(body, is_toplevel, output, allow_directives) {\n        var last = body.length - 1;\n        output.in_directive = allow_directives;\n        body.forEach(function(stmt, i) {\n            if (output.in_directive === true && !(stmt instanceof AST_Directive ||\n                stmt instanceof AST_EmptyStatement ||\n                (stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String)\n            )) {\n                output.in_directive = false;\n            }\n            if (!(stmt instanceof AST_EmptyStatement)) {\n                output.indent();\n                stmt.print(output);\n                if (!(i == last && is_toplevel)) {\n                    output.newline();\n                    if (is_toplevel) output.newline();\n                }\n            }\n            if (output.in_directive === true &&\n                stmt instanceof AST_SimpleStatement &&\n                stmt.body instanceof AST_String\n            ) {\n                output.in_directive = false;\n            }\n        });\n        output.in_directive = false;\n    }\n\n    AST_StatementWithBody.DEFMETHOD(\"_do_print_body\", function(output) {\n        force_statement(this.body, output);\n    });\n\n    DEFPRINT(AST_Statement, function(self, output) {\n        self.body.print(output);\n        output.semicolon();\n    });\n    DEFPRINT(AST_Toplevel, function(self, output) {\n        display_body(self.body, true, output, true);\n        output.print(\"\");\n    });\n    DEFPRINT(AST_LabeledStatement, function(self, output) {\n        self.label.print(output);\n        output.colon();\n        self.body.print(output);\n    });\n    DEFPRINT(AST_SimpleStatement, function(self, output) {\n        self.body.print(output);\n        output.semicolon();\n    });\n    function print_braced_empty(self, output) {\n        output.print(\"{\");\n        output.with_indent(output.next_indent(), function() {\n            output.append_comments(self, true);\n        });\n        output.print(\"}\");\n    }\n    function print_braced(self, output, allow_directives) {\n        if (self.body.length > 0) {\n            output.with_block(function() {\n                display_body(self.body, false, output, allow_directives);\n            });\n        } else print_braced_empty(self, output);\n    }\n    DEFPRINT(AST_BlockStatement, function(self, output) {\n        print_braced(self, output);\n    });\n    DEFPRINT(AST_EmptyStatement, function(self, output) {\n        output.semicolon();\n    });\n    DEFPRINT(AST_Do, function(self, output) {\n        output.print(\"do\");\n        output.space();\n        make_block(self.body, output);\n        output.space();\n        output.print(\"while\");\n        output.space();\n        output.with_parens(function() {\n            self.condition.print(output);\n        });\n        output.semicolon();\n    });\n    DEFPRINT(AST_While, function(self, output) {\n        output.print(\"while\");\n        output.space();\n        output.with_parens(function() {\n            self.condition.print(output);\n        });\n        output.space();\n        self._do_print_body(output);\n    });\n    DEFPRINT(AST_For, function(self, output) {\n        output.print(\"for\");\n        output.space();\n        output.with_parens(function() {\n            if (self.init) {\n                if (self.init instanceof AST_Definitions) {\n                    self.init.print(output);\n                } else {\n                    parenthesize_for_noin(self.init, output, true);\n                }\n                output.print(\";\");\n                output.space();\n            } else {\n                output.print(\";\");\n            }\n            if (self.condition) {\n                self.condition.print(output);\n                output.print(\";\");\n                output.space();\n            } else {\n                output.print(\";\");\n            }\n            if (self.step) {\n                self.step.print(output);\n            }\n        });\n        output.space();\n        self._do_print_body(output);\n    });\n    DEFPRINT(AST_ForIn, function(self, output) {\n        output.print(\"for\");\n        if (self.await) {\n            output.space();\n            output.print(\"await\");\n        }\n        output.space();\n        output.with_parens(function() {\n            self.init.print(output);\n            output.space();\n            output.print(self instanceof AST_ForOf ? \"of\" : \"in\");\n            output.space();\n            self.object.print(output);\n        });\n        output.space();\n        self._do_print_body(output);\n    });\n    DEFPRINT(AST_With, function(self, output) {\n        output.print(\"with\");\n        output.space();\n        output.with_parens(function() {\n            self.expression.print(output);\n        });\n        output.space();\n        self._do_print_body(output);\n    });\n\n    /* -----[ functions ]----- */\n    AST_Lambda.DEFMETHOD(\"_do_print\", function(output, nokeyword) {\n        var self = this;\n        if (!nokeyword) {\n            if (self.async) {\n                output.print(\"async\");\n                output.space();\n            }\n            output.print(\"function\");\n            if (self.is_generator) {\n                output.star();\n            }\n            if (self.name) {\n                output.space();\n            }\n        }\n        if (self.name instanceof AST_Symbol) {\n            self.name.print(output);\n        } else if (nokeyword && self.name instanceof AST_Node) {\n            output.with_square(function() {\n                self.name.print(output); // Computed method name\n            });\n        }\n        output.with_parens(function() {\n            self.argnames.forEach(function(arg, i) {\n                if (i) output.comma();\n                arg.print(output);\n            });\n        });\n        output.space();\n        print_braced(self, output, true);\n    });\n    DEFPRINT(AST_Lambda, function(self, output) {\n        self._do_print(output);\n    });\n\n    DEFPRINT(AST_PrefixedTemplateString, function(self, output) {\n        var tag = self.prefix;\n        var parenthesize_tag = tag instanceof AST_Lambda\n            || tag instanceof AST_Binary\n            || tag instanceof AST_Conditional\n            || tag instanceof AST_Sequence\n            || tag instanceof AST_Unary\n            || tag instanceof AST_Dot && tag.expression instanceof AST_Object;\n        if (parenthesize_tag) output.print(\"(\");\n        self.prefix.print(output);\n        if (parenthesize_tag) output.print(\")\");\n        self.template_string.print(output);\n    });\n    DEFPRINT(AST_TemplateString, function(self, output) {\n        var is_tagged = output.parent() instanceof AST_PrefixedTemplateString;\n\n        output.print(\"`\");\n        for (var i = 0; i < self.segments.length; i++) {\n            if (!(self.segments[i] instanceof AST_TemplateSegment)) {\n                output.print(\"${\");\n                self.segments[i].print(output);\n                output.print(\"}\");\n            } else if (is_tagged) {\n                output.print(self.segments[i].raw);\n            } else {\n                output.print_template_string_chars(self.segments[i].value);\n            }\n        }\n        output.print(\"`\");\n    });\n    DEFPRINT(AST_TemplateSegment, function(self, output) {\n        output.print_template_string_chars(self.value);\n    });\n\n    AST_Arrow.DEFMETHOD(\"_do_print\", function(output) {\n        var self = this;\n        var parent = output.parent();\n        var needs_parens = (parent instanceof AST_Binary && !(parent instanceof AST_Assign)) ||\n            parent instanceof AST_Unary ||\n            (parent instanceof AST_Call && self === parent.expression);\n        if (needs_parens) { output.print(\"(\"); }\n        if (self.async) {\n            output.print(\"async\");\n            output.space();\n        }\n        if (self.argnames.length === 1 && self.argnames[0] instanceof AST_Symbol) {\n            self.argnames[0].print(output);\n        } else {\n            output.with_parens(function() {\n                self.argnames.forEach(function(arg, i) {\n                    if (i) output.comma();\n                    arg.print(output);\n                });\n            });\n        }\n        output.space();\n        output.print(\"=>\");\n        output.space();\n        const first_statement = self.body[0];\n        if (\n            self.body.length === 1\n            && first_statement instanceof AST_Return\n        ) {\n            const returned = first_statement.value;\n            if (!returned) {\n                output.print(\"{}\");\n            } else if (left_is_object(returned)) {\n                output.print(\"(\");\n                returned.print(output);\n                output.print(\")\");\n            } else {\n                returned.print(output);\n            }\n        } else {\n            print_braced(self, output);\n        }\n        if (needs_parens) { output.print(\")\"); }\n    });\n\n    /* -----[ exits ]----- */\n    AST_Exit.DEFMETHOD(\"_do_print\", function(output, kind) {\n        output.print(kind);\n        if (this.value) {\n            output.space();\n            const comments = this.value.start.comments_before;\n            if (comments && comments.length && !output.printed_comments.has(comments)) {\n                output.print(\"(\");\n                this.value.print(output);\n                output.print(\")\");\n            } else {\n                this.value.print(output);\n            }\n        }\n        output.semicolon();\n    });\n    DEFPRINT(AST_Return, function(self, output) {\n        self._do_print(output, \"return\");\n    });\n    DEFPRINT(AST_Throw, function(self, output) {\n        self._do_print(output, \"throw\");\n    });\n\n    /* -----[ yield ]----- */\n\n    DEFPRINT(AST_Yield, function(self, output) {\n        var star = self.is_star ? \"*\" : \"\";\n        output.print(\"yield\" + star);\n        if (self.expression) {\n            output.space();\n            self.expression.print(output);\n        }\n    });\n\n    DEFPRINT(AST_Await, function(self, output) {\n        output.print(\"await\");\n        output.space();\n        var e = self.expression;\n        var parens = !(\n               e instanceof AST_Call\n            || e instanceof AST_SymbolRef\n            || e instanceof AST_PropAccess\n            || e instanceof AST_Unary\n            || e instanceof AST_Constant\n            || e instanceof AST_Await\n            || e instanceof AST_Object\n        );\n        if (parens) output.print(\"(\");\n        self.expression.print(output);\n        if (parens) output.print(\")\");\n    });\n\n    /* -----[ loop control ]----- */\n    AST_LoopControl.DEFMETHOD(\"_do_print\", function(output, kind) {\n        output.print(kind);\n        if (this.label) {\n            output.space();\n            this.label.print(output);\n        }\n        output.semicolon();\n    });\n    DEFPRINT(AST_Break, function(self, output) {\n        self._do_print(output, \"break\");\n    });\n    DEFPRINT(AST_Continue, function(self, output) {\n        self._do_print(output, \"continue\");\n    });\n\n    /* -----[ if ]----- */\n    function make_then(self, output) {\n        var b = self.body;\n        if (output.option(\"braces\")\n            || output.option(\"ie8\") && b instanceof AST_Do)\n            return make_block(b, output);\n        // The squeezer replaces \"block\"-s that contain only a single\n        // statement with the statement itself; technically, the AST\n        // is correct, but this can create problems when we output an\n        // IF having an ELSE clause where the THEN clause ends in an\n        // IF *without* an ELSE block (then the outer ELSE would refer\n        // to the inner IF).  This function checks for this case and\n        // adds the block braces if needed.\n        if (!b) return output.force_semicolon();\n        while (true) {\n            if (b instanceof AST_If) {\n                if (!b.alternative) {\n                    make_block(self.body, output);\n                    return;\n                }\n                b = b.alternative;\n            } else if (b instanceof AST_StatementWithBody) {\n                b = b.body;\n            } else break;\n        }\n        force_statement(self.body, output);\n    }\n    DEFPRINT(AST_If, function(self, output) {\n        output.print(\"if\");\n        output.space();\n        output.with_parens(function() {\n            self.condition.print(output);\n        });\n        output.space();\n        if (self.alternative) {\n            make_then(self, output);\n            output.space();\n            output.print(\"else\");\n            output.space();\n            if (self.alternative instanceof AST_If)\n                self.alternative.print(output);\n            else\n                force_statement(self.alternative, output);\n        } else {\n            self._do_print_body(output);\n        }\n    });\n\n    /* -----[ switch ]----- */\n    DEFPRINT(AST_Switch, function(self, output) {\n        output.print(\"switch\");\n        output.space();\n        output.with_parens(function() {\n            self.expression.print(output);\n        });\n        output.space();\n        var last = self.body.length - 1;\n        if (last < 0) print_braced_empty(self, output);\n        else output.with_block(function() {\n            self.body.forEach(function(branch, i) {\n                output.indent(true);\n                branch.print(output);\n                if (i < last && branch.body.length > 0)\n                    output.newline();\n            });\n        });\n    });\n    AST_SwitchBranch.DEFMETHOD(\"_do_print_body\", function(output) {\n        output.newline();\n        this.body.forEach(function(stmt) {\n            output.indent();\n            stmt.print(output);\n            output.newline();\n        });\n    });\n    DEFPRINT(AST_Default, function(self, output) {\n        output.print(\"default:\");\n        self._do_print_body(output);\n    });\n    DEFPRINT(AST_Case, function(self, output) {\n        output.print(\"case\");\n        output.space();\n        self.expression.print(output);\n        output.print(\":\");\n        self._do_print_body(output);\n    });\n\n    /* -----[ exceptions ]----- */\n    DEFPRINT(AST_Try, function(self, output) {\n        output.print(\"try\");\n        output.space();\n        print_braced(self, output);\n        if (self.bcatch) {\n            output.space();\n            self.bcatch.print(output);\n        }\n        if (self.bfinally) {\n            output.space();\n            self.bfinally.print(output);\n        }\n    });\n    DEFPRINT(AST_Catch, function(self, output) {\n        output.print(\"catch\");\n        if (self.argname) {\n            output.space();\n            output.with_parens(function() {\n                self.argname.print(output);\n            });\n        }\n        output.space();\n        print_braced(self, output);\n    });\n    DEFPRINT(AST_Finally, function(self, output) {\n        output.print(\"finally\");\n        output.space();\n        print_braced(self, output);\n    });\n\n    /* -----[ var/const ]----- */\n    AST_Definitions.DEFMETHOD(\"_do_print\", function(output, kind) {\n        output.print(kind);\n        output.space();\n        this.definitions.forEach(function(def, i) {\n            if (i) output.comma();\n            def.print(output);\n        });\n        var p = output.parent();\n        var in_for = p instanceof AST_For || p instanceof AST_ForIn;\n        var output_semicolon = !in_for || p && p.init !== this;\n        if (output_semicolon)\n            output.semicolon();\n    });\n    DEFPRINT(AST_Let, function(self, output) {\n        self._do_print(output, \"let\");\n    });\n    DEFPRINT(AST_Var, function(self, output) {\n        self._do_print(output, \"var\");\n    });\n    DEFPRINT(AST_Const, function(self, output) {\n        self._do_print(output, \"const\");\n    });\n    DEFPRINT(AST_Import, function(self, output) {\n        output.print(\"import\");\n        output.space();\n        if (self.imported_name) {\n            self.imported_name.print(output);\n        }\n        if (self.imported_name && self.imported_names) {\n            output.print(\",\");\n            output.space();\n        }\n        if (self.imported_names) {\n            if (self.imported_names.length === 1 && self.imported_names[0].foreign_name.name === \"*\") {\n                self.imported_names[0].print(output);\n            } else {\n                output.print(\"{\");\n                self.imported_names.forEach(function (name_import, i) {\n                    output.space();\n                    name_import.print(output);\n                    if (i < self.imported_names.length - 1) {\n                        output.print(\",\");\n                    }\n                });\n                output.space();\n                output.print(\"}\");\n            }\n        }\n        if (self.imported_name || self.imported_names) {\n            output.space();\n            output.print(\"from\");\n            output.space();\n        }\n        self.module_name.print(output);\n        output.semicolon();\n    });\n    DEFPRINT(AST_ImportMeta, function(self, output) {\n        output.print(\"import.meta\");\n    });\n\n    DEFPRINT(AST_NameMapping, function(self, output) {\n        var is_import = output.parent() instanceof AST_Import;\n        var definition = self.name.definition();\n        var names_are_different =\n            (definition && definition.mangled_name || self.name.name) !==\n            self.foreign_name.name;\n        if (names_are_different) {\n            if (is_import) {\n                output.print(self.foreign_name.name);\n            } else {\n                self.name.print(output);\n            }\n            output.space();\n            output.print(\"as\");\n            output.space();\n            if (is_import) {\n                self.name.print(output);\n            } else {\n                output.print(self.foreign_name.name);\n            }\n        } else {\n            self.name.print(output);\n        }\n    });\n\n    DEFPRINT(AST_Export, function(self, output) {\n        output.print(\"export\");\n        output.space();\n        if (self.is_default) {\n            output.print(\"default\");\n            output.space();\n        }\n        if (self.exported_names) {\n            if (self.exported_names.length === 1 && self.exported_names[0].name.name === \"*\") {\n                self.exported_names[0].print(output);\n            } else {\n                output.print(\"{\");\n                self.exported_names.forEach(function(name_export, i) {\n                    output.space();\n                    name_export.print(output);\n                    if (i < self.exported_names.length - 1) {\n                        output.print(\",\");\n                    }\n                });\n                output.space();\n                output.print(\"}\");\n            }\n        } else if (self.exported_value) {\n            self.exported_value.print(output);\n        } else if (self.exported_definition) {\n            self.exported_definition.print(output);\n            if (self.exported_definition instanceof AST_Definitions) return;\n        }\n        if (self.module_name) {\n            output.space();\n            output.print(\"from\");\n            output.space();\n            self.module_name.print(output);\n        }\n        if (self.exported_value\n                && !(self.exported_value instanceof AST_Defun ||\n                    self.exported_value instanceof AST_Function ||\n                    self.exported_value instanceof AST_Class)\n            || self.module_name\n            || self.exported_names\n        ) {\n            output.semicolon();\n        }\n    });\n\n    function parenthesize_for_noin(node, output, noin) {\n        var parens = false;\n        // need to take some precautions here:\n        //    https://github.com/mishoo/UglifyJS2/issues/60\n        if (noin) {\n            parens = walk(node, node => {\n                if (node instanceof AST_Scope) return true;\n                if (node instanceof AST_Binary && node.operator == \"in\") {\n                    return walk_abort;  // makes walk() return true\n                }\n            });\n        }\n        node.print(output, parens);\n    }\n\n    DEFPRINT(AST_VarDef, function(self, output) {\n        self.name.print(output);\n        if (self.value) {\n            output.space();\n            output.print(\"=\");\n            output.space();\n            var p = output.parent(1);\n            var noin = p instanceof AST_For || p instanceof AST_ForIn;\n            parenthesize_for_noin(self.value, output, noin);\n        }\n    });\n\n    /* -----[ other expressions ]----- */\n    DEFPRINT(AST_Call, function(self, output) {\n        self.expression.print(output);\n        if (self instanceof AST_New && self.args.length === 0)\n            return;\n        if (self.expression instanceof AST_Call || self.expression instanceof AST_Lambda) {\n            output.add_mapping(self.start);\n        }\n        if (self.optional) output.print(\"?.\");\n        output.with_parens(function() {\n            self.args.forEach(function(expr, i) {\n                if (i) output.comma();\n                expr.print(output);\n            });\n        });\n    });\n    DEFPRINT(AST_New, function(self, output) {\n        output.print(\"new\");\n        output.space();\n        AST_Call.prototype._codegen(self, output);\n    });\n\n    AST_Sequence.DEFMETHOD(\"_do_print\", function(output) {\n        this.expressions.forEach(function(node, index) {\n            if (index > 0) {\n                output.comma();\n                if (output.should_break()) {\n                    output.newline();\n                    output.indent();\n                }\n            }\n            node.print(output);\n        });\n    });\n    DEFPRINT(AST_Sequence, function(self, output) {\n        self._do_print(output);\n        // var p = output.parent();\n        // if (p instanceof AST_Statement) {\n        //     output.with_indent(output.next_indent(), function(){\n        //         self._do_print(output);\n        //     });\n        // } else {\n        //     self._do_print(output);\n        // }\n    });\n    DEFPRINT(AST_Dot, function(self, output) {\n        var expr = self.expression;\n        expr.print(output);\n        var prop = self.property;\n        var print_computed = RESERVED_WORDS.has(prop)\n            ? output.option(\"ie8\")\n            : !is_identifier_string(\n                prop,\n                output.option(\"ecma\") >= 2015 || output.option(\"safari10\")\n            );\n\n        if (self.optional) output.print(\"?.\");\n\n        if (print_computed) {\n            output.print(\"[\");\n            output.add_mapping(self.end);\n            output.print_string(prop);\n            output.print(\"]\");\n        } else {\n            if (expr instanceof AST_Number && expr.getValue() >= 0) {\n                if (!/[xa-f.)]/i.test(output.last())) {\n                    output.print(\".\");\n                }\n            }\n            if (!self.optional) output.print(\".\");\n            // the name after dot would be mapped about here.\n            output.add_mapping(self.end);\n            output.print_name(prop);\n        }\n    });\n    DEFPRINT(AST_DotHash, function(self, output) {\n        var expr = self.expression;\n        expr.print(output);\n        var prop = self.property;\n\n        if (self.optional) output.print(\"?\");\n        output.print(\".#\");\n        output.print_name(prop);\n    });\n    DEFPRINT(AST_Sub, function(self, output) {\n        self.expression.print(output);\n        if (self.optional) output.print(\"?.\");\n        output.print(\"[\");\n        self.property.print(output);\n        output.print(\"]\");\n    });\n    DEFPRINT(AST_Chain, function(self, output) {\n        self.expression.print(output);\n    });\n    DEFPRINT(AST_UnaryPrefix, function(self, output) {\n        var op = self.operator;\n        output.print(op);\n        if (/^[a-z]/i.test(op)\n            || (/[+-]$/.test(op)\n                && self.expression instanceof AST_UnaryPrefix\n                && /^[+-]/.test(self.expression.operator))) {\n            output.space();\n        }\n        self.expression.print(output);\n    });\n    DEFPRINT(AST_UnaryPostfix, function(self, output) {\n        self.expression.print(output);\n        output.print(self.operator);\n    });\n    DEFPRINT(AST_Binary, function(self, output) {\n        var op = self.operator;\n        self.left.print(output);\n        if (op[0] == \">\" /* \">>\" \">>>\" \">\" \">=\" */\n            && self.left instanceof AST_UnaryPostfix\n            && self.left.operator == \"--\") {\n            // space is mandatory to avoid outputting -->\n            output.print(\" \");\n        } else {\n            // the space is optional depending on \"beautify\"\n            output.space();\n        }\n        output.print(op);\n        if ((op == \"<\" || op == \"<<\")\n            && self.right instanceof AST_UnaryPrefix\n            && self.right.operator == \"!\"\n            && self.right.expression instanceof AST_UnaryPrefix\n            && self.right.expression.operator == \"--\") {\n            // space is mandatory to avoid outputting <!--\n            output.print(\" \");\n        } else {\n            // the space is optional depending on \"beautify\"\n            output.space();\n        }\n        self.right.print(output);\n    });\n    DEFPRINT(AST_Conditional, function(self, output) {\n        self.condition.print(output);\n        output.space();\n        output.print(\"?\");\n        output.space();\n        self.consequent.print(output);\n        output.space();\n        output.colon();\n        self.alternative.print(output);\n    });\n\n    /* -----[ literals ]----- */\n    DEFPRINT(AST_Array, function(self, output) {\n        output.with_square(function() {\n            var a = self.elements, len = a.length;\n            if (len > 0) output.space();\n            a.forEach(function(exp, i) {\n                if (i) output.comma();\n                exp.print(output);\n                // If the final element is a hole, we need to make sure it\n                // doesn't look like a trailing comma, by inserting an actual\n                // trailing comma.\n                if (i === len - 1 && exp instanceof AST_Hole)\n                  output.comma();\n            });\n            if (len > 0) output.space();\n        });\n    });\n    DEFPRINT(AST_Object, function(self, output) {\n        if (self.properties.length > 0) output.with_block(function() {\n            self.properties.forEach(function(prop, i) {\n                if (i) {\n                    output.print(\",\");\n                    output.newline();\n                }\n                output.indent();\n                prop.print(output);\n            });\n            output.newline();\n        });\n        else print_braced_empty(self, output);\n    });\n    DEFPRINT(AST_Class, function(self, output) {\n        output.print(\"class\");\n        output.space();\n        if (self.name) {\n            self.name.print(output);\n            output.space();\n        }\n        if (self.extends) {\n            var parens = (\n                   !(self.extends instanceof AST_SymbolRef)\n                && !(self.extends instanceof AST_PropAccess)\n                && !(self.extends instanceof AST_ClassExpression)\n                && !(self.extends instanceof AST_Function)\n            );\n            output.print(\"extends\");\n            if (parens) {\n                output.print(\"(\");\n            } else {\n                output.space();\n            }\n            self.extends.print(output);\n            if (parens) {\n                output.print(\")\");\n            } else {\n                output.space();\n            }\n        }\n        if (self.properties.length > 0) output.with_block(function() {\n            self.properties.forEach(function(prop, i) {\n                if (i) {\n                    output.newline();\n                }\n                output.indent();\n                prop.print(output);\n            });\n            output.newline();\n        });\n        else output.print(\"{}\");\n    });\n    DEFPRINT(AST_NewTarget, function(self, output) {\n        output.print(\"new.target\");\n    });\n\n    function print_property_name(key, quote, output) {\n        if (output.option(\"quote_keys\")) {\n            return output.print_string(key);\n        }\n        if (\"\" + +key == key && key >= 0) {\n            if (output.option(\"keep_numbers\")) {\n                return output.print(key);\n            }\n            return output.print(make_num(key));\n        }\n        var print_string = RESERVED_WORDS.has(key)\n            ? output.option(\"ie8\")\n            : (\n                output.option(\"ecma\") < 2015 || output.option(\"safari10\")\n                    ? !is_basic_identifier_string(key)\n                    : !is_identifier_string(key, true)\n            );\n        if (print_string || (quote && output.option(\"keep_quoted_props\"))) {\n            return output.print_string(key, quote);\n        }\n        return output.print_name(key);\n    }\n\n    DEFPRINT(AST_ObjectKeyVal, function(self, output) {\n        function get_name(self) {\n            var def = self.definition();\n            return def ? def.mangled_name || def.name : self.name;\n        }\n\n        var allowShortHand = output.option(\"shorthand\");\n        if (allowShortHand &&\n            self.value instanceof AST_Symbol &&\n            is_identifier_string(\n                self.key,\n                output.option(\"ecma\") >= 2015 || output.option(\"safari10\")\n            ) &&\n            get_name(self.value) === self.key &&\n            !RESERVED_WORDS.has(self.key)\n        ) {\n            print_property_name(self.key, self.quote, output);\n\n        } else if (allowShortHand &&\n            self.value instanceof AST_DefaultAssign &&\n            self.value.left instanceof AST_Symbol &&\n            is_identifier_string(\n                self.key,\n                output.option(\"ecma\") >= 2015 || output.option(\"safari10\")\n            ) &&\n            get_name(self.value.left) === self.key\n        ) {\n            print_property_name(self.key, self.quote, output);\n            output.space();\n            output.print(\"=\");\n            output.space();\n            self.value.right.print(output);\n        } else {\n            if (!(self.key instanceof AST_Node)) {\n                print_property_name(self.key, self.quote, output);\n            } else {\n                output.with_square(function() {\n                    self.key.print(output);\n                });\n            }\n            output.colon();\n            self.value.print(output);\n        }\n    });\n    DEFPRINT(AST_ClassPrivateProperty, (self, output) => {\n        if (self.static) {\n            output.print(\"static\");\n            output.space();\n        }\n\n        output.print(\"#\");\n        \n        print_property_name(self.key.name, self.quote, output);\n\n        if (self.value) {\n            output.print(\"=\");\n            self.value.print(output);\n        }\n\n        output.semicolon();\n    });\n    DEFPRINT(AST_ClassProperty, (self, output) => {\n        if (self.static) {\n            output.print(\"static\");\n            output.space();\n        }\n\n        if (self.key instanceof AST_SymbolClassProperty) {\n            print_property_name(self.key.name, self.quote, output);\n        } else {\n            output.print(\"[\");\n            self.key.print(output);\n            output.print(\"]\");\n        }\n\n        if (self.value) {\n            output.print(\"=\");\n            self.value.print(output);\n        }\n\n        output.semicolon();\n    });\n    AST_ObjectProperty.DEFMETHOD(\"_print_getter_setter\", function(type, is_private, output) {\n        var self = this;\n        if (self.static) {\n            output.print(\"static\");\n            output.space();\n        }\n        if (type) {\n            output.print(type);\n            output.space();\n        }\n        if (self.key instanceof AST_SymbolMethod) {\n            if (is_private) output.print(\"#\");\n            print_property_name(self.key.name, self.quote, output);\n        } else {\n            output.with_square(function() {\n                self.key.print(output);\n            });\n        }\n        self.value._do_print(output, true);\n    });\n    DEFPRINT(AST_ObjectSetter, function(self, output) {\n        self._print_getter_setter(\"set\", false, output);\n    });\n    DEFPRINT(AST_ObjectGetter, function(self, output) {\n        self._print_getter_setter(\"get\", false, output);\n    });\n    DEFPRINT(AST_PrivateSetter, function(self, output) {\n        self._print_getter_setter(\"set\", true, output);\n    });\n    DEFPRINT(AST_PrivateGetter, function(self, output) {\n        self._print_getter_setter(\"get\", true, output);\n    });\n    DEFPRINT(AST_PrivateMethod, function(self, output) {\n        var type;\n        if (self.is_generator && self.async) {\n            type = \"async*\";\n        } else if (self.is_generator) {\n            type = \"*\";\n        } else if (self.async) {\n            type = \"async\";\n        }\n        self._print_getter_setter(type, true, output);\n    });\n    DEFPRINT(AST_ConciseMethod, function(self, output) {\n        var type;\n        if (self.is_generator && self.async) {\n            type = \"async*\";\n        } else if (self.is_generator) {\n            type = \"*\";\n        } else if (self.async) {\n            type = \"async\";\n        }\n        self._print_getter_setter(type, false, output);\n    });\n    AST_Symbol.DEFMETHOD(\"_do_print\", function(output) {\n        var def = this.definition();\n        output.print_name(def ? def.mangled_name || def.name : this.name);\n    });\n    DEFPRINT(AST_Symbol, function (self, output) {\n        self._do_print(output);\n    });\n    DEFPRINT(AST_Hole, noop);\n    DEFPRINT(AST_This, function(self, output) {\n        output.print(\"this\");\n    });\n    DEFPRINT(AST_Super, function(self, output) {\n        output.print(\"super\");\n    });\n    DEFPRINT(AST_Constant, function(self, output) {\n        output.print(self.getValue());\n    });\n    DEFPRINT(AST_String, function(self, output) {\n        output.print_string(self.getValue(), self.quote, output.in_directive);\n    });\n    DEFPRINT(AST_Number, function(self, output) {\n        if ((output.option(\"keep_numbers\") || output.use_asm) && self.raw) {\n            output.print(self.raw);\n        } else {\n            output.print(make_num(self.getValue()));\n        }\n    });\n    DEFPRINT(AST_BigInt, function(self, output) {\n        output.print(self.getValue() + \"n\");\n    });\n\n    const r_slash_script = /(<\\s*\\/\\s*script)/i;\n    const slash_script_replace = (_, $1) => $1.replace(\"/\", \"\\\\/\");\n    DEFPRINT(AST_RegExp, function(self, output) {\n        let { source, flags } = self.getValue();\n        source = regexp_source_fix(source);\n        flags = flags ? sort_regexp_flags(flags) : \"\";\n        source = source.replace(r_slash_script, slash_script_replace);\n\n        output.print(output.to_utf8(`/${source}/${flags}`));\n\n        const parent = output.parent();\n        if (\n            parent instanceof AST_Binary\n            && /^\\w/.test(parent.operator)\n            && parent.left === self\n        ) {\n            output.print(\" \");\n        }\n    });\n\n    function force_statement(stat, output) {\n        if (output.option(\"braces\")) {\n            make_block(stat, output);\n        } else {\n            if (!stat || stat instanceof AST_EmptyStatement)\n                output.force_semicolon();\n            else\n                stat.print(output);\n        }\n    }\n\n    function best_of(a) {\n        var best = a[0], len = best.length;\n        for (var i = 1; i < a.length; ++i) {\n            if (a[i].length < len) {\n                best = a[i];\n                len = best.length;\n            }\n        }\n        return best;\n    }\n\n    function make_num(num) {\n        var str = num.toString(10).replace(/^0\\./, \".\").replace(\"e+\", \"e\");\n        var candidates = [ str ];\n        if (Math.floor(num) === num) {\n            if (num < 0) {\n                candidates.push(\"-0x\" + (-num).toString(16).toLowerCase());\n            } else {\n                candidates.push(\"0x\" + num.toString(16).toLowerCase());\n            }\n        }\n        var match, len, digits;\n        if (match = /^\\.0+/.exec(str)) {\n            len = match[0].length;\n            digits = str.slice(len);\n            candidates.push(digits + \"e-\" + (digits.length + len - 1));\n        } else if (match = /0+$/.exec(str)) {\n            len = match[0].length;\n            candidates.push(str.slice(0, -len) + \"e\" + len);\n        } else if (match = /^(\\d)\\.(\\d+)e(-?\\d+)$/.exec(str)) {\n            candidates.push(match[1] + match[2] + \"e\" + (match[3] - match[2].length));\n        }\n        return best_of(candidates);\n    }\n\n    function make_block(stmt, output) {\n        if (!stmt || stmt instanceof AST_EmptyStatement)\n            output.print(\"{}\");\n        else if (stmt instanceof AST_BlockStatement)\n            stmt.print(output);\n        else output.with_block(function() {\n            output.indent();\n            stmt.print(output);\n            output.newline();\n        });\n    }\n\n    /* -----[ source map generators ]----- */\n\n    function DEFMAP(nodetype, generator) {\n        nodetype.forEach(function(nodetype) {\n            nodetype.DEFMETHOD(\"add_source_map\", generator);\n        });\n    }\n\n    DEFMAP([\n        // We could easily add info for ALL nodes, but it seems to me that\n        // would be quite wasteful, hence this noop in the base class.\n        AST_Node,\n        // since the label symbol will mark it\n        AST_LabeledStatement,\n        AST_Toplevel,\n    ], noop);\n\n    // XXX: I'm not exactly sure if we need it for all of these nodes,\n    // or if we should add even more.\n    DEFMAP([\n        AST_Array,\n        AST_BlockStatement,\n        AST_Catch,\n        AST_Class,\n        AST_Constant,\n        AST_Debugger,\n        AST_Definitions,\n        AST_Directive,\n        AST_Finally,\n        AST_Jump,\n        AST_Lambda,\n        AST_New,\n        AST_Object,\n        AST_StatementWithBody,\n        AST_Symbol,\n        AST_Switch,\n        AST_SwitchBranch,\n        AST_TemplateString,\n        AST_TemplateSegment,\n        AST_Try,\n    ], function(output) {\n        output.add_mapping(this.start);\n    });\n\n    DEFMAP([\n        AST_ObjectGetter,\n        AST_ObjectSetter,\n    ], function(output) {\n        output.add_mapping(this.start, this.key.name);\n    });\n\n    DEFMAP([ AST_ObjectProperty ], function(output) {\n        output.add_mapping(this.start, this.key);\n    });\n})();\n\nconst shallow_cmp = (node1, node2) => {\n    return (\n        node1 === null && node2 === null\n        || node1.TYPE === node2.TYPE && node1.shallow_cmp(node2)\n    );\n};\n\nconst equivalent_to = (tree1, tree2) => {\n    if (!shallow_cmp(tree1, tree2)) return false;\n    const walk_1_state = [tree1];\n    const walk_2_state = [tree2];\n\n    const walk_1_push = walk_1_state.push.bind(walk_1_state);\n    const walk_2_push = walk_2_state.push.bind(walk_2_state);\n\n    while (walk_1_state.length && walk_2_state.length) {\n        const node_1 = walk_1_state.pop();\n        const node_2 = walk_2_state.pop();\n\n        if (!shallow_cmp(node_1, node_2)) return false;\n\n        node_1._children_backwards(walk_1_push);\n        node_2._children_backwards(walk_2_push);\n\n        if (walk_1_state.length !== walk_2_state.length) {\n            // Different number of children\n            return false;\n        }\n    }\n\n    return walk_1_state.length == 0 && walk_2_state.length == 0;\n};\n\n// Creates a shallow compare function\nconst mkshallow = (props) => {\n    const comparisons = Object\n        .keys(props)\n        .map(key => {\n            if (props[key] === \"eq\") {\n                return `this.${key} === other.${key}`;\n            } else if (props[key] === \"exist\") {\n                return `(this.${key} == null ? other.${key} == null : this.${key} === other.${key})`;\n            } else {\n                throw new Error(`mkshallow: Unexpected instruction: ${props[key]}`);\n            }\n        })\n        .join(\" && \");\n\n    return new Function(\"other\", \"return \" + comparisons);\n};\n\nconst pass_through = () => true;\n\nAST_Node.prototype.shallow_cmp = function () {\n    throw new Error(\"did not find a shallow_cmp function for \" + this.constructor.name);\n};\n\nAST_Debugger.prototype.shallow_cmp = pass_through;\n\nAST_Directive.prototype.shallow_cmp = mkshallow({ value: \"eq\" });\n\nAST_SimpleStatement.prototype.shallow_cmp = pass_through;\n\nAST_Block.prototype.shallow_cmp = pass_through;\n\nAST_EmptyStatement.prototype.shallow_cmp = pass_through;\n\nAST_LabeledStatement.prototype.shallow_cmp = mkshallow({ \"label.name\": \"eq\" });\n\nAST_Do.prototype.shallow_cmp = pass_through;\n\nAST_While.prototype.shallow_cmp = pass_through;\n\nAST_For.prototype.shallow_cmp = mkshallow({\n    init: \"exist\",\n    condition: \"exist\",\n    step: \"exist\"\n});\n\nAST_ForIn.prototype.shallow_cmp = pass_through;\n\nAST_ForOf.prototype.shallow_cmp = pass_through;\n\nAST_With.prototype.shallow_cmp = pass_through;\n\nAST_Toplevel.prototype.shallow_cmp = pass_through;\n\nAST_Expansion.prototype.shallow_cmp = pass_through;\n\nAST_Lambda.prototype.shallow_cmp = mkshallow({\n    is_generator: \"eq\",\n    async: \"eq\"\n});\n\nAST_Destructuring.prototype.shallow_cmp = mkshallow({\n    is_array: \"eq\"\n});\n\nAST_PrefixedTemplateString.prototype.shallow_cmp = pass_through;\n\nAST_TemplateString.prototype.shallow_cmp = pass_through;\n\nAST_TemplateSegment.prototype.shallow_cmp = mkshallow({\n    \"value\": \"eq\"\n});\n\nAST_Jump.prototype.shallow_cmp = pass_through;\n\nAST_LoopControl.prototype.shallow_cmp = pass_through;\n\nAST_Await.prototype.shallow_cmp = pass_through;\n\nAST_Yield.prototype.shallow_cmp = mkshallow({\n    is_star: \"eq\"\n});\n\nAST_If.prototype.shallow_cmp = mkshallow({\n    alternative: \"exist\"\n});\n\nAST_Switch.prototype.shallow_cmp = pass_through;\n\nAST_SwitchBranch.prototype.shallow_cmp = pass_through;\n\nAST_Try.prototype.shallow_cmp = mkshallow({\n    bcatch: \"exist\",\n    bfinally: \"exist\"\n});\n\nAST_Catch.prototype.shallow_cmp = mkshallow({\n    argname: \"exist\"\n});\n\nAST_Finally.prototype.shallow_cmp = pass_through;\n\nAST_Definitions.prototype.shallow_cmp = pass_through;\n\nAST_VarDef.prototype.shallow_cmp = mkshallow({\n    value: \"exist\"\n});\n\nAST_NameMapping.prototype.shallow_cmp = pass_through;\n\nAST_Import.prototype.shallow_cmp = mkshallow({\n    imported_name: \"exist\",\n    imported_names: \"exist\"\n});\n\nAST_ImportMeta.prototype.shallow_cmp = pass_through;\n\nAST_Export.prototype.shallow_cmp = mkshallow({\n    exported_definition: \"exist\",\n    exported_value: \"exist\",\n    exported_names: \"exist\",\n    module_name: \"eq\",\n    is_default: \"eq\",\n});\n\nAST_Call.prototype.shallow_cmp = pass_through;\n\nAST_Sequence.prototype.shallow_cmp = pass_through;\n\nAST_PropAccess.prototype.shallow_cmp = pass_through;\n\nAST_Chain.prototype.shallow_cmp = pass_through;\n\nAST_Dot.prototype.shallow_cmp = mkshallow({\n    property: \"eq\"\n});\n\nAST_DotHash.prototype.shallow_cmp = mkshallow({\n    property: \"eq\"\n});\n\nAST_Unary.prototype.shallow_cmp = mkshallow({\n    operator: \"eq\"\n});\n\nAST_Binary.prototype.shallow_cmp = mkshallow({\n    operator: \"eq\"\n});\n\nAST_Conditional.prototype.shallow_cmp = pass_through;\n\nAST_Array.prototype.shallow_cmp = pass_through;\n\nAST_Object.prototype.shallow_cmp = pass_through;\n\nAST_ObjectProperty.prototype.shallow_cmp = pass_through;\n\nAST_ObjectKeyVal.prototype.shallow_cmp = mkshallow({\n    key: \"eq\"\n});\n\nAST_ObjectSetter.prototype.shallow_cmp = mkshallow({\n    static: \"eq\"\n});\n\nAST_ObjectGetter.prototype.shallow_cmp = mkshallow({\n    static: \"eq\"\n});\n\nAST_ConciseMethod.prototype.shallow_cmp = mkshallow({\n    static: \"eq\",\n    is_generator: \"eq\",\n    async: \"eq\",\n});\n\nAST_Class.prototype.shallow_cmp = mkshallow({\n    name: \"exist\",\n    extends: \"exist\",\n});\n\nAST_ClassProperty.prototype.shallow_cmp = mkshallow({\n    static: \"eq\"\n});\n\nAST_Symbol.prototype.shallow_cmp = mkshallow({\n    name: \"eq\"\n});\n\nAST_NewTarget.prototype.shallow_cmp = pass_through;\n\nAST_This.prototype.shallow_cmp = pass_through;\n\nAST_Super.prototype.shallow_cmp = pass_through;\n\nAST_String.prototype.shallow_cmp = mkshallow({\n    value: \"eq\"\n});\n\nAST_Number.prototype.shallow_cmp = mkshallow({\n    value: \"eq\"\n});\n\nAST_BigInt.prototype.shallow_cmp = mkshallow({\n    value: \"eq\"\n});\n\nAST_RegExp.prototype.shallow_cmp = function (other) {\n    return (\n        this.value.flags === other.value.flags\n        && this.value.source === other.value.source\n    );\n};\n\nAST_Atom.prototype.shallow_cmp = pass_through;\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nconst MASK_EXPORT_DONT_MANGLE = 1 << 0;\nconst MASK_EXPORT_WANT_MANGLE = 1 << 1;\n\nlet function_defs = null;\nlet unmangleable_names = null;\n\nclass SymbolDef {\n    constructor(scope, orig, init) {\n        this.name = orig.name;\n        this.orig = [ orig ];\n        this.init = init;\n        this.eliminated = 0;\n        this.assignments = 0;\n        this.scope = scope;\n        this.replaced = 0;\n        this.global = false;\n        this.export = 0;\n        this.mangled_name = null;\n        this.undeclared = false;\n        this.id = SymbolDef.next_id++;\n        this.chained = false;\n        this.direct_access = false;\n        this.escaped = 0;\n        this.recursive_refs = 0;\n        this.references = [];\n        this.should_replace = undefined;\n        this.single_use = false;\n        this.fixed = false;\n        Object.seal(this);\n    }\n    fixed_value() {\n        if (!this.fixed || this.fixed instanceof AST_Node) return this.fixed;\n        return this.fixed();\n    }\n    unmangleable(options) {\n        if (!options) options = {};\n\n        if (\n            function_defs &&\n            function_defs.has(this.id) &&\n            keep_name(options.keep_fnames, this.orig[0].name)\n        ) return true;\n\n        return this.global && !options.toplevel\n            || (this.export & MASK_EXPORT_DONT_MANGLE)\n            || this.undeclared\n            || !options.eval && this.scope.pinned()\n            || (this.orig[0] instanceof AST_SymbolLambda\n                  || this.orig[0] instanceof AST_SymbolDefun) && keep_name(options.keep_fnames, this.orig[0].name)\n            || this.orig[0] instanceof AST_SymbolMethod\n            || (this.orig[0] instanceof AST_SymbolClass\n                  || this.orig[0] instanceof AST_SymbolDefClass) && keep_name(options.keep_classnames, this.orig[0].name);\n    }\n    mangle(options) {\n        const cache = options.cache && options.cache.props;\n        if (this.global && cache && cache.has(this.name)) {\n            this.mangled_name = cache.get(this.name);\n        } else if (!this.mangled_name && !this.unmangleable(options)) {\n            var s = this.scope;\n            var sym = this.orig[0];\n            if (options.ie8 && sym instanceof AST_SymbolLambda)\n                s = s.parent_scope;\n            const redefinition = redefined_catch_def(this);\n            this.mangled_name = redefinition\n                ? redefinition.mangled_name || redefinition.name\n                : s.next_mangled(options, this);\n            if (this.global && cache) {\n                cache.set(this.name, this.mangled_name);\n            }\n        }\n    }\n}\n\nSymbolDef.next_id = 1;\n\nfunction redefined_catch_def(def) {\n    if (def.orig[0] instanceof AST_SymbolCatch\n        && def.scope.is_block_scope()\n    ) {\n        return def.scope.get_defun_scope().variables.get(def.name);\n    }\n}\n\nAST_Scope.DEFMETHOD(\"figure_out_scope\", function(options, { parent_scope = null, toplevel = this } = {}) {\n    options = defaults(options, {\n        cache: null,\n        ie8: false,\n        safari10: false,\n    });\n\n    if (!(toplevel instanceof AST_Toplevel)) {\n        throw new Error(\"Invalid toplevel scope\");\n    }\n\n    // pass 1: setup scope chaining and handle definitions\n    var scope = this.parent_scope = parent_scope;\n    var labels = new Map();\n    var defun = null;\n    var in_destructuring = null;\n    var for_scopes = [];\n    var tw = new TreeWalker((node, descend) => {\n        if (node.is_block_scope()) {\n            const save_scope = scope;\n            node.block_scope = scope = new AST_Scope(node);\n            scope._block_scope = true;\n            // AST_Try in the AST sadly *is* (not has) a body itself,\n            // and its catch and finally branches are children of the AST_Try itself\n            const parent_scope = node instanceof AST_Catch\n                ? save_scope.parent_scope\n                : save_scope;\n            scope.init_scope_vars(parent_scope);\n            scope.uses_with = save_scope.uses_with;\n            scope.uses_eval = save_scope.uses_eval;\n            if (options.safari10) {\n                if (node instanceof AST_For || node instanceof AST_ForIn) {\n                    for_scopes.push(scope);\n                }\n            }\n\n            if (node instanceof AST_Switch) {\n                // XXX: HACK! Ensure the switch expression gets the correct scope (the parent scope) and the body gets the contained scope\n                // AST_Switch has a scope within the body, but it itself \"is a block scope\"\n                // This means the switched expression has to belong to the outer scope\n                // while the body inside belongs to the switch itself.\n                // This is pretty nasty and warrants an AST change similar to AST_Try (read above)\n                const the_block_scope = scope;\n                scope = save_scope;\n                node.expression.walk(tw);\n                scope = the_block_scope;\n                for (let i = 0; i < node.body.length; i++) {\n                    node.body[i].walk(tw);\n                }\n            } else {\n                descend();\n            }\n            scope = save_scope;\n            return true;\n        }\n        if (node instanceof AST_Destructuring) {\n            const save_destructuring = in_destructuring;\n            in_destructuring = node;\n            descend();\n            in_destructuring = save_destructuring;\n            return true;\n        }\n        if (node instanceof AST_Scope) {\n            node.init_scope_vars(scope);\n            var save_scope = scope;\n            var save_defun = defun;\n            var save_labels = labels;\n            defun = scope = node;\n            labels = new Map();\n            descend();\n            scope = save_scope;\n            defun = save_defun;\n            labels = save_labels;\n            return true;        // don't descend again in TreeWalker\n        }\n        if (node instanceof AST_LabeledStatement) {\n            var l = node.label;\n            if (labels.has(l.name)) {\n                throw new Error(string_template(\"Label {name} defined twice\", l));\n            }\n            labels.set(l.name, l);\n            descend();\n            labels.delete(l.name);\n            return true;        // no descend again\n        }\n        if (node instanceof AST_With) {\n            for (var s = scope; s; s = s.parent_scope)\n                s.uses_with = true;\n            return;\n        }\n        if (node instanceof AST_Symbol) {\n            node.scope = scope;\n        }\n        if (node instanceof AST_Label) {\n            node.thedef = node;\n            node.references = [];\n        }\n        if (node instanceof AST_SymbolLambda) {\n            defun.def_function(node, node.name == \"arguments\" ? undefined : defun);\n        } else if (node instanceof AST_SymbolDefun) {\n            // Careful here, the scope where this should be defined is\n            // the parent scope.  The reason is that we enter a new\n            // scope when we encounter the AST_Defun node (which is\n            // instanceof AST_Scope) but we get to the symbol a bit\n            // later.\n            const closest_scope = defun.parent_scope;\n\n            // In strict mode, function definitions are block-scoped\n            node.scope = tw.directives[\"use strict\"]\n                ? closest_scope\n                : closest_scope.get_defun_scope();\n\n            mark_export(node.scope.def_function(node, defun), 1);\n        } else if (node instanceof AST_SymbolClass) {\n            mark_export(defun.def_variable(node, defun), 1);\n        } else if (node instanceof AST_SymbolImport) {\n            scope.def_variable(node);\n        } else if (node instanceof AST_SymbolDefClass) {\n            // This deals with the name of the class being available\n            // inside the class.\n            mark_export((node.scope = defun.parent_scope).def_function(node, defun), 1);\n        } else if (\n            node instanceof AST_SymbolVar\n            || node instanceof AST_SymbolLet\n            || node instanceof AST_SymbolConst\n            || node instanceof AST_SymbolCatch\n        ) {\n            var def;\n            if (node instanceof AST_SymbolBlockDeclaration) {\n                def = scope.def_variable(node, null);\n            } else {\n                def = defun.def_variable(node, node.TYPE == \"SymbolVar\" ? null : undefined);\n            }\n            if (!def.orig.every((sym) => {\n                if (sym === node) return true;\n                if (node instanceof AST_SymbolBlockDeclaration) {\n                    return sym instanceof AST_SymbolLambda;\n                }\n                return !(sym instanceof AST_SymbolLet || sym instanceof AST_SymbolConst);\n            })) {\n                js_error(\n                    `\"${node.name}\" is redeclared`,\n                    node.start.file,\n                    node.start.line,\n                    node.start.col,\n                    node.start.pos\n                );\n            }\n            if (!(node instanceof AST_SymbolFunarg)) mark_export(def, 2);\n            if (defun !== scope) {\n                node.mark_enclosed();\n                var def = scope.find_variable(node);\n                if (node.thedef !== def) {\n                    node.thedef = def;\n                    node.reference();\n                }\n            }\n        } else if (node instanceof AST_LabelRef) {\n            var sym = labels.get(node.name);\n            if (!sym) throw new Error(string_template(\"Undefined label {name} [{line},{col}]\", {\n                name: node.name,\n                line: node.start.line,\n                col: node.start.col\n            }));\n            node.thedef = sym;\n        }\n        if (!(scope instanceof AST_Toplevel) && (node instanceof AST_Export || node instanceof AST_Import)) {\n            js_error(\n                `\"${node.TYPE}\" statement may only appear at the top level`,\n                node.start.file,\n                node.start.line,\n                node.start.col,\n                node.start.pos\n            );\n        }\n    });\n    this.walk(tw);\n\n    function mark_export(def, level) {\n        if (in_destructuring) {\n            var i = 0;\n            do {\n                level++;\n            } while (tw.parent(i++) !== in_destructuring);\n        }\n        var node = tw.parent(level);\n        if (def.export = node instanceof AST_Export ? MASK_EXPORT_DONT_MANGLE : 0) {\n            var exported = node.exported_definition;\n            if ((exported instanceof AST_Defun || exported instanceof AST_DefClass) && node.is_default) {\n                def.export = MASK_EXPORT_WANT_MANGLE;\n            }\n        }\n    }\n\n    // pass 2: find back references and eval\n    const is_toplevel = this instanceof AST_Toplevel;\n    if (is_toplevel) {\n        this.globals = new Map();\n    }\n\n    var tw = new TreeWalker(node => {\n        if (node instanceof AST_LoopControl && node.label) {\n            node.label.thedef.references.push(node);\n            return true;\n        }\n        if (node instanceof AST_SymbolRef) {\n            var name = node.name;\n            if (name == \"eval\" && tw.parent() instanceof AST_Call) {\n                for (var s = node.scope; s && !s.uses_eval; s = s.parent_scope) {\n                    s.uses_eval = true;\n                }\n            }\n            var sym;\n            if (tw.parent() instanceof AST_NameMapping && tw.parent(1).module_name\n                || !(sym = node.scope.find_variable(name))) {\n\n                sym = toplevel.def_global(node);\n                if (node instanceof AST_SymbolExport) sym.export = MASK_EXPORT_DONT_MANGLE;\n            } else if (sym.scope instanceof AST_Lambda && name == \"arguments\") {\n                sym.scope.uses_arguments = true;\n            }\n            node.thedef = sym;\n            node.reference();\n            if (node.scope.is_block_scope()\n                && !(sym.orig[0] instanceof AST_SymbolBlockDeclaration)) {\n                node.scope = node.scope.get_defun_scope();\n            }\n            return true;\n        }\n        // ensure mangling works if catch reuses a scope variable\n        var def;\n        if (node instanceof AST_SymbolCatch && (def = redefined_catch_def(node.definition()))) {\n            var s = node.scope;\n            while (s) {\n                push_uniq(s.enclosed, def);\n                if (s === def.scope) break;\n                s = s.parent_scope;\n            }\n        }\n    });\n    this.walk(tw);\n\n    // pass 3: work around IE8 and Safari catch scope bugs\n    if (options.ie8 || options.safari10) {\n        walk(this, node => {\n            if (node instanceof AST_SymbolCatch) {\n                var name = node.name;\n                var refs = node.thedef.references;\n                var scope = node.scope.get_defun_scope();\n                var def = scope.find_variable(name)\n                    || toplevel.globals.get(name)\n                    || scope.def_variable(node);\n                refs.forEach(function(ref) {\n                    ref.thedef = def;\n                    ref.reference();\n                });\n                node.thedef = def;\n                node.reference();\n                return true;\n            }\n        });\n    }\n\n    // pass 4: add symbol definitions to loop scopes\n    // Safari/Webkit bug workaround - loop init let variable shadowing argument.\n    // https://github.com/mishoo/UglifyJS2/issues/1753\n    // https://bugs.webkit.org/show_bug.cgi?id=171041\n    if (options.safari10) {\n        for (const scope of for_scopes) {\n            scope.parent_scope.variables.forEach(function(def) {\n                push_uniq(scope.enclosed, def);\n            });\n        }\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"def_global\", function(node) {\n    var globals = this.globals, name = node.name;\n    if (globals.has(name)) {\n        return globals.get(name);\n    } else {\n        var g = new SymbolDef(this, node);\n        g.undeclared = true;\n        g.global = true;\n        globals.set(name, g);\n        return g;\n    }\n});\n\nAST_Scope.DEFMETHOD(\"init_scope_vars\", function(parent_scope) {\n    this.variables = new Map();         // map name to AST_SymbolVar (variables defined in this scope; includes functions)\n    this.uses_with = false;             // will be set to true if this or some nested scope uses the `with` statement\n    this.uses_eval = false;             // will be set to true if this or nested scope uses the global `eval`\n    this.parent_scope = parent_scope;   // the parent scope\n    this.enclosed = [];                 // a list of variables from this or outer scope(s) that are referenced from this or inner scopes\n    this.cname = -1;                    // the current index for mangling functions/variables\n});\n\nAST_Scope.DEFMETHOD(\"conflicting_def\", function (name) {\n    return (\n        this.enclosed.find(def => def.name === name)\n        || this.variables.has(name)\n        || (this.parent_scope && this.parent_scope.conflicting_def(name))\n    );\n});\n\nAST_Scope.DEFMETHOD(\"conflicting_def_shallow\", function (name) {\n    return (\n        this.enclosed.find(def => def.name === name)\n        || this.variables.has(name)\n    );\n});\n\nAST_Scope.DEFMETHOD(\"add_child_scope\", function (scope) {\n    // `scope` is going to be moved into `this` right now.\n    // Update the required scopes' information\n\n    if (scope.parent_scope === this) return;\n\n    scope.parent_scope = this;\n\n    // TODO uses_with, uses_eval, etc\n\n    const scope_ancestry = (() => {\n        const ancestry = [];\n        let cur = this;\n        do {\n            ancestry.push(cur);\n        } while ((cur = cur.parent_scope));\n        ancestry.reverse();\n        return ancestry;\n    })();\n\n    const new_scope_enclosed_set = new Set(scope.enclosed);\n    const to_enclose = [];\n    for (const scope_topdown of scope_ancestry) {\n        to_enclose.forEach(e => push_uniq(scope_topdown.enclosed, e));\n        for (const def of scope_topdown.variables.values()) {\n            if (new_scope_enclosed_set.has(def)) {\n                push_uniq(to_enclose, def);\n                push_uniq(scope_topdown.enclosed, def);\n            }\n        }\n    }\n});\n\nfunction find_scopes_visible_from(scopes) {\n    const found_scopes = new Set();\n\n    for (const scope of new Set(scopes)) {\n        (function bubble_up(scope) {\n            if (scope == null || found_scopes.has(scope)) return;\n\n            found_scopes.add(scope);\n\n            bubble_up(scope.parent_scope);\n        })(scope);\n    }\n\n    return [...found_scopes];\n}\n\n// Creates a symbol during compression\nAST_Scope.DEFMETHOD(\"create_symbol\", function(SymClass, {\n    source,\n    tentative_name,\n    scope,\n    conflict_scopes = [scope],\n    init = null\n} = {}) {\n    let symbol_name;\n\n    conflict_scopes = find_scopes_visible_from(conflict_scopes);\n\n    if (tentative_name) {\n        // Implement hygiene (no new names are conflicting with existing names)\n        tentative_name =\n            symbol_name =\n            tentative_name.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/ig, \"_\");\n\n        let i = 0;\n        while (conflict_scopes.find(s => s.conflicting_def_shallow(symbol_name))) {\n            symbol_name = tentative_name + \"$\" + i++;\n        }\n    }\n\n    if (!symbol_name) {\n        throw new Error(\"No symbol name could be generated in create_symbol()\");\n    }\n\n    const symbol = make_node(SymClass, source, {\n        name: symbol_name,\n        scope\n    });\n\n    this.def_variable(symbol, init || null);\n\n    symbol.mark_enclosed();\n\n    return symbol;\n});\n\n\nAST_Node.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Class.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Lambda.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Toplevel.DEFMETHOD(\"is_block_scope\", return_false);\nAST_SwitchBranch.DEFMETHOD(\"is_block_scope\", return_false);\nAST_Block.DEFMETHOD(\"is_block_scope\", return_true);\nAST_Scope.DEFMETHOD(\"is_block_scope\", function () {\n    return this._block_scope || false;\n});\nAST_IterationStatement.DEFMETHOD(\"is_block_scope\", return_true);\n\nAST_Lambda.DEFMETHOD(\"init_scope_vars\", function() {\n    AST_Scope.prototype.init_scope_vars.apply(this, arguments);\n    this.uses_arguments = false;\n    this.def_variable(new AST_SymbolFunarg({\n        name: \"arguments\",\n        start: this.start,\n        end: this.end\n    }));\n});\n\nAST_Arrow.DEFMETHOD(\"init_scope_vars\", function() {\n    AST_Scope.prototype.init_scope_vars.apply(this, arguments);\n    this.uses_arguments = false;\n});\n\nAST_Symbol.DEFMETHOD(\"mark_enclosed\", function() {\n    var def = this.definition();\n    var s = this.scope;\n    while (s) {\n        push_uniq(s.enclosed, def);\n        if (s === def.scope) break;\n        s = s.parent_scope;\n    }\n});\n\nAST_Symbol.DEFMETHOD(\"reference\", function() {\n    this.definition().references.push(this);\n    this.mark_enclosed();\n});\n\nAST_Scope.DEFMETHOD(\"find_variable\", function(name) {\n    if (name instanceof AST_Symbol) name = name.name;\n    return this.variables.get(name)\n        || (this.parent_scope && this.parent_scope.find_variable(name));\n});\n\nAST_Scope.DEFMETHOD(\"def_function\", function(symbol, init) {\n    var def = this.def_variable(symbol, init);\n    if (!def.init || def.init instanceof AST_Defun) def.init = init;\n    return def;\n});\n\nAST_Scope.DEFMETHOD(\"def_variable\", function(symbol, init) {\n    var def = this.variables.get(symbol.name);\n    if (def) {\n        def.orig.push(symbol);\n        if (def.init && (def.scope !== symbol.scope || def.init instanceof AST_Function)) {\n            def.init = init;\n        }\n    } else {\n        def = new SymbolDef(this, symbol, init);\n        this.variables.set(symbol.name, def);\n        def.global = !this.parent_scope;\n    }\n    return symbol.thedef = def;\n});\n\nfunction next_mangled(scope, options) {\n    var ext = scope.enclosed;\n    out: while (true) {\n        var m = base54(++scope.cname);\n        if (RESERVED_WORDS.has(m)) continue; // skip over \"do\"\n\n        // https://github.com/mishoo/UglifyJS2/issues/242 -- do not\n        // shadow a name reserved from mangling.\n        if (options.reserved.has(m)) continue;\n\n        // Functions with short names might collide with base54 output\n        // and therefore cause collisions when keep_fnames is true.\n        if (unmangleable_names && unmangleable_names.has(m)) continue out;\n\n        // we must ensure that the mangled name does not shadow a name\n        // from some parent scope that is referenced in this or in\n        // inner scopes.\n        for (let i = ext.length; --i >= 0;) {\n            const def = ext[i];\n            const name = def.mangled_name || (def.unmangleable(options) && def.name);\n            if (m == name) continue out;\n        }\n        return m;\n    }\n}\n\nAST_Scope.DEFMETHOD(\"next_mangled\", function(options) {\n    return next_mangled(this, options);\n});\n\nAST_Toplevel.DEFMETHOD(\"next_mangled\", function(options) {\n    let name;\n    const mangled_names = this.mangled_names;\n    do {\n        name = next_mangled(this, options);\n    } while (mangled_names.has(name));\n    return name;\n});\n\nAST_Function.DEFMETHOD(\"next_mangled\", function(options, def) {\n    // #179, #326\n    // in Safari strict mode, something like (function x(x){...}) is a syntax error;\n    // a function expression's argument cannot shadow the function expression's name\n\n    var tricky_def = def.orig[0] instanceof AST_SymbolFunarg && this.name && this.name.definition();\n\n    // the function's mangled_name is null when keep_fnames is true\n    var tricky_name = tricky_def ? tricky_def.mangled_name || tricky_def.name : null;\n\n    while (true) {\n        var name = next_mangled(this, options);\n        if (!tricky_name || tricky_name != name)\n            return name;\n    }\n});\n\nAST_Symbol.DEFMETHOD(\"unmangleable\", function(options) {\n    var def = this.definition();\n    return !def || def.unmangleable(options);\n});\n\n// labels are always mangleable\nAST_Label.DEFMETHOD(\"unmangleable\", return_false);\n\nAST_Symbol.DEFMETHOD(\"unreferenced\", function() {\n    return !this.definition().references.length && !this.scope.pinned();\n});\n\nAST_Symbol.DEFMETHOD(\"definition\", function() {\n    return this.thedef;\n});\n\nAST_Symbol.DEFMETHOD(\"global\", function() {\n    return this.thedef.global;\n});\n\nAST_Toplevel.DEFMETHOD(\"_default_mangler_options\", function(options) {\n    options = defaults(options, {\n        eval        : false,\n        ie8         : false,\n        keep_classnames: false,\n        keep_fnames : false,\n        module      : false,\n        reserved    : [],\n        toplevel    : false,\n    });\n    if (options.module) options.toplevel = true;\n    if (!Array.isArray(options.reserved)\n        && !(options.reserved instanceof Set)\n    ) {\n        options.reserved = [];\n    }\n    options.reserved = new Set(options.reserved);\n    // Never mangle arguments\n    options.reserved.add(\"arguments\");\n    return options;\n});\n\nAST_Toplevel.DEFMETHOD(\"mangle_names\", function(options) {\n    options = this._default_mangler_options(options);\n\n    // We only need to mangle declaration nodes.  Special logic wired\n    // into the code generator will display the mangled name if it's\n    // present (and for AST_SymbolRef-s it'll use the mangled name of\n    // the AST_SymbolDeclaration that it points to).\n    var lname = -1;\n    var to_mangle = [];\n\n    if (options.keep_fnames) {\n        function_defs = new Set();\n    }\n\n    const mangled_names = this.mangled_names = new Set();\n    if (options.cache) {\n        this.globals.forEach(collect);\n        if (options.cache.props) {\n            options.cache.props.forEach(function(mangled_name) {\n                mangled_names.add(mangled_name);\n            });\n        }\n    }\n\n    var tw = new TreeWalker(function(node, descend) {\n        if (node instanceof AST_LabeledStatement) {\n            // lname is incremented when we get to the AST_Label\n            var save_nesting = lname;\n            descend();\n            lname = save_nesting;\n            return true;        // don't descend again in TreeWalker\n        }\n        if (node instanceof AST_Scope) {\n            node.variables.forEach(collect);\n            return;\n        }\n        if (node.is_block_scope()) {\n            node.block_scope.variables.forEach(collect);\n            return;\n        }\n        if (\n            function_defs\n            && node instanceof AST_VarDef\n            && node.value instanceof AST_Lambda\n            && !node.value.name\n            && keep_name(options.keep_fnames, node.name.name)\n        ) {\n            function_defs.add(node.name.definition().id);\n            return;\n        }\n        if (node instanceof AST_Label) {\n            let name;\n            do {\n                name = base54(++lname);\n            } while (RESERVED_WORDS.has(name));\n            node.mangled_name = name;\n            return true;\n        }\n        if (!(options.ie8 || options.safari10) && node instanceof AST_SymbolCatch) {\n            to_mangle.push(node.definition());\n            return;\n        }\n    });\n\n    this.walk(tw);\n\n    if (options.keep_fnames || options.keep_classnames) {\n        unmangleable_names = new Set();\n        // Collect a set of short names which are unmangleable,\n        // for use in avoiding collisions in next_mangled.\n        to_mangle.forEach(def => {\n            if (def.name.length < 6 && def.unmangleable(options)) {\n                unmangleable_names.add(def.name);\n            }\n        });\n    }\n\n    to_mangle.forEach(def => { def.mangle(options); });\n\n    function_defs = null;\n    unmangleable_names = null;\n\n    function collect(symbol) {\n        const should_mangle = !options.reserved.has(symbol.name)\n            && !(symbol.export & MASK_EXPORT_DONT_MANGLE);\n        if (should_mangle) {\n            to_mangle.push(symbol);\n        }\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"find_colliding_names\", function(options) {\n    const cache = options.cache && options.cache.props;\n    const avoid = new Set();\n    options.reserved.forEach(to_avoid);\n    this.globals.forEach(add_def);\n    this.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_Scope) node.variables.forEach(add_def);\n        if (node instanceof AST_SymbolCatch) add_def(node.definition());\n    }));\n    return avoid;\n\n    function to_avoid(name) {\n        avoid.add(name);\n    }\n\n    function add_def(def) {\n        var name = def.name;\n        if (def.global && cache && cache.has(name)) name = cache.get(name);\n        else if (!def.unmangleable(options)) return;\n        to_avoid(name);\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"expand_names\", function(options) {\n    base54.reset();\n    base54.sort();\n    options = this._default_mangler_options(options);\n    var avoid = this.find_colliding_names(options);\n    var cname = 0;\n    this.globals.forEach(rename);\n    this.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_Scope) node.variables.forEach(rename);\n        if (node instanceof AST_SymbolCatch) rename(node.definition());\n    }));\n\n    function next_name() {\n        var name;\n        do {\n            name = base54(cname++);\n        } while (avoid.has(name) || RESERVED_WORDS.has(name));\n        return name;\n    }\n\n    function rename(def) {\n        if (def.global && options.cache) return;\n        if (def.unmangleable(options)) return;\n        if (options.reserved.has(def.name)) return;\n        const redefinition = redefined_catch_def(def);\n        const name = def.name = redefinition ? redefinition.name : next_name();\n        def.orig.forEach(function(sym) {\n            sym.name = name;\n        });\n        def.references.forEach(function(sym) {\n            sym.name = name;\n        });\n    }\n});\n\nAST_Node.DEFMETHOD(\"tail_node\", return_this);\nAST_Sequence.DEFMETHOD(\"tail_node\", function() {\n    return this.expressions[this.expressions.length - 1];\n});\n\nAST_Toplevel.DEFMETHOD(\"compute_char_frequency\", function(options) {\n    options = this._default_mangler_options(options);\n    try {\n        AST_Node.prototype.print = function(stream, force_parens) {\n            this._print(stream, force_parens);\n            if (this instanceof AST_Symbol && !this.unmangleable(options)) {\n                base54.consider(this.name, -1);\n            } else if (options.properties) {\n                if (this instanceof AST_DotHash) {\n                    base54.consider(\"#\" + this.property, -1);\n                } else if (this instanceof AST_Dot) {\n                    base54.consider(this.property, -1);\n                } else if (this instanceof AST_Sub) {\n                    skip_string(this.property);\n                }\n            }\n        };\n        base54.consider(this.print_to_string(), 1);\n    } finally {\n        AST_Node.prototype.print = AST_Node.prototype._print;\n    }\n    base54.sort();\n\n    function skip_string(node) {\n        if (node instanceof AST_String) {\n            base54.consider(node.value, -1);\n        } else if (node instanceof AST_Conditional) {\n            skip_string(node.consequent);\n            skip_string(node.alternative);\n        } else if (node instanceof AST_Sequence) {\n            skip_string(node.tail_node());\n        }\n    }\n});\n\nconst base54 = (() => {\n    const leading = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\".split(\"\");\n    const digits = \"0123456789\".split(\"\");\n    let chars;\n    let frequency;\n    function reset() {\n        frequency = new Map();\n        leading.forEach(function(ch) {\n            frequency.set(ch, 0);\n        });\n        digits.forEach(function(ch) {\n            frequency.set(ch, 0);\n        });\n    }\n    base54.consider = function(str, delta) {\n        for (var i = str.length; --i >= 0;) {\n            frequency.set(str[i], frequency.get(str[i]) + delta);\n        }\n    };\n    function compare(a, b) {\n        return frequency.get(b) - frequency.get(a);\n    }\n    base54.sort = function() {\n        chars = mergeSort(leading, compare).concat(mergeSort(digits, compare));\n    };\n    base54.reset = reset;\n    reset();\n    function base54(num) {\n        var ret = \"\", base = 54;\n        num++;\n        do {\n            num--;\n            ret += chars[num % base];\n            num = Math.floor(num / base);\n            base = 64;\n        } while (num > 0);\n        return ret;\n    }\n    return base54;\n})();\n\nlet mangle_options = undefined;\nAST_Node.prototype.size = function (compressor, stack) {\n    mangle_options = compressor && compressor.mangle_options;\n\n    let size = 0;\n    walk_parent(this, (node, info) => {\n        size += node._size(info);\n\n        // Braceless arrow functions have fake \"return\" statements\n        if (node instanceof AST_Arrow && node.is_braceless()) {\n            size += node.body[0].value._size(info);\n            return true;\n        }\n    }, stack || (compressor && compressor.stack));\n\n    // just to save a bit of memory\n    mangle_options = undefined;\n\n    return size;\n};\n\nAST_Node.prototype._size = () => 0;\n\nAST_Debugger.prototype._size = () => 8;\n\nAST_Directive.prototype._size = function () {\n    // TODO string encoding stuff\n    return 2 + this.value.length;\n};\n\nconst list_overhead = (array) => array.length && array.length - 1;\n\nAST_Block.prototype._size = function () {\n    return 2 + list_overhead(this.body);\n};\n\nAST_Toplevel.prototype._size = function() {\n    return list_overhead(this.body);\n};\n\nAST_EmptyStatement.prototype._size = () => 1;\n\nAST_LabeledStatement.prototype._size = () => 2;  // x:\n\nAST_Do.prototype._size = () => 9;\n\nAST_While.prototype._size = () => 7;\n\nAST_For.prototype._size = () => 8;\n\nAST_ForIn.prototype._size = () => 8;\n// AST_ForOf inherits ^\n\nAST_With.prototype._size = () => 6;\n\nAST_Expansion.prototype._size = () => 3;\n\nconst lambda_modifiers = func =>\n    (func.is_generator ? 1 : 0) + (func.async ? 6 : 0);\n\nAST_Accessor.prototype._size = function () {\n    return lambda_modifiers(this) + 4 + list_overhead(this.argnames) + list_overhead(this.body);\n};\n\nAST_Function.prototype._size = function (info) {\n    const first = !!first_in_statement(info);\n    return (first * 2) + lambda_modifiers(this) + 12 + list_overhead(this.argnames) + list_overhead(this.body);\n};\n\nAST_Defun.prototype._size = function () {\n    return lambda_modifiers(this) + 13 + list_overhead(this.argnames) + list_overhead(this.body);\n};\n\nAST_Arrow.prototype._size = function () {\n    let args_and_arrow = 2 + list_overhead(this.argnames);\n\n    if (\n        !(\n            this.argnames.length === 1\n            && this.argnames[0] instanceof AST_Symbol\n        )\n    ) {\n        args_and_arrow += 2;\n    }\n\n    const body_overhead = this.is_braceless() ? 0 : list_overhead(this.body) + 2;\n\n    return lambda_modifiers(this) + args_and_arrow + body_overhead;\n};\n\nAST_Destructuring.prototype._size = () => 2;\n\nAST_TemplateString.prototype._size = function () {\n    return 2 + (Math.floor(this.segments.length / 2) * 3);  /* \"${}\" */\n};\n\nAST_TemplateSegment.prototype._size = function () {\n    return this.value.length;\n};\n\nAST_Return.prototype._size = function () {\n    return this.value ? 7 : 6;\n};\n\nAST_Throw.prototype._size = () => 6;\n\nAST_Break.prototype._size = function () {\n    return this.label ? 6 : 5;\n};\n\nAST_Continue.prototype._size = function () {\n    return this.label ? 9 : 8;\n};\n\nAST_If.prototype._size = () => 4;\n\nAST_Switch.prototype._size = function () {\n    return 8 + list_overhead(this.body);\n};\n\nAST_Case.prototype._size = function () {\n    return 5 + list_overhead(this.body);\n};\n\nAST_Default.prototype._size = function () {\n    return 8 + list_overhead(this.body);\n};\n\nAST_Try.prototype._size = function () {\n    return 3 + list_overhead(this.body);\n};\n\nAST_Catch.prototype._size = function () {\n    let size = 7 + list_overhead(this.body);\n    if (this.argname) {\n        size += 2;\n    }\n    return size;\n};\n\nAST_Finally.prototype._size = function () {\n    return 7 + list_overhead(this.body);\n};\n\n/*#__INLINE__*/\nconst def_size = (size, def) => size + list_overhead(def.definitions);\n\nAST_Var.prototype._size = function () {\n    return def_size(4, this);\n};\n\nAST_Let.prototype._size = function () {\n    return def_size(4, this);\n};\n\nAST_Const.prototype._size = function () {\n    return def_size(6, this);\n};\n\nAST_VarDef.prototype._size = function () {\n    return this.value ? 1 : 0;\n};\n\nAST_NameMapping.prototype._size = function () {\n    // foreign name isn't mangled\n    return this.name ? 4 : 0;\n};\n\nAST_Import.prototype._size = function () {\n    // import\n    let size = 6;\n\n    if (this.imported_name) size += 1;\n\n    // from\n    if (this.imported_name || this.imported_names) size += 5;\n\n    // braces, and the commas\n    if (this.imported_names) {\n        size += 2 + list_overhead(this.imported_names);\n    }\n\n    return size;\n};\n\nAST_ImportMeta.prototype._size = () => 11;\n\nAST_Export.prototype._size = function () {\n    let size = 7 + (this.is_default ? 8 : 0);\n\n    if (this.exported_value) {\n        size += this.exported_value._size();\n    }\n\n    if (this.exported_names) {\n        // Braces and commas\n        size += 2 + list_overhead(this.exported_names);\n    }\n\n    if (this.module_name) {\n        // \"from \"\n        size += 5;\n    }\n\n    return size;\n};\n\nAST_Call.prototype._size = function () {\n    if (this.optional) {\n        return 4 + list_overhead(this.args);\n    }\n    return 2 + list_overhead(this.args);\n};\n\nAST_New.prototype._size = function () {\n    return 6 + list_overhead(this.args);\n};\n\nAST_Sequence.prototype._size = function () {\n    return list_overhead(this.expressions);\n};\n\nAST_Dot.prototype._size = function () {\n    if (this.optional) {\n        return this.property.length + 2;\n    }\n    return this.property.length + 1;\n};\n\nAST_DotHash.prototype._size = function () {\n    if (this.optional) {\n        return this.property.length + 3;\n    }\n    return this.property.length + 2;\n};\n\nAST_Sub.prototype._size = function () {\n    return this.optional ? 4 : 2;\n};\n\nAST_Unary.prototype._size = function () {\n    if (this.operator === \"typeof\") return 7;\n    if (this.operator === \"void\") return 5;\n    return this.operator.length;\n};\n\nAST_Binary.prototype._size = function (info) {\n    if (this.operator === \"in\") return 4;\n\n    let size = this.operator.length;\n\n    if (\n        (this.operator === \"+\" || this.operator === \"-\")\n        && this.right instanceof AST_Unary && this.right.operator === this.operator\n    ) {\n        // 1+ +a > needs space between the +\n        size += 1;\n    }\n\n    if (this.needs_parens(info)) {\n        size += 2;\n    }\n\n    return size;\n};\n\nAST_Conditional.prototype._size = () => 3;\n\nAST_Array.prototype._size = function () {\n    return 2 + list_overhead(this.elements);\n};\n\nAST_Object.prototype._size = function (info) {\n    let base = 2;\n    if (first_in_statement(info)) {\n        base += 2; // parens\n    }\n    return base + list_overhead(this.properties);\n};\n\n/*#__INLINE__*/\nconst key_size = key =>\n    typeof key === \"string\" ? key.length : 0;\n\nAST_ObjectKeyVal.prototype._size = function () {\n    return key_size(this.key) + 1;\n};\n\n/*#__INLINE__*/\nconst static_size = is_static => is_static ? 7 : 0;\n\nAST_ObjectGetter.prototype._size = function () {\n    return 5 + static_size(this.static) + key_size(this.key);\n};\n\nAST_ObjectSetter.prototype._size = function () {\n    return 5 + static_size(this.static) + key_size(this.key);\n};\n\nAST_ConciseMethod.prototype._size = function () {\n    return static_size(this.static) + key_size(this.key) + lambda_modifiers(this);\n};\n\nAST_PrivateMethod.prototype._size = function () {\n    return AST_ConciseMethod.prototype._size.call(this) + 1;\n};\n\nAST_PrivateGetter.prototype._size = AST_PrivateSetter.prototype._size = function () {\n    return AST_ConciseMethod.prototype._size.call(this) + 4;\n};\n\nAST_Class.prototype._size = function () {\n    return (\n        (this.name ? 8 : 7)\n        + (this.extends ? 8 : 0)\n    );\n};\n\nAST_ClassProperty.prototype._size = function () {\n    return (\n        static_size(this.static)\n        + (typeof this.key === \"string\" ? this.key.length + 2 : 0)\n        + (this.value ? 1 : 0)\n    );\n};\n\nAST_ClassPrivateProperty.prototype._size = function () {\n    return AST_ClassProperty.prototype._size.call(this) + 1;\n};\n\nAST_Symbol.prototype._size = function () {\n    return !mangle_options || this.definition().unmangleable(mangle_options)\n        ? this.name.length\n        : 1;\n};\n\n// TODO take propmangle into account\nAST_SymbolClassProperty.prototype._size = function () {\n    return this.name.length;\n};\n\nAST_SymbolRef.prototype._size = AST_SymbolDeclaration.prototype._size = function () {\n    const { name, thedef } = this;\n\n    if (thedef && thedef.global) return name.length;\n\n    if (name === \"arguments\") return 9;\n\n    return AST_Symbol.prototype._size.call(this);\n};\n\nAST_NewTarget.prototype._size = () => 10;\n\nAST_SymbolImportForeign.prototype._size = function () {\n    return this.name.length;\n};\n\nAST_SymbolExportForeign.prototype._size = function () {\n    return this.name.length;\n};\n\nAST_This.prototype._size = () => 4;\n\nAST_Super.prototype._size = () => 5;\n\nAST_String.prototype._size = function () {\n    return this.value.length + 2;\n};\n\nAST_Number.prototype._size = function () {\n    const { value } = this;\n    if (value === 0) return 1;\n    if (value > 0 && Math.floor(value) === value) {\n        return Math.floor(Math.log10(value) + 1);\n    }\n    return value.toString().length;\n};\n\nAST_BigInt.prototype._size = function () {\n    return this.value.length;\n};\n\nAST_RegExp.prototype._size = function () {\n    return this.value.toString().length;\n};\n\nAST_Null.prototype._size = () => 4;\n\nAST_NaN.prototype._size = () => 3;\n\nAST_Undefined.prototype._size = () => 6; // \"void 0\"\n\nAST_Hole.prototype._size = () => 0;  // comma is taken into account\n\nAST_Infinity.prototype._size = () => 8;\n\nAST_True.prototype._size = () => 4;\n\nAST_False.prototype._size = () => 5;\n\nAST_Await.prototype._size = () => 6;\n\nAST_Yield.prototype._size = () => 6;\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nconst UNUSED    = 0b00000001;\nconst TRUTHY    = 0b00000010;\nconst FALSY     = 0b00000100;\nconst UNDEFINED = 0b00001000;\nconst INLINED   = 0b00010000;\n// Nodes to which values are ever written. Used when keep_assign is part of the unused option string.\nconst WRITE_ONLY= 0b00100000;\n\n// information specific to a single compression pass\nconst SQUEEZED  = 0b0000000100000000;\nconst OPTIMIZED = 0b0000001000000000;\nconst TOP       = 0b0000010000000000;\n\nconst CLEAR_BETWEEN_PASSES = SQUEEZED | OPTIMIZED | TOP;\n\nconst has_flag = (node, flag) => node.flags & flag;\nconst set_flag = (node, flag) => { node.flags |= flag; };\nconst clear_flag = (node, flag) => { node.flags &= ~flag; };\n\nclass Compressor extends TreeWalker {\n    constructor(options, { false_by_default = false, mangle_options = false }) {\n        super();\n        if (options.defaults !== undefined && !options.defaults) false_by_default = true;\n        this.options = defaults(options, {\n            arguments     : false,\n            arrows        : !false_by_default,\n            booleans      : !false_by_default,\n            booleans_as_integers : false,\n            collapse_vars : !false_by_default,\n            comparisons   : !false_by_default,\n            computed_props: !false_by_default,\n            conditionals  : !false_by_default,\n            dead_code     : !false_by_default,\n            defaults      : true,\n            directives    : !false_by_default,\n            drop_console  : false,\n            drop_debugger : !false_by_default,\n            ecma          : 5,\n            evaluate      : !false_by_default,\n            expression    : false,\n            global_defs   : false,\n            hoist_funs    : false,\n            hoist_props   : !false_by_default,\n            hoist_vars    : false,\n            ie8           : false,\n            if_return     : !false_by_default,\n            inline        : !false_by_default,\n            join_vars     : !false_by_default,\n            keep_classnames: false,\n            keep_fargs    : true,\n            keep_fnames   : false,\n            keep_infinity : false,\n            loops         : !false_by_default,\n            module        : false,\n            negate_iife   : !false_by_default,\n            passes        : 1,\n            properties    : !false_by_default,\n            pure_getters  : !false_by_default && \"strict\",\n            pure_funcs    : null,\n            reduce_funcs  : !false_by_default,\n            reduce_vars   : !false_by_default,\n            sequences     : !false_by_default,\n            side_effects  : !false_by_default,\n            switches      : !false_by_default,\n            top_retain    : null,\n            toplevel      : !!(options && options[\"top_retain\"]),\n            typeofs       : !false_by_default,\n            unsafe        : false,\n            unsafe_arrows : false,\n            unsafe_comps  : false,\n            unsafe_Function: false,\n            unsafe_math   : false,\n            unsafe_symbols: false,\n            unsafe_methods: false,\n            unsafe_proto  : false,\n            unsafe_regexp : false,\n            unsafe_undefined: false,\n            unused        : !false_by_default,\n            warnings      : false  // legacy\n        }, true);\n        var global_defs = this.options[\"global_defs\"];\n        if (typeof global_defs == \"object\") for (var key in global_defs) {\n            if (key[0] === \"@\" && HOP(global_defs, key)) {\n                global_defs[key.slice(1)] = parse(global_defs[key], {\n                    expression: true\n                });\n            }\n        }\n        if (this.options[\"inline\"] === true) this.options[\"inline\"] = 3;\n        var pure_funcs = this.options[\"pure_funcs\"];\n        if (typeof pure_funcs == \"function\") {\n            this.pure_funcs = pure_funcs;\n        } else {\n            this.pure_funcs = pure_funcs ? function(node) {\n                return !pure_funcs.includes(node.expression.print_to_string());\n            } : return_true;\n        }\n        var top_retain = this.options[\"top_retain\"];\n        if (top_retain instanceof RegExp) {\n            this.top_retain = function(def) {\n                return top_retain.test(def.name);\n            };\n        } else if (typeof top_retain == \"function\") {\n            this.top_retain = top_retain;\n        } else if (top_retain) {\n            if (typeof top_retain == \"string\") {\n                top_retain = top_retain.split(/,/);\n            }\n            this.top_retain = function(def) {\n                return top_retain.includes(def.name);\n            };\n        }\n        if (this.options[\"module\"]) {\n            this.directives[\"use strict\"] = true;\n            this.options[\"toplevel\"] = true;\n        }\n        var toplevel = this.options[\"toplevel\"];\n        this.toplevel = typeof toplevel == \"string\" ? {\n            funcs: /funcs/.test(toplevel),\n            vars: /vars/.test(toplevel)\n        } : {\n            funcs: toplevel,\n            vars: toplevel\n        };\n        var sequences = this.options[\"sequences\"];\n        this.sequences_limit = sequences == 1 ? 800 : sequences | 0;\n        this.evaluated_regexps = new Map();\n        this._toplevel = undefined;\n        this.mangle_options = mangle_options;\n    }\n\n    option(key) {\n        return this.options[key];\n    }\n\n    exposed(def) {\n        if (def.export) return true;\n        if (def.global) for (var i = 0, len = def.orig.length; i < len; i++)\n            if (!this.toplevel[def.orig[i] instanceof AST_SymbolDefun ? \"funcs\" : \"vars\"])\n                return true;\n        return false;\n    }\n\n    in_boolean_context() {\n        if (!this.option(\"booleans\")) return false;\n        var self = this.self();\n        for (var i = 0, p; p = this.parent(i); i++) {\n            if (p instanceof AST_SimpleStatement\n                || p instanceof AST_Conditional && p.condition === self\n                || p instanceof AST_DWLoop && p.condition === self\n                || p instanceof AST_For && p.condition === self\n                || p instanceof AST_If && p.condition === self\n                || p instanceof AST_UnaryPrefix && p.operator == \"!\" && p.expression === self) {\n                return true;\n            }\n            if (\n                p instanceof AST_Binary\n                    && (\n                        p.operator == \"&&\"\n                        || p.operator == \"||\"\n                        || p.operator == \"??\"\n                    )\n                || p instanceof AST_Conditional\n                || p.tail_node() === self\n            ) {\n                self = p;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    get_toplevel() {\n        return this._toplevel;\n    }\n\n    compress(toplevel) {\n        toplevel = toplevel.resolve_defines(this);\n        this._toplevel = toplevel;\n        if (this.option(\"expression\")) {\n            this._toplevel.process_expression(true);\n        }\n        var passes = +this.options.passes || 1;\n        var min_count = 1 / 0;\n        var stopping = false;\n        var mangle = { ie8: this.option(\"ie8\") };\n        for (var pass = 0; pass < passes; pass++) {\n            this._toplevel.figure_out_scope(mangle);\n            if (pass === 0 && this.option(\"drop_console\")) {\n                // must be run before reduce_vars and compress pass\n                this._toplevel = this._toplevel.drop_console();\n            }\n            if (pass > 0 || this.option(\"reduce_vars\")) {\n                this._toplevel.reset_opt_flags(this);\n            }\n            this._toplevel = this._toplevel.transform(this);\n            if (passes > 1) {\n                let count = 0;\n                walk(this._toplevel, () => { count++; });\n                if (count < min_count) {\n                    min_count = count;\n                    stopping = false;\n                } else if (stopping) {\n                    break;\n                } else {\n                    stopping = true;\n                }\n            }\n        }\n        if (this.option(\"expression\")) {\n            this._toplevel.process_expression(false);\n        }\n        toplevel = this._toplevel;\n        this._toplevel = undefined;\n        return toplevel;\n    }\n\n    before(node, descend) {\n        if (has_flag(node, SQUEEZED)) return node;\n        var was_scope = false;\n        if (node instanceof AST_Scope) {\n            node = node.hoist_properties(this);\n            node = node.hoist_declarations(this);\n            was_scope = true;\n        }\n        // Before https://github.com/mishoo/UglifyJS2/pull/1602 AST_Node.optimize()\n        // would call AST_Node.transform() if a different instance of AST_Node is\n        // produced after def_optimize().\n        // This corrupts TreeWalker.stack, which cause AST look-ups to malfunction.\n        // Migrate and defer all children's AST_Node.transform() to below, which\n        // will now happen after this parent AST_Node has been properly substituted\n        // thus gives a consistent AST snapshot.\n        descend(node, this);\n        // Existing code relies on how AST_Node.optimize() worked, and omitting the\n        // following replacement call would result in degraded efficiency of both\n        // output and performance.\n        descend(node, this);\n        var opt = node.optimize(this);\n        if (was_scope && opt instanceof AST_Scope) {\n            opt.drop_unused(this);\n            descend(opt, this);\n        }\n        if (opt === node) set_flag(opt, SQUEEZED);\n        return opt;\n    }\n}\n\nfunction def_optimize(node, optimizer) {\n    node.DEFMETHOD(\"optimize\", function(compressor) {\n        var self = this;\n        if (has_flag(self, OPTIMIZED)) return self;\n        if (compressor.has_directive(\"use asm\")) return self;\n        var opt = optimizer(self, compressor);\n        set_flag(opt, OPTIMIZED);\n        return opt;\n    });\n}\n\ndef_optimize(AST_Node, function(self) {\n    return self;\n});\n\nAST_Toplevel.DEFMETHOD(\"drop_console\", function() {\n    return this.transform(new TreeTransformer(function(self) {\n        if (self.TYPE == \"Call\") {\n            var exp = self.expression;\n            if (exp instanceof AST_PropAccess) {\n                var name = exp.expression;\n                while (name.expression) {\n                    name = name.expression;\n                }\n                if (is_undeclared_ref(name) && name.name == \"console\") {\n                    return make_node(AST_Undefined, self);\n                }\n            }\n        }\n    }));\n});\n\nAST_Node.DEFMETHOD(\"equivalent_to\", function(node) {\n    return equivalent_to(this, node);\n});\n\nAST_Scope.DEFMETHOD(\"process_expression\", function(insert, compressor) {\n    var self = this;\n    var tt = new TreeTransformer(function(node) {\n        if (insert && node instanceof AST_SimpleStatement) {\n            return make_node(AST_Return, node, {\n                value: node.body\n            });\n        }\n        if (!insert && node instanceof AST_Return) {\n            if (compressor) {\n                var value = node.value && node.value.drop_side_effect_free(compressor, true);\n                return value ? make_node(AST_SimpleStatement, node, {\n                    body: value\n                }) : make_node(AST_EmptyStatement, node);\n            }\n            return make_node(AST_SimpleStatement, node, {\n                body: node.value || make_node(AST_UnaryPrefix, node, {\n                    operator: \"void\",\n                    expression: make_node(AST_Number, node, {\n                        value: 0\n                    })\n                })\n            });\n        }\n        if (node instanceof AST_Class || node instanceof AST_Lambda && node !== self) {\n            return node;\n        }\n        if (node instanceof AST_Block) {\n            var index = node.body.length - 1;\n            if (index >= 0) {\n                node.body[index] = node.body[index].transform(tt);\n            }\n        } else if (node instanceof AST_If) {\n            node.body = node.body.transform(tt);\n            if (node.alternative) {\n                node.alternative = node.alternative.transform(tt);\n            }\n        } else if (node instanceof AST_With) {\n            node.body = node.body.transform(tt);\n        }\n        return node;\n    });\n    self.transform(tt);\n});\n\nfunction read_property(obj, key) {\n    key = get_value(key);\n    if (key instanceof AST_Node) return;\n\n    var value;\n    if (obj instanceof AST_Array) {\n        var elements = obj.elements;\n        if (key == \"length\") return make_node_from_constant(elements.length, obj);\n        if (typeof key == \"number\" && key in elements) value = elements[key];\n    } else if (obj instanceof AST_Object) {\n        key = \"\" + key;\n        var props = obj.properties;\n        for (var i = props.length; --i >= 0;) {\n            var prop = props[i];\n            if (!(prop instanceof AST_ObjectKeyVal)) return;\n            if (!value && props[i].key === key) value = props[i].value;\n        }\n    }\n\n    return value instanceof AST_SymbolRef && value.fixed_value() || value;\n}\n\nfunction is_modified(compressor, tw, node, value, level, immutable) {\n    var parent = tw.parent(level);\n    var lhs = is_lhs(node, parent);\n    if (lhs) return lhs;\n    if (!immutable\n        && parent instanceof AST_Call\n        && parent.expression === node\n        && !(value instanceof AST_Arrow)\n        && !(value instanceof AST_Class)\n        && !parent.is_callee_pure(compressor)\n        && (!(value instanceof AST_Function)\n            || !(parent instanceof AST_New) && value.contains_this())) {\n        return true;\n    }\n    if (parent instanceof AST_Array) {\n        return is_modified(compressor, tw, parent, parent, level + 1);\n    }\n    if (parent instanceof AST_ObjectKeyVal && node === parent.value) {\n        var obj = tw.parent(level + 1);\n        return is_modified(compressor, tw, obj, obj, level + 2);\n    }\n    if (parent instanceof AST_PropAccess && parent.expression === node) {\n        var prop = read_property(value, parent.property);\n        return !immutable && is_modified(compressor, tw, parent, prop, level + 1);\n    }\n}\n\n(function(def_reduce_vars) {\n    def_reduce_vars(AST_Node, noop);\n\n    function reset_def(compressor, def) {\n        def.assignments = 0;\n        def.chained = false;\n        def.direct_access = false;\n        def.escaped = 0;\n        def.recursive_refs = 0;\n        def.references = [];\n        def.single_use = undefined;\n        if (def.scope.pinned()) {\n            def.fixed = false;\n        } else if (def.orig[0] instanceof AST_SymbolConst || !compressor.exposed(def)) {\n            def.fixed = def.init;\n        } else {\n            def.fixed = false;\n        }\n    }\n\n    function reset_variables(tw, compressor, node) {\n        node.variables.forEach(function(def) {\n            reset_def(compressor, def);\n            if (def.fixed === null) {\n                tw.defs_to_safe_ids.set(def.id, tw.safe_ids);\n                mark(tw, def, true);\n            } else if (def.fixed) {\n                tw.loop_ids.set(def.id, tw.in_loop);\n                mark(tw, def, true);\n            }\n        });\n    }\n\n    function reset_block_variables(compressor, node) {\n        if (node.block_scope) node.block_scope.variables.forEach((def) => {\n            reset_def(compressor, def);\n        });\n    }\n\n    function push(tw) {\n        tw.safe_ids = Object.create(tw.safe_ids);\n    }\n\n    function pop(tw) {\n        tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);\n    }\n\n    function mark(tw, def, safe) {\n        tw.safe_ids[def.id] = safe;\n    }\n\n    function safe_to_read(tw, def) {\n        if (def.single_use == \"m\") return false;\n        if (tw.safe_ids[def.id]) {\n            if (def.fixed == null) {\n                var orig = def.orig[0];\n                if (orig instanceof AST_SymbolFunarg || orig.name == \"arguments\") return false;\n                def.fixed = make_node(AST_Undefined, orig);\n            }\n            return true;\n        }\n        return def.fixed instanceof AST_Defun;\n    }\n\n    function safe_to_assign(tw, def, scope, value) {\n        if (def.fixed === undefined) return true;\n        let def_safe_ids;\n        if (def.fixed === null\n            && (def_safe_ids = tw.defs_to_safe_ids.get(def.id))\n        ) {\n            def_safe_ids[def.id] = false;\n            tw.defs_to_safe_ids.delete(def.id);\n            return true;\n        }\n        if (!HOP(tw.safe_ids, def.id)) return false;\n        if (!safe_to_read(tw, def)) return false;\n        if (def.fixed === false) return false;\n        if (def.fixed != null && (!value || def.references.length > def.assignments)) return false;\n        if (def.fixed instanceof AST_Defun) {\n            return value instanceof AST_Node && def.fixed.parent_scope === scope;\n        }\n        return def.orig.every((sym) => {\n            return !(sym instanceof AST_SymbolConst\n                || sym instanceof AST_SymbolDefun\n                || sym instanceof AST_SymbolLambda);\n        });\n    }\n\n    function ref_once(tw, compressor, def) {\n        return compressor.option(\"unused\")\n            && !def.scope.pinned()\n            && def.references.length - def.recursive_refs == 1\n            && tw.loop_ids.get(def.id) === tw.in_loop;\n    }\n\n    function is_immutable(value) {\n        if (!value) return false;\n        return value.is_constant()\n            || value instanceof AST_Lambda\n            || value instanceof AST_This;\n    }\n\n    // A definition \"escapes\" when its value can leave the point of use.\n    // Example: `a = b || c`\n    // In this example, \"b\" and \"c\" are escaping, because they're going into \"a\"\n    //\n    // def.escaped is != 0 when it escapes.\n    //\n    // When greater than 1, it means that N chained properties will be read off\n    // of that def before an escape occurs. This is useful for evaluating\n    // property accesses, where you need to know when to stop.\n    function mark_escaped(tw, d, scope, node, value, level = 0, depth = 1) {\n        var parent = tw.parent(level);\n        if (value) {\n            if (value.is_constant()) return;\n            if (value instanceof AST_ClassExpression) return;\n        }\n\n        if (\n            parent instanceof AST_Assign && (parent.operator === \"=\" || parent.logical) && node === parent.right\n            || parent instanceof AST_Call && (node !== parent.expression || parent instanceof AST_New)\n            || parent instanceof AST_Exit && node === parent.value && node.scope !== d.scope\n            || parent instanceof AST_VarDef && node === parent.value\n            || parent instanceof AST_Yield && node === parent.value && node.scope !== d.scope\n        ) {\n            if (depth > 1 && !(value && value.is_constant_expression(scope))) depth = 1;\n            if (!d.escaped || d.escaped > depth) d.escaped = depth;\n            return;\n        } else if (\n            parent instanceof AST_Array\n            || parent instanceof AST_Await\n            || parent instanceof AST_Binary && lazy_op.has(parent.operator)\n            || parent instanceof AST_Conditional && node !== parent.condition\n            || parent instanceof AST_Expansion\n            || parent instanceof AST_Sequence && node === parent.tail_node()\n        ) {\n            mark_escaped(tw, d, scope, parent, parent, level + 1, depth);\n        } else if (parent instanceof AST_ObjectKeyVal && node === parent.value) {\n            var obj = tw.parent(level + 1);\n\n            mark_escaped(tw, d, scope, obj, obj, level + 2, depth);\n        } else if (parent instanceof AST_PropAccess && node === parent.expression) {\n            value = read_property(value, parent.property);\n\n            mark_escaped(tw, d, scope, parent, value, level + 1, depth + 1);\n            if (value) return;\n        }\n\n        if (level > 0) return;\n        if (parent instanceof AST_Sequence && node !== parent.tail_node()) return;\n        if (parent instanceof AST_SimpleStatement) return;\n\n        d.direct_access = true;\n    }\n\n    const suppress = node => walk(node, node => {\n        if (!(node instanceof AST_Symbol)) return;\n        var d = node.definition();\n        if (!d) return;\n        if (node instanceof AST_SymbolRef) d.references.push(node);\n        d.fixed = false;\n    });\n    def_reduce_vars(AST_Accessor, function(tw, descend, compressor) {\n        push(tw);\n        reset_variables(tw, compressor, this);\n        descend();\n        pop(tw);\n        return true;\n    });\n    def_reduce_vars(AST_Assign, function(tw, descend, compressor) {\n        var node = this;\n        if (node.left instanceof AST_Destructuring) {\n            suppress(node.left);\n            return;\n        }\n\n        const finish_walk = () => {\n            if (node.logical) {\n                node.left.walk(tw);\n\n                push(tw);\n                node.right.walk(tw);\n                pop(tw);\n\n                return true;\n            }\n        };\n\n        var sym = node.left;\n        if (!(sym instanceof AST_SymbolRef)) return finish_walk();\n\n        var def = sym.definition();\n        var safe = safe_to_assign(tw, def, sym.scope, node.right);\n        def.assignments++;\n        if (!safe) return finish_walk();\n\n        var fixed = def.fixed;\n        if (!fixed && node.operator != \"=\" && !node.logical) return finish_walk();\n\n        var eq = node.operator == \"=\";\n        var value = eq ? node.right : node;\n        if (is_modified(compressor, tw, node, value, 0)) return finish_walk();\n\n        def.references.push(sym);\n\n        if (!node.logical) {\n            if (!eq) def.chained = true;\n\n            def.fixed = eq ? function() {\n                return node.right;\n            } : function() {\n                return make_node(AST_Binary, node, {\n                    operator: node.operator.slice(0, -1),\n                    left: fixed instanceof AST_Node ? fixed : fixed(),\n                    right: node.right\n                });\n            };\n        }\n\n        if (node.logical) {\n            mark(tw, def, false);\n            push(tw);\n            node.right.walk(tw);\n            pop(tw);\n            return true;\n        }\n\n        mark(tw, def, false);\n        node.right.walk(tw);\n        mark(tw, def, true);\n\n        mark_escaped(tw, def, sym.scope, node, value, 0, 1);\n\n        return true;\n    });\n    def_reduce_vars(AST_Binary, function(tw) {\n        if (!lazy_op.has(this.operator)) return;\n        this.left.walk(tw);\n        push(tw);\n        this.right.walk(tw);\n        pop(tw);\n        return true;\n    });\n    def_reduce_vars(AST_Block, function(tw, descend, compressor) {\n        reset_block_variables(compressor, this);\n    });\n    def_reduce_vars(AST_Case, function(tw) {\n        push(tw);\n        this.expression.walk(tw);\n        pop(tw);\n        push(tw);\n        walk_body(this, tw);\n        pop(tw);\n        return true;\n    });\n    def_reduce_vars(AST_Class, function(tw, descend) {\n        clear_flag(this, INLINED);\n        push(tw);\n        descend();\n        pop(tw);\n        return true;\n    });\n    def_reduce_vars(AST_Conditional, function(tw) {\n        this.condition.walk(tw);\n        push(tw);\n        this.consequent.walk(tw);\n        pop(tw);\n        push(tw);\n        this.alternative.walk(tw);\n        pop(tw);\n        return true;\n    });\n\n    def_reduce_vars(AST_Chain, function(tw, descend) {\n        // Chains' conditions apply left-to-right, cumulatively.\n        // If we walk normally we don't go in that order because we would pop before pushing again\n        // Solution: AST_PropAccess and AST_Call push when they are optional, and never pop.\n        // Then we pop everything when they are done being walked.\n        const safe_ids = tw.safe_ids;\n\n        descend();\n\n        // Unroll back to start\n        tw.safe_ids = safe_ids;\n        return true;\n    });\n    def_reduce_vars(AST_Call, function (tw) {\n        this.expression.walk(tw);\n\n        if (this.optional) {\n            // Never pop -- it's popped at AST_Chain above\n            push(tw);\n        }\n\n        for (const arg of this.args) arg.walk(tw);\n\n        return true;\n    });\n    def_reduce_vars(AST_PropAccess, function (tw) {\n        if (!this.optional) return;\n\n        this.expression.walk(tw);\n\n        // Never pop -- it's popped at AST_Chain above\n        push(tw);\n\n        if (this.property instanceof AST_Node) this.property.walk(tw);\n\n        return true;\n    });\n    def_reduce_vars(AST_Default, function(tw, descend) {\n        push(tw);\n        descend();\n        pop(tw);\n        return true;\n    });\n    function mark_lambda(tw, descend, compressor) {\n        clear_flag(this, INLINED);\n        push(tw);\n        reset_variables(tw, compressor, this);\n        if (this.uses_arguments) {\n            descend();\n            pop(tw);\n            return;\n        }\n        var iife;\n        if (!this.name\n            && (iife = tw.parent()) instanceof AST_Call\n            && iife.expression === this\n            && !iife.args.some(arg => arg instanceof AST_Expansion)\n            && this.argnames.every(arg_name => arg_name instanceof AST_Symbol)\n        ) {\n            // Virtually turn IIFE parameters into variable definitions:\n            //   (function(a,b) {...})(c,d) => (function() {var a=c,b=d; ...})()\n            // So existing transformation rules can work on them.\n            this.argnames.forEach((arg, i) => {\n                if (!arg.definition) return;\n                var d = arg.definition();\n                // Avoid setting fixed when there's more than one origin for a variable value\n                if (d.orig.length > 1) return;\n                if (d.fixed === undefined && (!this.uses_arguments || tw.has_directive(\"use strict\"))) {\n                    d.fixed = function() {\n                        return iife.args[i] || make_node(AST_Undefined, iife);\n                    };\n                    tw.loop_ids.set(d.id, tw.in_loop);\n                    mark(tw, d, true);\n                } else {\n                    d.fixed = false;\n                }\n            });\n        }\n        descend();\n        pop(tw);\n        return true;\n    }\n\n    def_reduce_vars(AST_Lambda, mark_lambda);\n\n    def_reduce_vars(AST_Do, function(tw, descend, compressor) {\n        reset_block_variables(compressor, this);\n        const saved_loop = tw.in_loop;\n        tw.in_loop = this;\n        push(tw);\n        this.body.walk(tw);\n        if (has_break_or_continue(this)) {\n            pop(tw);\n            push(tw);\n        }\n        this.condition.walk(tw);\n        pop(tw);\n        tw.in_loop = saved_loop;\n        return true;\n    });\n    def_reduce_vars(AST_For, function(tw, descend, compressor) {\n        reset_block_variables(compressor, this);\n        if (this.init) this.init.walk(tw);\n        const saved_loop = tw.in_loop;\n        tw.in_loop = this;\n        push(tw);\n        if (this.condition) this.condition.walk(tw);\n        this.body.walk(tw);\n        if (this.step) {\n            if (has_break_or_continue(this)) {\n                pop(tw);\n                push(tw);\n            }\n            this.step.walk(tw);\n        }\n        pop(tw);\n        tw.in_loop = saved_loop;\n        return true;\n    });\n    def_reduce_vars(AST_ForIn, function(tw, descend, compressor) {\n        reset_block_variables(compressor, this);\n        suppress(this.init);\n        this.object.walk(tw);\n        const saved_loop = tw.in_loop;\n        tw.in_loop = this;\n        push(tw);\n        this.body.walk(tw);\n        pop(tw);\n        tw.in_loop = saved_loop;\n        return true;\n    });\n\n    def_reduce_vars(AST_If, function(tw) {\n        this.condition.walk(tw);\n        push(tw);\n        this.body.walk(tw);\n        pop(tw);\n        if (this.alternative) {\n            push(tw);\n            this.alternative.walk(tw);\n            pop(tw);\n        }\n        return true;\n    });\n    def_reduce_vars(AST_LabeledStatement, function(tw) {\n        push(tw);\n        this.body.walk(tw);\n        pop(tw);\n        return true;\n    });\n    def_reduce_vars(AST_SymbolCatch, function() {\n        this.definition().fixed = false;\n    });\n\n    def_reduce_vars(AST_SymbolRef, function(tw, descend, compressor) {\n        var d = this.definition();\n        d.references.push(this);\n        if (d.references.length == 1\n            && !d.fixed\n            && d.orig[0] instanceof AST_SymbolDefun) {\n            tw.loop_ids.set(d.id, tw.in_loop);\n        }\n        var fixed_value;\n        if (d.fixed === undefined || !safe_to_read(tw, d)) {\n            d.fixed = false;\n        } else if (d.fixed) {\n            fixed_value = this.fixed_value();\n            if (\n                fixed_value instanceof AST_Lambda\n                && recursive_ref(tw, d)\n            ) {\n                d.recursive_refs++;\n            } else if (fixed_value\n                && !compressor.exposed(d)\n                && ref_once(tw, compressor, d)\n            ) {\n                d.single_use =\n                    fixed_value instanceof AST_Lambda && !fixed_value.pinned()\n                    || fixed_value instanceof AST_Class\n                    || d.scope === this.scope && fixed_value.is_constant_expression();\n            } else {\n                d.single_use = false;\n            }\n            if (is_modified(compressor, tw, this, fixed_value, 0, is_immutable(fixed_value))) {\n                if (d.single_use) {\n                    d.single_use = \"m\";\n                } else {\n                    d.fixed = false;\n                }\n            }\n        }\n        mark_escaped(tw, d, this.scope, this, fixed_value, 0, 1);\n    });\n    def_reduce_vars(AST_Toplevel, function(tw, descend, compressor) {\n        this.globals.forEach(function(def) {\n            reset_def(compressor, def);\n        });\n        reset_variables(tw, compressor, this);\n    });\n    def_reduce_vars(AST_Try, function(tw, descend, compressor) {\n        reset_block_variables(compressor, this);\n        push(tw);\n        walk_body(this, tw);\n        pop(tw);\n        if (this.bcatch) {\n            push(tw);\n            this.bcatch.walk(tw);\n            pop(tw);\n        }\n        if (this.bfinally) this.bfinally.walk(tw);\n        return true;\n    });\n    def_reduce_vars(AST_Unary, function(tw) {\n        var node = this;\n        if (node.operator !== \"++\" && node.operator !== \"--\") return;\n        var exp = node.expression;\n        if (!(exp instanceof AST_SymbolRef)) return;\n        var def = exp.definition();\n        var safe = safe_to_assign(tw, def, exp.scope, true);\n        def.assignments++;\n        if (!safe) return;\n        var fixed = def.fixed;\n        if (!fixed) return;\n        def.references.push(exp);\n        def.chained = true;\n        def.fixed = function() {\n            return make_node(AST_Binary, node, {\n                operator: node.operator.slice(0, -1),\n                left: make_node(AST_UnaryPrefix, node, {\n                    operator: \"+\",\n                    expression: fixed instanceof AST_Node ? fixed : fixed()\n                }),\n                right: make_node(AST_Number, node, {\n                    value: 1\n                })\n            });\n        };\n        mark(tw, def, true);\n        return true;\n    });\n    def_reduce_vars(AST_VarDef, function(tw, descend) {\n        var node = this;\n        if (node.name instanceof AST_Destructuring) {\n            suppress(node.name);\n            return;\n        }\n        var d = node.name.definition();\n        if (node.value) {\n            if (safe_to_assign(tw, d, node.name.scope, node.value)) {\n                d.fixed = function() {\n                    return node.value;\n                };\n                tw.loop_ids.set(d.id, tw.in_loop);\n                mark(tw, d, false);\n                descend();\n                mark(tw, d, true);\n                return true;\n            } else {\n                d.fixed = false;\n            }\n        }\n    });\n    def_reduce_vars(AST_While, function(tw, descend, compressor) {\n        reset_block_variables(compressor, this);\n        const saved_loop = tw.in_loop;\n        tw.in_loop = this;\n        push(tw);\n        descend();\n        pop(tw);\n        tw.in_loop = saved_loop;\n        return true;\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"reduce_vars\", func);\n});\n\nAST_Toplevel.DEFMETHOD(\"reset_opt_flags\", function(compressor) {\n    const self = this;\n    const reduce_vars = compressor.option(\"reduce_vars\");\n\n    const preparation = new TreeWalker(function(node, descend) {\n        clear_flag(node, CLEAR_BETWEEN_PASSES);\n        if (reduce_vars) {\n            if (compressor.top_retain\n                && node instanceof AST_Defun  // Only functions are retained\n                && preparation.parent() === self\n            ) {\n                set_flag(node, TOP);\n            }\n            return node.reduce_vars(preparation, descend, compressor);\n        }\n    });\n    // Stack of look-up tables to keep track of whether a `SymbolDef` has been\n    // properly assigned before use:\n    // - `push()` & `pop()` when visiting conditional branches\n    preparation.safe_ids = Object.create(null);\n    preparation.in_loop = null;\n    preparation.loop_ids = new Map();\n    preparation.defs_to_safe_ids = new Map();\n    self.walk(preparation);\n});\n\nAST_Symbol.DEFMETHOD(\"fixed_value\", function() {\n    var fixed = this.thedef.fixed;\n    if (!fixed || fixed instanceof AST_Node) return fixed;\n    return fixed();\n});\n\nAST_SymbolRef.DEFMETHOD(\"is_immutable\", function() {\n    var orig = this.definition().orig;\n    return orig.length == 1 && orig[0] instanceof AST_SymbolLambda;\n});\n\nfunction is_func_expr(node) {\n    return node instanceof AST_Arrow || node instanceof AST_Function;\n}\n\nfunction is_lhs_read_only(lhs) {\n    if (lhs instanceof AST_This) return true;\n    if (lhs instanceof AST_SymbolRef) return lhs.definition().orig[0] instanceof AST_SymbolLambda;\n    if (lhs instanceof AST_PropAccess) {\n        lhs = lhs.expression;\n        if (lhs instanceof AST_SymbolRef) {\n            if (lhs.is_immutable()) return false;\n            lhs = lhs.fixed_value();\n        }\n        if (!lhs) return true;\n        if (lhs instanceof AST_RegExp) return false;\n        if (lhs instanceof AST_Constant) return true;\n        return is_lhs_read_only(lhs);\n    }\n    return false;\n}\n\nfunction is_ref_of(ref, type) {\n    if (!(ref instanceof AST_SymbolRef)) return false;\n    var orig = ref.definition().orig;\n    for (var i = orig.length; --i >= 0;) {\n        if (orig[i] instanceof type) return true;\n    }\n}\n\nfunction find_scope(tw) {\n    for (let i = 0;;i++) {\n        const p = tw.parent(i);\n        if (p instanceof AST_Toplevel) return p;\n        if (p instanceof AST_Lambda) return p;\n        if (p.block_scope) return p.block_scope;\n    }\n}\n\nfunction find_variable(compressor, name) {\n    var scope, i = 0;\n    while (scope = compressor.parent(i++)) {\n        if (scope instanceof AST_Scope) break;\n        if (scope instanceof AST_Catch && scope.argname) {\n            scope = scope.argname.definition().scope;\n            break;\n        }\n    }\n    return scope.find_variable(name);\n}\n\nfunction make_sequence(orig, expressions) {\n    if (expressions.length == 1) return expressions[0];\n    if (expressions.length == 0) throw new Error(\"trying to create a sequence with length zero!\");\n    return make_node(AST_Sequence, orig, {\n        expressions: expressions.reduce(merge_sequence, [])\n    });\n}\n\nfunction make_node_from_constant(val, orig) {\n    switch (typeof val) {\n      case \"string\":\n        return make_node(AST_String, orig, {\n            value: val\n        });\n      case \"number\":\n        if (isNaN(val)) return make_node(AST_NaN, orig);\n        if (isFinite(val)) {\n            return 1 / val < 0 ? make_node(AST_UnaryPrefix, orig, {\n                operator: \"-\",\n                expression: make_node(AST_Number, orig, { value: -val })\n            }) : make_node(AST_Number, orig, { value: val });\n        }\n        return val < 0 ? make_node(AST_UnaryPrefix, orig, {\n            operator: \"-\",\n            expression: make_node(AST_Infinity, orig)\n        }) : make_node(AST_Infinity, orig);\n      case \"boolean\":\n        return make_node(val ? AST_True : AST_False, orig);\n      case \"undefined\":\n        return make_node(AST_Undefined, orig);\n      default:\n        if (val === null) {\n            return make_node(AST_Null, orig, { value: null });\n        }\n        if (val instanceof RegExp) {\n            return make_node(AST_RegExp, orig, {\n                value: {\n                    source: regexp_source_fix(val.source),\n                    flags: val.flags\n                }\n            });\n        }\n        throw new Error(string_template(\"Can't handle constant of type: {type}\", {\n            type: typeof val\n        }));\n    }\n}\n\n// we shouldn't compress (1,func)(something) to\n// func(something) because that changes the meaning of\n// the func (becomes lexical instead of global).\nfunction maintain_this_binding(parent, orig, val) {\n    if (parent instanceof AST_UnaryPrefix && parent.operator == \"delete\"\n        || parent instanceof AST_Call && parent.expression === orig\n            && (val instanceof AST_PropAccess || val instanceof AST_SymbolRef && val.name == \"eval\")) {\n        return make_sequence(orig, [ make_node(AST_Number, orig, { value: 0 }), val ]);\n    }\n    return val;\n}\n\nfunction merge_sequence(array, node) {\n    if (node instanceof AST_Sequence) {\n        array.push(...node.expressions);\n    } else {\n        array.push(node);\n    }\n    return array;\n}\n\nfunction as_statement_array(thing) {\n    if (thing === null) return [];\n    if (thing instanceof AST_BlockStatement) return thing.body;\n    if (thing instanceof AST_EmptyStatement) return [];\n    if (thing instanceof AST_Statement) return [ thing ];\n    throw new Error(\"Can't convert thing to statement array\");\n}\n\nfunction is_empty(thing) {\n    if (thing === null) return true;\n    if (thing instanceof AST_EmptyStatement) return true;\n    if (thing instanceof AST_BlockStatement) return thing.body.length == 0;\n    return false;\n}\n\nfunction can_be_evicted_from_block(node) {\n    return !(\n        node instanceof AST_DefClass ||\n        node instanceof AST_Defun ||\n        node instanceof AST_Let ||\n        node instanceof AST_Const ||\n        node instanceof AST_Export ||\n        node instanceof AST_Import\n    );\n}\n\nfunction loop_body(x) {\n    if (x instanceof AST_IterationStatement) {\n        return x.body instanceof AST_BlockStatement ? x.body : x;\n    }\n    return x;\n}\n\nfunction is_iife_call(node) {\n    // Used to determine whether the node can benefit from negation.\n    // Not the case with arrow functions (you need an extra set of parens).\n    if (node.TYPE != \"Call\") return false;\n    return node.expression instanceof AST_Function || is_iife_call(node.expression);\n}\n\nfunction is_undeclared_ref(node) {\n    return node instanceof AST_SymbolRef && node.definition().undeclared;\n}\n\nvar global_names = makePredicate(\"Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Math Number parseFloat parseInt RangeError ReferenceError RegExp Object setInterval setTimeout String SyntaxError TypeError unescape URIError\");\nAST_SymbolRef.DEFMETHOD(\"is_declared\", function(compressor) {\n    return !this.definition().undeclared\n        || compressor.option(\"unsafe\") && global_names.has(this.name);\n});\n\nvar identifier_atom = makePredicate(\"Infinity NaN undefined\");\nfunction is_identifier_atom(node) {\n    return node instanceof AST_Infinity\n        || node instanceof AST_NaN\n        || node instanceof AST_Undefined;\n}\n\n// Tighten a bunch of statements together. Used whenever there is a block.\nfunction tighten_body(statements, compressor) {\n    var in_loop, in_try;\n    var scope = compressor.find_parent(AST_Scope).get_defun_scope();\n    find_loop_scope_try();\n    var CHANGED, max_iter = 10;\n    do {\n        CHANGED = false;\n        eliminate_spurious_blocks(statements);\n        if (compressor.option(\"dead_code\")) {\n            eliminate_dead_code(statements, compressor);\n        }\n        if (compressor.option(\"if_return\")) {\n            handle_if_return(statements, compressor);\n        }\n        if (compressor.sequences_limit > 0) {\n            sequencesize(statements, compressor);\n            sequencesize_2(statements, compressor);\n        }\n        if (compressor.option(\"join_vars\")) {\n            join_consecutive_vars(statements);\n        }\n        if (compressor.option(\"collapse_vars\")) {\n            collapse(statements, compressor);\n        }\n    } while (CHANGED && max_iter-- > 0);\n\n    function find_loop_scope_try() {\n        var node = compressor.self(), level = 0;\n        do {\n            if (node instanceof AST_Catch || node instanceof AST_Finally) {\n                level++;\n            } else if (node instanceof AST_IterationStatement) {\n                in_loop = true;\n            } else if (node instanceof AST_Scope) {\n                scope = node;\n                break;\n            } else if (node instanceof AST_Try) {\n                in_try = true;\n            }\n        } while (node = compressor.parent(level++));\n    }\n\n    // Search from right to left for assignment-like expressions:\n    // - `var a = x;`\n    // - `a = x;`\n    // - `++a`\n    // For each candidate, scan from left to right for first usage, then try\n    // to fold assignment into the site for compression.\n    // Will not attempt to collapse assignments into or past code blocks\n    // which are not sequentially executed, e.g. loops and conditionals.\n    function collapse(statements, compressor) {\n        if (scope.pinned()) return statements;\n        var args;\n        var candidates = [];\n        var stat_index = statements.length;\n        var scanner = new TreeTransformer(function(node) {\n            if (abort) return node;\n            // Skip nodes before `candidate` as quickly as possible\n            if (!hit) {\n                if (node !== hit_stack[hit_index]) return node;\n                hit_index++;\n                if (hit_index < hit_stack.length) return handle_custom_scan_order(node);\n                hit = true;\n                stop_after = find_stop(node, 0);\n                if (stop_after === node) abort = true;\n                return node;\n            }\n            // Stop immediately if these node types are encountered\n            var parent = scanner.parent();\n            if (node instanceof AST_Assign\n                    && (node.logical || node.operator != \"=\" && lhs.equivalent_to(node.left))\n                || node instanceof AST_Await\n                || node instanceof AST_Call && lhs instanceof AST_PropAccess && lhs.equivalent_to(node.expression)\n                || node instanceof AST_Debugger\n                || node instanceof AST_Destructuring\n                || node instanceof AST_Expansion\n                    && node.expression instanceof AST_Symbol\n                    && (\n                        node.expression instanceof AST_This\n                        || node.expression.definition().references.length > 1\n                    )\n                || node instanceof AST_IterationStatement && !(node instanceof AST_For)\n                || node instanceof AST_LoopControl\n                || node instanceof AST_Try\n                || node instanceof AST_With\n                || node instanceof AST_Yield\n                || node instanceof AST_Export\n                || node instanceof AST_Class\n                || parent instanceof AST_For && node !== parent.init\n                || !replace_all\n                    && (\n                        node instanceof AST_SymbolRef\n                        && !node.is_declared(compressor)\n                        && !pure_prop_access_globals.has(node))\n                || node instanceof AST_SymbolRef\n                    && parent instanceof AST_Call\n                    && has_annotation(parent, _NOINLINE)\n            ) {\n                abort = true;\n                return node;\n            }\n            // Stop only if candidate is found within conditional branches\n            if (!stop_if_hit && (!lhs_local || !replace_all)\n                && (parent instanceof AST_Binary && lazy_op.has(parent.operator) && parent.left !== node\n                    || parent instanceof AST_Conditional && parent.condition !== node\n                    || parent instanceof AST_If && parent.condition !== node)) {\n                stop_if_hit = parent;\n            }\n            // Replace variable with assignment when found\n            if (can_replace\n                && !(node instanceof AST_SymbolDeclaration)\n                && lhs.equivalent_to(node)\n            ) {\n                if (stop_if_hit) {\n                    abort = true;\n                    return node;\n                }\n                if (is_lhs(node, parent)) {\n                    if (value_def) replaced++;\n                    return node;\n                } else {\n                    replaced++;\n                    if (value_def && candidate instanceof AST_VarDef) return node;\n                }\n                CHANGED = abort = true;\n                if (candidate instanceof AST_UnaryPostfix) {\n                    return make_node(AST_UnaryPrefix, candidate, candidate);\n                }\n                if (candidate instanceof AST_VarDef) {\n                    var def = candidate.name.definition();\n                    var value = candidate.value;\n                    if (def.references.length - def.replaced == 1 && !compressor.exposed(def)) {\n                        def.replaced++;\n                        if (funarg && is_identifier_atom(value)) {\n                            return value.transform(compressor);\n                        } else {\n                            return maintain_this_binding(parent, node, value);\n                        }\n                    }\n                    return make_node(AST_Assign, candidate, {\n                        operator: \"=\",\n                        logical: false,\n                        left: make_node(AST_SymbolRef, candidate.name, candidate.name),\n                        right: value\n                    });\n                }\n                clear_flag(candidate, WRITE_ONLY);\n                return candidate;\n            }\n            // These node types have child nodes that execute sequentially,\n            // but are otherwise not safe to scan into or beyond them.\n            var sym;\n            if (node instanceof AST_Call\n                || node instanceof AST_Exit\n                    && (side_effects || lhs instanceof AST_PropAccess || may_modify(lhs))\n                || node instanceof AST_PropAccess\n                    && (side_effects || node.expression.may_throw_on_access(compressor))\n                || node instanceof AST_SymbolRef\n                    && (lvalues.get(node.name) || side_effects && may_modify(node))\n                || node instanceof AST_VarDef && node.value\n                    && (lvalues.has(node.name.name) || side_effects && may_modify(node.name))\n                || (sym = is_lhs(node.left, node))\n                    && (sym instanceof AST_PropAccess || lvalues.has(sym.name))\n                || may_throw\n                    && (in_try ? node.has_side_effects(compressor) : side_effects_external(node))) {\n                stop_after = node;\n                if (node instanceof AST_Scope) abort = true;\n            }\n            return handle_custom_scan_order(node);\n        }, function(node) {\n            if (abort) return;\n            if (stop_after === node) abort = true;\n            if (stop_if_hit === node) stop_if_hit = null;\n        });\n\n        var multi_replacer = new TreeTransformer(function(node) {\n            if (abort) return node;\n            // Skip nodes before `candidate` as quickly as possible\n            if (!hit) {\n                if (node !== hit_stack[hit_index]) return node;\n                hit_index++;\n                if (hit_index < hit_stack.length) return;\n                hit = true;\n                return node;\n            }\n            // Replace variable when found\n            if (node instanceof AST_SymbolRef\n                && node.name == def.name) {\n                if (!--replaced) abort = true;\n                if (is_lhs(node, multi_replacer.parent())) return node;\n                def.replaced++;\n                value_def.replaced--;\n                return candidate.value;\n            }\n            // Skip (non-executed) functions and (leading) default case in switch statements\n            if (node instanceof AST_Default || node instanceof AST_Scope) return node;\n        });\n\n        while (--stat_index >= 0) {\n            // Treat parameters as collapsible in IIFE, i.e.\n            //   function(a, b){ ... }(x());\n            // would be translated into equivalent assignments:\n            //   var a = x(), b = undefined;\n            if (stat_index == 0 && compressor.option(\"unused\")) extract_args();\n            // Find collapsible assignments\n            var hit_stack = [];\n            extract_candidates(statements[stat_index]);\n            while (candidates.length > 0) {\n                hit_stack = candidates.pop();\n                var hit_index = 0;\n                var candidate = hit_stack[hit_stack.length - 1];\n                var value_def = null;\n                var stop_after = null;\n                var stop_if_hit = null;\n                var lhs = get_lhs(candidate);\n                if (!lhs || is_lhs_read_only(lhs) || lhs.has_side_effects(compressor)) continue;\n                // Locate symbols which may execute code outside of scanning range\n                var lvalues = get_lvalues(candidate);\n                var lhs_local = is_lhs_local(lhs);\n                if (lhs instanceof AST_SymbolRef) lvalues.set(lhs.name, false);\n                var side_effects = value_has_side_effects(candidate);\n                var replace_all = replace_all_symbols();\n                var may_throw = candidate.may_throw(compressor);\n                var funarg = candidate.name instanceof AST_SymbolFunarg;\n                var hit = funarg;\n                var abort = false, replaced = 0, can_replace = !args || !hit;\n                if (!can_replace) {\n                    for (var j = compressor.self().argnames.lastIndexOf(candidate.name) + 1; !abort && j < args.length; j++) {\n                        args[j].transform(scanner);\n                    }\n                    can_replace = true;\n                }\n                for (var i = stat_index; !abort && i < statements.length; i++) {\n                    statements[i].transform(scanner);\n                }\n                if (value_def) {\n                    var def = candidate.name.definition();\n                    if (abort && def.references.length - def.replaced > replaced) replaced = false;\n                    else {\n                        abort = false;\n                        hit_index = 0;\n                        hit = funarg;\n                        for (var i = stat_index; !abort && i < statements.length; i++) {\n                            statements[i].transform(multi_replacer);\n                        }\n                        value_def.single_use = false;\n                    }\n                }\n                if (replaced && !remove_candidate(candidate)) statements.splice(stat_index, 1);\n            }\n        }\n\n        function handle_custom_scan_order(node) {\n            // Skip (non-executed) functions\n            if (node instanceof AST_Scope) return node;\n\n            // Scan case expressions first in a switch statement\n            if (node instanceof AST_Switch) {\n                node.expression = node.expression.transform(scanner);\n                for (var i = 0, len = node.body.length; !abort && i < len; i++) {\n                    var branch = node.body[i];\n                    if (branch instanceof AST_Case) {\n                        if (!hit) {\n                            if (branch !== hit_stack[hit_index]) continue;\n                            hit_index++;\n                        }\n                        branch.expression = branch.expression.transform(scanner);\n                        if (!replace_all) break;\n                    }\n                }\n                abort = true;\n                return node;\n            }\n        }\n\n        function redefined_within_scope(def, scope) {\n            if (def.global) return false;\n            let cur_scope = def.scope;\n            while (cur_scope && cur_scope !== scope) {\n                if (cur_scope.variables.has(def.name)) return true;\n                cur_scope = cur_scope.parent_scope;\n            }\n            return false;\n        }\n\n        function has_overlapping_symbol(fn, arg, fn_strict) {\n            var found = false, scan_this = !(fn instanceof AST_Arrow);\n            arg.walk(new TreeWalker(function(node, descend) {\n                if (found) return true;\n                if (node instanceof AST_SymbolRef && (fn.variables.has(node.name) || redefined_within_scope(node.definition(), fn))) {\n                    var s = node.definition().scope;\n                    if (s !== scope) while (s = s.parent_scope) {\n                        if (s === scope) return true;\n                    }\n                    return found = true;\n                }\n                if ((fn_strict || scan_this) && node instanceof AST_This) {\n                    return found = true;\n                }\n                if (node instanceof AST_Scope && !(node instanceof AST_Arrow)) {\n                    var prev = scan_this;\n                    scan_this = false;\n                    descend();\n                    scan_this = prev;\n                    return true;\n                }\n            }));\n            return found;\n        }\n\n        function extract_args() {\n            var iife, fn = compressor.self();\n            if (is_func_expr(fn)\n                && !fn.name\n                && !fn.uses_arguments\n                && !fn.pinned()\n                && (iife = compressor.parent()) instanceof AST_Call\n                && iife.expression === fn\n                && iife.args.every((arg) => !(arg instanceof AST_Expansion))\n            ) {\n                var fn_strict = compressor.has_directive(\"use strict\");\n                if (fn_strict && !member(fn_strict, fn.body)) fn_strict = false;\n                var len = fn.argnames.length;\n                args = iife.args.slice(len);\n                var names = new Set();\n                for (var i = len; --i >= 0;) {\n                    var sym = fn.argnames[i];\n                    var arg = iife.args[i];\n                    // The following two line fix is a duplicate of the fix at\n                    // https://github.com/terser/terser/commit/011d3eb08cefe6922c7d1bdfa113fc4aeaca1b75\n                    // This might mean that these two pieces of code (one here in collapse_vars and another in reduce_vars\n                    // Might be doing the exact same thing.\n                    const def = sym.definition && sym.definition();\n                    const is_reassigned = def && def.orig.length > 1;\n                    if (is_reassigned) continue;\n                    args.unshift(make_node(AST_VarDef, sym, {\n                        name: sym,\n                        value: arg\n                    }));\n                    if (names.has(sym.name)) continue;\n                    names.add(sym.name);\n                    if (sym instanceof AST_Expansion) {\n                        var elements = iife.args.slice(i);\n                        if (elements.every((arg) =>\n                            !has_overlapping_symbol(fn, arg, fn_strict)\n                        )) {\n                            candidates.unshift([ make_node(AST_VarDef, sym, {\n                                name: sym.expression,\n                                value: make_node(AST_Array, iife, {\n                                    elements: elements\n                                })\n                            }) ]);\n                        }\n                    } else {\n                        if (!arg) {\n                            arg = make_node(AST_Undefined, sym).transform(compressor);\n                        } else if (arg instanceof AST_Lambda && arg.pinned()\n                            || has_overlapping_symbol(fn, arg, fn_strict)\n                        ) {\n                            arg = null;\n                        }\n                        if (arg) candidates.unshift([ make_node(AST_VarDef, sym, {\n                            name: sym,\n                            value: arg\n                        }) ]);\n                    }\n                }\n            }\n        }\n\n        function extract_candidates(expr) {\n            hit_stack.push(expr);\n            if (expr instanceof AST_Assign) {\n                if (\n                    !expr.left.has_side_effects(compressor)\n                    && !(expr.right instanceof AST_Chain)\n                ) {\n                    candidates.push(hit_stack.slice());\n                }\n                extract_candidates(expr.right);\n            } else if (expr instanceof AST_Binary) {\n                extract_candidates(expr.left);\n                extract_candidates(expr.right);\n            } else if (expr instanceof AST_Call && !has_annotation(expr, _NOINLINE)) {\n                extract_candidates(expr.expression);\n                expr.args.forEach(extract_candidates);\n            } else if (expr instanceof AST_Case) {\n                extract_candidates(expr.expression);\n            } else if (expr instanceof AST_Conditional) {\n                extract_candidates(expr.condition);\n                extract_candidates(expr.consequent);\n                extract_candidates(expr.alternative);\n            } else if (expr instanceof AST_Definitions) {\n                var len = expr.definitions.length;\n                // limit number of trailing variable definitions for consideration\n                var i = len - 200;\n                if (i < 0) i = 0;\n                for (; i < len; i++) {\n                    extract_candidates(expr.definitions[i]);\n                }\n            } else if (expr instanceof AST_DWLoop) {\n                extract_candidates(expr.condition);\n                if (!(expr.body instanceof AST_Block)) {\n                    extract_candidates(expr.body);\n                }\n            } else if (expr instanceof AST_Exit) {\n                if (expr.value) extract_candidates(expr.value);\n            } else if (expr instanceof AST_For) {\n                if (expr.init) extract_candidates(expr.init);\n                if (expr.condition) extract_candidates(expr.condition);\n                if (expr.step) extract_candidates(expr.step);\n                if (!(expr.body instanceof AST_Block)) {\n                    extract_candidates(expr.body);\n                }\n            } else if (expr instanceof AST_ForIn) {\n                extract_candidates(expr.object);\n                if (!(expr.body instanceof AST_Block)) {\n                    extract_candidates(expr.body);\n                }\n            } else if (expr instanceof AST_If) {\n                extract_candidates(expr.condition);\n                if (!(expr.body instanceof AST_Block)) {\n                    extract_candidates(expr.body);\n                }\n                if (expr.alternative && !(expr.alternative instanceof AST_Block)) {\n                    extract_candidates(expr.alternative);\n                }\n            } else if (expr instanceof AST_Sequence) {\n                expr.expressions.forEach(extract_candidates);\n            } else if (expr instanceof AST_SimpleStatement) {\n                extract_candidates(expr.body);\n            } else if (expr instanceof AST_Switch) {\n                extract_candidates(expr.expression);\n                expr.body.forEach(extract_candidates);\n            } else if (expr instanceof AST_Unary) {\n                if (expr.operator == \"++\" || expr.operator == \"--\") {\n                    candidates.push(hit_stack.slice());\n                }\n            } else if (expr instanceof AST_VarDef) {\n                if (expr.value && !(expr.value instanceof AST_Chain)) {\n                    candidates.push(hit_stack.slice());\n                    extract_candidates(expr.value);\n                }\n            }\n            hit_stack.pop();\n        }\n\n        function find_stop(node, level, write_only) {\n            var parent = scanner.parent(level);\n            if (parent instanceof AST_Assign) {\n                if (write_only\n                    && !parent.logical\n                    && !(parent.left instanceof AST_PropAccess\n                        || lvalues.has(parent.left.name))) {\n                    return find_stop(parent, level + 1, write_only);\n                }\n                return node;\n            }\n            if (parent instanceof AST_Binary) {\n                if (write_only && (!lazy_op.has(parent.operator) || parent.left === node)) {\n                    return find_stop(parent, level + 1, write_only);\n                }\n                return node;\n            }\n            if (parent instanceof AST_Call) return node;\n            if (parent instanceof AST_Case) return node;\n            if (parent instanceof AST_Conditional) {\n                if (write_only && parent.condition === node) {\n                    return find_stop(parent, level + 1, write_only);\n                }\n                return node;\n            }\n            if (parent instanceof AST_Definitions) {\n                return find_stop(parent, level + 1, true);\n            }\n            if (parent instanceof AST_Exit) {\n                return write_only ? find_stop(parent, level + 1, write_only) : node;\n            }\n            if (parent instanceof AST_If) {\n                if (write_only && parent.condition === node) {\n                    return find_stop(parent, level + 1, write_only);\n                }\n                return node;\n            }\n            if (parent instanceof AST_IterationStatement) return node;\n            if (parent instanceof AST_Sequence) {\n                return find_stop(parent, level + 1, parent.tail_node() !== node);\n            }\n            if (parent instanceof AST_SimpleStatement) {\n                return find_stop(parent, level + 1, true);\n            }\n            if (parent instanceof AST_Switch) return node;\n            if (parent instanceof AST_VarDef) return node;\n            return null;\n        }\n\n        function mangleable_var(var_def) {\n            var value = var_def.value;\n            if (!(value instanceof AST_SymbolRef)) return;\n            if (value.name == \"arguments\") return;\n            var def = value.definition();\n            if (def.undeclared) return;\n            return value_def = def;\n        }\n\n        function get_lhs(expr) {\n            if (expr instanceof AST_Assign && expr.logical) {\n                return false;\n            } else if (expr instanceof AST_VarDef && expr.name instanceof AST_SymbolDeclaration) {\n                var def = expr.name.definition();\n                if (!member(expr.name, def.orig)) return;\n                var referenced = def.references.length - def.replaced;\n                if (!referenced) return;\n                var declared = def.orig.length - def.eliminated;\n                if (declared > 1 && !(expr.name instanceof AST_SymbolFunarg)\n                    || (referenced > 1 ? mangleable_var(expr) : !compressor.exposed(def))) {\n                    return make_node(AST_SymbolRef, expr.name, expr.name);\n                }\n            } else {\n                const lhs = expr instanceof AST_Assign\n                    ? expr.left\n                    : expr.expression;\n                return !is_ref_of(lhs, AST_SymbolConst)\n                    && !is_ref_of(lhs, AST_SymbolLet) && lhs;\n            }\n        }\n\n        function get_rvalue(expr) {\n            if (expr instanceof AST_Assign) {\n                return expr.right;\n            } else {\n                return expr.value;\n            }\n        }\n\n        function get_lvalues(expr) {\n            var lvalues = new Map();\n            if (expr instanceof AST_Unary) return lvalues;\n            var tw = new TreeWalker(function(node) {\n                var sym = node;\n                while (sym instanceof AST_PropAccess) sym = sym.expression;\n                if (sym instanceof AST_SymbolRef || sym instanceof AST_This) {\n                    lvalues.set(sym.name, lvalues.get(sym.name) || is_modified(compressor, tw, node, node, 0));\n                }\n            });\n            get_rvalue(expr).walk(tw);\n            return lvalues;\n        }\n\n        function remove_candidate(expr) {\n            if (expr.name instanceof AST_SymbolFunarg) {\n                var iife = compressor.parent(), argnames = compressor.self().argnames;\n                var index = argnames.indexOf(expr.name);\n                if (index < 0) {\n                    iife.args.length = Math.min(iife.args.length, argnames.length - 1);\n                } else {\n                    var args = iife.args;\n                    if (args[index]) args[index] = make_node(AST_Number, args[index], {\n                        value: 0\n                    });\n                }\n                return true;\n            }\n            var found = false;\n            return statements[stat_index].transform(new TreeTransformer(function(node, descend, in_list) {\n                if (found) return node;\n                if (node === expr || node.body === expr) {\n                    found = true;\n                    if (node instanceof AST_VarDef) {\n                        node.value = node.name instanceof AST_SymbolConst\n                             ? make_node(AST_Undefined, node.value)  // `const` always needs value.\n                             : null;\n                        return node;\n                    }\n                    return in_list ? MAP.skip : null;\n                }\n            }, function(node) {\n                if (node instanceof AST_Sequence) switch (node.expressions.length) {\n                  case 0: return null;\n                  case 1: return node.expressions[0];\n                }\n            }));\n        }\n\n        function is_lhs_local(lhs) {\n            while (lhs instanceof AST_PropAccess) lhs = lhs.expression;\n            return lhs instanceof AST_SymbolRef\n                && lhs.definition().scope === scope\n                && !(in_loop\n                    && (lvalues.has(lhs.name)\n                        || candidate instanceof AST_Unary\n                        || (candidate instanceof AST_Assign\n                            && !candidate.logical\n                            && candidate.operator != \"=\")));\n        }\n\n        function value_has_side_effects(expr) {\n            if (expr instanceof AST_Unary) return unary_side_effects.has(expr.operator);\n            return get_rvalue(expr).has_side_effects(compressor);\n        }\n\n        function replace_all_symbols() {\n            if (side_effects) return false;\n            if (value_def) return true;\n            if (lhs instanceof AST_SymbolRef) {\n                var def = lhs.definition();\n                if (def.references.length - def.replaced == (candidate instanceof AST_VarDef ? 1 : 2)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function may_modify(sym) {\n            if (!sym.definition) return true; // AST_Destructuring\n            var def = sym.definition();\n            if (def.orig.length == 1 && def.orig[0] instanceof AST_SymbolDefun) return false;\n            if (def.scope.get_defun_scope() !== scope) return true;\n            return !def.references.every((ref) => {\n                var s = ref.scope.get_defun_scope();\n                // \"block\" scope within AST_Catch\n                if (s.TYPE == \"Scope\") s = s.parent_scope;\n                return s === scope;\n            });\n        }\n\n        function side_effects_external(node, lhs) {\n            if (node instanceof AST_Assign) return side_effects_external(node.left, true);\n            if (node instanceof AST_Unary) return side_effects_external(node.expression, true);\n            if (node instanceof AST_VarDef) return node.value && side_effects_external(node.value);\n            if (lhs) {\n                if (node instanceof AST_Dot) return side_effects_external(node.expression, true);\n                if (node instanceof AST_Sub) return side_effects_external(node.expression, true);\n                if (node instanceof AST_SymbolRef) return node.definition().scope !== scope;\n            }\n            return false;\n        }\n    }\n\n    function eliminate_spurious_blocks(statements) {\n        var seen_dirs = [];\n        for (var i = 0; i < statements.length;) {\n            var stat = statements[i];\n            if (stat instanceof AST_BlockStatement && stat.body.every(can_be_evicted_from_block)) {\n                CHANGED = true;\n                eliminate_spurious_blocks(stat.body);\n                statements.splice(i, 1, ...stat.body);\n                i += stat.body.length;\n            } else if (stat instanceof AST_EmptyStatement) {\n                CHANGED = true;\n                statements.splice(i, 1);\n            } else if (stat instanceof AST_Directive) {\n                if (seen_dirs.indexOf(stat.value) < 0) {\n                    i++;\n                    seen_dirs.push(stat.value);\n                } else {\n                    CHANGED = true;\n                    statements.splice(i, 1);\n                }\n            } else i++;\n        }\n    }\n\n    function handle_if_return(statements, compressor) {\n        var self = compressor.self();\n        var multiple_if_returns = has_multiple_if_returns(statements);\n        var in_lambda = self instanceof AST_Lambda;\n        for (var i = statements.length; --i >= 0;) {\n            var stat = statements[i];\n            var j = next_index(i);\n            var next = statements[j];\n\n            if (in_lambda && !next && stat instanceof AST_Return) {\n                if (!stat.value) {\n                    CHANGED = true;\n                    statements.splice(i, 1);\n                    continue;\n                }\n                if (stat.value instanceof AST_UnaryPrefix && stat.value.operator == \"void\") {\n                    CHANGED = true;\n                    statements[i] = make_node(AST_SimpleStatement, stat, {\n                        body: stat.value.expression\n                    });\n                    continue;\n                }\n            }\n\n            if (stat instanceof AST_If) {\n                var ab = aborts(stat.body);\n                if (can_merge_flow(ab)) {\n                    if (ab.label) {\n                        remove(ab.label.thedef.references, ab);\n                    }\n                    CHANGED = true;\n                    stat = stat.clone();\n                    stat.condition = stat.condition.negate(compressor);\n                    var body = as_statement_array_with_return(stat.body, ab);\n                    stat.body = make_node(AST_BlockStatement, stat, {\n                        body: as_statement_array(stat.alternative).concat(extract_functions())\n                    });\n                    stat.alternative = make_node(AST_BlockStatement, stat, {\n                        body: body\n                    });\n                    statements[i] = stat.transform(compressor);\n                    continue;\n                }\n\n                var ab = aborts(stat.alternative);\n                if (can_merge_flow(ab)) {\n                    if (ab.label) {\n                        remove(ab.label.thedef.references, ab);\n                    }\n                    CHANGED = true;\n                    stat = stat.clone();\n                    stat.body = make_node(AST_BlockStatement, stat.body, {\n                        body: as_statement_array(stat.body).concat(extract_functions())\n                    });\n                    var body = as_statement_array_with_return(stat.alternative, ab);\n                    stat.alternative = make_node(AST_BlockStatement, stat.alternative, {\n                        body: body\n                    });\n                    statements[i] = stat.transform(compressor);\n                    continue;\n                }\n            }\n\n            if (stat instanceof AST_If && stat.body instanceof AST_Return) {\n                var value = stat.body.value;\n                //---\n                // pretty silly case, but:\n                // if (foo()) return; return; ==> foo(); return;\n                if (!value && !stat.alternative\n                    && (in_lambda && !next || next instanceof AST_Return && !next.value)) {\n                    CHANGED = true;\n                    statements[i] = make_node(AST_SimpleStatement, stat.condition, {\n                        body: stat.condition\n                    });\n                    continue;\n                }\n                //---\n                // if (foo()) return x; return y; ==> return foo() ? x : y;\n                if (value && !stat.alternative && next instanceof AST_Return && next.value) {\n                    CHANGED = true;\n                    stat = stat.clone();\n                    stat.alternative = next;\n                    statements[i] = stat.transform(compressor);\n                    statements.splice(j, 1);\n                    continue;\n                }\n                //---\n                // if (foo()) return x; [ return ; ] ==> return foo() ? x : undefined;\n                if (value && !stat.alternative\n                    && (!next && in_lambda && multiple_if_returns\n                        || next instanceof AST_Return)) {\n                    CHANGED = true;\n                    stat = stat.clone();\n                    stat.alternative = next || make_node(AST_Return, stat, {\n                        value: null\n                    });\n                    statements[i] = stat.transform(compressor);\n                    if (next) statements.splice(j, 1);\n                    continue;\n                }\n                //---\n                // if (a) return b; if (c) return d; e; ==> return a ? b : c ? d : void e;\n                //\n                // if sequences is not enabled, this can lead to an endless loop (issue #866).\n                // however, with sequences on this helps producing slightly better output for\n                // the example code.\n                var prev = statements[prev_index(i)];\n                if (compressor.option(\"sequences\") && in_lambda && !stat.alternative\n                    && prev instanceof AST_If && prev.body instanceof AST_Return\n                    && next_index(j) == statements.length && next instanceof AST_SimpleStatement) {\n                    CHANGED = true;\n                    stat = stat.clone();\n                    stat.alternative = make_node(AST_BlockStatement, next, {\n                        body: [\n                            next,\n                            make_node(AST_Return, next, {\n                                value: null\n                            })\n                        ]\n                    });\n                    statements[i] = stat.transform(compressor);\n                    statements.splice(j, 1);\n                    continue;\n                }\n            }\n        }\n\n        function has_multiple_if_returns(statements) {\n            var n = 0;\n            for (var i = statements.length; --i >= 0;) {\n                var stat = statements[i];\n                if (stat instanceof AST_If && stat.body instanceof AST_Return) {\n                    if (++n > 1) return true;\n                }\n            }\n            return false;\n        }\n\n        function is_return_void(value) {\n            return !value || value instanceof AST_UnaryPrefix && value.operator == \"void\";\n        }\n\n        function can_merge_flow(ab) {\n            if (!ab) return false;\n            for (var j = i + 1, len = statements.length; j < len; j++) {\n                var stat = statements[j];\n                if (stat instanceof AST_Const || stat instanceof AST_Let) return false;\n            }\n            var lct = ab instanceof AST_LoopControl ? compressor.loopcontrol_target(ab) : null;\n            return ab instanceof AST_Return && in_lambda && is_return_void(ab.value)\n                || ab instanceof AST_Continue && self === loop_body(lct)\n                || ab instanceof AST_Break && lct instanceof AST_BlockStatement && self === lct;\n        }\n\n        function extract_functions() {\n            var tail = statements.slice(i + 1);\n            statements.length = i + 1;\n            return tail.filter(function(stat) {\n                if (stat instanceof AST_Defun) {\n                    statements.push(stat);\n                    return false;\n                }\n                return true;\n            });\n        }\n\n        function as_statement_array_with_return(node, ab) {\n            var body = as_statement_array(node).slice(0, -1);\n            if (ab.value) {\n                body.push(make_node(AST_SimpleStatement, ab.value, {\n                    body: ab.value.expression\n                }));\n            }\n            return body;\n        }\n\n        function next_index(i) {\n            for (var j = i + 1, len = statements.length; j < len; j++) {\n                var stat = statements[j];\n                if (!(stat instanceof AST_Var && declarations_only(stat))) {\n                    break;\n                }\n            }\n            return j;\n        }\n\n        function prev_index(i) {\n            for (var j = i; --j >= 0;) {\n                var stat = statements[j];\n                if (!(stat instanceof AST_Var && declarations_only(stat))) {\n                    break;\n                }\n            }\n            return j;\n        }\n    }\n\n    function eliminate_dead_code(statements, compressor) {\n        var has_quit;\n        var self = compressor.self();\n        for (var i = 0, n = 0, len = statements.length; i < len; i++) {\n            var stat = statements[i];\n            if (stat instanceof AST_LoopControl) {\n                var lct = compressor.loopcontrol_target(stat);\n                if (stat instanceof AST_Break\n                        && !(lct instanceof AST_IterationStatement)\n                        && loop_body(lct) === self\n                    || stat instanceof AST_Continue\n                        && loop_body(lct) === self) {\n                    if (stat.label) {\n                        remove(stat.label.thedef.references, stat);\n                    }\n                } else {\n                    statements[n++] = stat;\n                }\n            } else {\n                statements[n++] = stat;\n            }\n            if (aborts(stat)) {\n                has_quit = statements.slice(i + 1);\n                break;\n            }\n        }\n        statements.length = n;\n        CHANGED = n != len;\n        if (has_quit) has_quit.forEach(function(stat) {\n            trim_unreachable_code(compressor, stat, statements);\n        });\n    }\n\n    function declarations_only(node) {\n        return node.definitions.every((var_def) =>\n            !var_def.value\n        );\n    }\n\n    function sequencesize(statements, compressor) {\n        if (statements.length < 2) return;\n        var seq = [], n = 0;\n        function push_seq() {\n            if (!seq.length) return;\n            var body = make_sequence(seq[0], seq);\n            statements[n++] = make_node(AST_SimpleStatement, body, { body: body });\n            seq = [];\n        }\n        for (var i = 0, len = statements.length; i < len; i++) {\n            var stat = statements[i];\n            if (stat instanceof AST_SimpleStatement) {\n                if (seq.length >= compressor.sequences_limit) push_seq();\n                var body = stat.body;\n                if (seq.length > 0) body = body.drop_side_effect_free(compressor);\n                if (body) merge_sequence(seq, body);\n            } else if (stat instanceof AST_Definitions && declarations_only(stat)\n                || stat instanceof AST_Defun) {\n                statements[n++] = stat;\n            } else {\n                push_seq();\n                statements[n++] = stat;\n            }\n        }\n        push_seq();\n        statements.length = n;\n        if (n != len) CHANGED = true;\n    }\n\n    function to_simple_statement(block, decls) {\n        if (!(block instanceof AST_BlockStatement)) return block;\n        var stat = null;\n        for (var i = 0, len = block.body.length; i < len; i++) {\n            var line = block.body[i];\n            if (line instanceof AST_Var && declarations_only(line)) {\n                decls.push(line);\n            } else if (stat) {\n                return false;\n            } else {\n                stat = line;\n            }\n        }\n        return stat;\n    }\n\n    function sequencesize_2(statements, compressor) {\n        function cons_seq(right) {\n            n--;\n            CHANGED = true;\n            var left = prev.body;\n            return make_sequence(left, [ left, right ]).transform(compressor);\n        }\n        var n = 0, prev;\n        for (var i = 0; i < statements.length; i++) {\n            var stat = statements[i];\n            if (prev) {\n                if (stat instanceof AST_Exit) {\n                    stat.value = cons_seq(stat.value || make_node(AST_Undefined, stat).transform(compressor));\n                } else if (stat instanceof AST_For) {\n                    if (!(stat.init instanceof AST_Definitions)) {\n                        const abort = walk(prev.body, node => {\n                            if (node instanceof AST_Scope) return true;\n                            if (\n                                node instanceof AST_Binary\n                                && node.operator === \"in\"\n                            ) {\n                                return walk_abort;\n                            }\n                        });\n                        if (!abort) {\n                            if (stat.init) stat.init = cons_seq(stat.init);\n                            else {\n                                stat.init = prev.body;\n                                n--;\n                                CHANGED = true;\n                            }\n                        }\n                    }\n                } else if (stat instanceof AST_ForIn) {\n                    if (!(stat.init instanceof AST_Const) && !(stat.init instanceof AST_Let)) {\n                        stat.object = cons_seq(stat.object);\n                    }\n                } else if (stat instanceof AST_If) {\n                    stat.condition = cons_seq(stat.condition);\n                } else if (stat instanceof AST_Switch) {\n                    stat.expression = cons_seq(stat.expression);\n                } else if (stat instanceof AST_With) {\n                    stat.expression = cons_seq(stat.expression);\n                }\n            }\n            if (compressor.option(\"conditionals\") && stat instanceof AST_If) {\n                var decls = [];\n                var body = to_simple_statement(stat.body, decls);\n                var alt = to_simple_statement(stat.alternative, decls);\n                if (body !== false && alt !== false && decls.length > 0) {\n                    var len = decls.length;\n                    decls.push(make_node(AST_If, stat, {\n                        condition: stat.condition,\n                        body: body || make_node(AST_EmptyStatement, stat.body),\n                        alternative: alt\n                    }));\n                    decls.unshift(n, 1);\n                    [].splice.apply(statements, decls);\n                    i += len;\n                    n += len + 1;\n                    prev = null;\n                    CHANGED = true;\n                    continue;\n                }\n            }\n            statements[n++] = stat;\n            prev = stat instanceof AST_SimpleStatement ? stat : null;\n        }\n        statements.length = n;\n    }\n\n    function join_object_assignments(defn, body) {\n        if (!(defn instanceof AST_Definitions)) return;\n        var def = defn.definitions[defn.definitions.length - 1];\n        if (!(def.value instanceof AST_Object)) return;\n        var exprs;\n        if (body instanceof AST_Assign && !body.logical) {\n            exprs = [ body ];\n        } else if (body instanceof AST_Sequence) {\n            exprs = body.expressions.slice();\n        }\n        if (!exprs) return;\n        var trimmed = false;\n        do {\n            var node = exprs[0];\n            if (!(node instanceof AST_Assign)) break;\n            if (node.operator != \"=\") break;\n            if (!(node.left instanceof AST_PropAccess)) break;\n            var sym = node.left.expression;\n            if (!(sym instanceof AST_SymbolRef)) break;\n            if (def.name.name != sym.name) break;\n            if (!node.right.is_constant_expression(scope)) break;\n            var prop = node.left.property;\n            if (prop instanceof AST_Node) {\n                prop = prop.evaluate(compressor);\n            }\n            if (prop instanceof AST_Node) break;\n            prop = \"\" + prop;\n            var diff = compressor.option(\"ecma\") < 2015\n                && compressor.has_directive(\"use strict\") ? function(node) {\n                return node.key != prop && (node.key && node.key.name != prop);\n            } : function(node) {\n                return node.key && node.key.name != prop;\n            };\n            if (!def.value.properties.every(diff)) break;\n            var p = def.value.properties.filter(function (p) { return p.key === prop; })[0];\n            if (!p) {\n                def.value.properties.push(make_node(AST_ObjectKeyVal, node, {\n                    key: prop,\n                    value: node.right\n                }));\n            } else {\n                p.value = new AST_Sequence({\n                    start: p.start,\n                    expressions: [p.value.clone(), node.right.clone()],\n                    end: p.end\n                });\n            }\n            exprs.shift();\n            trimmed = true;\n        } while (exprs.length);\n        return trimmed && exprs;\n    }\n\n    function join_consecutive_vars(statements) {\n        var defs;\n        for (var i = 0, j = -1, len = statements.length; i < len; i++) {\n            var stat = statements[i];\n            var prev = statements[j];\n            if (stat instanceof AST_Definitions) {\n                if (prev && prev.TYPE == stat.TYPE) {\n                    prev.definitions = prev.definitions.concat(stat.definitions);\n                    CHANGED = true;\n                } else if (defs && defs.TYPE == stat.TYPE && declarations_only(stat)) {\n                    defs.definitions = defs.definitions.concat(stat.definitions);\n                    CHANGED = true;\n                } else {\n                    statements[++j] = stat;\n                    defs = stat;\n                }\n            } else if (stat instanceof AST_Exit) {\n                stat.value = extract_object_assignments(stat.value);\n            } else if (stat instanceof AST_For) {\n                var exprs = join_object_assignments(prev, stat.init);\n                if (exprs) {\n                    CHANGED = true;\n                    stat.init = exprs.length ? make_sequence(stat.init, exprs) : null;\n                    statements[++j] = stat;\n                } else if (prev instanceof AST_Var && (!stat.init || stat.init.TYPE == prev.TYPE)) {\n                    if (stat.init) {\n                        prev.definitions = prev.definitions.concat(stat.init.definitions);\n                    }\n                    stat.init = prev;\n                    statements[j] = stat;\n                    CHANGED = true;\n                } else if (defs && stat.init && defs.TYPE == stat.init.TYPE && declarations_only(stat.init)) {\n                    defs.definitions = defs.definitions.concat(stat.init.definitions);\n                    stat.init = null;\n                    statements[++j] = stat;\n                    CHANGED = true;\n                } else {\n                    statements[++j] = stat;\n                }\n            } else if (stat instanceof AST_ForIn) {\n                stat.object = extract_object_assignments(stat.object);\n            } else if (stat instanceof AST_If) {\n                stat.condition = extract_object_assignments(stat.condition);\n            } else if (stat instanceof AST_SimpleStatement) {\n                var exprs = join_object_assignments(prev, stat.body);\n                if (exprs) {\n                    CHANGED = true;\n                    if (!exprs.length) continue;\n                    stat.body = make_sequence(stat.body, exprs);\n                }\n                statements[++j] = stat;\n            } else if (stat instanceof AST_Switch) {\n                stat.expression = extract_object_assignments(stat.expression);\n            } else if (stat instanceof AST_With) {\n                stat.expression = extract_object_assignments(stat.expression);\n            } else {\n                statements[++j] = stat;\n            }\n        }\n        statements.length = j + 1;\n\n        function extract_object_assignments(value) {\n            statements[++j] = stat;\n            var exprs = join_object_assignments(prev, value);\n            if (exprs) {\n                CHANGED = true;\n                if (exprs.length) {\n                    return make_sequence(value, exprs);\n                } else if (value instanceof AST_Sequence) {\n                    return value.tail_node().left;\n                } else {\n                    return value.left;\n                }\n            }\n            return value;\n        }\n    }\n}\n\nfunction trim_unreachable_code(compressor, stat, target) {\n    walk(stat, node => {\n        if (node instanceof AST_Var) {\n            node.remove_initializers();\n            target.push(node);\n            return true;\n        }\n        if (\n            node instanceof AST_Defun\n            && (node === stat || !compressor.has_directive(\"use strict\"))\n        ) {\n            target.push(node === stat ? node : make_node(AST_Var, node, {\n                definitions: [\n                    make_node(AST_VarDef, node, {\n                        name: make_node(AST_SymbolVar, node.name, node.name),\n                        value: null\n                    })\n                ]\n            }));\n            return true;\n        }\n        if (node instanceof AST_Export || node instanceof AST_Import) {\n            target.push(node);\n            return true;\n        }\n        if (node instanceof AST_Scope) {\n            return true;\n        }\n    });\n}\n\nfunction get_value(key) {\n    if (key instanceof AST_Constant) {\n        return key.getValue();\n    }\n    if (key instanceof AST_UnaryPrefix\n        && key.operator == \"void\"\n        && key.expression instanceof AST_Constant) {\n        return;\n    }\n    return key;\n}\n\nfunction is_undefined(node, compressor) {\n    return (\n        has_flag(node, UNDEFINED)\n        || node instanceof AST_Undefined\n        || node instanceof AST_UnaryPrefix\n            && node.operator == \"void\"\n            && !node.expression.has_side_effects(compressor)\n    );\n}\n\n// may_throw_on_access()\n// returns true if this node may be null, undefined or contain `AST_Accessor`\n(function(def_may_throw_on_access) {\n    AST_Node.DEFMETHOD(\"may_throw_on_access\", function(compressor) {\n        return !compressor.option(\"pure_getters\")\n            || this._dot_throw(compressor);\n    });\n\n    function is_strict(compressor) {\n        return /strict/.test(compressor.option(\"pure_getters\"));\n    }\n\n    def_may_throw_on_access(AST_Node, is_strict);\n    def_may_throw_on_access(AST_Null, return_true);\n    def_may_throw_on_access(AST_Undefined, return_true);\n    def_may_throw_on_access(AST_Constant, return_false);\n    def_may_throw_on_access(AST_Array, return_false);\n    def_may_throw_on_access(AST_Object, function(compressor) {\n        if (!is_strict(compressor)) return false;\n        for (var i = this.properties.length; --i >=0;)\n            if (this.properties[i]._dot_throw(compressor)) return true;\n        return false;\n    });\n    // Do not be as strict with classes as we are with objects.\n    // Hopefully the community is not going to abuse static getters and setters.\n    // https://github.com/terser/terser/issues/724#issuecomment-643655656\n    def_may_throw_on_access(AST_Class, return_false);\n    def_may_throw_on_access(AST_ObjectProperty, return_false);\n    def_may_throw_on_access(AST_ObjectGetter, return_true);\n    def_may_throw_on_access(AST_Expansion, function(compressor) {\n        return this.expression._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Function, return_false);\n    def_may_throw_on_access(AST_Arrow, return_false);\n    def_may_throw_on_access(AST_UnaryPostfix, return_false);\n    def_may_throw_on_access(AST_UnaryPrefix, function() {\n        return this.operator == \"void\";\n    });\n    def_may_throw_on_access(AST_Binary, function(compressor) {\n        return (this.operator == \"&&\" || this.operator == \"||\" || this.operator == \"??\")\n            && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));\n    });\n    def_may_throw_on_access(AST_Assign, function(compressor) {\n        if (this.logical) return true;\n\n        return this.operator == \"=\"\n            && this.right._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Conditional, function(compressor) {\n        return this.consequent._dot_throw(compressor)\n            || this.alternative._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Dot, function(compressor) {\n        if (!is_strict(compressor)) return false;\n\n        if (this.property == \"prototype\") {\n            return !(\n                this.expression instanceof AST_Function\n                || this.expression instanceof AST_Class\n            );\n        }\n        return true;\n    });\n    def_may_throw_on_access(AST_Chain, function(compressor) {\n        return this.expression._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_Sequence, function(compressor) {\n        return this.tail_node()._dot_throw(compressor);\n    });\n    def_may_throw_on_access(AST_SymbolRef, function(compressor) {\n        if (this.name === \"arguments\") return false;\n        if (has_flag(this, UNDEFINED)) return true;\n        if (!is_strict(compressor)) return false;\n        if (is_undeclared_ref(this) && this.is_declared(compressor)) return false;\n        if (this.is_immutable()) return false;\n        var fixed = this.fixed_value();\n        return !fixed || fixed._dot_throw(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"_dot_throw\", func);\n});\n\n/* -----[ boolean/negation helpers ]----- */\n\n// methods to determine whether an expression has a boolean result type\n(function(def_is_boolean) {\n    const unary_bool = makePredicate(\"! delete\");\n    const binary_bool = makePredicate(\"in instanceof == != === !== < <= >= >\");\n    def_is_boolean(AST_Node, return_false);\n    def_is_boolean(AST_UnaryPrefix, function() {\n        return unary_bool.has(this.operator);\n    });\n    def_is_boolean(AST_Binary, function() {\n        return binary_bool.has(this.operator)\n            || lazy_op.has(this.operator)\n                && this.left.is_boolean()\n                && this.right.is_boolean();\n    });\n    def_is_boolean(AST_Conditional, function() {\n        return this.consequent.is_boolean() && this.alternative.is_boolean();\n    });\n    def_is_boolean(AST_Assign, function() {\n        return this.operator == \"=\" && this.right.is_boolean();\n    });\n    def_is_boolean(AST_Sequence, function() {\n        return this.tail_node().is_boolean();\n    });\n    def_is_boolean(AST_True, return_true);\n    def_is_boolean(AST_False, return_true);\n})(function(node, func) {\n    node.DEFMETHOD(\"is_boolean\", func);\n});\n\n// methods to determine if an expression has a numeric result type\n(function(def_is_number) {\n    def_is_number(AST_Node, return_false);\n    def_is_number(AST_Number, return_true);\n    var unary = makePredicate(\"+ - ~ ++ --\");\n    def_is_number(AST_Unary, function() {\n        return unary.has(this.operator);\n    });\n    var binary = makePredicate(\"- * / % & | ^ << >> >>>\");\n    def_is_number(AST_Binary, function(compressor) {\n        return binary.has(this.operator) || this.operator == \"+\"\n            && this.left.is_number(compressor)\n            && this.right.is_number(compressor);\n    });\n    def_is_number(AST_Assign, function(compressor) {\n        return binary.has(this.operator.slice(0, -1))\n            || this.operator == \"=\" && this.right.is_number(compressor);\n    });\n    def_is_number(AST_Sequence, function(compressor) {\n        return this.tail_node().is_number(compressor);\n    });\n    def_is_number(AST_Conditional, function(compressor) {\n        return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_number\", func);\n});\n\n// methods to determine if an expression has a string result type\n(function(def_is_string) {\n    def_is_string(AST_Node, return_false);\n    def_is_string(AST_String, return_true);\n    def_is_string(AST_TemplateString, return_true);\n    def_is_string(AST_UnaryPrefix, function() {\n        return this.operator == \"typeof\";\n    });\n    def_is_string(AST_Binary, function(compressor) {\n        return this.operator == \"+\" &&\n            (this.left.is_string(compressor) || this.right.is_string(compressor));\n    });\n    def_is_string(AST_Assign, function(compressor) {\n        return (this.operator == \"=\" || this.operator == \"+=\") && this.right.is_string(compressor);\n    });\n    def_is_string(AST_Sequence, function(compressor) {\n        return this.tail_node().is_string(compressor);\n    });\n    def_is_string(AST_Conditional, function(compressor) {\n        return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_string\", func);\n});\n\nvar lazy_op = makePredicate(\"&& || ??\");\nvar unary_side_effects = makePredicate(\"delete ++ --\");\n\nfunction is_lhs(node, parent) {\n    if (parent instanceof AST_Unary && unary_side_effects.has(parent.operator)) return parent.expression;\n    if (parent instanceof AST_Assign && parent.left === node) return node;\n}\n\n(function(def_find_defs) {\n    function to_node(value, orig) {\n        if (value instanceof AST_Node) return make_node(value.CTOR, orig, value);\n        if (Array.isArray(value)) return make_node(AST_Array, orig, {\n            elements: value.map(function(value) {\n                return to_node(value, orig);\n            })\n        });\n        if (value && typeof value == \"object\") {\n            var props = [];\n            for (var key in value) if (HOP(value, key)) {\n                props.push(make_node(AST_ObjectKeyVal, orig, {\n                    key: key,\n                    value: to_node(value[key], orig)\n                }));\n            }\n            return make_node(AST_Object, orig, {\n                properties: props\n            });\n        }\n        return make_node_from_constant(value, orig);\n    }\n\n    AST_Toplevel.DEFMETHOD(\"resolve_defines\", function(compressor) {\n        if (!compressor.option(\"global_defs\")) return this;\n        this.figure_out_scope({ ie8: compressor.option(\"ie8\") });\n        return this.transform(new TreeTransformer(function(node) {\n            var def = node._find_defs(compressor, \"\");\n            if (!def) return;\n            var level = 0, child = node, parent;\n            while (parent = this.parent(level++)) {\n                if (!(parent instanceof AST_PropAccess)) break;\n                if (parent.expression !== child) break;\n                child = parent;\n            }\n            if (is_lhs(child, parent)) {\n                return;\n            }\n            return def;\n        }));\n    });\n    def_find_defs(AST_Node, noop);\n    def_find_defs(AST_Chain, function(compressor, suffix) {\n        return this.expression._find_defs(compressor, suffix);\n    });\n    def_find_defs(AST_Dot, function(compressor, suffix) {\n        return this.expression._find_defs(compressor, \".\" + this.property + suffix);\n    });\n    def_find_defs(AST_SymbolDeclaration, function() {\n        if (!this.global()) return;\n    });\n    def_find_defs(AST_SymbolRef, function(compressor, suffix) {\n        if (!this.global()) return;\n        var defines = compressor.option(\"global_defs\");\n        var name = this.name + suffix;\n        if (HOP(defines, name)) return to_node(defines[name], this);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"_find_defs\", func);\n});\n\nfunction best_of_expression(ast1, ast2) {\n    return ast1.size() > ast2.size() ? ast2 : ast1;\n}\n\nfunction best_of_statement(ast1, ast2) {\n    return best_of_expression(\n        make_node(AST_SimpleStatement, ast1, {\n            body: ast1\n        }),\n        make_node(AST_SimpleStatement, ast2, {\n            body: ast2\n        })\n    ).body;\n}\n\nfunction best_of(compressor, ast1, ast2) {\n    return (first_in_statement(compressor) ? best_of_statement : best_of_expression)(ast1, ast2);\n}\n\nfunction convert_to_predicate(obj) {\n    const out = new Map();\n    for (var key of Object.keys(obj)) {\n        out.set(key, makePredicate(obj[key]));\n    }\n    return out;\n}\n\nvar object_fns = [\n    \"constructor\",\n    \"toString\",\n    \"valueOf\",\n];\nvar native_fns = convert_to_predicate({\n    Array: [\n        \"indexOf\",\n        \"join\",\n        \"lastIndexOf\",\n        \"slice\",\n    ].concat(object_fns),\n    Boolean: object_fns,\n    Function: object_fns,\n    Number: [\n        \"toExponential\",\n        \"toFixed\",\n        \"toPrecision\",\n    ].concat(object_fns),\n    Object: object_fns,\n    RegExp: [\n        \"test\",\n    ].concat(object_fns),\n    String: [\n        \"charAt\",\n        \"charCodeAt\",\n        \"concat\",\n        \"indexOf\",\n        \"italics\",\n        \"lastIndexOf\",\n        \"match\",\n        \"replace\",\n        \"search\",\n        \"slice\",\n        \"split\",\n        \"substr\",\n        \"substring\",\n        \"toLowerCase\",\n        \"toUpperCase\",\n        \"trim\",\n    ].concat(object_fns),\n});\nvar static_fns = convert_to_predicate({\n    Array: [\n        \"isArray\",\n    ],\n    Math: [\n        \"abs\",\n        \"acos\",\n        \"asin\",\n        \"atan\",\n        \"ceil\",\n        \"cos\",\n        \"exp\",\n        \"floor\",\n        \"log\",\n        \"round\",\n        \"sin\",\n        \"sqrt\",\n        \"tan\",\n        \"atan2\",\n        \"pow\",\n        \"max\",\n        \"min\",\n    ],\n    Number: [\n        \"isFinite\",\n        \"isNaN\",\n    ],\n    Object: [\n        \"create\",\n        \"getOwnPropertyDescriptor\",\n        \"getOwnPropertyNames\",\n        \"getPrototypeOf\",\n        \"isExtensible\",\n        \"isFrozen\",\n        \"isSealed\",\n        \"keys\",\n    ],\n    String: [\n        \"fromCharCode\",\n    ],\n});\n\n// methods to evaluate a constant expression\n(function(def_eval) {\n    // If the node has been successfully reduced to a constant,\n    // then its value is returned; otherwise the element itself\n    // is returned.\n    // They can be distinguished as constant value is never a\n    // descendant of AST_Node.\n    AST_Node.DEFMETHOD(\"evaluate\", function(compressor) {\n        if (!compressor.option(\"evaluate\")) return this;\n        var val = this._eval(compressor, 1);\n        if (!val || val instanceof RegExp) return val;\n        if (typeof val == \"function\" || typeof val == \"object\") return this;\n        return val;\n    });\n    var unaryPrefix = makePredicate(\"! ~ - + void\");\n    AST_Node.DEFMETHOD(\"is_constant\", function() {\n        // Accomodate when compress option evaluate=false\n        // as well as the common constant expressions !0 and -1\n        if (this instanceof AST_Constant) {\n            return !(this instanceof AST_RegExp);\n        } else {\n            return this instanceof AST_UnaryPrefix\n                && this.expression instanceof AST_Constant\n                && unaryPrefix.has(this.operator);\n        }\n    });\n    def_eval(AST_Statement, function() {\n        throw new Error(string_template(\"Cannot evaluate a statement [{file}:{line},{col}]\", this.start));\n    });\n    def_eval(AST_Lambda, return_this);\n    def_eval(AST_Class, return_this);\n    def_eval(AST_Node, return_this);\n    def_eval(AST_Constant, function() {\n        return this.getValue();\n    });\n    def_eval(AST_BigInt, return_this);\n    def_eval(AST_RegExp, function(compressor) {\n        let evaluated = compressor.evaluated_regexps.get(this);\n        if (evaluated === undefined) {\n            try {\n                evaluated = (0, eval)(this.print_to_string());\n            } catch (e) {\n                evaluated = null;\n            }\n            compressor.evaluated_regexps.set(this, evaluated);\n        }\n        return evaluated || this;\n    });\n    def_eval(AST_TemplateString, function() {\n        if (this.segments.length !== 1) return this;\n        return this.segments[0].value;\n    });\n    def_eval(AST_Function, function(compressor) {\n        if (compressor.option(\"unsafe\")) {\n            var fn = function() {};\n            fn.node = this;\n            fn.toString = () => this.print_to_string();\n            return fn;\n        }\n        return this;\n    });\n    def_eval(AST_Array, function(compressor, depth) {\n        if (compressor.option(\"unsafe\")) {\n            var elements = [];\n            for (var i = 0, len = this.elements.length; i < len; i++) {\n                var element = this.elements[i];\n                var value = element._eval(compressor, depth);\n                if (element === value) return this;\n                elements.push(value);\n            }\n            return elements;\n        }\n        return this;\n    });\n    def_eval(AST_Object, function(compressor, depth) {\n        if (compressor.option(\"unsafe\")) {\n            var val = {};\n            for (var i = 0, len = this.properties.length; i < len; i++) {\n                var prop = this.properties[i];\n                if (prop instanceof AST_Expansion) return this;\n                var key = prop.key;\n                if (key instanceof AST_Symbol) {\n                    key = key.name;\n                } else if (key instanceof AST_Node) {\n                    key = key._eval(compressor, depth);\n                    if (key === prop.key) return this;\n                }\n                if (typeof Object.prototype[key] === \"function\") {\n                    return this;\n                }\n                if (prop.value instanceof AST_Function) continue;\n                val[key] = prop.value._eval(compressor, depth);\n                if (val[key] === prop.value) return this;\n            }\n            return val;\n        }\n        return this;\n    });\n    var non_converting_unary = makePredicate(\"! typeof void\");\n    def_eval(AST_UnaryPrefix, function(compressor, depth) {\n        var e = this.expression;\n        // Function would be evaluated to an array and so typeof would\n        // incorrectly return 'object'. Hence making is a special case.\n        if (compressor.option(\"typeofs\")\n            && this.operator == \"typeof\"\n            && (e instanceof AST_Lambda\n                || e instanceof AST_SymbolRef\n                    && e.fixed_value() instanceof AST_Lambda)) {\n            return typeof function() {};\n        }\n        if (!non_converting_unary.has(this.operator)) depth++;\n        e = e._eval(compressor, depth);\n        if (e === this.expression) return this;\n        switch (this.operator) {\n          case \"!\": return !e;\n          case \"typeof\":\n            // typeof <RegExp> returns \"object\" or \"function\" on different platforms\n            // so cannot evaluate reliably\n            if (e instanceof RegExp) return this;\n            return typeof e;\n          case \"void\": return void e;\n          case \"~\": return ~e;\n          case \"-\": return -e;\n          case \"+\": return +e;\n        }\n        return this;\n    });\n    var non_converting_binary = makePredicate(\"&& || ?? === !==\");\n    const identity_comparison = makePredicate(\"== != === !==\");\n    const has_identity = value =>\n        typeof value === \"object\"\n        || typeof value === \"function\"\n        || typeof value === \"symbol\";\n\n    def_eval(AST_Binary, function(compressor, depth) {\n        if (!non_converting_binary.has(this.operator)) depth++;\n\n        var left = this.left._eval(compressor, depth);\n        if (left === this.left) return this;\n        var right = this.right._eval(compressor, depth);\n        if (right === this.right) return this;\n        var result;\n\n        if (\n            left != null\n            && right != null\n            && identity_comparison.has(this.operator)\n            && has_identity(left)\n            && has_identity(right)\n            && typeof left === typeof right\n        ) {\n            // Do not compare by reference\n            return this;\n        }\n\n        switch (this.operator) {\n          case \"&&\"  : result = left &&  right; break;\n          case \"||\"  : result = left ||  right; break;\n          case \"??\"  : result = left != null ? left : right; break;\n          case \"|\"   : result = left |   right; break;\n          case \"&\"   : result = left &   right; break;\n          case \"^\"   : result = left ^   right; break;\n          case \"+\"   : result = left +   right; break;\n          case \"*\"   : result = left *   right; break;\n          case \"**\"  : result = Math.pow(left, right); break;\n          case \"/\"   : result = left /   right; break;\n          case \"%\"   : result = left %   right; break;\n          case \"-\"   : result = left -   right; break;\n          case \"<<\"  : result = left <<  right; break;\n          case \">>\"  : result = left >>  right; break;\n          case \">>>\" : result = left >>> right; break;\n          case \"==\"  : result = left ==  right; break;\n          case \"===\" : result = left === right; break;\n          case \"!=\"  : result = left !=  right; break;\n          case \"!==\" : result = left !== right; break;\n          case \"<\"   : result = left <   right; break;\n          case \"<=\"  : result = left <=  right; break;\n          case \">\"   : result = left >   right; break;\n          case \">=\"  : result = left >=  right; break;\n          default:\n              return this;\n        }\n        if (isNaN(result) && compressor.find_parent(AST_With)) {\n            // leave original expression as is\n            return this;\n        }\n        return result;\n    });\n    def_eval(AST_Conditional, function(compressor, depth) {\n        var condition = this.condition._eval(compressor, depth);\n        if (condition === this.condition) return this;\n        var node = condition ? this.consequent : this.alternative;\n        var value = node._eval(compressor, depth);\n        return value === node ? this : value;\n    });\n\n    // Set of AST_SymbolRef which are currently being evaluated.\n    // Avoids infinite recursion of ._eval()\n    const reentrant_ref_eval = new Set();\n    def_eval(AST_SymbolRef, function(compressor, depth) {\n        if (reentrant_ref_eval.has(this)) return this;\n\n        var fixed = this.fixed_value();\n        if (!fixed) return this;\n\n        reentrant_ref_eval.add(this);\n        const value = fixed._eval(compressor, depth);\n        reentrant_ref_eval.delete(this);\n\n        if (value === fixed) return this;\n\n        if (value && typeof value == \"object\") {\n            var escaped = this.definition().escaped;\n            if (escaped && depth > escaped) return this;\n        }\n        return value;\n    });\n    var global_objs = { Array, Math, Number, Object, String };\n    var static_values = convert_to_predicate({\n        Math: [\n            \"E\",\n            \"LN10\",\n            \"LN2\",\n            \"LOG2E\",\n            \"LOG10E\",\n            \"PI\",\n            \"SQRT1_2\",\n            \"SQRT2\",\n        ],\n        Number: [\n            \"MAX_VALUE\",\n            \"MIN_VALUE\",\n            \"NaN\",\n            \"NEGATIVE_INFINITY\",\n            \"POSITIVE_INFINITY\",\n        ],\n    });\n    const regexp_flags = new Set([\n        \"dotAll\",\n        \"global\",\n        \"ignoreCase\",\n        \"multiline\",\n        \"sticky\",\n        \"unicode\",\n    ]);\n    def_eval(AST_PropAccess, function(compressor, depth) {\n        if (this.optional) {\n            const obj = this.expression._eval(compressor, depth);\n            if (obj == null) return undefined;\n        }\n        if (compressor.option(\"unsafe\")) {\n            var key = this.property;\n            if (key instanceof AST_Node) {\n                key = key._eval(compressor, depth);\n                if (key === this.property) return this;\n            }\n            var exp = this.expression;\n            var val;\n            if (is_undeclared_ref(exp)) {\n\n                var aa;\n                var first_arg = exp.name === \"hasOwnProperty\"\n                    && key === \"call\"\n                    && (aa = compressor.parent() && compressor.parent().args)\n                    && (aa && aa[0]\n                    && aa[0].evaluate(compressor));\n\n                first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;\n\n                if (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared) {\n                    return this.clone();\n                }\n                var static_value = static_values.get(exp.name);\n                if (!static_value || !static_value.has(key)) return this;\n                val = global_objs[exp.name];\n            } else {\n                val = exp._eval(compressor, depth + 1);\n                if (val instanceof RegExp) {\n                    if (key == \"source\") {\n                        return regexp_source_fix(val.source);\n                    } else if (key == \"flags\" || regexp_flags.has(key)) {\n                        return val[key];\n                    }\n                }\n                if (!val || val === exp || !HOP(val, key)) return this;\n                if (typeof val == \"function\") switch (key) {\n                  case \"name\":\n                    return val.node.name ? val.node.name.name : \"\";\n                  case \"length\":\n                    return val.node.length_property();\n                  default:\n                    return this;\n                }\n            }\n            return val[key];\n        }\n        return this;\n    });\n    def_eval(AST_Chain, function(compressor, depth) {\n        const evaluated = this.expression._eval(compressor, depth);\n        return evaluated === this.expression ? this : evaluated;\n    });\n    def_eval(AST_Call, function(compressor, depth) {\n        var exp = this.expression;\n        if (this.optional) {\n            const callee = this.expression._eval(compressor, depth);\n            if (callee == null) return undefined;\n        }\n        if (compressor.option(\"unsafe\") && exp instanceof AST_PropAccess) {\n            var key = exp.property;\n            if (key instanceof AST_Node) {\n                key = key._eval(compressor, depth);\n                if (key === exp.property) return this;\n            }\n            var val;\n            var e = exp.expression;\n            if (is_undeclared_ref(e)) {\n                var first_arg =\n                    e.name === \"hasOwnProperty\" &&\n                    key === \"call\" &&\n                    (this.args[0] && this.args[0].evaluate(compressor));\n\n                first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;\n\n                if ((first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)) {\n                    return this.clone();\n                }\n                var static_fn = static_fns.get(e.name);\n                if (!static_fn || !static_fn.has(key)) return this;\n                val = global_objs[e.name];\n            } else {\n                val = e._eval(compressor, depth + 1);\n                if (val === e || !val) return this;\n                var native_fn = native_fns.get(val.constructor.name);\n                if (!native_fn || !native_fn.has(key)) return this;\n            }\n            var args = [];\n            for (var i = 0, len = this.args.length; i < len; i++) {\n                var arg = this.args[i];\n                var value = arg._eval(compressor, depth);\n                if (arg === value) return this;\n                if (arg instanceof AST_Lambda) return this;\n                args.push(value);\n            }\n            try {\n                return val[key].apply(val, args);\n            } catch (ex) {\n                // We don't really care\n            }\n        }\n        return this;\n    });\n    def_eval(AST_New, return_this);\n})(function(node, func) {\n    node.DEFMETHOD(\"_eval\", func);\n});\n\n// method to negate an expression\n(function(def_negate) {\n    function basic_negation(exp) {\n        return make_node(AST_UnaryPrefix, exp, {\n            operator: \"!\",\n            expression: exp\n        });\n    }\n    function best(orig, alt, first_in_statement) {\n        var negated = basic_negation(orig);\n        if (first_in_statement) {\n            var stat = make_node(AST_SimpleStatement, alt, {\n                body: alt\n            });\n            return best_of_expression(negated, stat) === stat ? alt : negated;\n        }\n        return best_of_expression(negated, alt);\n    }\n    def_negate(AST_Node, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_Statement, function() {\n        throw new Error(\"Cannot negate a statement\");\n    });\n    def_negate(AST_Function, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_Arrow, function() {\n        return basic_negation(this);\n    });\n    def_negate(AST_UnaryPrefix, function() {\n        if (this.operator == \"!\")\n            return this.expression;\n        return basic_negation(this);\n    });\n    def_negate(AST_Sequence, function(compressor) {\n        var expressions = this.expressions.slice();\n        expressions.push(expressions.pop().negate(compressor));\n        return make_sequence(this, expressions);\n    });\n    def_negate(AST_Conditional, function(compressor, first_in_statement) {\n        var self = this.clone();\n        self.consequent = self.consequent.negate(compressor);\n        self.alternative = self.alternative.negate(compressor);\n        return best(this, self, first_in_statement);\n    });\n    def_negate(AST_Binary, function(compressor, first_in_statement) {\n        var self = this.clone(), op = this.operator;\n        if (compressor.option(\"unsafe_comps\")) {\n            switch (op) {\n              case \"<=\" : self.operator = \">\"  ; return self;\n              case \"<\"  : self.operator = \">=\" ; return self;\n              case \">=\" : self.operator = \"<\"  ; return self;\n              case \">\"  : self.operator = \"<=\" ; return self;\n            }\n        }\n        switch (op) {\n          case \"==\" : self.operator = \"!=\"; return self;\n          case \"!=\" : self.operator = \"==\"; return self;\n          case \"===\": self.operator = \"!==\"; return self;\n          case \"!==\": self.operator = \"===\"; return self;\n          case \"&&\":\n            self.operator = \"||\";\n            self.left = self.left.negate(compressor, first_in_statement);\n            self.right = self.right.negate(compressor);\n            return best(this, self, first_in_statement);\n          case \"||\":\n            self.operator = \"&&\";\n            self.left = self.left.negate(compressor, first_in_statement);\n            self.right = self.right.negate(compressor);\n            return best(this, self, first_in_statement);\n          case \"??\":\n            self.right = self.right.negate(compressor);\n            return best(this, self, first_in_statement);\n        }\n        return basic_negation(this);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"negate\", function(compressor, first_in_statement) {\n        return func.call(this, compressor, first_in_statement);\n    });\n});\n\nvar global_pure_fns = makePredicate(\"Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError\");\nAST_Call.DEFMETHOD(\"is_callee_pure\", function(compressor) {\n    if (compressor.option(\"unsafe\")) {\n        var expr = this.expression;\n        var first_arg = (this.args && this.args[0] && this.args[0].evaluate(compressor));\n        if (\n            expr.expression && expr.expression.name === \"hasOwnProperty\" &&\n            (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)\n        ) {\n            return false;\n        }\n        if (is_undeclared_ref(expr) && global_pure_fns.has(expr.name)) return true;\n        let static_fn;\n        if (expr instanceof AST_Dot\n            && is_undeclared_ref(expr.expression)\n            && (static_fn = static_fns.get(expr.expression.name))\n            && static_fn.has(expr.property)) {\n            return true;\n        }\n    }\n    return !!has_annotation(this, _PURE) || !compressor.pure_funcs(this);\n});\nAST_Node.DEFMETHOD(\"is_call_pure\", return_false);\nAST_Dot.DEFMETHOD(\"is_call_pure\", function(compressor) {\n    if (!compressor.option(\"unsafe\")) return;\n    const expr = this.expression;\n    let map;\n    if (expr instanceof AST_Array) {\n        map = native_fns.get(\"Array\");\n    } else if (expr.is_boolean()) {\n        map = native_fns.get(\"Boolean\");\n    } else if (expr.is_number(compressor)) {\n        map = native_fns.get(\"Number\");\n    } else if (expr instanceof AST_RegExp) {\n        map = native_fns.get(\"RegExp\");\n    } else if (expr.is_string(compressor)) {\n        map = native_fns.get(\"String\");\n    } else if (!this.may_throw_on_access(compressor)) {\n        map = native_fns.get(\"Object\");\n    }\n    return map && map.has(this.property);\n});\n\nconst pure_prop_access_globals = new Set([\n    \"Number\",\n    \"String\",\n    \"Array\",\n    \"Object\",\n    \"Function\",\n    \"Promise\",\n]);\n// determine if expression has side effects\n(function(def_has_side_effects) {\n    def_has_side_effects(AST_Node, return_true);\n\n    def_has_side_effects(AST_EmptyStatement, return_false);\n    def_has_side_effects(AST_Constant, return_false);\n    def_has_side_effects(AST_This, return_false);\n\n    function any(list, compressor) {\n        for (var i = list.length; --i >= 0;)\n            if (list[i].has_side_effects(compressor))\n                return true;\n        return false;\n    }\n\n    def_has_side_effects(AST_Block, function(compressor) {\n        return any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Call, function(compressor) {\n        if (\n            !this.is_callee_pure(compressor)\n            && (!this.expression.is_call_pure(compressor)\n                || this.expression.has_side_effects(compressor))\n        ) {\n            return true;\n        }\n        return any(this.args, compressor);\n    });\n    def_has_side_effects(AST_Switch, function(compressor) {\n        return this.expression.has_side_effects(compressor)\n            || any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Case, function(compressor) {\n        return this.expression.has_side_effects(compressor)\n            || any(this.body, compressor);\n    });\n    def_has_side_effects(AST_Try, function(compressor) {\n        return any(this.body, compressor)\n            || this.bcatch && this.bcatch.has_side_effects(compressor)\n            || this.bfinally && this.bfinally.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_If, function(compressor) {\n        return this.condition.has_side_effects(compressor)\n            || this.body && this.body.has_side_effects(compressor)\n            || this.alternative && this.alternative.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_LabeledStatement, function(compressor) {\n        return this.body.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_SimpleStatement, function(compressor) {\n        return this.body.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Lambda, return_false);\n    def_has_side_effects(AST_Class, function (compressor) {\n        if (this.extends && this.extends.has_side_effects(compressor)) {\n            return true;\n        }\n        return any(this.properties, compressor);\n    });\n    def_has_side_effects(AST_Binary, function(compressor) {\n        return this.left.has_side_effects(compressor)\n            || this.right.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Assign, return_true);\n    def_has_side_effects(AST_Conditional, function(compressor) {\n        return this.condition.has_side_effects(compressor)\n            || this.consequent.has_side_effects(compressor)\n            || this.alternative.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Unary, function(compressor) {\n        return unary_side_effects.has(this.operator)\n            || this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_SymbolRef, function(compressor) {\n        return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);\n    });\n    def_has_side_effects(AST_SymbolClassProperty, return_false);\n    def_has_side_effects(AST_SymbolDeclaration, return_false);\n    def_has_side_effects(AST_Object, function(compressor) {\n        return any(this.properties, compressor);\n    });\n    def_has_side_effects(AST_ObjectProperty, function(compressor) {\n        return (\n            this.computed_key() && this.key.has_side_effects(compressor)\n            || this.value && this.value.has_side_effects(compressor)\n        );\n    });\n    def_has_side_effects(AST_ClassProperty, function(compressor) {\n        return (\n            this.computed_key() && this.key.has_side_effects(compressor)\n            || this.static && this.value && this.value.has_side_effects(compressor)\n        );\n    });\n    def_has_side_effects(AST_ConciseMethod, function(compressor) {\n        return this.computed_key() && this.key.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_ObjectGetter, function(compressor) {\n        return this.computed_key() && this.key.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_ObjectSetter, function(compressor) {\n        return this.computed_key() && this.key.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Array, function(compressor) {\n        return any(this.elements, compressor);\n    });\n    def_has_side_effects(AST_Dot, function(compressor) {\n        return !this.optional && this.expression.may_throw_on_access(compressor)\n            || this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Sub, function(compressor) {\n        if (this.optional && is_nullish(this.expression, compressor)) {\n            return false;\n        }\n\n        return !this.optional && this.expression.may_throw_on_access(compressor)\n            || this.expression.has_side_effects(compressor)\n            || this.property.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Chain, function (compressor) {\n        return this.expression.has_side_effects(compressor);\n    });\n    def_has_side_effects(AST_Sequence, function(compressor) {\n        return any(this.expressions, compressor);\n    });\n    def_has_side_effects(AST_Definitions, function(compressor) {\n        return any(this.definitions, compressor);\n    });\n    def_has_side_effects(AST_VarDef, function() {\n        return this.value;\n    });\n    def_has_side_effects(AST_TemplateSegment, return_false);\n    def_has_side_effects(AST_TemplateString, function(compressor) {\n        return any(this.segments, compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"has_side_effects\", func);\n});\n\n// determine if expression may throw\n(function(def_may_throw) {\n    def_may_throw(AST_Node, return_true);\n\n    def_may_throw(AST_Constant, return_false);\n    def_may_throw(AST_EmptyStatement, return_false);\n    def_may_throw(AST_Lambda, return_false);\n    def_may_throw(AST_SymbolDeclaration, return_false);\n    def_may_throw(AST_This, return_false);\n\n    function any(list, compressor) {\n        for (var i = list.length; --i >= 0;)\n            if (list[i].may_throw(compressor))\n                return true;\n        return false;\n    }\n\n    def_may_throw(AST_Class, function(compressor) {\n        if (this.extends && this.extends.may_throw(compressor)) return true;\n        return any(this.properties, compressor);\n    });\n\n    def_may_throw(AST_Array, function(compressor) {\n        return any(this.elements, compressor);\n    });\n    def_may_throw(AST_Assign, function(compressor) {\n        if (this.right.may_throw(compressor)) return true;\n        if (!compressor.has_directive(\"use strict\")\n            && this.operator == \"=\"\n            && this.left instanceof AST_SymbolRef) {\n            return false;\n        }\n        return this.left.may_throw(compressor);\n    });\n    def_may_throw(AST_Binary, function(compressor) {\n        return this.left.may_throw(compressor)\n            || this.right.may_throw(compressor);\n    });\n    def_may_throw(AST_Block, function(compressor) {\n        return any(this.body, compressor);\n    });\n    def_may_throw(AST_Call, function(compressor) {\n        if (this.optional && is_nullish(this.expression, compressor)) return false;\n        if (any(this.args, compressor)) return true;\n        if (this.is_callee_pure(compressor)) return false;\n        if (this.expression.may_throw(compressor)) return true;\n        return !(this.expression instanceof AST_Lambda)\n            || any(this.expression.body, compressor);\n    });\n    def_may_throw(AST_Case, function(compressor) {\n        return this.expression.may_throw(compressor)\n            || any(this.body, compressor);\n    });\n    def_may_throw(AST_Conditional, function(compressor) {\n        return this.condition.may_throw(compressor)\n            || this.consequent.may_throw(compressor)\n            || this.alternative.may_throw(compressor);\n    });\n    def_may_throw(AST_Definitions, function(compressor) {\n        return any(this.definitions, compressor);\n    });\n    def_may_throw(AST_If, function(compressor) {\n        return this.condition.may_throw(compressor)\n            || this.body && this.body.may_throw(compressor)\n            || this.alternative && this.alternative.may_throw(compressor);\n    });\n    def_may_throw(AST_LabeledStatement, function(compressor) {\n        return this.body.may_throw(compressor);\n    });\n    def_may_throw(AST_Object, function(compressor) {\n        return any(this.properties, compressor);\n    });\n    def_may_throw(AST_ObjectProperty, function(compressor) {\n        // TODO key may throw too\n        return this.value ? this.value.may_throw(compressor) : false;\n    });\n    def_may_throw(AST_ClassProperty, function(compressor) {\n        return (\n            this.computed_key() && this.key.may_throw(compressor)\n            || this.static && this.value && this.value.may_throw(compressor)\n        );\n    });\n    def_may_throw(AST_ConciseMethod, function(compressor) {\n        return this.computed_key() && this.key.may_throw(compressor);\n    });\n    def_may_throw(AST_ObjectGetter, function(compressor) {\n        return this.computed_key() && this.key.may_throw(compressor);\n    });\n    def_may_throw(AST_ObjectSetter, function(compressor) {\n        return this.computed_key() && this.key.may_throw(compressor);\n    });\n    def_may_throw(AST_Return, function(compressor) {\n        return this.value && this.value.may_throw(compressor);\n    });\n    def_may_throw(AST_Sequence, function(compressor) {\n        return any(this.expressions, compressor);\n    });\n    def_may_throw(AST_SimpleStatement, function(compressor) {\n        return this.body.may_throw(compressor);\n    });\n    def_may_throw(AST_Dot, function(compressor) {\n        return !this.optional && this.expression.may_throw_on_access(compressor)\n            || this.expression.may_throw(compressor);\n    });\n    def_may_throw(AST_Sub, function(compressor) {\n        if (this.optional && is_nullish(this.expression, compressor)) return false;\n\n        return !this.optional && this.expression.may_throw_on_access(compressor)\n            || this.expression.may_throw(compressor)\n            || this.property.may_throw(compressor);\n    });\n    def_may_throw(AST_Chain, function(compressor) {\n        return this.expression.may_throw(compressor);\n    });\n    def_may_throw(AST_Switch, function(compressor) {\n        return this.expression.may_throw(compressor)\n            || any(this.body, compressor);\n    });\n    def_may_throw(AST_SymbolRef, function(compressor) {\n        return !this.is_declared(compressor) && !pure_prop_access_globals.has(this.name);\n    });\n    def_may_throw(AST_SymbolClassProperty, return_false);\n    def_may_throw(AST_Try, function(compressor) {\n        return this.bcatch ? this.bcatch.may_throw(compressor) : any(this.body, compressor)\n            || this.bfinally && this.bfinally.may_throw(compressor);\n    });\n    def_may_throw(AST_Unary, function(compressor) {\n        if (this.operator == \"typeof\" && this.expression instanceof AST_SymbolRef)\n            return false;\n        return this.expression.may_throw(compressor);\n    });\n    def_may_throw(AST_VarDef, function(compressor) {\n        if (!this.value) return false;\n        return this.value.may_throw(compressor);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"may_throw\", func);\n});\n\n// determine if expression is constant\n(function(def_is_constant_expression) {\n    function all_refs_local(scope) {\n        let result = true;\n        walk(this, node => {\n            if (node instanceof AST_SymbolRef) {\n                if (has_flag(this, INLINED)) {\n                    result = false;\n                    return walk_abort;\n                }\n                var def = node.definition();\n                if (\n                    member(def, this.enclosed)\n                    && !this.variables.has(def.name)\n                ) {\n                    if (scope) {\n                        var scope_def = scope.find_variable(node);\n                        if (def.undeclared ? !scope_def : scope_def === def) {\n                            result = \"f\";\n                            return true;\n                        }\n                    }\n                    result = false;\n                    return walk_abort;\n                }\n                return true;\n            }\n            if (node instanceof AST_This && this instanceof AST_Arrow) {\n                // TODO check arguments too!\n                result = false;\n                return walk_abort;\n            }\n        });\n        return result;\n    }\n\n    def_is_constant_expression(AST_Node, return_false);\n    def_is_constant_expression(AST_Constant, return_true);\n    def_is_constant_expression(AST_Class, function(scope) {\n        if (this.extends && !this.extends.is_constant_expression(scope)) {\n            return false;\n        }\n\n        for (const prop of this.properties) {\n            if (prop.computed_key() && !prop.key.is_constant_expression(scope)) {\n                return false;\n            }\n            if (prop.static && prop.value && !prop.value.is_constant_expression(scope)) {\n                return false;\n            }\n        }\n\n        return all_refs_local.call(this, scope);\n    });\n    def_is_constant_expression(AST_Lambda, all_refs_local);\n    def_is_constant_expression(AST_Unary, function() {\n        return this.expression.is_constant_expression();\n    });\n    def_is_constant_expression(AST_Binary, function() {\n        return this.left.is_constant_expression()\n            && this.right.is_constant_expression();\n    });\n    def_is_constant_expression(AST_Array, function() {\n        return this.elements.every((l) => l.is_constant_expression());\n    });\n    def_is_constant_expression(AST_Object, function() {\n        return this.properties.every((l) => l.is_constant_expression());\n    });\n    def_is_constant_expression(AST_ObjectProperty, function() {\n        return !!(!(this.key instanceof AST_Node) && this.value && this.value.is_constant_expression());\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"is_constant_expression\", func);\n});\n\n// tell me if a statement aborts\nfunction aborts(thing) {\n    return thing && thing.aborts();\n}\n(function(def_aborts) {\n    def_aborts(AST_Statement, return_null);\n    def_aborts(AST_Jump, return_this);\n    function block_aborts() {\n        for (var i = 0; i < this.body.length; i++) {\n            if (aborts(this.body[i])) {\n                return this.body[i];\n            }\n        }\n        return null;\n    }\n    def_aborts(AST_Import, function() { return null; });\n    def_aborts(AST_BlockStatement, block_aborts);\n    def_aborts(AST_SwitchBranch, block_aborts);\n    def_aborts(AST_If, function() {\n        return this.alternative && aborts(this.body) && aborts(this.alternative) && this;\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"aborts\", func);\n});\n\n/* -----[ optimizers ]----- */\n\nvar directives = new Set([\"use asm\", \"use strict\"]);\ndef_optimize(AST_Directive, function(self, compressor) {\n    if (compressor.option(\"directives\")\n        && (!directives.has(self.value) || compressor.has_directive(self.value) !== self)) {\n        return make_node(AST_EmptyStatement, self);\n    }\n    return self;\n});\n\ndef_optimize(AST_Debugger, function(self, compressor) {\n    if (compressor.option(\"drop_debugger\"))\n        return make_node(AST_EmptyStatement, self);\n    return self;\n});\n\ndef_optimize(AST_LabeledStatement, function(self, compressor) {\n    if (self.body instanceof AST_Break\n        && compressor.loopcontrol_target(self.body) === self.body) {\n        return make_node(AST_EmptyStatement, self);\n    }\n    return self.label.references.length == 0 ? self.body : self;\n});\n\ndef_optimize(AST_Block, function(self, compressor) {\n    tighten_body(self.body, compressor);\n    return self;\n});\n\nfunction can_be_extracted_from_if_block(node) {\n    return !(\n        node instanceof AST_Const\n        || node instanceof AST_Let\n        || node instanceof AST_Class\n    );\n}\n\ndef_optimize(AST_BlockStatement, function(self, compressor) {\n    tighten_body(self.body, compressor);\n    switch (self.body.length) {\n      case 1:\n        if (!compressor.has_directive(\"use strict\")\n            && compressor.parent() instanceof AST_If\n            && can_be_extracted_from_if_block(self.body[0])\n            || can_be_evicted_from_block(self.body[0])) {\n            return self.body[0];\n        }\n        break;\n      case 0: return make_node(AST_EmptyStatement, self);\n    }\n    return self;\n});\n\nfunction opt_AST_Lambda(self, compressor) {\n    tighten_body(self.body, compressor);\n    if (compressor.option(\"side_effects\")\n        && self.body.length == 1\n        && self.body[0] === compressor.has_directive(\"use strict\")) {\n        self.body.length = 0;\n    }\n    return self;\n}\ndef_optimize(AST_Lambda, opt_AST_Lambda);\n\nconst r_keep_assign = /keep_assign/;\nAST_Scope.DEFMETHOD(\"drop_unused\", function(compressor) {\n    if (!compressor.option(\"unused\")) return;\n    if (compressor.has_directive(\"use asm\")) return;\n    var self = this;\n    if (self.pinned()) return;\n    var drop_funcs = !(self instanceof AST_Toplevel) || compressor.toplevel.funcs;\n    var drop_vars = !(self instanceof AST_Toplevel) || compressor.toplevel.vars;\n    const assign_as_unused = r_keep_assign.test(compressor.option(\"unused\")) ? return_false : function(node) {\n        if (node instanceof AST_Assign\n            && !node.logical\n            && (has_flag(node, WRITE_ONLY) || node.operator == \"=\")\n        ) {\n            return node.left;\n        }\n        if (node instanceof AST_Unary && has_flag(node, WRITE_ONLY)) {\n            return node.expression;\n        }\n    };\n    var in_use_ids = new Map();\n    var fixed_ids = new Map();\n    if (self instanceof AST_Toplevel && compressor.top_retain) {\n        self.variables.forEach(function(def) {\n            if (compressor.top_retain(def) && !in_use_ids.has(def.id)) {\n                in_use_ids.set(def.id, def);\n            }\n        });\n    }\n    var var_defs_by_id = new Map();\n    var initializations = new Map();\n    // pass 1: find out which symbols are directly used in\n    // this scope (not in nested scopes).\n    var scope = this;\n    var tw = new TreeWalker(function(node, descend) {\n        if (node instanceof AST_Lambda && node.uses_arguments && !tw.has_directive(\"use strict\")) {\n            node.argnames.forEach(function(argname) {\n                if (!(argname instanceof AST_SymbolDeclaration)) return;\n                var def = argname.definition();\n                if (!in_use_ids.has(def.id)) {\n                    in_use_ids.set(def.id, def);\n                }\n            });\n        }\n        if (node === self) return;\n        if (node instanceof AST_Defun || node instanceof AST_DefClass) {\n            var node_def = node.name.definition();\n            const in_export = tw.parent() instanceof AST_Export;\n            if (in_export || !drop_funcs && scope === self) {\n                if (node_def.global && !in_use_ids.has(node_def.id)) {\n                    in_use_ids.set(node_def.id, node_def);\n                }\n            }\n            if (node instanceof AST_DefClass) {\n                if (\n                    node.extends\n                    && (node.extends.has_side_effects(compressor)\n                    || node.extends.may_throw(compressor))\n                ) {\n                    node.extends.walk(tw);\n                }\n                for (const prop of node.properties) {\n                    if (\n                        prop.has_side_effects(compressor) ||\n                        prop.may_throw(compressor)\n                    ) {\n                        prop.walk(tw);\n                    }\n                }\n            }\n            map_add(initializations, node_def.id, node);\n            return true; // don't go in nested scopes\n        }\n        if (node instanceof AST_SymbolFunarg && scope === self) {\n            map_add(var_defs_by_id, node.definition().id, node);\n        }\n        if (node instanceof AST_Definitions && scope === self) {\n            const in_export = tw.parent() instanceof AST_Export;\n            node.definitions.forEach(function(def) {\n                if (def.name instanceof AST_SymbolVar) {\n                    map_add(var_defs_by_id, def.name.definition().id, def);\n                }\n                if (in_export || !drop_vars) {\n                    walk(def.name, node => {\n                        if (node instanceof AST_SymbolDeclaration) {\n                            const def = node.definition();\n                            if (\n                                (in_export || def.global)\n                                && !in_use_ids.has(def.id)\n                            ) {\n                                in_use_ids.set(def.id, def);\n                            }\n                        }\n                    });\n                }\n                if (def.value) {\n                    if (def.name instanceof AST_Destructuring) {\n                        def.walk(tw);\n                    } else {\n                        var node_def = def.name.definition();\n                        map_add(initializations, node_def.id, def.value);\n                        if (!node_def.chained && def.name.fixed_value() === def.value) {\n                            fixed_ids.set(node_def.id, def);\n                        }\n                    }\n                    if (def.value.has_side_effects(compressor)) {\n                        def.value.walk(tw);\n                    }\n                }\n            });\n            return true;\n        }\n        return scan_ref_scoped(node, descend);\n    });\n    self.walk(tw);\n    // pass 2: for every used symbol we need to walk its\n    // initialization code to figure out if it uses other\n    // symbols (that may not be in_use).\n    tw = new TreeWalker(scan_ref_scoped);\n    in_use_ids.forEach(function (def) {\n        var init = initializations.get(def.id);\n        if (init) init.forEach(function(init) {\n            init.walk(tw);\n        });\n    });\n    // pass 3: we should drop declarations not in_use\n    var tt = new TreeTransformer(\n        function before(node, descend, in_list) {\n            var parent = tt.parent();\n            if (drop_vars) {\n                const sym = assign_as_unused(node);\n                if (sym instanceof AST_SymbolRef) {\n                    var def = sym.definition();\n                    var in_use = in_use_ids.has(def.id);\n                    if (node instanceof AST_Assign) {\n                        if (!in_use || fixed_ids.has(def.id) && fixed_ids.get(def.id) !== node) {\n                            return maintain_this_binding(parent, node, node.right.transform(tt));\n                        }\n                    } else if (!in_use) return in_list ? MAP.skip : make_node(AST_Number, node, {\n                        value: 0\n                    });\n                }\n            }\n            if (scope !== self) return;\n            var def;\n            if (node.name\n                && (node instanceof AST_ClassExpression\n                    && !keep_name(compressor.option(\"keep_classnames\"), (def = node.name.definition()).name)\n                || node instanceof AST_Function\n                    && !keep_name(compressor.option(\"keep_fnames\"), (def = node.name.definition()).name))) {\n                // any declarations with same name will overshadow\n                // name of this anonymous function and can therefore\n                // never be used anywhere\n                if (!in_use_ids.has(def.id) || def.orig.length > 1) node.name = null;\n            }\n            if (node instanceof AST_Lambda && !(node instanceof AST_Accessor)) {\n                var trim = !compressor.option(\"keep_fargs\");\n                for (var a = node.argnames, i = a.length; --i >= 0;) {\n                    var sym = a[i];\n                    if (sym instanceof AST_Expansion) {\n                        sym = sym.expression;\n                    }\n                    if (sym instanceof AST_DefaultAssign) {\n                        sym = sym.left;\n                    }\n                    // Do not drop destructuring arguments.\n                    // They constitute a type assertion, so dropping\n                    // them would stop that TypeError which would happen\n                    // if someone called it with an incorrectly formatted\n                    // parameter.\n                    if (!(sym instanceof AST_Destructuring) && !in_use_ids.has(sym.definition().id)) {\n                        set_flag(sym, UNUSED);\n                        if (trim) {\n                            a.pop();\n                        }\n                    } else {\n                        trim = false;\n                    }\n                }\n            }\n            if ((node instanceof AST_Defun || node instanceof AST_DefClass) && node !== self) {\n                const def = node.name.definition();\n                let keep = def.global && !drop_funcs || in_use_ids.has(def.id);\n                if (!keep) {\n                    def.eliminated++;\n                    if (node instanceof AST_DefClass) {\n                        // Classes might have extends with side effects\n                        const side_effects = node.drop_side_effect_free(compressor);\n                        if (side_effects) {\n                            return make_node(AST_SimpleStatement, node, {\n                                body: side_effects\n                            });\n                        }\n                    }\n                    return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);\n                }\n            }\n            if (node instanceof AST_Definitions && !(parent instanceof AST_ForIn && parent.init === node)) {\n                var drop_block = !(parent instanceof AST_Toplevel) && !(node instanceof AST_Var);\n                // place uninitialized names at the start\n                var body = [], head = [], tail = [];\n                // for unused names whose initialization has\n                // side effects, we can cascade the init. code\n                // into the next one, or next statement.\n                var side_effects = [];\n                node.definitions.forEach(function(def) {\n                    if (def.value) def.value = def.value.transform(tt);\n                    var is_destructure = def.name instanceof AST_Destructuring;\n                    var sym = is_destructure\n                        ? new SymbolDef(null, { name: \"<destructure>\" }) /* fake SymbolDef */\n                        : def.name.definition();\n                    if (drop_block && sym.global) return tail.push(def);\n                    if (!(drop_vars || drop_block)\n                        || is_destructure\n                            && (def.name.names.length\n                                || def.name.is_array\n                                || compressor.option(\"pure_getters\") != true)\n                        || in_use_ids.has(sym.id)\n                    ) {\n                        if (def.value && fixed_ids.has(sym.id) && fixed_ids.get(sym.id) !== def) {\n                            def.value = def.value.drop_side_effect_free(compressor);\n                        }\n                        if (def.name instanceof AST_SymbolVar) {\n                            var var_defs = var_defs_by_id.get(sym.id);\n                            if (var_defs.length > 1 && (!def.value || sym.orig.indexOf(def.name) > sym.eliminated)) {\n                                if (def.value) {\n                                    var ref = make_node(AST_SymbolRef, def.name, def.name);\n                                    sym.references.push(ref);\n                                    var assign = make_node(AST_Assign, def, {\n                                        operator: \"=\",\n                                        logical: false,\n                                        left: ref,\n                                        right: def.value\n                                    });\n                                    if (fixed_ids.get(sym.id) === def) {\n                                        fixed_ids.set(sym.id, assign);\n                                    }\n                                    side_effects.push(assign.transform(tt));\n                                }\n                                remove(var_defs, def);\n                                sym.eliminated++;\n                                return;\n                            }\n                        }\n                        if (def.value) {\n                            if (side_effects.length > 0) {\n                                if (tail.length > 0) {\n                                    side_effects.push(def.value);\n                                    def.value = make_sequence(def.value, side_effects);\n                                } else {\n                                    body.push(make_node(AST_SimpleStatement, node, {\n                                        body: make_sequence(node, side_effects)\n                                    }));\n                                }\n                                side_effects = [];\n                            }\n                            tail.push(def);\n                        } else {\n                            head.push(def);\n                        }\n                    } else if (sym.orig[0] instanceof AST_SymbolCatch) {\n                        var value = def.value && def.value.drop_side_effect_free(compressor);\n                        if (value) side_effects.push(value);\n                        def.value = null;\n                        head.push(def);\n                    } else {\n                        var value = def.value && def.value.drop_side_effect_free(compressor);\n                        if (value) {\n                            side_effects.push(value);\n                        }\n                        sym.eliminated++;\n                    }\n                });\n                if (head.length > 0 || tail.length > 0) {\n                    node.definitions = head.concat(tail);\n                    body.push(node);\n                }\n                if (side_effects.length > 0) {\n                    body.push(make_node(AST_SimpleStatement, node, {\n                        body: make_sequence(node, side_effects)\n                    }));\n                }\n                switch (body.length) {\n                  case 0:\n                    return in_list ? MAP.skip : make_node(AST_EmptyStatement, node);\n                  case 1:\n                    return body[0];\n                  default:\n                    return in_list ? MAP.splice(body) : make_node(AST_BlockStatement, node, {\n                        body: body\n                    });\n                }\n            }\n            // certain combination of unused name + side effect leads to:\n            //    https://github.com/mishoo/UglifyJS2/issues/44\n            //    https://github.com/mishoo/UglifyJS2/issues/1830\n            //    https://github.com/mishoo/UglifyJS2/issues/1838\n            // that's an invalid AST.\n            // We fix it at this stage by moving the `var` outside the `for`.\n            if (node instanceof AST_For) {\n                descend(node, this);\n                var block;\n                if (node.init instanceof AST_BlockStatement) {\n                    block = node.init;\n                    node.init = block.body.pop();\n                    block.body.push(node);\n                }\n                if (node.init instanceof AST_SimpleStatement) {\n                    node.init = node.init.body;\n                } else if (is_empty(node.init)) {\n                    node.init = null;\n                }\n                return !block ? node : in_list ? MAP.splice(block.body) : block;\n            }\n            if (node instanceof AST_LabeledStatement\n                && node.body instanceof AST_For\n            ) {\n                descend(node, this);\n                if (node.body instanceof AST_BlockStatement) {\n                    var block = node.body;\n                    node.body = block.body.pop();\n                    block.body.push(node);\n                    return in_list ? MAP.splice(block.body) : block;\n                }\n                return node;\n            }\n            if (node instanceof AST_BlockStatement) {\n                descend(node, this);\n                if (in_list && node.body.every(can_be_evicted_from_block)) {\n                    return MAP.splice(node.body);\n                }\n                return node;\n            }\n            if (node instanceof AST_Scope) {\n                const save_scope = scope;\n                scope = node;\n                descend(node, this);\n                scope = save_scope;\n                return node;\n            }\n        }\n    );\n\n    self.transform(tt);\n\n    function scan_ref_scoped(node, descend) {\n        var node_def;\n        const sym = assign_as_unused(node);\n        if (sym instanceof AST_SymbolRef\n            && !is_ref_of(node.left, AST_SymbolBlockDeclaration)\n            && self.variables.get(sym.name) === (node_def = sym.definition())\n        ) {\n            if (node instanceof AST_Assign) {\n                node.right.walk(tw);\n                if (!node_def.chained && node.left.fixed_value() === node.right) {\n                    fixed_ids.set(node_def.id, node);\n                }\n            }\n            return true;\n        }\n        if (node instanceof AST_SymbolRef) {\n            node_def = node.definition();\n            if (!in_use_ids.has(node_def.id)) {\n                in_use_ids.set(node_def.id, node_def);\n                if (node_def.orig[0] instanceof AST_SymbolCatch) {\n                    const redef = node_def.scope.is_block_scope()\n                        && node_def.scope.get_defun_scope().variables.get(node_def.name);\n                    if (redef) in_use_ids.set(redef.id, redef);\n                }\n            }\n            return true;\n        }\n        if (node instanceof AST_Scope) {\n            var save_scope = scope;\n            scope = node;\n            descend();\n            scope = save_scope;\n            return true;\n        }\n    }\n});\n\nAST_Scope.DEFMETHOD(\"hoist_declarations\", function(compressor) {\n    var self = this;\n    if (compressor.has_directive(\"use asm\")) return self;\n    // Hoisting makes no sense in an arrow func\n    if (!Array.isArray(self.body)) return self;\n\n    var hoist_funs = compressor.option(\"hoist_funs\");\n    var hoist_vars = compressor.option(\"hoist_vars\");\n\n    if (hoist_funs || hoist_vars) {\n        var dirs = [];\n        var hoisted = [];\n        var vars = new Map(), vars_found = 0, var_decl = 0;\n        // let's count var_decl first, we seem to waste a lot of\n        // space if we hoist `var` when there's only one.\n        walk(self, node => {\n            if (node instanceof AST_Scope && node !== self)\n                return true;\n            if (node instanceof AST_Var) {\n                ++var_decl;\n                return true;\n            }\n        });\n        hoist_vars = hoist_vars && var_decl > 1;\n        var tt = new TreeTransformer(\n            function before(node) {\n                if (node !== self) {\n                    if (node instanceof AST_Directive) {\n                        dirs.push(node);\n                        return make_node(AST_EmptyStatement, node);\n                    }\n                    if (hoist_funs && node instanceof AST_Defun\n                        && !(tt.parent() instanceof AST_Export)\n                        && tt.parent() === self) {\n                        hoisted.push(node);\n                        return make_node(AST_EmptyStatement, node);\n                    }\n                    if (\n                        hoist_vars\n                        && node instanceof AST_Var\n                        && !node.definitions.some(def => def.name instanceof AST_Destructuring)\n                    ) {\n                        node.definitions.forEach(function(def) {\n                            vars.set(def.name.name, def);\n                            ++vars_found;\n                        });\n                        var seq = node.to_assignments(compressor);\n                        var p = tt.parent();\n                        if (p instanceof AST_ForIn && p.init === node) {\n                            if (seq == null) {\n                                var def = node.definitions[0].name;\n                                return make_node(AST_SymbolRef, def, def);\n                            }\n                            return seq;\n                        }\n                        if (p instanceof AST_For && p.init === node) {\n                            return seq;\n                        }\n                        if (!seq) return make_node(AST_EmptyStatement, node);\n                        return make_node(AST_SimpleStatement, node, {\n                            body: seq\n                        });\n                    }\n                    if (node instanceof AST_Scope)\n                        return node; // to avoid descending in nested scopes\n                }\n            }\n        );\n        self = self.transform(tt);\n        if (vars_found > 0) {\n            // collect only vars which don't show up in self's arguments list\n            var defs = [];\n            const is_lambda = self instanceof AST_Lambda;\n            const args_as_names = is_lambda ? self.args_as_names() : null;\n            vars.forEach((def, name) => {\n                if (is_lambda && args_as_names.some((x) => x.name === def.name.name)) {\n                    vars.delete(name);\n                } else {\n                    def = def.clone();\n                    def.value = null;\n                    defs.push(def);\n                    vars.set(name, def);\n                }\n            });\n            if (defs.length > 0) {\n                // try to merge in assignments\n                for (var i = 0; i < self.body.length;) {\n                    if (self.body[i] instanceof AST_SimpleStatement) {\n                        var expr = self.body[i].body, sym, assign;\n                        if (expr instanceof AST_Assign\n                            && expr.operator == \"=\"\n                            && (sym = expr.left) instanceof AST_Symbol\n                            && vars.has(sym.name)\n                        ) {\n                            var def = vars.get(sym.name);\n                            if (def.value) break;\n                            def.value = expr.right;\n                            remove(defs, def);\n                            defs.push(def);\n                            self.body.splice(i, 1);\n                            continue;\n                        }\n                        if (expr instanceof AST_Sequence\n                            && (assign = expr.expressions[0]) instanceof AST_Assign\n                            && assign.operator == \"=\"\n                            && (sym = assign.left) instanceof AST_Symbol\n                            && vars.has(sym.name)\n                        ) {\n                            var def = vars.get(sym.name);\n                            if (def.value) break;\n                            def.value = assign.right;\n                            remove(defs, def);\n                            defs.push(def);\n                            self.body[i].body = make_sequence(expr, expr.expressions.slice(1));\n                            continue;\n                        }\n                    }\n                    if (self.body[i] instanceof AST_EmptyStatement) {\n                        self.body.splice(i, 1);\n                        continue;\n                    }\n                    if (self.body[i] instanceof AST_BlockStatement) {\n                        self.body.splice(i, 1, ...self.body[i].body);\n                        continue;\n                    }\n                    break;\n                }\n                defs = make_node(AST_Var, self, {\n                    definitions: defs\n                });\n                hoisted.push(defs);\n            }\n        }\n        self.body = dirs.concat(hoisted, self.body);\n    }\n    return self;\n});\n\nAST_Scope.DEFMETHOD(\"hoist_properties\", function(compressor) {\n    var self = this;\n    if (!compressor.option(\"hoist_props\") || compressor.has_directive(\"use asm\")) return self;\n    var top_retain = self instanceof AST_Toplevel && compressor.top_retain || return_false;\n    var defs_by_id = new Map();\n    var hoister = new TreeTransformer(function(node, descend) {\n        if (node instanceof AST_Definitions\n            && hoister.parent() instanceof AST_Export) return node;\n        if (node instanceof AST_VarDef) {\n            const sym = node.name;\n            let def;\n            let value;\n            if (sym.scope === self\n                && (def = sym.definition()).escaped != 1\n                && !def.assignments\n                && !def.direct_access\n                && !def.single_use\n                && !compressor.exposed(def)\n                && !top_retain(def)\n                && (value = sym.fixed_value()) === node.value\n                && value instanceof AST_Object\n                && !value.properties.some(prop =>\n                    prop instanceof AST_Expansion || prop.computed_key()\n                )\n            ) {\n                descend(node, this);\n                const defs = new Map();\n                const assignments = [];\n                value.properties.forEach(({ key, value }) => {\n                    const scope = find_scope(hoister);\n                    const symbol = self.create_symbol(sym.CTOR, {\n                        source: sym,\n                        scope,\n                        conflict_scopes: new Set([\n                            scope,\n                            ...sym.definition().references.map(ref => ref.scope)\n                        ]),\n                        tentative_name: sym.name + \"_\" + key\n                    });\n\n                    defs.set(String(key), symbol.definition());\n\n                    assignments.push(make_node(AST_VarDef, node, {\n                        name: symbol,\n                        value\n                    }));\n                });\n                defs_by_id.set(def.id, defs);\n                return MAP.splice(assignments);\n            }\n        } else if (node instanceof AST_PropAccess\n            && node.expression instanceof AST_SymbolRef\n        ) {\n            const defs = defs_by_id.get(node.expression.definition().id);\n            if (defs) {\n                const def = defs.get(String(get_value(node.property)));\n                const sym = make_node(AST_SymbolRef, node, {\n                    name: def.name,\n                    scope: node.expression.scope,\n                    thedef: def\n                });\n                sym.reference({});\n                return sym;\n            }\n        }\n    });\n    return self.transform(hoister);\n});\n\n// drop_side_effect_free()\n// remove side-effect-free parts which only affects return value\n(function(def_drop_side_effect_free) {\n    // Drop side-effect-free elements from an array of expressions.\n    // Returns an array of expressions with side-effects or null\n    // if all elements were dropped. Note: original array may be\n    // returned if nothing changed.\n    function trim(nodes, compressor, first_in_statement) {\n        var len = nodes.length;\n        if (!len) return null;\n        var ret = [], changed = false;\n        for (var i = 0; i < len; i++) {\n            var node = nodes[i].drop_side_effect_free(compressor, first_in_statement);\n            changed |= node !== nodes[i];\n            if (node) {\n                ret.push(node);\n                first_in_statement = false;\n            }\n        }\n        return changed ? ret.length ? ret : null : nodes;\n    }\n\n    def_drop_side_effect_free(AST_Node, return_this);\n    def_drop_side_effect_free(AST_Constant, return_null);\n    def_drop_side_effect_free(AST_This, return_null);\n    def_drop_side_effect_free(AST_Call, function(compressor, first_in_statement) {\n        if (this.optional && is_nullish(this.expression, compressor)) {\n            return make_node(AST_Undefined, this);\n        }\n\n        if (!this.is_callee_pure(compressor)) {\n            if (this.expression.is_call_pure(compressor)) {\n                var exprs = this.args.slice();\n                exprs.unshift(this.expression.expression);\n                exprs = trim(exprs, compressor, first_in_statement);\n                return exprs && make_sequence(this, exprs);\n            }\n            if (is_func_expr(this.expression)\n                && (!this.expression.name || !this.expression.name.definition().references.length)) {\n                var node = this.clone();\n                node.expression.process_expression(false, compressor);\n                return node;\n            }\n            return this;\n        }\n        var args = trim(this.args, compressor, first_in_statement);\n        return args && make_sequence(this, args);\n    });\n    def_drop_side_effect_free(AST_Accessor, return_null);\n    def_drop_side_effect_free(AST_Function, return_null);\n    def_drop_side_effect_free(AST_Arrow, return_null);\n    def_drop_side_effect_free(AST_Class, function (compressor) {\n        const with_effects = [];\n        const trimmed_extends = this.extends && this.extends.drop_side_effect_free(compressor);\n        if (trimmed_extends) with_effects.push(trimmed_extends);\n        for (const prop of this.properties) {\n            const trimmed_prop = prop.drop_side_effect_free(compressor);\n            if (trimmed_prop) with_effects.push(trimmed_prop);\n        }\n        if (!with_effects.length) return null;\n        return make_sequence(this, with_effects);\n    });\n    def_drop_side_effect_free(AST_Binary, function(compressor, first_in_statement) {\n        var right = this.right.drop_side_effect_free(compressor);\n        if (!right) return this.left.drop_side_effect_free(compressor, first_in_statement);\n        if (lazy_op.has(this.operator)) {\n            if (right === this.right) return this;\n            var node = this.clone();\n            node.right = right;\n            return node;\n        } else {\n            var left = this.left.drop_side_effect_free(compressor, first_in_statement);\n            if (!left) return this.right.drop_side_effect_free(compressor, first_in_statement);\n            return make_sequence(this, [ left, right ]);\n        }\n    });\n    def_drop_side_effect_free(AST_Assign, function(compressor) {\n        if (this.logical) return this;\n\n        var left = this.left;\n        if (left.has_side_effects(compressor)\n            || compressor.has_directive(\"use strict\")\n                && left instanceof AST_PropAccess\n                && left.expression.is_constant()) {\n            return this;\n        }\n        set_flag(this, WRITE_ONLY);\n        while (left instanceof AST_PropAccess) {\n            left = left.expression;\n        }\n        if (left.is_constant_expression(compressor.find_parent(AST_Scope))) {\n            return this.right.drop_side_effect_free(compressor);\n        }\n        return this;\n    });\n    def_drop_side_effect_free(AST_Conditional, function(compressor) {\n        var consequent = this.consequent.drop_side_effect_free(compressor);\n        var alternative = this.alternative.drop_side_effect_free(compressor);\n        if (consequent === this.consequent && alternative === this.alternative) return this;\n        if (!consequent) return alternative ? make_node(AST_Binary, this, {\n            operator: \"||\",\n            left: this.condition,\n            right: alternative\n        }) : this.condition.drop_side_effect_free(compressor);\n        if (!alternative) return make_node(AST_Binary, this, {\n            operator: \"&&\",\n            left: this.condition,\n            right: consequent\n        });\n        var node = this.clone();\n        node.consequent = consequent;\n        node.alternative = alternative;\n        return node;\n    });\n    def_drop_side_effect_free(AST_Unary, function(compressor, first_in_statement) {\n        if (unary_side_effects.has(this.operator)) {\n            if (!this.expression.has_side_effects(compressor)) {\n                set_flag(this, WRITE_ONLY);\n            } else {\n                clear_flag(this, WRITE_ONLY);\n            }\n            return this;\n        }\n        if (this.operator == \"typeof\" && this.expression instanceof AST_SymbolRef) return null;\n        var expression = this.expression.drop_side_effect_free(compressor, first_in_statement);\n        if (first_in_statement && expression && is_iife_call(expression)) {\n            if (expression === this.expression && this.operator == \"!\") return this;\n            return expression.negate(compressor, first_in_statement);\n        }\n        return expression;\n    });\n    def_drop_side_effect_free(AST_SymbolRef, function(compressor) {\n        const safe_access = this.is_declared(compressor)\n            || pure_prop_access_globals.has(this.name);\n        return safe_access ? null : this;\n    });\n    def_drop_side_effect_free(AST_Object, function(compressor, first_in_statement) {\n        var values = trim(this.properties, compressor, first_in_statement);\n        return values && make_sequence(this, values);\n    });\n    def_drop_side_effect_free(AST_ObjectProperty, function(compressor, first_in_statement) {\n        const computed_key = this instanceof AST_ObjectKeyVal && this.key instanceof AST_Node;\n        const key = computed_key && this.key.drop_side_effect_free(compressor, first_in_statement);\n        const value = this.value && this.value.drop_side_effect_free(compressor, first_in_statement);\n        if (key && value) {\n            return make_sequence(this, [key, value]);\n        }\n        return key || value;\n    });\n    def_drop_side_effect_free(AST_ClassProperty, function (compressor) {\n        const key = this.computed_key() && this.key.drop_side_effect_free(compressor);\n\n        const value = this.static && this.value\n            && this.value.drop_side_effect_free(compressor);\n\n        if (key && value) return make_sequence(this, [key, value]);\n        return key || value || null;\n    });\n    def_drop_side_effect_free(AST_ConciseMethod, function () {\n        return this.computed_key() ? this.key : null;\n    });\n    def_drop_side_effect_free(AST_ObjectGetter, function () {\n        return this.computed_key() ? this.key : null;\n    });\n    def_drop_side_effect_free(AST_ObjectSetter, function () {\n        return this.computed_key() ? this.key : null;\n    });\n    def_drop_side_effect_free(AST_Array, function(compressor, first_in_statement) {\n        var values = trim(this.elements, compressor, first_in_statement);\n        return values && make_sequence(this, values);\n    });\n    def_drop_side_effect_free(AST_Dot, function(compressor, first_in_statement) {\n        if (this.optional) {\n            return is_nullish(this.expression, compressor) ? make_node(AST_Undefined, this) : this;\n        }\n        if (this.expression.may_throw_on_access(compressor)) return this;\n\n        return this.expression.drop_side_effect_free(compressor, first_in_statement);\n    });\n    def_drop_side_effect_free(AST_Sub, function(compressor, first_in_statement) {\n        if (this.optional) {\n            return is_nullish(this.expression, compressor) ? make_node(AST_Undefined, this): this;\n        }\n        if (this.expression.may_throw_on_access(compressor)) return this;\n\n        var expression = this.expression.drop_side_effect_free(compressor, first_in_statement);\n        if (!expression) return this.property.drop_side_effect_free(compressor, first_in_statement);\n        var property = this.property.drop_side_effect_free(compressor);\n        if (!property) return expression;\n        return make_sequence(this, [ expression, property ]);\n    });\n    def_drop_side_effect_free(AST_Chain, function (compressor, first_in_statement) {\n        return this.expression.drop_side_effect_free(compressor, first_in_statement);\n    });\n    def_drop_side_effect_free(AST_Sequence, function(compressor) {\n        var last = this.tail_node();\n        var expr = last.drop_side_effect_free(compressor);\n        if (expr === last) return this;\n        var expressions = this.expressions.slice(0, -1);\n        if (expr) expressions.push(expr);\n        if (!expressions.length) {\n            return make_node(AST_Number, this, { value: 0 });\n        }\n        return make_sequence(this, expressions);\n    });\n    def_drop_side_effect_free(AST_Expansion, function(compressor, first_in_statement) {\n        return this.expression.drop_side_effect_free(compressor, first_in_statement);\n    });\n    def_drop_side_effect_free(AST_TemplateSegment, return_null);\n    def_drop_side_effect_free(AST_TemplateString, function(compressor) {\n        var values = trim(this.segments, compressor, first_in_statement);\n        return values && make_sequence(this, values);\n    });\n})(function(node, func) {\n    node.DEFMETHOD(\"drop_side_effect_free\", func);\n});\n\ndef_optimize(AST_SimpleStatement, function(self, compressor) {\n    if (compressor.option(\"side_effects\")) {\n        var body = self.body;\n        var node = body.drop_side_effect_free(compressor, true);\n        if (!node) {\n            return make_node(AST_EmptyStatement, self);\n        }\n        if (node !== body) {\n            return make_node(AST_SimpleStatement, self, { body: node });\n        }\n    }\n    return self;\n});\n\ndef_optimize(AST_While, function(self, compressor) {\n    return compressor.option(\"loops\") ? make_node(AST_For, self, self).optimize(compressor) : self;\n});\n\nfunction has_break_or_continue(loop, parent) {\n    var found = false;\n    var tw = new TreeWalker(function(node) {\n        if (found || node instanceof AST_Scope) return true;\n        if (node instanceof AST_LoopControl && tw.loopcontrol_target(node) === loop) {\n            return found = true;\n        }\n    });\n    if (parent instanceof AST_LabeledStatement) tw.push(parent);\n    tw.push(loop);\n    loop.body.walk(tw);\n    return found;\n}\n\ndef_optimize(AST_Do, function(self, compressor) {\n    if (!compressor.option(\"loops\")) return self;\n    var cond = self.condition.tail_node().evaluate(compressor);\n    if (!(cond instanceof AST_Node)) {\n        if (cond) return make_node(AST_For, self, {\n            body: make_node(AST_BlockStatement, self.body, {\n                body: [\n                    self.body,\n                    make_node(AST_SimpleStatement, self.condition, {\n                        body: self.condition\n                    })\n                ]\n            })\n        }).optimize(compressor);\n        if (!has_break_or_continue(self, compressor.parent())) {\n            return make_node(AST_BlockStatement, self.body, {\n                body: [\n                    self.body,\n                    make_node(AST_SimpleStatement, self.condition, {\n                        body: self.condition\n                    })\n                ]\n            }).optimize(compressor);\n        }\n    }\n    return self;\n});\n\nfunction if_break_in_loop(self, compressor) {\n    var first = self.body instanceof AST_BlockStatement ? self.body.body[0] : self.body;\n    if (compressor.option(\"dead_code\") && is_break(first)) {\n        var body = [];\n        if (self.init instanceof AST_Statement) {\n            body.push(self.init);\n        } else if (self.init) {\n            body.push(make_node(AST_SimpleStatement, self.init, {\n                body: self.init\n            }));\n        }\n        if (self.condition) {\n            body.push(make_node(AST_SimpleStatement, self.condition, {\n                body: self.condition\n            }));\n        }\n        trim_unreachable_code(compressor, self.body, body);\n        return make_node(AST_BlockStatement, self, {\n            body: body\n        });\n    }\n    if (first instanceof AST_If) {\n        if (is_break(first.body)) {\n            if (self.condition) {\n                self.condition = make_node(AST_Binary, self.condition, {\n                    left: self.condition,\n                    operator: \"&&\",\n                    right: first.condition.negate(compressor),\n                });\n            } else {\n                self.condition = first.condition.negate(compressor);\n            }\n            drop_it(first.alternative);\n        } else if (is_break(first.alternative)) {\n            if (self.condition) {\n                self.condition = make_node(AST_Binary, self.condition, {\n                    left: self.condition,\n                    operator: \"&&\",\n                    right: first.condition,\n                });\n            } else {\n                self.condition = first.condition;\n            }\n            drop_it(first.body);\n        }\n    }\n    return self;\n\n    function is_break(node) {\n        return node instanceof AST_Break\n            && compressor.loopcontrol_target(node) === compressor.self();\n    }\n\n    function drop_it(rest) {\n        rest = as_statement_array(rest);\n        if (self.body instanceof AST_BlockStatement) {\n            self.body = self.body.clone();\n            self.body.body = rest.concat(self.body.body.slice(1));\n            self.body = self.body.transform(compressor);\n        } else {\n            self.body = make_node(AST_BlockStatement, self.body, {\n                body: rest\n            }).transform(compressor);\n        }\n        self = if_break_in_loop(self, compressor);\n    }\n}\n\ndef_optimize(AST_For, function(self, compressor) {\n    if (!compressor.option(\"loops\")) return self;\n    if (compressor.option(\"side_effects\") && self.init) {\n        self.init = self.init.drop_side_effect_free(compressor);\n    }\n    if (self.condition) {\n        var cond = self.condition.evaluate(compressor);\n        if (!(cond instanceof AST_Node)) {\n            if (cond) self.condition = null;\n            else if (!compressor.option(\"dead_code\")) {\n                var orig = self.condition;\n                self.condition = make_node_from_constant(cond, self.condition);\n                self.condition = best_of_expression(self.condition.transform(compressor), orig);\n            }\n        }\n        if (compressor.option(\"dead_code\")) {\n            if (cond instanceof AST_Node) cond = self.condition.tail_node().evaluate(compressor);\n            if (!cond) {\n                var body = [];\n                trim_unreachable_code(compressor, self.body, body);\n                if (self.init instanceof AST_Statement) {\n                    body.push(self.init);\n                } else if (self.init) {\n                    body.push(make_node(AST_SimpleStatement, self.init, {\n                        body: self.init\n                    }));\n                }\n                body.push(make_node(AST_SimpleStatement, self.condition, {\n                    body: self.condition\n                }));\n                return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n            }\n        }\n    }\n    return if_break_in_loop(self, compressor);\n});\n\ndef_optimize(AST_If, function(self, compressor) {\n    if (is_empty(self.alternative)) self.alternative = null;\n\n    if (!compressor.option(\"conditionals\")) return self;\n    // if condition can be statically determined, drop\n    // one of the blocks.  note, statically determined implies\n    // “has no side effects”; also it doesn't work for cases like\n    // `x && true`, though it probably should.\n    var cond = self.condition.evaluate(compressor);\n    if (!compressor.option(\"dead_code\") && !(cond instanceof AST_Node)) {\n        var orig = self.condition;\n        self.condition = make_node_from_constant(cond, orig);\n        self.condition = best_of_expression(self.condition.transform(compressor), orig);\n    }\n    if (compressor.option(\"dead_code\")) {\n        if (cond instanceof AST_Node) cond = self.condition.tail_node().evaluate(compressor);\n        if (!cond) {\n            var body = [];\n            trim_unreachable_code(compressor, self.body, body);\n            body.push(make_node(AST_SimpleStatement, self.condition, {\n                body: self.condition\n            }));\n            if (self.alternative) body.push(self.alternative);\n            return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n        } else if (!(cond instanceof AST_Node)) {\n            var body = [];\n            body.push(make_node(AST_SimpleStatement, self.condition, {\n                body: self.condition\n            }));\n            body.push(self.body);\n            if (self.alternative) {\n                trim_unreachable_code(compressor, self.alternative, body);\n            }\n            return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n        }\n    }\n    var negated = self.condition.negate(compressor);\n    var self_condition_length = self.condition.size();\n    var negated_length = negated.size();\n    var negated_is_best = negated_length < self_condition_length;\n    if (self.alternative && negated_is_best) {\n        negated_is_best = false; // because we already do the switch here.\n        // no need to swap values of self_condition_length and negated_length\n        // here because they are only used in an equality comparison later on.\n        self.condition = negated;\n        var tmp = self.body;\n        self.body = self.alternative || make_node(AST_EmptyStatement, self);\n        self.alternative = tmp;\n    }\n    if (is_empty(self.body) && is_empty(self.alternative)) {\n        return make_node(AST_SimpleStatement, self.condition, {\n            body: self.condition.clone()\n        }).optimize(compressor);\n    }\n    if (self.body instanceof AST_SimpleStatement\n        && self.alternative instanceof AST_SimpleStatement) {\n        return make_node(AST_SimpleStatement, self, {\n            body: make_node(AST_Conditional, self, {\n                condition   : self.condition,\n                consequent  : self.body.body,\n                alternative : self.alternative.body\n            })\n        }).optimize(compressor);\n    }\n    if (is_empty(self.alternative) && self.body instanceof AST_SimpleStatement) {\n        if (self_condition_length === negated_length && !negated_is_best\n            && self.condition instanceof AST_Binary && self.condition.operator == \"||\") {\n            // although the code length of self.condition and negated are the same,\n            // negated does not require additional surrounding parentheses.\n            // see https://github.com/mishoo/UglifyJS2/issues/979\n            negated_is_best = true;\n        }\n        if (negated_is_best) return make_node(AST_SimpleStatement, self, {\n            body: make_node(AST_Binary, self, {\n                operator : \"||\",\n                left     : negated,\n                right    : self.body.body\n            })\n        }).optimize(compressor);\n        return make_node(AST_SimpleStatement, self, {\n            body: make_node(AST_Binary, self, {\n                operator : \"&&\",\n                left     : self.condition,\n                right    : self.body.body\n            })\n        }).optimize(compressor);\n    }\n    if (self.body instanceof AST_EmptyStatement\n        && self.alternative instanceof AST_SimpleStatement) {\n        return make_node(AST_SimpleStatement, self, {\n            body: make_node(AST_Binary, self, {\n                operator : \"||\",\n                left     : self.condition,\n                right    : self.alternative.body\n            })\n        }).optimize(compressor);\n    }\n    if (self.body instanceof AST_Exit\n        && self.alternative instanceof AST_Exit\n        && self.body.TYPE == self.alternative.TYPE) {\n        return make_node(self.body.CTOR, self, {\n            value: make_node(AST_Conditional, self, {\n                condition   : self.condition,\n                consequent  : self.body.value || make_node(AST_Undefined, self.body),\n                alternative : self.alternative.value || make_node(AST_Undefined, self.alternative)\n            }).transform(compressor)\n        }).optimize(compressor);\n    }\n    if (self.body instanceof AST_If\n        && !self.body.alternative\n        && !self.alternative) {\n        self = make_node(AST_If, self, {\n            condition: make_node(AST_Binary, self.condition, {\n                operator: \"&&\",\n                left: self.condition,\n                right: self.body.condition\n            }),\n            body: self.body.body,\n            alternative: null\n        });\n    }\n    if (aborts(self.body)) {\n        if (self.alternative) {\n            var alt = self.alternative;\n            self.alternative = null;\n            return make_node(AST_BlockStatement, self, {\n                body: [ self, alt ]\n            }).optimize(compressor);\n        }\n    }\n    if (aborts(self.alternative)) {\n        var body = self.body;\n        self.body = self.alternative;\n        self.condition = negated_is_best ? negated : self.condition.negate(compressor);\n        self.alternative = null;\n        return make_node(AST_BlockStatement, self, {\n            body: [ self, body ]\n        }).optimize(compressor);\n    }\n    return self;\n});\n\ndef_optimize(AST_Switch, function(self, compressor) {\n    if (!compressor.option(\"switches\")) return self;\n    var branch;\n    var value = self.expression.evaluate(compressor);\n    if (!(value instanceof AST_Node)) {\n        var orig = self.expression;\n        self.expression = make_node_from_constant(value, orig);\n        self.expression = best_of_expression(self.expression.transform(compressor), orig);\n    }\n    if (!compressor.option(\"dead_code\")) return self;\n    if (value instanceof AST_Node) {\n        value = self.expression.tail_node().evaluate(compressor);\n    }\n    var decl = [];\n    var body = [];\n    var default_branch;\n    var exact_match;\n    for (var i = 0, len = self.body.length; i < len && !exact_match; i++) {\n        branch = self.body[i];\n        if (branch instanceof AST_Default) {\n            if (!default_branch) {\n                default_branch = branch;\n            } else {\n                eliminate_branch(branch, body[body.length - 1]);\n            }\n        } else if (!(value instanceof AST_Node)) {\n            var exp = branch.expression.evaluate(compressor);\n            if (!(exp instanceof AST_Node) && exp !== value) {\n                eliminate_branch(branch, body[body.length - 1]);\n                continue;\n            }\n            if (exp instanceof AST_Node) exp = branch.expression.tail_node().evaluate(compressor);\n            if (exp === value) {\n                exact_match = branch;\n                if (default_branch) {\n                    var default_index = body.indexOf(default_branch);\n                    body.splice(default_index, 1);\n                    eliminate_branch(default_branch, body[default_index - 1]);\n                    default_branch = null;\n                }\n            }\n        }\n        if (aborts(branch)) {\n            var prev = body[body.length - 1];\n            if (aborts(prev) && prev.body.length == branch.body.length\n                && make_node(AST_BlockStatement, prev, prev).equivalent_to(make_node(AST_BlockStatement, branch, branch))) {\n                prev.body = [];\n            }\n        }\n        body.push(branch);\n    }\n    while (i < len) eliminate_branch(self.body[i++], body[body.length - 1]);\n    if (body.length > 0) {\n        body[0].body = decl.concat(body[0].body);\n    }\n    self.body = body;\n    while (branch = body[body.length - 1]) {\n        var stat = branch.body[branch.body.length - 1];\n        if (stat instanceof AST_Break && compressor.loopcontrol_target(stat) === self)\n            branch.body.pop();\n        if (branch.body.length || branch instanceof AST_Case\n            && (default_branch || branch.expression.has_side_effects(compressor))) break;\n        if (body.pop() === default_branch) default_branch = null;\n    }\n    if (body.length == 0) {\n        return make_node(AST_BlockStatement, self, {\n            body: decl.concat(make_node(AST_SimpleStatement, self.expression, {\n                body: self.expression\n            }))\n        }).optimize(compressor);\n    }\n    if (body.length == 1 && (body[0] === exact_match || body[0] === default_branch)) {\n        var has_break = false;\n        var tw = new TreeWalker(function(node) {\n            if (has_break\n                || node instanceof AST_Lambda\n                || node instanceof AST_SimpleStatement) return true;\n            if (node instanceof AST_Break && tw.loopcontrol_target(node) === self)\n                has_break = true;\n        });\n        self.walk(tw);\n        if (!has_break) {\n            var statements = body[0].body.slice();\n            var exp = body[0].expression;\n            if (exp) statements.unshift(make_node(AST_SimpleStatement, exp, {\n                body: exp\n            }));\n            statements.unshift(make_node(AST_SimpleStatement, self.expression, {\n                body:self.expression\n            }));\n            return make_node(AST_BlockStatement, self, {\n                body: statements\n            }).optimize(compressor);\n        }\n    }\n    return self;\n\n    function eliminate_branch(branch, prev) {\n        if (prev && !aborts(prev)) {\n            prev.body = prev.body.concat(branch.body);\n        } else {\n            trim_unreachable_code(compressor, branch, decl);\n        }\n    }\n});\n\ndef_optimize(AST_Try, function(self, compressor) {\n    tighten_body(self.body, compressor);\n    if (self.bcatch && self.bfinally && self.bfinally.body.every(is_empty)) self.bfinally = null;\n    if (compressor.option(\"dead_code\") && self.body.every(is_empty)) {\n        var body = [];\n        if (self.bcatch) {\n            trim_unreachable_code(compressor, self.bcatch, body);\n        }\n        if (self.bfinally) body.push(...self.bfinally.body);\n        return make_node(AST_BlockStatement, self, {\n            body: body\n        }).optimize(compressor);\n    }\n    return self;\n});\n\nAST_Definitions.DEFMETHOD(\"remove_initializers\", function() {\n    var decls = [];\n    this.definitions.forEach(function(def) {\n        if (def.name instanceof AST_SymbolDeclaration) {\n            def.value = null;\n            decls.push(def);\n        } else {\n            walk(def.name, node => {\n                if (node instanceof AST_SymbolDeclaration) {\n                    decls.push(make_node(AST_VarDef, def, {\n                        name: node,\n                        value: null\n                    }));\n                }\n            });\n        }\n    });\n    this.definitions = decls;\n});\n\nAST_Definitions.DEFMETHOD(\"to_assignments\", function(compressor) {\n    var reduce_vars = compressor.option(\"reduce_vars\");\n    var assignments = [];\n\n    for (const def of this.definitions) {\n        if (def.value) {\n            var name = make_node(AST_SymbolRef, def.name, def.name);\n            assignments.push(make_node(AST_Assign, def, {\n                operator : \"=\",\n                logical: false,\n                left     : name,\n                right    : def.value\n            }));\n            if (reduce_vars) name.definition().fixed = false;\n        } else if (def.value) {\n            // Because it's a destructuring, do not turn into an assignment.\n            var varDef = make_node(AST_VarDef, def, {\n                name: def.name,\n                value: def.value\n            });\n            var var_ = make_node(AST_Var, def, {\n                definitions: [ varDef ]\n            });\n            assignments.push(var_);\n        }\n        const thedef = def.name.definition();\n        thedef.eliminated++;\n        thedef.replaced--;\n    }\n\n    if (assignments.length == 0) return null;\n    return make_sequence(this, assignments);\n});\n\ndef_optimize(AST_Definitions, function(self) {\n    if (self.definitions.length == 0)\n        return make_node(AST_EmptyStatement, self);\n    return self;\n});\n\ndef_optimize(AST_VarDef, function(self, compressor) {\n    if (\n        self.name instanceof AST_SymbolLet\n        && self.value != null\n        && is_undefined(self.value, compressor)\n    ) {\n        self.value = null;\n    }\n    return self;\n});\n\ndef_optimize(AST_Import, function(self) {\n    return self;\n});\n\n// TODO this only works with AST_Defun, shouldn't it work for other ways of defining functions?\nfunction retain_top_func(fn, compressor) {\n    return compressor.top_retain\n        && fn instanceof AST_Defun\n        && has_flag(fn, TOP)\n        && fn.name\n        && compressor.top_retain(fn.name);\n}\n\ndef_optimize(AST_Call, function(self, compressor) {\n    var exp = self.expression;\n    var fn = exp;\n    inline_array_like_spread(self.args);\n    var simple_args = self.args.every((arg) =>\n        !(arg instanceof AST_Expansion)\n    );\n\n    if (compressor.option(\"reduce_vars\")\n        && fn instanceof AST_SymbolRef\n        && !has_annotation(self, _NOINLINE)\n    ) {\n        const fixed = fn.fixed_value();\n        if (!retain_top_func(fixed, compressor)) {\n            fn = fixed;\n        }\n    }\n\n    if (self.optional && is_nullish(fn, compressor)) {\n        return make_node(AST_Undefined, self);\n    }\n\n    var is_func = fn instanceof AST_Lambda;\n\n    if (is_func && fn.pinned()) return self;\n\n    if (compressor.option(\"unused\")\n        && simple_args\n        && is_func\n        && !fn.uses_arguments) {\n        var pos = 0, last = 0;\n        for (var i = 0, len = self.args.length; i < len; i++) {\n            if (fn.argnames[i] instanceof AST_Expansion) {\n                if (has_flag(fn.argnames[i].expression, UNUSED)) while (i < len) {\n                    var node = self.args[i++].drop_side_effect_free(compressor);\n                    if (node) {\n                        self.args[pos++] = node;\n                    }\n                } else while (i < len) {\n                    self.args[pos++] = self.args[i++];\n                }\n                last = pos;\n                break;\n            }\n            var trim = i >= fn.argnames.length;\n            if (trim || has_flag(fn.argnames[i], UNUSED)) {\n                var node = self.args[i].drop_side_effect_free(compressor);\n                if (node) {\n                    self.args[pos++] = node;\n                } else if (!trim) {\n                    self.args[pos++] = make_node(AST_Number, self.args[i], {\n                        value: 0\n                    });\n                    continue;\n                }\n            } else {\n                self.args[pos++] = self.args[i];\n            }\n            last = pos;\n        }\n        self.args.length = last;\n    }\n\n    if (compressor.option(\"unsafe\")) {\n        if (is_undeclared_ref(exp)) switch (exp.name) {\n          case \"Array\":\n            if (self.args.length != 1) {\n                return make_node(AST_Array, self, {\n                    elements: self.args\n                }).optimize(compressor);\n            } else if (self.args[0] instanceof AST_Number && self.args[0].value <= 11) {\n                const elements = [];\n                for (let i = 0; i < self.args[0].value; i++) elements.push(new AST_Hole);\n                return new AST_Array({ elements });\n            }\n            break;\n          case \"Object\":\n            if (self.args.length == 0) {\n                return make_node(AST_Object, self, {\n                    properties: []\n                });\n            }\n            break;\n          case \"String\":\n            if (self.args.length == 0) return make_node(AST_String, self, {\n                value: \"\"\n            });\n            if (self.args.length <= 1) return make_node(AST_Binary, self, {\n                left: self.args[0],\n                operator: \"+\",\n                right: make_node(AST_String, self, { value: \"\" })\n            }).optimize(compressor);\n            break;\n          case \"Number\":\n            if (self.args.length == 0) return make_node(AST_Number, self, {\n                value: 0\n            });\n            if (self.args.length == 1 && compressor.option(\"unsafe_math\")) {\n                return make_node(AST_UnaryPrefix, self, {\n                    expression: self.args[0],\n                    operator: \"+\"\n                }).optimize(compressor);\n            }\n            break;\n          case \"Symbol\":\n            if (self.args.length == 1 && self.args[0] instanceof AST_String && compressor.option(\"unsafe_symbols\"))\n                self.args.length = 0;\n                break;\n          case \"Boolean\":\n            if (self.args.length == 0) return make_node(AST_False, self);\n            if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {\n                expression: make_node(AST_UnaryPrefix, self, {\n                    expression: self.args[0],\n                    operator: \"!\"\n                }),\n                operator: \"!\"\n            }).optimize(compressor);\n            break;\n          case \"RegExp\":\n            var params = [];\n            if (self.args.length >= 1\n                && self.args.length <= 2\n                && self.args.every((arg) => {\n                    var value = arg.evaluate(compressor);\n                    params.push(value);\n                    return arg !== value;\n                })\n            ) {\n                let [ source, flags ] = params;\n                source = regexp_source_fix(new RegExp(source).source);\n                const rx = make_node(AST_RegExp, self, {\n                    value: { source, flags }\n                });\n                if (rx._eval(compressor) !== rx) {\n                    return rx;\n                }\n            }\n            break;\n        } else if (exp instanceof AST_Dot) switch(exp.property) {\n          case \"toString\":\n            if (self.args.length == 0 && !exp.expression.may_throw_on_access(compressor)) {\n                return make_node(AST_Binary, self, {\n                    left: make_node(AST_String, self, { value: \"\" }),\n                    operator: \"+\",\n                    right: exp.expression\n                }).optimize(compressor);\n            }\n            break;\n          case \"join\":\n            if (exp.expression instanceof AST_Array) EXIT: {\n                var separator;\n                if (self.args.length > 0) {\n                    separator = self.args[0].evaluate(compressor);\n                    if (separator === self.args[0]) break EXIT; // not a constant\n                }\n                var elements = [];\n                var consts = [];\n                for (var i = 0, len = exp.expression.elements.length; i < len; i++) {\n                    var el = exp.expression.elements[i];\n                    if (el instanceof AST_Expansion) break EXIT;\n                    var value = el.evaluate(compressor);\n                    if (value !== el) {\n                        consts.push(value);\n                    } else {\n                        if (consts.length > 0) {\n                            elements.push(make_node(AST_String, self, {\n                                value: consts.join(separator)\n                            }));\n                            consts.length = 0;\n                        }\n                        elements.push(el);\n                    }\n                }\n                if (consts.length > 0) {\n                    elements.push(make_node(AST_String, self, {\n                        value: consts.join(separator)\n                    }));\n                }\n                if (elements.length == 0) return make_node(AST_String, self, { value: \"\" });\n                if (elements.length == 1) {\n                    if (elements[0].is_string(compressor)) {\n                        return elements[0];\n                    }\n                    return make_node(AST_Binary, elements[0], {\n                        operator : \"+\",\n                        left     : make_node(AST_String, self, { value: \"\" }),\n                        right    : elements[0]\n                    });\n                }\n                if (separator == \"\") {\n                    var first;\n                    if (elements[0].is_string(compressor)\n                        || elements[1].is_string(compressor)) {\n                        first = elements.shift();\n                    } else {\n                        first = make_node(AST_String, self, { value: \"\" });\n                    }\n                    return elements.reduce(function(prev, el) {\n                        return make_node(AST_Binary, el, {\n                            operator : \"+\",\n                            left     : prev,\n                            right    : el\n                        });\n                    }, first).optimize(compressor);\n                }\n                // need this awkward cloning to not affect original element\n                // best_of will decide which one to get through.\n                var node = self.clone();\n                node.expression = node.expression.clone();\n                node.expression.expression = node.expression.expression.clone();\n                node.expression.expression.elements = elements;\n                return best_of(compressor, self, node);\n            }\n            break;\n          case \"charAt\":\n            if (exp.expression.is_string(compressor)) {\n                var arg = self.args[0];\n                var index = arg ? arg.evaluate(compressor) : 0;\n                if (index !== arg) {\n                    return make_node(AST_Sub, exp, {\n                        expression: exp.expression,\n                        property: make_node_from_constant(index | 0, arg || exp)\n                    }).optimize(compressor);\n                }\n            }\n            break;\n          case \"apply\":\n            if (self.args.length == 2 && self.args[1] instanceof AST_Array) {\n                var args = self.args[1].elements.slice();\n                args.unshift(self.args[0]);\n                return make_node(AST_Call, self, {\n                    expression: make_node(AST_Dot, exp, {\n                        expression: exp.expression,\n                        optional: false,\n                        property: \"call\"\n                    }),\n                    args: args\n                }).optimize(compressor);\n            }\n            break;\n          case \"call\":\n            var func = exp.expression;\n            if (func instanceof AST_SymbolRef) {\n                func = func.fixed_value();\n            }\n            if (func instanceof AST_Lambda && !func.contains_this()) {\n                return (self.args.length ? make_sequence(this, [\n                    self.args[0],\n                    make_node(AST_Call, self, {\n                        expression: exp.expression,\n                        args: self.args.slice(1)\n                    })\n                ]) : make_node(AST_Call, self, {\n                    expression: exp.expression,\n                    args: []\n                })).optimize(compressor);\n            }\n            break;\n        }\n    }\n\n    if (compressor.option(\"unsafe_Function\")\n        && is_undeclared_ref(exp)\n        && exp.name == \"Function\") {\n        // new Function() => function(){}\n        if (self.args.length == 0) return make_node(AST_Function, self, {\n            argnames: [],\n            body: []\n        }).optimize(compressor);\n        if (self.args.every((x) => x instanceof AST_String)) {\n            // quite a corner-case, but we can handle it:\n            //   https://github.com/mishoo/UglifyJS2/issues/203\n            // if the code argument is a constant, then we can minify it.\n            try {\n                var code = \"n(function(\" + self.args.slice(0, -1).map(function(arg) {\n                    return arg.value;\n                }).join(\",\") + \"){\" + self.args[self.args.length - 1].value + \"})\";\n                var ast = parse(code);\n                var mangle = { ie8: compressor.option(\"ie8\") };\n                ast.figure_out_scope(mangle);\n                var comp = new Compressor(compressor.options, {\n                    mangle_options: compressor.mangle_options\n                });\n                ast = ast.transform(comp);\n                ast.figure_out_scope(mangle);\n                base54.reset();\n                ast.compute_char_frequency(mangle);\n                ast.mangle_names(mangle);\n                var fun;\n                walk(ast, node => {\n                    if (is_func_expr(node)) {\n                        fun = node;\n                        return walk_abort;\n                    }\n                });\n                var code = OutputStream();\n                AST_BlockStatement.prototype._codegen.call(fun, fun, code);\n                self.args = [\n                    make_node(AST_String, self, {\n                        value: fun.argnames.map(function(arg) {\n                            return arg.print_to_string();\n                        }).join(\",\")\n                    }),\n                    make_node(AST_String, self.args[self.args.length - 1], {\n                        value: code.get().replace(/^{|}$/g, \"\")\n                    })\n                ];\n                return self;\n            } catch (ex) {\n                if (!(ex instanceof JS_Parse_Error)) {\n                    throw ex;\n                }\n\n                // Otherwise, it crashes at runtime. Or maybe it's nonstandard syntax.\n            }\n        }\n    }\n\n    var stat = is_func && fn.body[0];\n    var is_regular_func = is_func && !fn.is_generator && !fn.async;\n    var can_inline = is_regular_func && compressor.option(\"inline\") && !self.is_callee_pure(compressor);\n    if (can_inline && stat instanceof AST_Return) {\n        let returned = stat.value;\n        if (!returned || returned.is_constant_expression()) {\n            if (returned) {\n                returned = returned.clone(true);\n            } else {\n                returned = make_node(AST_Undefined, self);\n            }\n            const args = self.args.concat(returned);\n            return make_sequence(self, args).optimize(compressor);\n        }\n\n        // optimize identity function\n        if (\n            fn.argnames.length === 1\n            && (fn.argnames[0] instanceof AST_SymbolFunarg)\n            && self.args.length < 2\n            && returned instanceof AST_SymbolRef\n            && returned.name === fn.argnames[0].name\n        ) {\n            const replacement =\n                (self.args[0] || make_node(AST_Undefined)).optimize(compressor);\n\n            let parent;\n            if (\n                replacement instanceof AST_PropAccess\n                && (parent = compressor.parent()) instanceof AST_Call\n                && parent.expression === self\n            ) {\n                // identity function was being used to remove `this`, like in\n                //\n                // id(bag.no_this)(...)\n                //\n                // Replace with a larger but more effish (0, bag.no_this) wrapper.\n\n                return make_sequence(self, [\n                    make_node(AST_Number, self, { value: 0 }),\n                    replacement\n                ]);\n            }\n            // replace call with first argument or undefined if none passed\n            return replacement;\n        }\n    }\n\n    if (can_inline) {\n        var scope, in_loop, level = -1;\n        let def;\n        let returned_value;\n        let nearest_scope;\n        if (simple_args\n            && !fn.uses_arguments\n            && !(compressor.parent() instanceof AST_Class)\n            && !(fn.name && fn instanceof AST_Function)\n            && (returned_value = can_flatten_body(stat))\n            && (exp === fn\n                || has_annotation(self, _INLINE)\n                || compressor.option(\"unused\")\n                    && (def = exp.definition()).references.length == 1\n                    && !recursive_ref(compressor, def)\n                    && fn.is_constant_expression(exp.scope))\n            && !has_annotation(self, _PURE | _NOINLINE)\n            && !fn.contains_this()\n            && can_inject_symbols()\n            && (nearest_scope = find_scope(compressor))\n            && !scope_encloses_variables_in_this_scope(nearest_scope, fn)\n            && !(function in_default_assign() {\n                    // Due to the fact function parameters have their own scope\n                    // which can't use `var something` in the function body within,\n                    // we simply don't inline into DefaultAssign.\n                    let i = 0;\n                    let p;\n                    while ((p = compressor.parent(i++))) {\n                        if (p instanceof AST_DefaultAssign) return true;\n                        if (p instanceof AST_Block) break;\n                    }\n                    return false;\n                })()\n            && !(scope instanceof AST_Class)\n        ) {\n            set_flag(fn, SQUEEZED);\n            nearest_scope.add_child_scope(fn);\n            return make_sequence(self, flatten_fn(returned_value)).optimize(compressor);\n        }\n    }\n\n    if (can_inline && has_annotation(self, _INLINE)) {\n        set_flag(fn, SQUEEZED);\n        fn = make_node(fn.CTOR === AST_Defun ? AST_Function : fn.CTOR, fn, fn);\n        fn.figure_out_scope({}, {\n            parent_scope: find_scope(compressor),\n            toplevel: compressor.get_toplevel()\n        });\n\n        return make_node(AST_Call, self, {\n            expression: fn,\n            args: self.args,\n        }).optimize(compressor);\n    }\n\n    const can_drop_this_call = is_regular_func && compressor.option(\"side_effects\") && fn.body.every(is_empty);\n    if (can_drop_this_call) {\n        var args = self.args.concat(make_node(AST_Undefined, self));\n        return make_sequence(self, args).optimize(compressor);\n    }\n\n    if (compressor.option(\"negate_iife\")\n        && compressor.parent() instanceof AST_SimpleStatement\n        && is_iife_call(self)) {\n        return self.negate(compressor, true);\n    }\n\n    var ev = self.evaluate(compressor);\n    if (ev !== self) {\n        ev = make_node_from_constant(ev, self).optimize(compressor);\n        return best_of(compressor, ev, self);\n    }\n\n    return self;\n\n    function return_value(stat) {\n        if (!stat) return make_node(AST_Undefined, self);\n        if (stat instanceof AST_Return) {\n            if (!stat.value) return make_node(AST_Undefined, self);\n            return stat.value.clone(true);\n        }\n        if (stat instanceof AST_SimpleStatement) {\n            return make_node(AST_UnaryPrefix, stat, {\n                operator: \"void\",\n                expression: stat.body.clone(true)\n            });\n        }\n    }\n\n    function can_flatten_body(stat) {\n        var body = fn.body;\n        var len = body.length;\n        if (compressor.option(\"inline\") < 3) {\n            return len == 1 && return_value(stat);\n        }\n        stat = null;\n        for (var i = 0; i < len; i++) {\n            var line = body[i];\n            if (line instanceof AST_Var) {\n                if (stat && !line.definitions.every((var_def) =>\n                    !var_def.value\n                )) {\n                    return false;\n                }\n            } else if (stat) {\n                return false;\n            } else if (!(line instanceof AST_EmptyStatement)) {\n                stat = line;\n            }\n        }\n        return return_value(stat);\n    }\n\n    function can_inject_args(block_scoped, safe_to_inject) {\n        for (var i = 0, len = fn.argnames.length; i < len; i++) {\n            var arg = fn.argnames[i];\n            if (arg instanceof AST_DefaultAssign) {\n                if (has_flag(arg.left, UNUSED)) continue;\n                return false;\n            }\n            if (arg instanceof AST_Destructuring) return false;\n            if (arg instanceof AST_Expansion) {\n                if (has_flag(arg.expression, UNUSED)) continue;\n                return false;\n            }\n            if (has_flag(arg, UNUSED)) continue;\n            if (!safe_to_inject\n                || block_scoped.has(arg.name)\n                || identifier_atom.has(arg.name)\n                || scope.conflicting_def(arg.name)) {\n                return false;\n            }\n            if (in_loop) in_loop.push(arg.definition());\n        }\n        return true;\n    }\n\n    function can_inject_vars(block_scoped, safe_to_inject) {\n        var len = fn.body.length;\n        for (var i = 0; i < len; i++) {\n            var stat = fn.body[i];\n            if (!(stat instanceof AST_Var)) continue;\n            if (!safe_to_inject) return false;\n            for (var j = stat.definitions.length; --j >= 0;) {\n                var name = stat.definitions[j].name;\n                if (name instanceof AST_Destructuring\n                    || block_scoped.has(name.name)\n                    || identifier_atom.has(name.name)\n                    || scope.conflicting_def(name.name)) {\n                    return false;\n                }\n                if (in_loop) in_loop.push(name.definition());\n            }\n        }\n        return true;\n    }\n\n    function can_inject_symbols() {\n        var block_scoped = new Set();\n        do {\n            scope = compressor.parent(++level);\n            if (scope.is_block_scope() && scope.block_scope) {\n                // TODO this is sometimes undefined during compression.\n                // But it should always have a value!\n                scope.block_scope.variables.forEach(function (variable) {\n                    block_scoped.add(variable.name);\n                });\n            }\n            if (scope instanceof AST_Catch) {\n                // TODO can we delete? AST_Catch is a block scope.\n                if (scope.argname) {\n                    block_scoped.add(scope.argname.name);\n                }\n            } else if (scope instanceof AST_IterationStatement) {\n                in_loop = [];\n            } else if (scope instanceof AST_SymbolRef) {\n                if (scope.fixed_value() instanceof AST_Scope) return false;\n            }\n        } while (!(scope instanceof AST_Scope));\n\n        var safe_to_inject = !(scope instanceof AST_Toplevel) || compressor.toplevel.vars;\n        var inline = compressor.option(\"inline\");\n        if (!can_inject_vars(block_scoped, inline >= 3 && safe_to_inject)) return false;\n        if (!can_inject_args(block_scoped, inline >= 2 && safe_to_inject)) return false;\n        return !in_loop || in_loop.length == 0 || !is_reachable(fn, in_loop);\n    }\n\n    function append_var(decls, expressions, name, value) {\n        var def = name.definition();\n\n        // Name already exists, only when a function argument had the same name\n        const already_appended = scope.variables.has(name.name);\n        if (!already_appended) {\n            scope.variables.set(name.name, def);\n            scope.enclosed.push(def);\n            decls.push(make_node(AST_VarDef, name, {\n                name: name,\n                value: null\n            }));\n        }\n\n        var sym = make_node(AST_SymbolRef, name, name);\n        def.references.push(sym);\n        if (value) expressions.push(make_node(AST_Assign, self, {\n            operator: \"=\",\n            logical: false,\n            left: sym,\n            right: value.clone()\n        }));\n    }\n\n    function flatten_args(decls, expressions) {\n        var len = fn.argnames.length;\n        for (var i = self.args.length; --i >= len;) {\n            expressions.push(self.args[i]);\n        }\n        for (i = len; --i >= 0;) {\n            var name = fn.argnames[i];\n            var value = self.args[i];\n            if (has_flag(name, UNUSED) || !name.name || scope.conflicting_def(name.name)) {\n                if (value) expressions.push(value);\n            } else {\n                var symbol = make_node(AST_SymbolVar, name, name);\n                name.definition().orig.push(symbol);\n                if (!value && in_loop) value = make_node(AST_Undefined, self);\n                append_var(decls, expressions, symbol, value);\n            }\n        }\n        decls.reverse();\n        expressions.reverse();\n    }\n\n    function flatten_vars(decls, expressions) {\n        var pos = expressions.length;\n        for (var i = 0, lines = fn.body.length; i < lines; i++) {\n            var stat = fn.body[i];\n            if (!(stat instanceof AST_Var)) continue;\n            for (var j = 0, defs = stat.definitions.length; j < defs; j++) {\n                var var_def = stat.definitions[j];\n                var name = var_def.name;\n                append_var(decls, expressions, name, var_def.value);\n                if (in_loop && fn.argnames.every((argname) =>\n                    argname.name != name.name\n                )) {\n                    var def = fn.variables.get(name.name);\n                    var sym = make_node(AST_SymbolRef, name, name);\n                    def.references.push(sym);\n                    expressions.splice(pos++, 0, make_node(AST_Assign, var_def, {\n                        operator: \"=\",\n                        logical: false,\n                        left: sym,\n                        right: make_node(AST_Undefined, name)\n                    }));\n                }\n            }\n        }\n    }\n\n    function flatten_fn(returned_value) {\n        var decls = [];\n        var expressions = [];\n        flatten_args(decls, expressions);\n        flatten_vars(decls, expressions);\n        expressions.push(returned_value);\n        if (decls.length) {\n            const i = scope.body.indexOf(compressor.parent(level - 1)) + 1;\n            scope.body.splice(i, 0, make_node(AST_Var, fn, {\n                definitions: decls\n            }));\n        }\n        return expressions.map(exp => exp.clone(true));\n    }\n});\n\ndef_optimize(AST_New, function(self, compressor) {\n    if (\n        compressor.option(\"unsafe\") &&\n        is_undeclared_ref(self.expression) &&\n        [\"Object\", \"RegExp\", \"Function\", \"Error\", \"Array\"].includes(self.expression.name)\n    ) return make_node(AST_Call, self, self).transform(compressor);\n    return self;\n});\n\ndef_optimize(AST_Sequence, function(self, compressor) {\n    if (!compressor.option(\"side_effects\")) return self;\n    var expressions = [];\n    filter_for_side_effects();\n    var end = expressions.length - 1;\n    trim_right_for_undefined();\n    if (end == 0) {\n        self = maintain_this_binding(compressor.parent(), compressor.self(), expressions[0]);\n        if (!(self instanceof AST_Sequence)) self = self.optimize(compressor);\n        return self;\n    }\n    self.expressions = expressions;\n    return self;\n\n    function filter_for_side_effects() {\n        var first = first_in_statement(compressor);\n        var last = self.expressions.length - 1;\n        self.expressions.forEach(function(expr, index) {\n            if (index < last) expr = expr.drop_side_effect_free(compressor, first);\n            if (expr) {\n                merge_sequence(expressions, expr);\n                first = false;\n            }\n        });\n    }\n\n    function trim_right_for_undefined() {\n        while (end > 0 && is_undefined(expressions[end], compressor)) end--;\n        if (end < expressions.length - 1) {\n            expressions[end] = make_node(AST_UnaryPrefix, self, {\n                operator   : \"void\",\n                expression : expressions[end]\n            });\n            expressions.length = end + 1;\n        }\n    }\n});\n\nAST_Unary.DEFMETHOD(\"lift_sequences\", function(compressor) {\n    if (compressor.option(\"sequences\")) {\n        if (this.expression instanceof AST_Sequence) {\n            var x = this.expression.expressions.slice();\n            var e = this.clone();\n            e.expression = x.pop();\n            x.push(e);\n            return make_sequence(this, x).optimize(compressor);\n        }\n    }\n    return this;\n});\n\ndef_optimize(AST_UnaryPostfix, function(self, compressor) {\n    return self.lift_sequences(compressor);\n});\n\ndef_optimize(AST_UnaryPrefix, function(self, compressor) {\n    var e = self.expression;\n    if (self.operator == \"delete\"\n        && !(e instanceof AST_SymbolRef\n            || e instanceof AST_PropAccess\n            || is_identifier_atom(e))) {\n        if (e instanceof AST_Sequence) {\n            const exprs = e.expressions.slice();\n            exprs.push(make_node(AST_True, self));\n            return make_sequence(self, exprs).optimize(compressor);\n        }\n        return make_sequence(self, [ e, make_node(AST_True, self) ]).optimize(compressor);\n    }\n    var seq = self.lift_sequences(compressor);\n    if (seq !== self) {\n        return seq;\n    }\n    if (compressor.option(\"side_effects\") && self.operator == \"void\") {\n        e = e.drop_side_effect_free(compressor);\n        if (e) {\n            self.expression = e;\n            return self;\n        } else {\n            return make_node(AST_Undefined, self).optimize(compressor);\n        }\n    }\n    if (compressor.in_boolean_context()) {\n        switch (self.operator) {\n          case \"!\":\n            if (e instanceof AST_UnaryPrefix && e.operator == \"!\") {\n                // !!foo ==> foo, if we're in boolean context\n                return e.expression;\n            }\n            if (e instanceof AST_Binary) {\n                self = best_of(compressor, self, e.negate(compressor, first_in_statement(compressor)));\n            }\n            break;\n          case \"typeof\":\n            // typeof always returns a non-empty string, thus it's\n            // always true in booleans\n            // And we don't need to check if it's undeclared, because in typeof, that's OK\n            return (e instanceof AST_SymbolRef ? make_node(AST_True, self) : make_sequence(self, [\n                e,\n                make_node(AST_True, self)\n            ])).optimize(compressor);\n        }\n    }\n    if (self.operator == \"-\" && e instanceof AST_Infinity) {\n        e = e.transform(compressor);\n    }\n    if (e instanceof AST_Binary\n        && (self.operator == \"+\" || self.operator == \"-\")\n        && (e.operator == \"*\" || e.operator == \"/\" || e.operator == \"%\")) {\n        return make_node(AST_Binary, self, {\n            operator: e.operator,\n            left: make_node(AST_UnaryPrefix, e.left, {\n                operator: self.operator,\n                expression: e.left\n            }),\n            right: e.right\n        });\n    }\n    // avoids infinite recursion of numerals\n    if (self.operator != \"-\"\n        || !(e instanceof AST_Number || e instanceof AST_Infinity || e instanceof AST_BigInt)) {\n        var ev = self.evaluate(compressor);\n        if (ev !== self) {\n            ev = make_node_from_constant(ev, self).optimize(compressor);\n            return best_of(compressor, ev, self);\n        }\n    }\n    return self;\n});\n\nAST_Binary.DEFMETHOD(\"lift_sequences\", function(compressor) {\n    if (compressor.option(\"sequences\")) {\n        if (this.left instanceof AST_Sequence) {\n            var x = this.left.expressions.slice();\n            var e = this.clone();\n            e.left = x.pop();\n            x.push(e);\n            return make_sequence(this, x).optimize(compressor);\n        }\n        if (this.right instanceof AST_Sequence && !this.left.has_side_effects(compressor)) {\n            var assign = this.operator == \"=\" && this.left instanceof AST_SymbolRef;\n            var x = this.right.expressions;\n            var last = x.length - 1;\n            for (var i = 0; i < last; i++) {\n                if (!assign && x[i].has_side_effects(compressor)) break;\n            }\n            if (i == last) {\n                x = x.slice();\n                var e = this.clone();\n                e.right = x.pop();\n                x.push(e);\n                return make_sequence(this, x).optimize(compressor);\n            } else if (i > 0) {\n                var e = this.clone();\n                e.right = make_sequence(this.right, x.slice(i));\n                x = x.slice(0, i);\n                x.push(e);\n                return make_sequence(this, x).optimize(compressor);\n            }\n        }\n    }\n    return this;\n});\n\nvar commutativeOperators = makePredicate(\"== === != !== * & | ^\");\nfunction is_object(node) {\n    return node instanceof AST_Array\n        || node instanceof AST_Lambda\n        || node instanceof AST_Object\n        || node instanceof AST_Class;\n}\n\ndef_optimize(AST_Binary, function(self, compressor) {\n    function reversible() {\n        return self.left.is_constant()\n            || self.right.is_constant()\n            || !self.left.has_side_effects(compressor)\n                && !self.right.has_side_effects(compressor);\n    }\n    function reverse(op) {\n        if (reversible()) {\n            if (op) self.operator = op;\n            var tmp = self.left;\n            self.left = self.right;\n            self.right = tmp;\n        }\n    }\n    if (commutativeOperators.has(self.operator)) {\n        if (self.right.is_constant()\n            && !self.left.is_constant()) {\n            // if right is a constant, whatever side effects the\n            // left side might have could not influence the\n            // result.  hence, force switch.\n\n            if (!(self.left instanceof AST_Binary\n                  && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {\n                reverse();\n            }\n        }\n    }\n    self = self.lift_sequences(compressor);\n    if (compressor.option(\"comparisons\")) switch (self.operator) {\n      case \"===\":\n      case \"!==\":\n        var is_strict_comparison = true;\n        if ((self.left.is_string(compressor) && self.right.is_string(compressor)) ||\n            (self.left.is_number(compressor) && self.right.is_number(compressor)) ||\n            (self.left.is_boolean() && self.right.is_boolean()) ||\n            self.left.equivalent_to(self.right)) {\n            self.operator = self.operator.substr(0, 2);\n        }\n        // XXX: intentionally falling down to the next case\n      case \"==\":\n      case \"!=\":\n        // void 0 == x => null == x\n        if (!is_strict_comparison && is_undefined(self.left, compressor)) {\n            self.left = make_node(AST_Null, self.left);\n        } else if (compressor.option(\"typeofs\")\n            // \"undefined\" == typeof x => undefined === x\n            && self.left instanceof AST_String\n            && self.left.value == \"undefined\"\n            && self.right instanceof AST_UnaryPrefix\n            && self.right.operator == \"typeof\") {\n            var expr = self.right.expression;\n            if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor)\n                : !(expr instanceof AST_PropAccess && compressor.option(\"ie8\"))) {\n                self.right = expr;\n                self.left = make_node(AST_Undefined, self.left).optimize(compressor);\n                if (self.operator.length == 2) self.operator += \"=\";\n            }\n        } else if (self.left instanceof AST_SymbolRef\n            // obj !== obj => false\n            && self.right instanceof AST_SymbolRef\n            && self.left.definition() === self.right.definition()\n            && is_object(self.left.fixed_value())) {\n            return make_node(self.operator[0] == \"=\" ? AST_True : AST_False, self);\n        }\n        break;\n      case \"&&\":\n      case \"||\":\n        var lhs = self.left;\n        if (lhs.operator == self.operator) {\n            lhs = lhs.right;\n        }\n        if (lhs instanceof AST_Binary\n            && lhs.operator == (self.operator == \"&&\" ? \"!==\" : \"===\")\n            && self.right instanceof AST_Binary\n            && lhs.operator == self.right.operator\n            && (is_undefined(lhs.left, compressor) && self.right.left instanceof AST_Null\n                || lhs.left instanceof AST_Null && is_undefined(self.right.left, compressor))\n            && !lhs.right.has_side_effects(compressor)\n            && lhs.right.equivalent_to(self.right.right)) {\n            var combined = make_node(AST_Binary, self, {\n                operator: lhs.operator.slice(0, -1),\n                left: make_node(AST_Null, self),\n                right: lhs.right\n            });\n            if (lhs !== self.left) {\n                combined = make_node(AST_Binary, self, {\n                    operator: self.operator,\n                    left: self.left.left,\n                    right: combined\n                });\n            }\n            return combined;\n        }\n        break;\n    }\n    if (self.operator == \"+\" && compressor.in_boolean_context()) {\n        var ll = self.left.evaluate(compressor);\n        var rr = self.right.evaluate(compressor);\n        if (ll && typeof ll == \"string\") {\n            return make_sequence(self, [\n                self.right,\n                make_node(AST_True, self)\n            ]).optimize(compressor);\n        }\n        if (rr && typeof rr == \"string\") {\n            return make_sequence(self, [\n                self.left,\n                make_node(AST_True, self)\n            ]).optimize(compressor);\n        }\n    }\n    if (compressor.option(\"comparisons\") && self.is_boolean()) {\n        if (!(compressor.parent() instanceof AST_Binary)\n            || compressor.parent() instanceof AST_Assign) {\n            var negated = make_node(AST_UnaryPrefix, self, {\n                operator: \"!\",\n                expression: self.negate(compressor, first_in_statement(compressor))\n            });\n            self = best_of(compressor, self, negated);\n        }\n        if (compressor.option(\"unsafe_comps\")) {\n            switch (self.operator) {\n              case \"<\": reverse(\">\"); break;\n              case \"<=\": reverse(\">=\"); break;\n            }\n        }\n    }\n    if (self.operator == \"+\") {\n        if (self.right instanceof AST_String\n            && self.right.getValue() == \"\"\n            && self.left.is_string(compressor)) {\n            return self.left;\n        }\n        if (self.left instanceof AST_String\n            && self.left.getValue() == \"\"\n            && self.right.is_string(compressor)) {\n            return self.right;\n        }\n        if (self.left instanceof AST_Binary\n            && self.left.operator == \"+\"\n            && self.left.left instanceof AST_String\n            && self.left.left.getValue() == \"\"\n            && self.right.is_string(compressor)) {\n            self.left = self.left.right;\n            return self;\n        }\n    }\n    if (compressor.option(\"evaluate\")) {\n        switch (self.operator) {\n          case \"&&\":\n            var ll = has_flag(self.left, TRUTHY)\n                ? true\n                : has_flag(self.left, FALSY)\n                    ? false\n                    : self.left.evaluate(compressor);\n            if (!ll) {\n                return maintain_this_binding(compressor.parent(), compressor.self(), self.left).optimize(compressor);\n            } else if (!(ll instanceof AST_Node)) {\n                return make_sequence(self, [ self.left, self.right ]).optimize(compressor);\n            }\n            var rr = self.right.evaluate(compressor);\n            if (!rr) {\n                if (compressor.in_boolean_context()) {\n                    return make_sequence(self, [\n                        self.left,\n                        make_node(AST_False, self)\n                    ]).optimize(compressor);\n                } else {\n                    set_flag(self, FALSY);\n                }\n            } else if (!(rr instanceof AST_Node)) {\n                var parent = compressor.parent();\n                if (parent.operator == \"&&\" && parent.left === compressor.self() || compressor.in_boolean_context()) {\n                    return self.left.optimize(compressor);\n                }\n            }\n            // x || false && y ---> x ? y : false\n            if (self.left.operator == \"||\") {\n                var lr = self.left.right.evaluate(compressor);\n                if (!lr) return make_node(AST_Conditional, self, {\n                    condition: self.left.left,\n                    consequent: self.right,\n                    alternative: self.left.right\n                }).optimize(compressor);\n            }\n            break;\n          case \"||\":\n            var ll = has_flag(self.left, TRUTHY)\n              ? true\n              : has_flag(self.left, FALSY)\n                ? false\n                : self.left.evaluate(compressor);\n            if (!ll) {\n                return make_sequence(self, [ self.left, self.right ]).optimize(compressor);\n            } else if (!(ll instanceof AST_Node)) {\n                return maintain_this_binding(compressor.parent(), compressor.self(), self.left).optimize(compressor);\n            }\n            var rr = self.right.evaluate(compressor);\n            if (!rr) {\n                var parent = compressor.parent();\n                if (parent.operator == \"||\" && parent.left === compressor.self() || compressor.in_boolean_context()) {\n                    return self.left.optimize(compressor);\n                }\n            } else if (!(rr instanceof AST_Node)) {\n                if (compressor.in_boolean_context()) {\n                    return make_sequence(self, [\n                        self.left,\n                        make_node(AST_True, self)\n                    ]).optimize(compressor);\n                } else {\n                    set_flag(self, TRUTHY);\n                }\n            }\n            if (self.left.operator == \"&&\") {\n                var lr = self.left.right.evaluate(compressor);\n                if (lr && !(lr instanceof AST_Node)) return make_node(AST_Conditional, self, {\n                    condition: self.left.left,\n                    consequent: self.left.right,\n                    alternative: self.right\n                }).optimize(compressor);\n            }\n            break;\n          case \"??\":\n            if (is_nullish(self.left, compressor)) {\n                return self.right;\n            }\n\n            var ll = self.left.evaluate(compressor);\n            if (!(ll instanceof AST_Node)) {\n                // if we know the value for sure we can simply compute right away.\n                return ll == null ? self.right : self.left;\n            }\n\n            if (compressor.in_boolean_context()) {\n                const rr = self.right.evaluate(compressor);\n                if (!(rr instanceof AST_Node) && !rr) {\n                    return self.left;\n                }\n            }\n        }\n        var associative = true;\n        switch (self.operator) {\n          case \"+\":\n            // (x + \"foo\") + \"bar\" => x + \"foobar\"\n            if (self.right instanceof AST_Constant\n                && self.left instanceof AST_Binary\n                && self.left.operator == \"+\"\n                && self.left.is_string(compressor)) {\n                var binary = make_node(AST_Binary, self, {\n                    operator: \"+\",\n                    left: self.left.right,\n                    right: self.right,\n                });\n                var r = binary.optimize(compressor);\n                if (binary !== r) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: self.left.left,\n                        right: r\n                    });\n                }\n            }\n            // (x + \"foo\") + (\"bar\" + y) => (x + \"foobar\") + y\n            if (self.left instanceof AST_Binary\n                && self.left.operator == \"+\"\n                && self.left.is_string(compressor)\n                && self.right instanceof AST_Binary\n                && self.right.operator == \"+\"\n                && self.right.is_string(compressor)) {\n                var binary = make_node(AST_Binary, self, {\n                    operator: \"+\",\n                    left: self.left.right,\n                    right: self.right.left,\n                });\n                var m = binary.optimize(compressor);\n                if (binary !== m) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: make_node(AST_Binary, self.left, {\n                            operator: \"+\",\n                            left: self.left.left,\n                            right: m\n                        }),\n                        right: self.right.right\n                    });\n                }\n            }\n            // a + -b => a - b\n            if (self.right instanceof AST_UnaryPrefix\n                && self.right.operator == \"-\"\n                && self.left.is_number(compressor)) {\n                self = make_node(AST_Binary, self, {\n                    operator: \"-\",\n                    left: self.left,\n                    right: self.right.expression\n                });\n                break;\n            }\n            // -a + b => b - a\n            if (self.left instanceof AST_UnaryPrefix\n                && self.left.operator == \"-\"\n                && reversible()\n                && self.right.is_number(compressor)) {\n                self = make_node(AST_Binary, self, {\n                    operator: \"-\",\n                    left: self.right,\n                    right: self.left.expression\n                });\n                break;\n            }\n            // `foo${bar}baz` + 1 => `foo${bar}baz1`\n            if (self.left instanceof AST_TemplateString) {\n                var l = self.left;\n                var r = self.right.evaluate(compressor);\n                if (r != self.right) {\n                    l.segments[l.segments.length - 1].value += String(r);\n                    return l;\n                }\n            }\n            // 1 + `foo${bar}baz` => `1foo${bar}baz`\n            if (self.right instanceof AST_TemplateString) {\n                var r = self.right;\n                var l = self.left.evaluate(compressor);\n                if (l != self.left) {\n                    r.segments[0].value = String(l) + r.segments[0].value;\n                    return r;\n                }\n            }\n            // `1${bar}2` + `foo${bar}baz` => `1${bar}2foo${bar}baz`\n            if (self.left instanceof AST_TemplateString\n                && self.right instanceof AST_TemplateString) {\n                var l = self.left;\n                var segments = l.segments;\n                var r = self.right;\n                segments[segments.length - 1].value += r.segments[0].value;\n                for (var i = 1; i < r.segments.length; i++) {\n                    segments.push(r.segments[i]);\n                }\n                return l;\n            }\n          case \"*\":\n            associative = compressor.option(\"unsafe_math\");\n          case \"&\":\n          case \"|\":\n          case \"^\":\n            // a + +b => +b + a\n            if (self.left.is_number(compressor)\n                && self.right.is_number(compressor)\n                && reversible()\n                && !(self.left instanceof AST_Binary\n                    && self.left.operator != self.operator\n                    && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {\n                var reversed = make_node(AST_Binary, self, {\n                    operator: self.operator,\n                    left: self.right,\n                    right: self.left\n                });\n                if (self.right instanceof AST_Constant\n                    && !(self.left instanceof AST_Constant)) {\n                    self = best_of(compressor, reversed, self);\n                } else {\n                    self = best_of(compressor, self, reversed);\n                }\n            }\n            if (associative && self.is_number(compressor)) {\n                // a + (b + c) => (a + b) + c\n                if (self.right instanceof AST_Binary\n                    && self.right.operator == self.operator) {\n                    self = make_node(AST_Binary, self, {\n                        operator: self.operator,\n                        left: make_node(AST_Binary, self.left, {\n                            operator: self.operator,\n                            left: self.left,\n                            right: self.right.left,\n                            start: self.left.start,\n                            end: self.right.left.end\n                        }),\n                        right: self.right.right\n                    });\n                }\n                // (n + 2) + 3 => 5 + n\n                // (2 * n) * 3 => 6 + n\n                if (self.right instanceof AST_Constant\n                    && self.left instanceof AST_Binary\n                    && self.left.operator == self.operator) {\n                    if (self.left.left instanceof AST_Constant) {\n                        self = make_node(AST_Binary, self, {\n                            operator: self.operator,\n                            left: make_node(AST_Binary, self.left, {\n                                operator: self.operator,\n                                left: self.left.left,\n                                right: self.right,\n                                start: self.left.left.start,\n                                end: self.right.end\n                            }),\n                            right: self.left.right\n                        });\n                    } else if (self.left.right instanceof AST_Constant) {\n                        self = make_node(AST_Binary, self, {\n                            operator: self.operator,\n                            left: make_node(AST_Binary, self.left, {\n                                operator: self.operator,\n                                left: self.left.right,\n                                right: self.right,\n                                start: self.left.right.start,\n                                end: self.right.end\n                            }),\n                            right: self.left.left\n                        });\n                    }\n                }\n                // (a | 1) | (2 | d) => (3 | a) | b\n                if (self.left instanceof AST_Binary\n                    && self.left.operator == self.operator\n                    && self.left.right instanceof AST_Constant\n                    && self.right instanceof AST_Binary\n                    && self.right.operator == self.operator\n                    && self.right.left instanceof AST_Constant) {\n                    self = make_node(AST_Binary, self, {\n                        operator: self.operator,\n                        left: make_node(AST_Binary, self.left, {\n                            operator: self.operator,\n                            left: make_node(AST_Binary, self.left.left, {\n                                operator: self.operator,\n                                left: self.left.right,\n                                right: self.right.left,\n                                start: self.left.right.start,\n                                end: self.right.left.end\n                            }),\n                            right: self.left.left\n                        }),\n                        right: self.right.right\n                    });\n                }\n            }\n        }\n    }\n    // x && (y && z)  ==>  x && y && z\n    // x || (y || z)  ==>  x || y || z\n    // x + (\"y\" + z)  ==>  x + \"y\" + z\n    // \"x\" + (y + \"z\")==>  \"x\" + y + \"z\"\n    if (self.right instanceof AST_Binary\n        && self.right.operator == self.operator\n        && (lazy_op.has(self.operator)\n            || (self.operator == \"+\"\n                && (self.right.left.is_string(compressor)\n                    || (self.left.is_string(compressor)\n                        && self.right.right.is_string(compressor)))))\n    ) {\n        self.left = make_node(AST_Binary, self.left, {\n            operator : self.operator,\n            left     : self.left.transform(compressor),\n            right    : self.right.left.transform(compressor)\n        });\n        self.right = self.right.right.transform(compressor);\n        return self.transform(compressor);\n    }\n    var ev = self.evaluate(compressor);\n    if (ev !== self) {\n        ev = make_node_from_constant(ev, self).optimize(compressor);\n        return best_of(compressor, ev, self);\n    }\n    return self;\n});\n\ndef_optimize(AST_SymbolExport, function(self) {\n    return self;\n});\n\nfunction recursive_ref(compressor, def) {\n    var node;\n    for (var i = 0; node = compressor.parent(i); i++) {\n        if (\n            node instanceof AST_Lambda\n            || node instanceof AST_Class\n        ) {\n            var name = node.name;\n            if (name && name.definition() === def) break;\n        }\n    }\n    return node;\n}\n\nfunction within_array_or_object_literal(compressor) {\n    var node, level = 0;\n    while (node = compressor.parent(level++)) {\n        if (node instanceof AST_Statement) return false;\n        if (node instanceof AST_Array\n            || node instanceof AST_ObjectKeyVal\n            || node instanceof AST_Object) {\n            return true;\n        }\n    }\n    return false;\n}\n\ndef_optimize(AST_SymbolRef, function(self, compressor) {\n    if (\n        !compressor.option(\"ie8\")\n        && is_undeclared_ref(self)\n        && !compressor.find_parent(AST_With)\n    ) {\n        switch (self.name) {\n          case \"undefined\":\n            return make_node(AST_Undefined, self).optimize(compressor);\n          case \"NaN\":\n            return make_node(AST_NaN, self).optimize(compressor);\n          case \"Infinity\":\n            return make_node(AST_Infinity, self).optimize(compressor);\n        }\n    }\n\n    const parent = compressor.parent();\n    if (compressor.option(\"reduce_vars\") && is_lhs(self, parent) !== self) {\n        const def = self.definition();\n        const nearest_scope = find_scope(compressor);\n        if (compressor.top_retain && def.global && compressor.top_retain(def)) {\n            def.fixed = false;\n            def.single_use = false;\n            return self;\n        }\n\n        let fixed = self.fixed_value();\n        let single_use = def.single_use\n            && !(parent instanceof AST_Call\n                && (parent.is_callee_pure(compressor))\n                    || has_annotation(parent, _NOINLINE))\n            && !(parent instanceof AST_Export\n                && fixed instanceof AST_Lambda\n                && fixed.name);\n\n        if (single_use && fixed instanceof AST_Node) {\n            single_use =\n                !fixed.has_side_effects(compressor)\n                && !fixed.may_throw(compressor);\n        }\n\n        if (single_use && (fixed instanceof AST_Lambda || fixed instanceof AST_Class)) {\n            if (retain_top_func(fixed, compressor)) {\n                single_use = false;\n            } else if (def.scope !== self.scope\n                && (def.escaped == 1\n                    || has_flag(fixed, INLINED)\n                    || within_array_or_object_literal(compressor)\n                    || !compressor.option(\"reduce_funcs\"))) {\n                single_use = false;\n            } else if (recursive_ref(compressor, def)) {\n                single_use = false;\n            } else if (def.scope !== self.scope || def.orig[0] instanceof AST_SymbolFunarg) {\n                single_use = fixed.is_constant_expression(self.scope);\n                if (single_use == \"f\") {\n                    var scope = self.scope;\n                    do {\n                        if (scope instanceof AST_Defun || is_func_expr(scope)) {\n                            set_flag(scope, INLINED);\n                        }\n                    } while (scope = scope.parent_scope);\n                }\n            }\n        }\n\n        if (single_use && fixed instanceof AST_Lambda) {\n            single_use =\n                def.scope === self.scope\n                    && !scope_encloses_variables_in_this_scope(nearest_scope, fixed)\n                || parent instanceof AST_Call\n                    && parent.expression === self\n                    && !scope_encloses_variables_in_this_scope(nearest_scope, fixed)\n                    && !(fixed.name && fixed.name.definition().recursive_refs > 0);\n        }\n\n        if (single_use && fixed) {\n            if (fixed instanceof AST_DefClass) {\n                set_flag(fixed, SQUEEZED);\n                fixed = make_node(AST_ClassExpression, fixed, fixed);\n            }\n            if (fixed instanceof AST_Defun) {\n                set_flag(fixed, SQUEEZED);\n                fixed = make_node(AST_Function, fixed, fixed);\n            }\n            if (def.recursive_refs > 0 && fixed.name instanceof AST_SymbolDefun) {\n                const defun_def = fixed.name.definition();\n                let lambda_def = fixed.variables.get(fixed.name.name);\n                let name = lambda_def && lambda_def.orig[0];\n                if (!(name instanceof AST_SymbolLambda)) {\n                    name = make_node(AST_SymbolLambda, fixed.name, fixed.name);\n                    name.scope = fixed;\n                    fixed.name = name;\n                    lambda_def = fixed.def_function(name);\n                }\n                walk(fixed, node => {\n                    if (node instanceof AST_SymbolRef && node.definition() === defun_def) {\n                        node.thedef = lambda_def;\n                        lambda_def.references.push(node);\n                    }\n                });\n            }\n            if (\n                (fixed instanceof AST_Lambda || fixed instanceof AST_Class)\n                && fixed.parent_scope !== nearest_scope\n            ) {\n                fixed = fixed.clone(true, compressor.get_toplevel());\n\n                nearest_scope.add_child_scope(fixed);\n            }\n            return fixed.optimize(compressor);\n        }\n\n        // multiple uses\n        if (fixed) {\n            let replace;\n\n            if (fixed instanceof AST_This) {\n                if (!(def.orig[0] instanceof AST_SymbolFunarg)\n                    && def.references.every((ref) =>\n                        def.scope === ref.scope\n                    )) {\n                    replace = fixed;\n                }\n            } else {\n                var ev = fixed.evaluate(compressor);\n                if (\n                    ev !== fixed\n                    && (compressor.option(\"unsafe_regexp\") || !(ev instanceof RegExp))\n                ) {\n                    replace = make_node_from_constant(ev, fixed);\n                }\n            }\n\n            if (replace) {\n                const name_length = self.size(compressor);\n                const replace_size = replace.size(compressor);\n\n                let overhead = 0;\n                if (compressor.option(\"unused\") && !compressor.exposed(def)) {\n                    overhead =\n                        (name_length + 2 + replace_size) /\n                        (def.references.length - def.assignments);\n                }\n\n                if (replace_size <= name_length + overhead) {\n                    return replace;\n                }\n            }\n        }\n    }\n\n    return self;\n});\n\nfunction scope_encloses_variables_in_this_scope(scope, pulled_scope) {\n    for (const enclosed of pulled_scope.enclosed) {\n        if (pulled_scope.variables.has(enclosed.name)) {\n            continue;\n        }\n        const looked_up = scope.find_variable(enclosed.name);\n        if (looked_up) {\n            if (looked_up === enclosed) continue;\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction is_atomic(lhs, self) {\n    return lhs instanceof AST_SymbolRef || lhs.TYPE === self.TYPE;\n}\n\ndef_optimize(AST_Undefined, function(self, compressor) {\n    if (compressor.option(\"unsafe_undefined\")) {\n        var undef = find_variable(compressor, \"undefined\");\n        if (undef) {\n            var ref = make_node(AST_SymbolRef, self, {\n                name   : \"undefined\",\n                scope  : undef.scope,\n                thedef : undef\n            });\n            set_flag(ref, UNDEFINED);\n            return ref;\n        }\n    }\n    var lhs = is_lhs(compressor.self(), compressor.parent());\n    if (lhs && is_atomic(lhs, self)) return self;\n    return make_node(AST_UnaryPrefix, self, {\n        operator: \"void\",\n        expression: make_node(AST_Number, self, {\n            value: 0\n        })\n    });\n});\n\ndef_optimize(AST_Infinity, function(self, compressor) {\n    var lhs = is_lhs(compressor.self(), compressor.parent());\n    if (lhs && is_atomic(lhs, self)) return self;\n    if (\n        compressor.option(\"keep_infinity\")\n        && !(lhs && !is_atomic(lhs, self))\n        && !find_variable(compressor, \"Infinity\")\n    ) {\n        return self;\n    }\n    return make_node(AST_Binary, self, {\n        operator: \"/\",\n        left: make_node(AST_Number, self, {\n            value: 1\n        }),\n        right: make_node(AST_Number, self, {\n            value: 0\n        })\n    });\n});\n\ndef_optimize(AST_NaN, function(self, compressor) {\n    var lhs = is_lhs(compressor.self(), compressor.parent());\n    if (lhs && !is_atomic(lhs, self)\n        || find_variable(compressor, \"NaN\")) {\n        return make_node(AST_Binary, self, {\n            operator: \"/\",\n            left: make_node(AST_Number, self, {\n                value: 0\n            }),\n            right: make_node(AST_Number, self, {\n                value: 0\n            })\n        });\n    }\n    return self;\n});\n\nfunction is_reachable(self, defs) {\n    const find_ref = node => {\n        if (node instanceof AST_SymbolRef && member(node.definition(), defs)) {\n            return walk_abort;\n        }\n    };\n\n    return walk_parent(self, (node, info) => {\n        if (node instanceof AST_Scope && node !== self) {\n            var parent = info.parent();\n\n            if (parent instanceof AST_Call && parent.expression === node) return;\n\n            if (walk(node, find_ref)) return walk_abort;\n\n            return true;\n        }\n    });\n}\n\nconst ASSIGN_OPS = makePredicate(\"+ - / * % >> << >>> | ^ &\");\nconst ASSIGN_OPS_COMMUTATIVE = makePredicate(\"* | ^ &\");\ndef_optimize(AST_Assign, function(self, compressor) {\n    if (self.logical) {\n        return self.lift_sequences(compressor);\n    }\n\n    var def;\n    if (compressor.option(\"dead_code\")\n        && self.left instanceof AST_SymbolRef\n        && (def = self.left.definition()).scope === compressor.find_parent(AST_Lambda)) {\n        var level = 0, node, parent = self;\n        do {\n            node = parent;\n            parent = compressor.parent(level++);\n            if (parent instanceof AST_Exit) {\n                if (in_try(level, parent)) break;\n                if (is_reachable(def.scope, [ def ])) break;\n                if (self.operator == \"=\") return self.right;\n                def.fixed = false;\n                return make_node(AST_Binary, self, {\n                    operator: self.operator.slice(0, -1),\n                    left: self.left,\n                    right: self.right\n                }).optimize(compressor);\n            }\n        } while (parent instanceof AST_Binary && parent.right === node\n            || parent instanceof AST_Sequence && parent.tail_node() === node);\n    }\n    self = self.lift_sequences(compressor);\n    if (self.operator == \"=\" && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary) {\n        // x = expr1 OP expr2\n        if (self.right.left instanceof AST_SymbolRef\n            && self.right.left.name == self.left.name\n            && ASSIGN_OPS.has(self.right.operator)) {\n            // x = x - 2  --->  x -= 2\n            self.operator = self.right.operator + \"=\";\n            self.right = self.right.right;\n        } else if (self.right.right instanceof AST_SymbolRef\n            && self.right.right.name == self.left.name\n            && ASSIGN_OPS_COMMUTATIVE.has(self.right.operator)\n            && !self.right.left.has_side_effects(compressor)) {\n            // x = 2 & x  --->  x &= 2\n            self.operator = self.right.operator + \"=\";\n            self.right = self.right.left;\n        }\n    }\n    return self;\n\n    function in_try(level, node) {\n        var right = self.right;\n        self.right = make_node(AST_Null, right);\n        var may_throw = node.may_throw(compressor);\n        self.right = right;\n        var scope = self.left.definition().scope;\n        var parent;\n        while ((parent = compressor.parent(level++)) !== scope) {\n            if (parent instanceof AST_Try) {\n                if (parent.bfinally) return true;\n                if (may_throw && parent.bcatch) return true;\n            }\n        }\n    }\n});\n\ndef_optimize(AST_DefaultAssign, function(self, compressor) {\n    if (!compressor.option(\"evaluate\")) {\n        return self;\n    }\n    var evaluateRight = self.right.evaluate(compressor);\n\n    // `[x = undefined] = foo` ---> `[x] = foo`\n    if (evaluateRight === undefined) {\n        self = self.left;\n    } else if (evaluateRight !== self.right) {\n        evaluateRight = make_node_from_constant(evaluateRight, self.right);\n        self.right = best_of_expression(evaluateRight, self.right);\n    }\n\n    return self;\n});\n\nfunction is_nullish(node, compressor) {\n    let fixed;\n    return (\n        node instanceof AST_Null\n        || is_undefined(node, compressor)\n        || (\n            node instanceof AST_SymbolRef\n            && (fixed = node.definition().fixed) instanceof AST_Node\n            && is_nullish(fixed, compressor)\n        )\n        // Recurse into those optional chains!\n        || node instanceof AST_PropAccess && node.optional && is_nullish(node.expression, compressor)\n        || node instanceof AST_Call && node.optional && is_nullish(node.expression, compressor)\n        || node instanceof AST_Chain && is_nullish(node.expression, compressor)\n    );\n}\n\nfunction is_nullish_check(check, check_subject, compressor) {\n    if (check_subject.may_throw(compressor)) return false;\n\n    let nullish_side;\n\n    // foo == null\n    if (\n        check instanceof AST_Binary\n        && check.operator === \"==\"\n        // which side is nullish?\n        && (\n            (nullish_side = is_nullish(check.left, compressor) && check.left)\n            || (nullish_side = is_nullish(check.right, compressor) && check.right)\n        )\n        // is the other side the same as the check_subject\n        && (\n            nullish_side === check.left\n                ? check.right\n                : check.left\n        ).equivalent_to(check_subject)\n    ) {\n        return true;\n    }\n\n    // foo === null || foo === undefined\n    if (check instanceof AST_Binary && check.operator === \"||\") {\n        let null_cmp;\n        let undefined_cmp;\n\n        const find_comparison = cmp => {\n            if (!(\n                cmp instanceof AST_Binary\n                && (cmp.operator === \"===\" || cmp.operator === \"==\")\n            )) {\n                return false;\n            }\n\n            let found = 0;\n            let defined_side;\n\n            if (cmp.left instanceof AST_Null) {\n                found++;\n                null_cmp = cmp;\n                defined_side = cmp.right;\n            }\n            if (cmp.right instanceof AST_Null) {\n                found++;\n                null_cmp = cmp;\n                defined_side = cmp.left;\n            }\n            if (is_undefined(cmp.left, compressor)) {\n                found++;\n                undefined_cmp = cmp;\n                defined_side = cmp.right;\n            }\n            if (is_undefined(cmp.right, compressor)) {\n                found++;\n                undefined_cmp = cmp;\n                defined_side = cmp.left;\n            }\n\n            if (found !== 1) {\n                return false;\n            }\n\n            if (!defined_side.equivalent_to(check_subject)) {\n                return false;\n            }\n\n            return true;\n        };\n\n        if (!find_comparison(check.left)) return false;\n        if (!find_comparison(check.right)) return false;\n\n        if (null_cmp && undefined_cmp && null_cmp !== undefined_cmp) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\ndef_optimize(AST_Conditional, function(self, compressor) {\n    if (!compressor.option(\"conditionals\")) return self;\n    // This looks like lift_sequences(), should probably be under \"sequences\"\n    if (self.condition instanceof AST_Sequence) {\n        var expressions = self.condition.expressions.slice();\n        self.condition = expressions.pop();\n        expressions.push(self);\n        return make_sequence(self, expressions);\n    }\n    var cond = self.condition.evaluate(compressor);\n    if (cond !== self.condition) {\n        if (cond) {\n            return maintain_this_binding(compressor.parent(), compressor.self(), self.consequent);\n        } else {\n            return maintain_this_binding(compressor.parent(), compressor.self(), self.alternative);\n        }\n    }\n    var negated = cond.negate(compressor, first_in_statement(compressor));\n    if (best_of(compressor, cond, negated) === negated) {\n        self = make_node(AST_Conditional, self, {\n            condition: negated,\n            consequent: self.alternative,\n            alternative: self.consequent\n        });\n    }\n    var condition = self.condition;\n    var consequent = self.consequent;\n    var alternative = self.alternative;\n    // x?x:y --> x||y\n    if (condition instanceof AST_SymbolRef\n        && consequent instanceof AST_SymbolRef\n        && condition.definition() === consequent.definition()) {\n        return make_node(AST_Binary, self, {\n            operator: \"||\",\n            left: condition,\n            right: alternative\n        });\n    }\n    // if (foo) exp = something; else exp = something_else;\n    //                   |\n    //                   v\n    // exp = foo ? something : something_else;\n    if (\n        consequent instanceof AST_Assign\n        && alternative instanceof AST_Assign\n        && consequent.operator === alternative.operator\n        && consequent.logical === alternative.logical\n        && consequent.left.equivalent_to(alternative.left)\n        && (!self.condition.has_side_effects(compressor)\n            || consequent.operator == \"=\"\n                && !consequent.left.has_side_effects(compressor))\n    ) {\n        return make_node(AST_Assign, self, {\n            operator: consequent.operator,\n            left: consequent.left,\n            logical: consequent.logical,\n            right: make_node(AST_Conditional, self, {\n                condition: self.condition,\n                consequent: consequent.right,\n                alternative: alternative.right\n            })\n        });\n    }\n    // x ? y(a) : y(b) --> y(x ? a : b)\n    var arg_index;\n    if (consequent instanceof AST_Call\n        && alternative.TYPE === consequent.TYPE\n        && consequent.args.length > 0\n        && consequent.args.length == alternative.args.length\n        && consequent.expression.equivalent_to(alternative.expression)\n        && !self.condition.has_side_effects(compressor)\n        && !consequent.expression.has_side_effects(compressor)\n        && typeof (arg_index = single_arg_diff()) == \"number\") {\n        var node = consequent.clone();\n        node.args[arg_index] = make_node(AST_Conditional, self, {\n            condition: self.condition,\n            consequent: consequent.args[arg_index],\n            alternative: alternative.args[arg_index]\n        });\n        return node;\n    }\n    // a ? b : c ? b : d --> (a || c) ? b : d\n    if (alternative instanceof AST_Conditional\n        && consequent.equivalent_to(alternative.consequent)) {\n        return make_node(AST_Conditional, self, {\n            condition: make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: condition,\n                right: alternative.condition\n            }),\n            consequent: consequent,\n            alternative: alternative.alternative\n        }).optimize(compressor);\n    }\n\n    // a == null ? b : a -> a ?? b\n    if (\n        compressor.option(\"ecma\") >= 2020 &&\n        is_nullish_check(condition, alternative, compressor)\n    ) {\n        return make_node(AST_Binary, self, {\n            operator: \"??\",\n            left: alternative,\n            right: consequent\n        }).optimize(compressor);\n    }\n\n    // a ? b : (c, b) --> (a || c), b\n    if (alternative instanceof AST_Sequence\n        && consequent.equivalent_to(alternative.expressions[alternative.expressions.length - 1])) {\n        return make_sequence(self, [\n            make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: condition,\n                right: make_sequence(self, alternative.expressions.slice(0, -1))\n            }),\n            consequent\n        ]).optimize(compressor);\n    }\n    // a ? b : (c && b) --> (a || c) && b\n    if (alternative instanceof AST_Binary\n        && alternative.operator == \"&&\"\n        && consequent.equivalent_to(alternative.right)) {\n        return make_node(AST_Binary, self, {\n            operator: \"&&\",\n            left: make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: condition,\n                right: alternative.left\n            }),\n            right: consequent\n        }).optimize(compressor);\n    }\n    // x?y?z:a:a --> x&&y?z:a\n    if (consequent instanceof AST_Conditional\n        && consequent.alternative.equivalent_to(alternative)) {\n        return make_node(AST_Conditional, self, {\n            condition: make_node(AST_Binary, self, {\n                left: self.condition,\n                operator: \"&&\",\n                right: consequent.condition\n            }),\n            consequent: consequent.consequent,\n            alternative: alternative\n        });\n    }\n    // x ? y : y --> x, y\n    if (consequent.equivalent_to(alternative)) {\n        return make_sequence(self, [\n            self.condition,\n            consequent\n        ]).optimize(compressor);\n    }\n    // x ? y || z : z --> x && y || z\n    if (consequent instanceof AST_Binary\n        && consequent.operator == \"||\"\n        && consequent.right.equivalent_to(alternative)) {\n        return make_node(AST_Binary, self, {\n            operator: \"||\",\n            left: make_node(AST_Binary, self, {\n                operator: \"&&\",\n                left: self.condition,\n                right: consequent.left\n            }),\n            right: alternative\n        }).optimize(compressor);\n    }\n    var in_bool = compressor.in_boolean_context();\n    if (is_true(self.consequent)) {\n        if (is_false(self.alternative)) {\n            // c ? true : false ---> !!c\n            return booleanize(self.condition);\n        }\n        // c ? true : x ---> !!c || x\n        return make_node(AST_Binary, self, {\n            operator: \"||\",\n            left: booleanize(self.condition),\n            right: self.alternative\n        });\n    }\n    if (is_false(self.consequent)) {\n        if (is_true(self.alternative)) {\n            // c ? false : true ---> !c\n            return booleanize(self.condition.negate(compressor));\n        }\n        // c ? false : x ---> !c && x\n        return make_node(AST_Binary, self, {\n            operator: \"&&\",\n            left: booleanize(self.condition.negate(compressor)),\n            right: self.alternative\n        });\n    }\n    if (is_true(self.alternative)) {\n        // c ? x : true ---> !c || x\n        return make_node(AST_Binary, self, {\n            operator: \"||\",\n            left: booleanize(self.condition.negate(compressor)),\n            right: self.consequent\n        });\n    }\n    if (is_false(self.alternative)) {\n        // c ? x : false ---> !!c && x\n        return make_node(AST_Binary, self, {\n            operator: \"&&\",\n            left: booleanize(self.condition),\n            right: self.consequent\n        });\n    }\n\n    return self;\n\n    function booleanize(node) {\n        if (node.is_boolean()) return node;\n        // !!expression\n        return make_node(AST_UnaryPrefix, node, {\n            operator: \"!\",\n            expression: node.negate(compressor)\n        });\n    }\n\n    // AST_True or !0\n    function is_true(node) {\n        return node instanceof AST_True\n            || in_bool\n                && node instanceof AST_Constant\n                && node.getValue()\n            || (node instanceof AST_UnaryPrefix\n                && node.operator == \"!\"\n                && node.expression instanceof AST_Constant\n                && !node.expression.getValue());\n    }\n    // AST_False or !1\n    function is_false(node) {\n        return node instanceof AST_False\n            || in_bool\n                && node instanceof AST_Constant\n                && !node.getValue()\n            || (node instanceof AST_UnaryPrefix\n                && node.operator == \"!\"\n                && node.expression instanceof AST_Constant\n                && node.expression.getValue());\n    }\n\n    function single_arg_diff() {\n        var a = consequent.args;\n        var b = alternative.args;\n        for (var i = 0, len = a.length; i < len; i++) {\n            if (a[i] instanceof AST_Expansion) return;\n            if (!a[i].equivalent_to(b[i])) {\n                if (b[i] instanceof AST_Expansion) return;\n                for (var j = i + 1; j < len; j++) {\n                    if (a[j] instanceof AST_Expansion) return;\n                    if (!a[j].equivalent_to(b[j])) return;\n                }\n                return i;\n            }\n        }\n    }\n});\n\ndef_optimize(AST_Boolean, function(self, compressor) {\n    if (compressor.in_boolean_context()) return make_node(AST_Number, self, {\n        value: +self.value\n    });\n    var p = compressor.parent();\n    if (compressor.option(\"booleans_as_integers\")) {\n        if (p instanceof AST_Binary && (p.operator == \"===\" || p.operator == \"!==\")) {\n            p.operator = p.operator.replace(/=$/, \"\");\n        }\n        return make_node(AST_Number, self, {\n            value: +self.value\n        });\n    }\n    if (compressor.option(\"booleans\")) {\n        if (p instanceof AST_Binary && (p.operator == \"==\"\n                                        || p.operator == \"!=\")) {\n            return make_node(AST_Number, self, {\n                value: +self.value\n            });\n        }\n        return make_node(AST_UnaryPrefix, self, {\n            operator: \"!\",\n            expression: make_node(AST_Number, self, {\n                value: 1 - self.value\n            })\n        });\n    }\n    return self;\n});\n\nfunction safe_to_flatten(value, compressor) {\n    if (value instanceof AST_SymbolRef) {\n        value = value.fixed_value();\n    }\n    if (!value) return false;\n    if (!(value instanceof AST_Lambda || value instanceof AST_Class)) return true;\n    if (!(value instanceof AST_Lambda && value.contains_this())) return true;\n    return compressor.parent() instanceof AST_New;\n}\n\nAST_PropAccess.DEFMETHOD(\"flatten_object\", function(key, compressor) {\n    if (!compressor.option(\"properties\")) return;\n    if (key === \"__proto__\") return;\n\n    var arrows = compressor.option(\"unsafe_arrows\") && compressor.option(\"ecma\") >= 2015;\n    var expr = this.expression;\n    if (expr instanceof AST_Object) {\n        var props = expr.properties;\n\n        for (var i = props.length; --i >= 0;) {\n            var prop = props[i];\n\n            if (\"\" + (prop instanceof AST_ConciseMethod ? prop.key.name : prop.key) == key) {\n                const all_props_flattenable = props.every((p) =>\n                    (p instanceof AST_ObjectKeyVal\n                        || arrows && p instanceof AST_ConciseMethod && !p.is_generator\n                    )\n                    && !p.computed_key()\n                );\n\n                if (!all_props_flattenable) return;\n                if (!safe_to_flatten(prop.value, compressor)) return;\n\n                return make_node(AST_Sub, this, {\n                    expression: make_node(AST_Array, expr, {\n                        elements: props.map(function(prop) {\n                            var v = prop.value;\n                            if (v instanceof AST_Accessor) {\n                                v = make_node(AST_Function, v, v);\n                            }\n\n                            var k = prop.key;\n                            if (k instanceof AST_Node && !(k instanceof AST_SymbolMethod)) {\n                                return make_sequence(prop, [ k, v ]);\n                            }\n\n                            return v;\n                        })\n                    }),\n                    property: make_node(AST_Number, this, {\n                        value: i\n                    })\n                });\n            }\n        }\n    }\n});\n\ndef_optimize(AST_Sub, function(self, compressor) {\n    var expr = self.expression;\n    var prop = self.property;\n    if (compressor.option(\"properties\")) {\n        var key = prop.evaluate(compressor);\n        if (key !== prop) {\n            if (typeof key == \"string\") {\n                if (key == \"undefined\") {\n                    key = undefined;\n                } else {\n                    var value = parseFloat(key);\n                    if (value.toString() == key) {\n                        key = value;\n                    }\n                }\n            }\n            prop = self.property = best_of_expression(prop, make_node_from_constant(key, prop).transform(compressor));\n            var property = \"\" + key;\n            if (is_basic_identifier_string(property)\n                && property.length <= prop.size() + 1) {\n                return make_node(AST_Dot, self, {\n                    expression: expr,\n                    optional: self.optional,\n                    property: property,\n                    quote: prop.quote,\n                }).optimize(compressor);\n            }\n        }\n    }\n    var fn;\n    OPT_ARGUMENTS: if (compressor.option(\"arguments\")\n        && expr instanceof AST_SymbolRef\n        && expr.name == \"arguments\"\n        && expr.definition().orig.length == 1\n        && (fn = expr.scope) instanceof AST_Lambda\n        && fn.uses_arguments\n        && !(fn instanceof AST_Arrow)\n        && prop instanceof AST_Number) {\n        var index = prop.getValue();\n        var params = new Set();\n        var argnames = fn.argnames;\n        for (var n = 0; n < argnames.length; n++) {\n            if (!(argnames[n] instanceof AST_SymbolFunarg)) {\n                break OPT_ARGUMENTS; // destructuring parameter - bail\n            }\n            var param = argnames[n].name;\n            if (params.has(param)) {\n                break OPT_ARGUMENTS; // duplicate parameter - bail\n            }\n            params.add(param);\n        }\n        var argname = fn.argnames[index];\n        if (argname && compressor.has_directive(\"use strict\")) {\n            var def = argname.definition();\n            if (!compressor.option(\"reduce_vars\") || def.assignments || def.orig.length > 1) {\n                argname = null;\n            }\n        } else if (!argname && !compressor.option(\"keep_fargs\") && index < fn.argnames.length + 5) {\n            while (index >= fn.argnames.length) {\n                argname = fn.create_symbol(AST_SymbolFunarg, {\n                    source: fn,\n                    scope: fn,\n                    tentative_name: \"argument_\" + fn.argnames.length,\n                });\n                fn.argnames.push(argname);\n            }\n        }\n        if (argname) {\n            var sym = make_node(AST_SymbolRef, self, argname);\n            sym.reference({});\n            clear_flag(argname, UNUSED);\n            return sym;\n        }\n    }\n    if (is_lhs(self, compressor.parent())) return self;\n    if (key !== prop) {\n        var sub = self.flatten_object(property, compressor);\n        if (sub) {\n            expr = self.expression = sub.expression;\n            prop = self.property = sub.property;\n        }\n    }\n    if (compressor.option(\"properties\") && compressor.option(\"side_effects\")\n        && prop instanceof AST_Number && expr instanceof AST_Array) {\n        var index = prop.getValue();\n        var elements = expr.elements;\n        var retValue = elements[index];\n        FLATTEN: if (safe_to_flatten(retValue, compressor)) {\n            var flatten = true;\n            var values = [];\n            for (var i = elements.length; --i > index;) {\n                var value = elements[i].drop_side_effect_free(compressor);\n                if (value) {\n                    values.unshift(value);\n                    if (flatten && value.has_side_effects(compressor)) flatten = false;\n                }\n            }\n            if (retValue instanceof AST_Expansion) break FLATTEN;\n            retValue = retValue instanceof AST_Hole ? make_node(AST_Undefined, retValue) : retValue;\n            if (!flatten) values.unshift(retValue);\n            while (--i >= 0) {\n                var value = elements[i];\n                if (value instanceof AST_Expansion) break FLATTEN;\n                value = value.drop_side_effect_free(compressor);\n                if (value) values.unshift(value);\n                else index--;\n            }\n            if (flatten) {\n                values.push(retValue);\n                return make_sequence(self, values).optimize(compressor);\n            } else return make_node(AST_Sub, self, {\n                expression: make_node(AST_Array, expr, {\n                    elements: values\n                }),\n                property: make_node(AST_Number, prop, {\n                    value: index\n                })\n            });\n        }\n    }\n    var ev = self.evaluate(compressor);\n    if (ev !== self) {\n        ev = make_node_from_constant(ev, self).optimize(compressor);\n        return best_of(compressor, ev, self);\n    }\n    if (self.optional && is_nullish(self.expression, compressor)) {\n        return make_node(AST_Undefined, self);\n    }\n    return self;\n});\n\ndef_optimize(AST_Chain, function (self, compressor) {\n    self.expression = self.expression.optimize(compressor);\n    return self;\n});\n\nAST_Lambda.DEFMETHOD(\"contains_this\", function() {\n    return walk(this, node => {\n        if (node instanceof AST_This) return walk_abort;\n        if (\n            node !== this\n            && node instanceof AST_Scope\n            && !(node instanceof AST_Arrow)\n        ) {\n            return true;\n        }\n    });\n});\n\ndef_optimize(AST_Dot, function(self, compressor) {\n    const parent = compressor.parent();\n    if (is_lhs(self, parent)) return self;\n    if (compressor.option(\"unsafe_proto\")\n        && self.expression instanceof AST_Dot\n        && self.expression.property == \"prototype\") {\n        var exp = self.expression.expression;\n        if (is_undeclared_ref(exp)) switch (exp.name) {\n          case \"Array\":\n            self.expression = make_node(AST_Array, self.expression, {\n                elements: []\n            });\n            break;\n          case \"Function\":\n            self.expression = make_node(AST_Function, self.expression, {\n                argnames: [],\n                body: []\n            });\n            break;\n          case \"Number\":\n            self.expression = make_node(AST_Number, self.expression, {\n                value: 0\n            });\n            break;\n          case \"Object\":\n            self.expression = make_node(AST_Object, self.expression, {\n                properties: []\n            });\n            break;\n          case \"RegExp\":\n            self.expression = make_node(AST_RegExp, self.expression, {\n                value: { source: \"t\", flags: \"\" }\n            });\n            break;\n          case \"String\":\n            self.expression = make_node(AST_String, self.expression, {\n                value: \"\"\n            });\n            break;\n        }\n    }\n    if (!(parent instanceof AST_Call) || !has_annotation(parent, _NOINLINE)) {\n        const sub = self.flatten_object(self.property, compressor);\n        if (sub) return sub.optimize(compressor);\n    }\n    let ev = self.evaluate(compressor);\n    if (ev !== self) {\n        ev = make_node_from_constant(ev, self).optimize(compressor);\n        return best_of(compressor, ev, self);\n    }\n    if (self.optional && is_nullish(self.expression, compressor)) {\n        return make_node(AST_Undefined, self);\n    }\n    return self;\n});\n\nfunction literals_in_boolean_context(self, compressor) {\n    if (compressor.in_boolean_context()) {\n        return best_of(compressor, self, make_sequence(self, [\n            self,\n            make_node(AST_True, self)\n        ]).optimize(compressor));\n    }\n    return self;\n}\n\nfunction inline_array_like_spread(elements) {\n    for (var i = 0; i < elements.length; i++) {\n        var el = elements[i];\n        if (el instanceof AST_Expansion) {\n            var expr = el.expression;\n            if (\n                expr instanceof AST_Array\n                && !expr.elements.some(elm => elm instanceof AST_Hole)\n            ) {\n                elements.splice(i, 1, ...expr.elements);\n                // Step back one, as the element at i is now new.\n                i--;\n            }\n            // In array-like spread, spreading a non-iterable value is TypeError.\n            // We therefore can’t optimize anything else, unlike with object spread.\n        }\n    }\n}\n\ndef_optimize(AST_Array, function(self, compressor) {\n    var optimized = literals_in_boolean_context(self, compressor);\n    if (optimized !== self) {\n        return optimized;\n    }\n    inline_array_like_spread(self.elements);\n    return self;\n});\n\nfunction inline_object_prop_spread(props, compressor) {\n    for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        if (prop instanceof AST_Expansion) {\n            const expr = prop.expression;\n            if (\n                expr instanceof AST_Object\n                && expr.properties.every(prop => prop instanceof AST_ObjectKeyVal)\n            ) {\n                props.splice(i, 1, ...expr.properties);\n                // Step back one, as the property at i is now new.\n                i--;\n            } else if (expr instanceof AST_Constant\n                && !(expr instanceof AST_String)) {\n                // Unlike array-like spread, in object spread, spreading a\n                // non-iterable value silently does nothing; it is thus safe\n                // to remove. AST_String is the only iterable AST_Constant.\n                props.splice(i, 1);\n            } else if (is_nullish(expr, compressor)) {\n                // Likewise, null and undefined can be silently removed.\n                props.splice(i, 1);\n            }\n        }\n    }\n}\n\ndef_optimize(AST_Object, function(self, compressor) {\n    var optimized = literals_in_boolean_context(self, compressor);\n    if (optimized !== self) {\n        return optimized;\n    }\n    inline_object_prop_spread(self.properties, compressor);\n    return self;\n});\n\ndef_optimize(AST_RegExp, literals_in_boolean_context);\n\ndef_optimize(AST_Return, function(self, compressor) {\n    if (self.value && is_undefined(self.value, compressor)) {\n        self.value = null;\n    }\n    return self;\n});\n\ndef_optimize(AST_Arrow, opt_AST_Lambda);\n\ndef_optimize(AST_Function, function(self, compressor) {\n    self = opt_AST_Lambda(self, compressor);\n    if (compressor.option(\"unsafe_arrows\")\n        && compressor.option(\"ecma\") >= 2015\n        && !self.name\n        && !self.is_generator\n        && !self.uses_arguments\n        && !self.pinned()) {\n        const uses_this = walk(self, node => {\n            if (node instanceof AST_This) return walk_abort;\n        });\n        if (!uses_this) return make_node(AST_Arrow, self, self).optimize(compressor);\n    }\n    return self;\n});\n\ndef_optimize(AST_Class, function(self) {\n    // HACK to avoid compress failure.\n    // AST_Class is not really an AST_Scope/AST_Block as it lacks a body.\n    return self;\n});\n\ndef_optimize(AST_Yield, function(self, compressor) {\n    if (self.expression && !self.is_star && is_undefined(self.expression, compressor)) {\n        self.expression = null;\n    }\n    return self;\n});\n\ndef_optimize(AST_TemplateString, function(self, compressor) {\n    if (\n        !compressor.option(\"evaluate\")\n        || compressor.parent() instanceof AST_PrefixedTemplateString\n    ) {\n        return self;\n    }\n\n    var segments = [];\n    for (var i = 0; i < self.segments.length; i++) {\n        var segment = self.segments[i];\n        if (segment instanceof AST_Node) {\n            var result = segment.evaluate(compressor);\n            // Evaluate to constant value\n            // Constant value shorter than ${segment}\n            if (result !== segment && (result + \"\").length <= segment.size() + \"${}\".length) {\n                // There should always be a previous and next segment if segment is a node\n                segments[segments.length - 1].value = segments[segments.length - 1].value + result + self.segments[++i].value;\n                continue;\n            }\n            // `before ${`innerBefore ${any} innerAfter`} after` => `before innerBefore ${any} innerAfter after`\n            // TODO:\n            // `before ${'test' + foo} after` => `before innerBefore ${any} innerAfter after`\n            // `before ${foo + 'test} after` => `before innerBefore ${any} innerAfter after`\n            if (segment instanceof AST_TemplateString) {\n                var inners = segment.segments;\n                segments[segments.length - 1].value += inners[0].value;\n                for (var j = 1; j < inners.length; j++) {\n                    segment = inners[j];\n                    segments.push(segment);\n                }\n                continue;\n            }\n        }\n        segments.push(segment);\n    }\n    self.segments = segments;\n\n    // `foo` => \"foo\"\n    if (segments.length == 1) {\n        return make_node(AST_String, self, segments[0]);\n    }\n\n    if (\n        segments.length === 3\n        && segments[1] instanceof AST_Node\n        && (\n            segments[1].is_string(compressor)\n            || segments[1].is_number(compressor)\n            || is_nullish(segments[1], compressor)\n            || compressor.option(\"unsafe\")\n        )\n    ) {\n        // `foo${bar}` => \"foo\" + bar\n        if (segments[2].value === \"\") {\n            return make_node(AST_Binary, self, {\n                operator: \"+\",\n                left: make_node(AST_String, self, {\n                    value: segments[0].value,\n                }),\n                right: segments[1],\n            });\n        }\n        // `${bar}baz` => bar + \"baz\"\n        if (segments[0].value === \"\") {\n            return make_node(AST_Binary, self, {\n                operator: \"+\",\n                left: segments[1],\n                right: make_node(AST_String, self, {\n                    value: segments[2].value,\n                }),\n            });\n        }\n    }\n    return self;\n});\n\ndef_optimize(AST_PrefixedTemplateString, function(self) {\n    return self;\n});\n\n// [\"p\"]:1 ---> p:1\n// [42]:1 ---> 42:1\nfunction lift_key(self, compressor) {\n    if (!compressor.option(\"computed_props\")) return self;\n    // save a comparison in the typical case\n    if (!(self.key instanceof AST_Constant)) return self;\n    // allow certain acceptable props as not all AST_Constants are true constants\n    if (self.key instanceof AST_String || self.key instanceof AST_Number) {\n        if (self.key.value === \"__proto__\") return self;\n        if (self.key.value == \"constructor\"\n            && compressor.parent() instanceof AST_Class) return self;\n        if (self instanceof AST_ObjectKeyVal) {\n            self.key = self.key.value;\n        } else if (self instanceof AST_ClassProperty) {\n            self.key = make_node(AST_SymbolClassProperty, self.key, {\n                name: self.key.value\n            });\n        } else {\n            self.key = make_node(AST_SymbolMethod, self.key, {\n                name: self.key.value\n            });\n        }\n    }\n    return self;\n}\n\ndef_optimize(AST_ObjectProperty, lift_key);\n\ndef_optimize(AST_ConciseMethod, function(self, compressor) {\n    lift_key(self, compressor);\n    // p(){return x;} ---> p:()=>x\n    if (compressor.option(\"arrows\")\n        && compressor.parent() instanceof AST_Object\n        && !self.is_generator\n        && !self.value.uses_arguments\n        && !self.value.pinned()\n        && self.value.body.length == 1\n        && self.value.body[0] instanceof AST_Return\n        && self.value.body[0].value\n        && !self.value.contains_this()) {\n        var arrow = make_node(AST_Arrow, self.value, self.value);\n        arrow.async = self.async;\n        arrow.is_generator = self.is_generator;\n        return make_node(AST_ObjectKeyVal, self, {\n            key: self.key instanceof AST_SymbolMethod ? self.key.name : self.key,\n            value: arrow,\n            quote: self.quote,\n        });\n    }\n    return self;\n});\n\ndef_optimize(AST_ObjectKeyVal, function(self, compressor) {\n    lift_key(self, compressor);\n    // p:function(){} ---> p(){}\n    // p:function*(){} ---> *p(){}\n    // p:async function(){} ---> async p(){}\n    // p:()=>{} ---> p(){}\n    // p:async()=>{} ---> async p(){}\n    var unsafe_methods = compressor.option(\"unsafe_methods\");\n    if (unsafe_methods\n        && compressor.option(\"ecma\") >= 2015\n        && (!(unsafe_methods instanceof RegExp) || unsafe_methods.test(self.key + \"\"))) {\n        var key = self.key;\n        var value = self.value;\n        var is_arrow_with_block = value instanceof AST_Arrow\n            && Array.isArray(value.body)\n            && !value.contains_this();\n        if ((is_arrow_with_block || value instanceof AST_Function) && !value.name) {\n            return make_node(AST_ConciseMethod, self, {\n                async: value.async,\n                is_generator: value.is_generator,\n                key: key instanceof AST_Node ? key : make_node(AST_SymbolMethod, self, {\n                    name: key,\n                }),\n                value: make_node(AST_Accessor, value, value),\n                quote: self.quote,\n            });\n        }\n    }\n    return self;\n});\n\ndef_optimize(AST_Destructuring, function(self, compressor) {\n    if (compressor.option(\"pure_getters\") == true\n        && compressor.option(\"unused\")\n        && !self.is_array\n        && Array.isArray(self.names)\n        && !is_destructuring_export_decl(compressor)\n        && !(self.names[self.names.length - 1] instanceof AST_Expansion)) {\n        var keep = [];\n        for (var i = 0; i < self.names.length; i++) {\n            var elem = self.names[i];\n            if (!(elem instanceof AST_ObjectKeyVal\n                && typeof elem.key == \"string\"\n                && elem.value instanceof AST_SymbolDeclaration\n                && !should_retain(compressor, elem.value.definition()))) {\n                keep.push(elem);\n            }\n        }\n        if (keep.length != self.names.length) {\n            self.names = keep;\n        }\n    }\n    return self;\n\n    function is_destructuring_export_decl(compressor) {\n        var ancestors = [/^VarDef$/, /^(Const|Let|Var)$/, /^Export$/];\n        for (var a = 0, p = 0, len = ancestors.length; a < len; p++) {\n            var parent = compressor.parent(p);\n            if (!parent) return false;\n            if (a === 0 && parent.TYPE == \"Destructuring\") continue;\n            if (!ancestors[a].test(parent.TYPE)) {\n                return false;\n            }\n            a++;\n        }\n        return true;\n    }\n\n    function should_retain(compressor, def) {\n        if (def.references.length) return true;\n        if (!def.global) return false;\n        if (compressor.toplevel.vars) {\n             if (compressor.top_retain) {\n                 return compressor.top_retain(def);\n             }\n             return false;\n        }\n        return true;\n    }\n});\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n// a small wrapper around fitzgen's source-map library\nasync function SourceMap(options) {\n    options = defaults(options, {\n        file : null,\n        root : null,\n        orig : null,\n\n        orig_line_diff : 0,\n        dest_line_diff : 0,\n    });\n\n    var orig_map;\n    var generator = new MOZ_SourceMap__default['default'].SourceMapGenerator({\n        file       : options.file,\n        sourceRoot : options.root\n    });\n\n    if (options.orig) {\n        orig_map = await new MOZ_SourceMap__default['default'].SourceMapConsumer(options.orig);\n        orig_map.sources.forEach(function(source) {\n            var sourceContent = orig_map.sourceContentFor(source, true);\n            if (sourceContent) {\n                generator.setSourceContent(source, sourceContent);\n            }\n        });\n    }\n\n    function add(source, gen_line, gen_col, orig_line, orig_col, name) {\n        if (orig_map) {\n            var info = orig_map.originalPositionFor({\n                line: orig_line,\n                column: orig_col\n            });\n            if (info.source === null) {\n                return;\n            }\n            source = info.source;\n            orig_line = info.line;\n            orig_col = info.column;\n            name = info.name || name;\n        }\n        generator.addMapping({\n            generated : { line: gen_line + options.dest_line_diff, column: gen_col },\n            original  : { line: orig_line + options.orig_line_diff, column: orig_col },\n            source    : source,\n            name      : name\n        });\n    }\n\n    return {\n        add        : add,\n        get        : function() { return generator; },\n        toString   : function() { return generator.toString(); },\n        destroy    : function () {\n            if (orig_map && orig_map.destroy) {\n                orig_map.destroy();\n            }\n        }\n    };\n}\n\nvar domprops = [\n    \"$&\",\n    \"$'\",\n    \"$*\",\n    \"$+\",\n    \"$1\",\n    \"$2\",\n    \"$3\",\n    \"$4\",\n    \"$5\",\n    \"$6\",\n    \"$7\",\n    \"$8\",\n    \"$9\",\n    \"$_\",\n    \"$`\",\n    \"$input\",\n    \"-moz-animation\",\n    \"-moz-animation-delay\",\n    \"-moz-animation-direction\",\n    \"-moz-animation-duration\",\n    \"-moz-animation-fill-mode\",\n    \"-moz-animation-iteration-count\",\n    \"-moz-animation-name\",\n    \"-moz-animation-play-state\",\n    \"-moz-animation-timing-function\",\n    \"-moz-appearance\",\n    \"-moz-backface-visibility\",\n    \"-moz-border-end\",\n    \"-moz-border-end-color\",\n    \"-moz-border-end-style\",\n    \"-moz-border-end-width\",\n    \"-moz-border-image\",\n    \"-moz-border-start\",\n    \"-moz-border-start-color\",\n    \"-moz-border-start-style\",\n    \"-moz-border-start-width\",\n    \"-moz-box-align\",\n    \"-moz-box-direction\",\n    \"-moz-box-flex\",\n    \"-moz-box-ordinal-group\",\n    \"-moz-box-orient\",\n    \"-moz-box-pack\",\n    \"-moz-box-sizing\",\n    \"-moz-float-edge\",\n    \"-moz-font-feature-settings\",\n    \"-moz-font-language-override\",\n    \"-moz-force-broken-image-icon\",\n    \"-moz-hyphens\",\n    \"-moz-image-region\",\n    \"-moz-margin-end\",\n    \"-moz-margin-start\",\n    \"-moz-orient\",\n    \"-moz-osx-font-smoothing\",\n    \"-moz-outline-radius\",\n    \"-moz-outline-radius-bottomleft\",\n    \"-moz-outline-radius-bottomright\",\n    \"-moz-outline-radius-topleft\",\n    \"-moz-outline-radius-topright\",\n    \"-moz-padding-end\",\n    \"-moz-padding-start\",\n    \"-moz-perspective\",\n    \"-moz-perspective-origin\",\n    \"-moz-tab-size\",\n    \"-moz-text-size-adjust\",\n    \"-moz-transform\",\n    \"-moz-transform-origin\",\n    \"-moz-transform-style\",\n    \"-moz-transition\",\n    \"-moz-transition-delay\",\n    \"-moz-transition-duration\",\n    \"-moz-transition-property\",\n    \"-moz-transition-timing-function\",\n    \"-moz-user-focus\",\n    \"-moz-user-input\",\n    \"-moz-user-modify\",\n    \"-moz-user-select\",\n    \"-moz-window-dragging\",\n    \"-webkit-align-content\",\n    \"-webkit-align-items\",\n    \"-webkit-align-self\",\n    \"-webkit-animation\",\n    \"-webkit-animation-delay\",\n    \"-webkit-animation-direction\",\n    \"-webkit-animation-duration\",\n    \"-webkit-animation-fill-mode\",\n    \"-webkit-animation-iteration-count\",\n    \"-webkit-animation-name\",\n    \"-webkit-animation-play-state\",\n    \"-webkit-animation-timing-function\",\n    \"-webkit-appearance\",\n    \"-webkit-backface-visibility\",\n    \"-webkit-background-clip\",\n    \"-webkit-background-origin\",\n    \"-webkit-background-size\",\n    \"-webkit-border-bottom-left-radius\",\n    \"-webkit-border-bottom-right-radius\",\n    \"-webkit-border-image\",\n    \"-webkit-border-radius\",\n    \"-webkit-border-top-left-radius\",\n    \"-webkit-border-top-right-radius\",\n    \"-webkit-box-align\",\n    \"-webkit-box-direction\",\n    \"-webkit-box-flex\",\n    \"-webkit-box-ordinal-group\",\n    \"-webkit-box-orient\",\n    \"-webkit-box-pack\",\n    \"-webkit-box-shadow\",\n    \"-webkit-box-sizing\",\n    \"-webkit-filter\",\n    \"-webkit-flex\",\n    \"-webkit-flex-basis\",\n    \"-webkit-flex-direction\",\n    \"-webkit-flex-flow\",\n    \"-webkit-flex-grow\",\n    \"-webkit-flex-shrink\",\n    \"-webkit-flex-wrap\",\n    \"-webkit-justify-content\",\n    \"-webkit-line-clamp\",\n    \"-webkit-mask\",\n    \"-webkit-mask-clip\",\n    \"-webkit-mask-composite\",\n    \"-webkit-mask-image\",\n    \"-webkit-mask-origin\",\n    \"-webkit-mask-position\",\n    \"-webkit-mask-position-x\",\n    \"-webkit-mask-position-y\",\n    \"-webkit-mask-repeat\",\n    \"-webkit-mask-size\",\n    \"-webkit-order\",\n    \"-webkit-perspective\",\n    \"-webkit-perspective-origin\",\n    \"-webkit-text-fill-color\",\n    \"-webkit-text-size-adjust\",\n    \"-webkit-text-stroke\",\n    \"-webkit-text-stroke-color\",\n    \"-webkit-text-stroke-width\",\n    \"-webkit-transform\",\n    \"-webkit-transform-origin\",\n    \"-webkit-transform-style\",\n    \"-webkit-transition\",\n    \"-webkit-transition-delay\",\n    \"-webkit-transition-duration\",\n    \"-webkit-transition-property\",\n    \"-webkit-transition-timing-function\",\n    \"-webkit-user-select\",\n    \"0\",\n    \"1\",\n    \"10\",\n    \"11\",\n    \"12\",\n    \"13\",\n    \"14\",\n    \"15\",\n    \"16\",\n    \"17\",\n    \"18\",\n    \"19\",\n    \"2\",\n    \"20\",\n    \"3\",\n    \"4\",\n    \"5\",\n    \"6\",\n    \"7\",\n    \"8\",\n    \"9\",\n    \"@@iterator\",\n    \"ABORT_ERR\",\n    \"ACTIVE\",\n    \"ACTIVE_ATTRIBUTES\",\n    \"ACTIVE_TEXTURE\",\n    \"ACTIVE_UNIFORMS\",\n    \"ACTIVE_UNIFORM_BLOCKS\",\n    \"ADDITION\",\n    \"ALIASED_LINE_WIDTH_RANGE\",\n    \"ALIASED_POINT_SIZE_RANGE\",\n    \"ALLOW_KEYBOARD_INPUT\",\n    \"ALLPASS\",\n    \"ALPHA\",\n    \"ALPHA_BITS\",\n    \"ALREADY_SIGNALED\",\n    \"ALT_MASK\",\n    \"ALWAYS\",\n    \"ANY_SAMPLES_PASSED\",\n    \"ANY_SAMPLES_PASSED_CONSERVATIVE\",\n    \"ANY_TYPE\",\n    \"ANY_UNORDERED_NODE_TYPE\",\n    \"ARRAY_BUFFER\",\n    \"ARRAY_BUFFER_BINDING\",\n    \"ATTACHED_SHADERS\",\n    \"ATTRIBUTE_NODE\",\n    \"AT_TARGET\",\n    \"AbortController\",\n    \"AbortSignal\",\n    \"AbsoluteOrientationSensor\",\n    \"AbstractRange\",\n    \"Accelerometer\",\n    \"AddSearchProvider\",\n    \"AggregateError\",\n    \"AnalyserNode\",\n    \"Animation\",\n    \"AnimationEffect\",\n    \"AnimationEvent\",\n    \"AnimationPlaybackEvent\",\n    \"AnimationTimeline\",\n    \"AnonXMLHttpRequest\",\n    \"Any\",\n    \"ApplicationCache\",\n    \"ApplicationCacheErrorEvent\",\n    \"Array\",\n    \"ArrayBuffer\",\n    \"ArrayType\",\n    \"Atomics\",\n    \"Attr\",\n    \"Audio\",\n    \"AudioBuffer\",\n    \"AudioBufferSourceNode\",\n    \"AudioContext\",\n    \"AudioDestinationNode\",\n    \"AudioListener\",\n    \"AudioNode\",\n    \"AudioParam\",\n    \"AudioParamMap\",\n    \"AudioProcessingEvent\",\n    \"AudioScheduledSourceNode\",\n    \"AudioStreamTrack\",\n    \"AudioWorklet\",\n    \"AudioWorkletNode\",\n    \"AuthenticatorAssertionResponse\",\n    \"AuthenticatorAttestationResponse\",\n    \"AuthenticatorResponse\",\n    \"AutocompleteErrorEvent\",\n    \"BACK\",\n    \"BAD_BOUNDARYPOINTS_ERR\",\n    \"BAD_REQUEST\",\n    \"BANDPASS\",\n    \"BLEND\",\n    \"BLEND_COLOR\",\n    \"BLEND_DST_ALPHA\",\n    \"BLEND_DST_RGB\",\n    \"BLEND_EQUATION\",\n    \"BLEND_EQUATION_ALPHA\",\n    \"BLEND_EQUATION_RGB\",\n    \"BLEND_SRC_ALPHA\",\n    \"BLEND_SRC_RGB\",\n    \"BLUE_BITS\",\n    \"BLUR\",\n    \"BOOL\",\n    \"BOOLEAN_TYPE\",\n    \"BOOL_VEC2\",\n    \"BOOL_VEC3\",\n    \"BOOL_VEC4\",\n    \"BOTH\",\n    \"BROWSER_DEFAULT_WEBGL\",\n    \"BUBBLING_PHASE\",\n    \"BUFFER_SIZE\",\n    \"BUFFER_USAGE\",\n    \"BYTE\",\n    \"BYTES_PER_ELEMENT\",\n    \"BackgroundFetchManager\",\n    \"BackgroundFetchRecord\",\n    \"BackgroundFetchRegistration\",\n    \"BarProp\",\n    \"BarcodeDetector\",\n    \"BaseAudioContext\",\n    \"BaseHref\",\n    \"BatteryManager\",\n    \"BeforeInstallPromptEvent\",\n    \"BeforeLoadEvent\",\n    \"BeforeUnloadEvent\",\n    \"BigInt\",\n    \"BigInt64Array\",\n    \"BigUint64Array\",\n    \"BiquadFilterNode\",\n    \"Blob\",\n    \"BlobEvent\",\n    \"Bluetooth\",\n    \"BluetoothCharacteristicProperties\",\n    \"BluetoothDevice\",\n    \"BluetoothRemoteGATTCharacteristic\",\n    \"BluetoothRemoteGATTDescriptor\",\n    \"BluetoothRemoteGATTServer\",\n    \"BluetoothRemoteGATTService\",\n    \"BluetoothUUID\",\n    \"Boolean\",\n    \"BroadcastChannel\",\n    \"ByteLengthQueuingStrategy\",\n    \"CAPTURING_PHASE\",\n    \"CCW\",\n    \"CDATASection\",\n    \"CDATA_SECTION_NODE\",\n    \"CHANGE\",\n    \"CHARSET_RULE\",\n    \"CHECKING\",\n    \"CLAMP_TO_EDGE\",\n    \"CLICK\",\n    \"CLOSED\",\n    \"CLOSING\",\n    \"COLOR\",\n    \"COLOR_ATTACHMENT0\",\n    \"COLOR_ATTACHMENT1\",\n    \"COLOR_ATTACHMENT10\",\n    \"COLOR_ATTACHMENT11\",\n    \"COLOR_ATTACHMENT12\",\n    \"COLOR_ATTACHMENT13\",\n    \"COLOR_ATTACHMENT14\",\n    \"COLOR_ATTACHMENT15\",\n    \"COLOR_ATTACHMENT2\",\n    \"COLOR_ATTACHMENT3\",\n    \"COLOR_ATTACHMENT4\",\n    \"COLOR_ATTACHMENT5\",\n    \"COLOR_ATTACHMENT6\",\n    \"COLOR_ATTACHMENT7\",\n    \"COLOR_ATTACHMENT8\",\n    \"COLOR_ATTACHMENT9\",\n    \"COLOR_BUFFER_BIT\",\n    \"COLOR_CLEAR_VALUE\",\n    \"COLOR_WRITEMASK\",\n    \"COMMENT_NODE\",\n    \"COMPARE_REF_TO_TEXTURE\",\n    \"COMPILE_STATUS\",\n    \"COMPRESSED_RGBA_S3TC_DXT1_EXT\",\n    \"COMPRESSED_RGBA_S3TC_DXT3_EXT\",\n    \"COMPRESSED_RGBA_S3TC_DXT5_EXT\",\n    \"COMPRESSED_RGB_S3TC_DXT1_EXT\",\n    \"COMPRESSED_TEXTURE_FORMATS\",\n    \"CONDITION_SATISFIED\",\n    \"CONFIGURATION_UNSUPPORTED\",\n    \"CONNECTING\",\n    \"CONSTANT_ALPHA\",\n    \"CONSTANT_COLOR\",\n    \"CONSTRAINT_ERR\",\n    \"CONTEXT_LOST_WEBGL\",\n    \"CONTROL_MASK\",\n    \"COPY_READ_BUFFER\",\n    \"COPY_READ_BUFFER_BINDING\",\n    \"COPY_WRITE_BUFFER\",\n    \"COPY_WRITE_BUFFER_BINDING\",\n    \"COUNTER_STYLE_RULE\",\n    \"CSS\",\n    \"CSS2Properties\",\n    \"CSSAnimation\",\n    \"CSSCharsetRule\",\n    \"CSSConditionRule\",\n    \"CSSCounterStyleRule\",\n    \"CSSFontFaceRule\",\n    \"CSSFontFeatureValuesRule\",\n    \"CSSGroupingRule\",\n    \"CSSImageValue\",\n    \"CSSImportRule\",\n    \"CSSKeyframeRule\",\n    \"CSSKeyframesRule\",\n    \"CSSKeywordValue\",\n    \"CSSMathInvert\",\n    \"CSSMathMax\",\n    \"CSSMathMin\",\n    \"CSSMathNegate\",\n    \"CSSMathProduct\",\n    \"CSSMathSum\",\n    \"CSSMathValue\",\n    \"CSSMatrixComponent\",\n    \"CSSMediaRule\",\n    \"CSSMozDocumentRule\",\n    \"CSSNameSpaceRule\",\n    \"CSSNamespaceRule\",\n    \"CSSNumericArray\",\n    \"CSSNumericValue\",\n    \"CSSPageRule\",\n    \"CSSPerspective\",\n    \"CSSPositionValue\",\n    \"CSSPrimitiveValue\",\n    \"CSSRotate\",\n    \"CSSRule\",\n    \"CSSRuleList\",\n    \"CSSScale\",\n    \"CSSSkew\",\n    \"CSSSkewX\",\n    \"CSSSkewY\",\n    \"CSSStyleDeclaration\",\n    \"CSSStyleRule\",\n    \"CSSStyleSheet\",\n    \"CSSStyleValue\",\n    \"CSSSupportsRule\",\n    \"CSSTransformComponent\",\n    \"CSSTransformValue\",\n    \"CSSTransition\",\n    \"CSSTranslate\",\n    \"CSSUnitValue\",\n    \"CSSUnknownRule\",\n    \"CSSUnparsedValue\",\n    \"CSSValue\",\n    \"CSSValueList\",\n    \"CSSVariableReferenceValue\",\n    \"CSSVariablesDeclaration\",\n    \"CSSVariablesRule\",\n    \"CSSViewportRule\",\n    \"CSS_ATTR\",\n    \"CSS_CM\",\n    \"CSS_COUNTER\",\n    \"CSS_CUSTOM\",\n    \"CSS_DEG\",\n    \"CSS_DIMENSION\",\n    \"CSS_EMS\",\n    \"CSS_EXS\",\n    \"CSS_FILTER_BLUR\",\n    \"CSS_FILTER_BRIGHTNESS\",\n    \"CSS_FILTER_CONTRAST\",\n    \"CSS_FILTER_CUSTOM\",\n    \"CSS_FILTER_DROP_SHADOW\",\n    \"CSS_FILTER_GRAYSCALE\",\n    \"CSS_FILTER_HUE_ROTATE\",\n    \"CSS_FILTER_INVERT\",\n    \"CSS_FILTER_OPACITY\",\n    \"CSS_FILTER_REFERENCE\",\n    \"CSS_FILTER_SATURATE\",\n    \"CSS_FILTER_SEPIA\",\n    \"CSS_GRAD\",\n    \"CSS_HZ\",\n    \"CSS_IDENT\",\n    \"CSS_IN\",\n    \"CSS_INHERIT\",\n    \"CSS_KHZ\",\n    \"CSS_MATRIX\",\n    \"CSS_MATRIX3D\",\n    \"CSS_MM\",\n    \"CSS_MS\",\n    \"CSS_NUMBER\",\n    \"CSS_PC\",\n    \"CSS_PERCENTAGE\",\n    \"CSS_PERSPECTIVE\",\n    \"CSS_PRIMITIVE_VALUE\",\n    \"CSS_PT\",\n    \"CSS_PX\",\n    \"CSS_RAD\",\n    \"CSS_RECT\",\n    \"CSS_RGBCOLOR\",\n    \"CSS_ROTATE\",\n    \"CSS_ROTATE3D\",\n    \"CSS_ROTATEX\",\n    \"CSS_ROTATEY\",\n    \"CSS_ROTATEZ\",\n    \"CSS_S\",\n    \"CSS_SCALE\",\n    \"CSS_SCALE3D\",\n    \"CSS_SCALEX\",\n    \"CSS_SCALEY\",\n    \"CSS_SCALEZ\",\n    \"CSS_SKEW\",\n    \"CSS_SKEWX\",\n    \"CSS_SKEWY\",\n    \"CSS_STRING\",\n    \"CSS_TRANSLATE\",\n    \"CSS_TRANSLATE3D\",\n    \"CSS_TRANSLATEX\",\n    \"CSS_TRANSLATEY\",\n    \"CSS_TRANSLATEZ\",\n    \"CSS_UNKNOWN\",\n    \"CSS_URI\",\n    \"CSS_VALUE_LIST\",\n    \"CSS_VH\",\n    \"CSS_VMAX\",\n    \"CSS_VMIN\",\n    \"CSS_VW\",\n    \"CULL_FACE\",\n    \"CULL_FACE_MODE\",\n    \"CURRENT_PROGRAM\",\n    \"CURRENT_QUERY\",\n    \"CURRENT_VERTEX_ATTRIB\",\n    \"CUSTOM\",\n    \"CW\",\n    \"Cache\",\n    \"CacheStorage\",\n    \"CanvasCaptureMediaStream\",\n    \"CanvasCaptureMediaStreamTrack\",\n    \"CanvasGradient\",\n    \"CanvasPattern\",\n    \"CanvasRenderingContext2D\",\n    \"CaretPosition\",\n    \"ChannelMergerNode\",\n    \"ChannelSplitterNode\",\n    \"CharacterData\",\n    \"ClientRect\",\n    \"ClientRectList\",\n    \"Clipboard\",\n    \"ClipboardEvent\",\n    \"ClipboardItem\",\n    \"CloseEvent\",\n    \"Collator\",\n    \"CommandEvent\",\n    \"Comment\",\n    \"CompileError\",\n    \"CompositionEvent\",\n    \"CompressionStream\",\n    \"Console\",\n    \"ConstantSourceNode\",\n    \"Controllers\",\n    \"ConvolverNode\",\n    \"CountQueuingStrategy\",\n    \"Counter\",\n    \"Credential\",\n    \"CredentialsContainer\",\n    \"Crypto\",\n    \"CryptoKey\",\n    \"CustomElementRegistry\",\n    \"CustomEvent\",\n    \"DATABASE_ERR\",\n    \"DATA_CLONE_ERR\",\n    \"DATA_ERR\",\n    \"DBLCLICK\",\n    \"DECR\",\n    \"DECR_WRAP\",\n    \"DELETE_STATUS\",\n    \"DEPTH\",\n    \"DEPTH24_STENCIL8\",\n    \"DEPTH32F_STENCIL8\",\n    \"DEPTH_ATTACHMENT\",\n    \"DEPTH_BITS\",\n    \"DEPTH_BUFFER_BIT\",\n    \"DEPTH_CLEAR_VALUE\",\n    \"DEPTH_COMPONENT\",\n    \"DEPTH_COMPONENT16\",\n    \"DEPTH_COMPONENT24\",\n    \"DEPTH_COMPONENT32F\",\n    \"DEPTH_FUNC\",\n    \"DEPTH_RANGE\",\n    \"DEPTH_STENCIL\",\n    \"DEPTH_STENCIL_ATTACHMENT\",\n    \"DEPTH_TEST\",\n    \"DEPTH_WRITEMASK\",\n    \"DEVICE_INELIGIBLE\",\n    \"DIRECTION_DOWN\",\n    \"DIRECTION_LEFT\",\n    \"DIRECTION_RIGHT\",\n    \"DIRECTION_UP\",\n    \"DISABLED\",\n    \"DISPATCH_REQUEST_ERR\",\n    \"DITHER\",\n    \"DOCUMENT_FRAGMENT_NODE\",\n    \"DOCUMENT_NODE\",\n    \"DOCUMENT_POSITION_CONTAINED_BY\",\n    \"DOCUMENT_POSITION_CONTAINS\",\n    \"DOCUMENT_POSITION_DISCONNECTED\",\n    \"DOCUMENT_POSITION_FOLLOWING\",\n    \"DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\",\n    \"DOCUMENT_POSITION_PRECEDING\",\n    \"DOCUMENT_TYPE_NODE\",\n    \"DOMCursor\",\n    \"DOMError\",\n    \"DOMException\",\n    \"DOMImplementation\",\n    \"DOMImplementationLS\",\n    \"DOMMatrix\",\n    \"DOMMatrixReadOnly\",\n    \"DOMParser\",\n    \"DOMPoint\",\n    \"DOMPointReadOnly\",\n    \"DOMQuad\",\n    \"DOMRect\",\n    \"DOMRectList\",\n    \"DOMRectReadOnly\",\n    \"DOMRequest\",\n    \"DOMSTRING_SIZE_ERR\",\n    \"DOMSettableTokenList\",\n    \"DOMStringList\",\n    \"DOMStringMap\",\n    \"DOMTokenList\",\n    \"DOMTransactionEvent\",\n    \"DOM_DELTA_LINE\",\n    \"DOM_DELTA_PAGE\",\n    \"DOM_DELTA_PIXEL\",\n    \"DOM_INPUT_METHOD_DROP\",\n    \"DOM_INPUT_METHOD_HANDWRITING\",\n    \"DOM_INPUT_METHOD_IME\",\n    \"DOM_INPUT_METHOD_KEYBOARD\",\n    \"DOM_INPUT_METHOD_MULTIMODAL\",\n    \"DOM_INPUT_METHOD_OPTION\",\n    \"DOM_INPUT_METHOD_PASTE\",\n    \"DOM_INPUT_METHOD_SCRIPT\",\n    \"DOM_INPUT_METHOD_UNKNOWN\",\n    \"DOM_INPUT_METHOD_VOICE\",\n    \"DOM_KEY_LOCATION_JOYSTICK\",\n    \"DOM_KEY_LOCATION_LEFT\",\n    \"DOM_KEY_LOCATION_MOBILE\",\n    \"DOM_KEY_LOCATION_NUMPAD\",\n    \"DOM_KEY_LOCATION_RIGHT\",\n    \"DOM_KEY_LOCATION_STANDARD\",\n    \"DOM_VK_0\",\n    \"DOM_VK_1\",\n    \"DOM_VK_2\",\n    \"DOM_VK_3\",\n    \"DOM_VK_4\",\n    \"DOM_VK_5\",\n    \"DOM_VK_6\",\n    \"DOM_VK_7\",\n    \"DOM_VK_8\",\n    \"DOM_VK_9\",\n    \"DOM_VK_A\",\n    \"DOM_VK_ACCEPT\",\n    \"DOM_VK_ADD\",\n    \"DOM_VK_ALT\",\n    \"DOM_VK_ALTGR\",\n    \"DOM_VK_AMPERSAND\",\n    \"DOM_VK_ASTERISK\",\n    \"DOM_VK_AT\",\n    \"DOM_VK_ATTN\",\n    \"DOM_VK_B\",\n    \"DOM_VK_BACKSPACE\",\n    \"DOM_VK_BACK_QUOTE\",\n    \"DOM_VK_BACK_SLASH\",\n    \"DOM_VK_BACK_SPACE\",\n    \"DOM_VK_C\",\n    \"DOM_VK_CANCEL\",\n    \"DOM_VK_CAPS_LOCK\",\n    \"DOM_VK_CIRCUMFLEX\",\n    \"DOM_VK_CLEAR\",\n    \"DOM_VK_CLOSE_BRACKET\",\n    \"DOM_VK_CLOSE_CURLY_BRACKET\",\n    \"DOM_VK_CLOSE_PAREN\",\n    \"DOM_VK_COLON\",\n    \"DOM_VK_COMMA\",\n    \"DOM_VK_CONTEXT_MENU\",\n    \"DOM_VK_CONTROL\",\n    \"DOM_VK_CONVERT\",\n    \"DOM_VK_CRSEL\",\n    \"DOM_VK_CTRL\",\n    \"DOM_VK_D\",\n    \"DOM_VK_DECIMAL\",\n    \"DOM_VK_DELETE\",\n    \"DOM_VK_DIVIDE\",\n    \"DOM_VK_DOLLAR\",\n    \"DOM_VK_DOUBLE_QUOTE\",\n    \"DOM_VK_DOWN\",\n    \"DOM_VK_E\",\n    \"DOM_VK_EISU\",\n    \"DOM_VK_END\",\n    \"DOM_VK_ENTER\",\n    \"DOM_VK_EQUALS\",\n    \"DOM_VK_EREOF\",\n    \"DOM_VK_ESCAPE\",\n    \"DOM_VK_EXCLAMATION\",\n    \"DOM_VK_EXECUTE\",\n    \"DOM_VK_EXSEL\",\n    \"DOM_VK_F\",\n    \"DOM_VK_F1\",\n    \"DOM_VK_F10\",\n    \"DOM_VK_F11\",\n    \"DOM_VK_F12\",\n    \"DOM_VK_F13\",\n    \"DOM_VK_F14\",\n    \"DOM_VK_F15\",\n    \"DOM_VK_F16\",\n    \"DOM_VK_F17\",\n    \"DOM_VK_F18\",\n    \"DOM_VK_F19\",\n    \"DOM_VK_F2\",\n    \"DOM_VK_F20\",\n    \"DOM_VK_F21\",\n    \"DOM_VK_F22\",\n    \"DOM_VK_F23\",\n    \"DOM_VK_F24\",\n    \"DOM_VK_F25\",\n    \"DOM_VK_F26\",\n    \"DOM_VK_F27\",\n    \"DOM_VK_F28\",\n    \"DOM_VK_F29\",\n    \"DOM_VK_F3\",\n    \"DOM_VK_F30\",\n    \"DOM_VK_F31\",\n    \"DOM_VK_F32\",\n    \"DOM_VK_F33\",\n    \"DOM_VK_F34\",\n    \"DOM_VK_F35\",\n    \"DOM_VK_F36\",\n    \"DOM_VK_F4\",\n    \"DOM_VK_F5\",\n    \"DOM_VK_F6\",\n    \"DOM_VK_F7\",\n    \"DOM_VK_F8\",\n    \"DOM_VK_F9\",\n    \"DOM_VK_FINAL\",\n    \"DOM_VK_FRONT\",\n    \"DOM_VK_G\",\n    \"DOM_VK_GREATER_THAN\",\n    \"DOM_VK_H\",\n    \"DOM_VK_HANGUL\",\n    \"DOM_VK_HANJA\",\n    \"DOM_VK_HASH\",\n    \"DOM_VK_HELP\",\n    \"DOM_VK_HK_TOGGLE\",\n    \"DOM_VK_HOME\",\n    \"DOM_VK_HYPHEN_MINUS\",\n    \"DOM_VK_I\",\n    \"DOM_VK_INSERT\",\n    \"DOM_VK_J\",\n    \"DOM_VK_JUNJA\",\n    \"DOM_VK_K\",\n    \"DOM_VK_KANA\",\n    \"DOM_VK_KANJI\",\n    \"DOM_VK_L\",\n    \"DOM_VK_LEFT\",\n    \"DOM_VK_LEFT_TAB\",\n    \"DOM_VK_LESS_THAN\",\n    \"DOM_VK_M\",\n    \"DOM_VK_META\",\n    \"DOM_VK_MODECHANGE\",\n    \"DOM_VK_MULTIPLY\",\n    \"DOM_VK_N\",\n    \"DOM_VK_NONCONVERT\",\n    \"DOM_VK_NUMPAD0\",\n    \"DOM_VK_NUMPAD1\",\n    \"DOM_VK_NUMPAD2\",\n    \"DOM_VK_NUMPAD3\",\n    \"DOM_VK_NUMPAD4\",\n    \"DOM_VK_NUMPAD5\",\n    \"DOM_VK_NUMPAD6\",\n    \"DOM_VK_NUMPAD7\",\n    \"DOM_VK_NUMPAD8\",\n    \"DOM_VK_NUMPAD9\",\n    \"DOM_VK_NUM_LOCK\",\n    \"DOM_VK_O\",\n    \"DOM_VK_OEM_1\",\n    \"DOM_VK_OEM_102\",\n    \"DOM_VK_OEM_2\",\n    \"DOM_VK_OEM_3\",\n    \"DOM_VK_OEM_4\",\n    \"DOM_VK_OEM_5\",\n    \"DOM_VK_OEM_6\",\n    \"DOM_VK_OEM_7\",\n    \"DOM_VK_OEM_8\",\n    \"DOM_VK_OEM_COMMA\",\n    \"DOM_VK_OEM_MINUS\",\n    \"DOM_VK_OEM_PERIOD\",\n    \"DOM_VK_OEM_PLUS\",\n    \"DOM_VK_OPEN_BRACKET\",\n    \"DOM_VK_OPEN_CURLY_BRACKET\",\n    \"DOM_VK_OPEN_PAREN\",\n    \"DOM_VK_P\",\n    \"DOM_VK_PA1\",\n    \"DOM_VK_PAGEDOWN\",\n    \"DOM_VK_PAGEUP\",\n    \"DOM_VK_PAGE_DOWN\",\n    \"DOM_VK_PAGE_UP\",\n    \"DOM_VK_PAUSE\",\n    \"DOM_VK_PERCENT\",\n    \"DOM_VK_PERIOD\",\n    \"DOM_VK_PIPE\",\n    \"DOM_VK_PLAY\",\n    \"DOM_VK_PLUS\",\n    \"DOM_VK_PRINT\",\n    \"DOM_VK_PRINTSCREEN\",\n    \"DOM_VK_PROCESSKEY\",\n    \"DOM_VK_PROPERITES\",\n    \"DOM_VK_Q\",\n    \"DOM_VK_QUESTION_MARK\",\n    \"DOM_VK_QUOTE\",\n    \"DOM_VK_R\",\n    \"DOM_VK_REDO\",\n    \"DOM_VK_RETURN\",\n    \"DOM_VK_RIGHT\",\n    \"DOM_VK_S\",\n    \"DOM_VK_SCROLL_LOCK\",\n    \"DOM_VK_SELECT\",\n    \"DOM_VK_SEMICOLON\",\n    \"DOM_VK_SEPARATOR\",\n    \"DOM_VK_SHIFT\",\n    \"DOM_VK_SLASH\",\n    \"DOM_VK_SLEEP\",\n    \"DOM_VK_SPACE\",\n    \"DOM_VK_SUBTRACT\",\n    \"DOM_VK_T\",\n    \"DOM_VK_TAB\",\n    \"DOM_VK_TILDE\",\n    \"DOM_VK_U\",\n    \"DOM_VK_UNDERSCORE\",\n    \"DOM_VK_UNDO\",\n    \"DOM_VK_UNICODE\",\n    \"DOM_VK_UP\",\n    \"DOM_VK_V\",\n    \"DOM_VK_VOLUME_DOWN\",\n    \"DOM_VK_VOLUME_MUTE\",\n    \"DOM_VK_VOLUME_UP\",\n    \"DOM_VK_W\",\n    \"DOM_VK_WIN\",\n    \"DOM_VK_WINDOW\",\n    \"DOM_VK_WIN_ICO_00\",\n    \"DOM_VK_WIN_ICO_CLEAR\",\n    \"DOM_VK_WIN_ICO_HELP\",\n    \"DOM_VK_WIN_OEM_ATTN\",\n    \"DOM_VK_WIN_OEM_AUTO\",\n    \"DOM_VK_WIN_OEM_BACKTAB\",\n    \"DOM_VK_WIN_OEM_CLEAR\",\n    \"DOM_VK_WIN_OEM_COPY\",\n    \"DOM_VK_WIN_OEM_CUSEL\",\n    \"DOM_VK_WIN_OEM_ENLW\",\n    \"DOM_VK_WIN_OEM_FINISH\",\n    \"DOM_VK_WIN_OEM_FJ_JISHO\",\n    \"DOM_VK_WIN_OEM_FJ_LOYA\",\n    \"DOM_VK_WIN_OEM_FJ_MASSHOU\",\n    \"DOM_VK_WIN_OEM_FJ_ROYA\",\n    \"DOM_VK_WIN_OEM_FJ_TOUROKU\",\n    \"DOM_VK_WIN_OEM_JUMP\",\n    \"DOM_VK_WIN_OEM_PA1\",\n    \"DOM_VK_WIN_OEM_PA2\",\n    \"DOM_VK_WIN_OEM_PA3\",\n    \"DOM_VK_WIN_OEM_RESET\",\n    \"DOM_VK_WIN_OEM_WSCTRL\",\n    \"DOM_VK_X\",\n    \"DOM_VK_XF86XK_ADD_FAVORITE\",\n    \"DOM_VK_XF86XK_APPLICATION_LEFT\",\n    \"DOM_VK_XF86XK_APPLICATION_RIGHT\",\n    \"DOM_VK_XF86XK_AUDIO_CYCLE_TRACK\",\n    \"DOM_VK_XF86XK_AUDIO_FORWARD\",\n    \"DOM_VK_XF86XK_AUDIO_LOWER_VOLUME\",\n    \"DOM_VK_XF86XK_AUDIO_MEDIA\",\n    \"DOM_VK_XF86XK_AUDIO_MUTE\",\n    \"DOM_VK_XF86XK_AUDIO_NEXT\",\n    \"DOM_VK_XF86XK_AUDIO_PAUSE\",\n    \"DOM_VK_XF86XK_AUDIO_PLAY\",\n    \"DOM_VK_XF86XK_AUDIO_PREV\",\n    \"DOM_VK_XF86XK_AUDIO_RAISE_VOLUME\",\n    \"DOM_VK_XF86XK_AUDIO_RANDOM_PLAY\",\n    \"DOM_VK_XF86XK_AUDIO_RECORD\",\n    \"DOM_VK_XF86XK_AUDIO_REPEAT\",\n    \"DOM_VK_XF86XK_AUDIO_REWIND\",\n    \"DOM_VK_XF86XK_AUDIO_STOP\",\n    \"DOM_VK_XF86XK_AWAY\",\n    \"DOM_VK_XF86XK_BACK\",\n    \"DOM_VK_XF86XK_BACK_FORWARD\",\n    \"DOM_VK_XF86XK_BATTERY\",\n    \"DOM_VK_XF86XK_BLUE\",\n    \"DOM_VK_XF86XK_BLUETOOTH\",\n    \"DOM_VK_XF86XK_BOOK\",\n    \"DOM_VK_XF86XK_BRIGHTNESS_ADJUST\",\n    \"DOM_VK_XF86XK_CALCULATOR\",\n    \"DOM_VK_XF86XK_CALENDAR\",\n    \"DOM_VK_XF86XK_CD\",\n    \"DOM_VK_XF86XK_CLOSE\",\n    \"DOM_VK_XF86XK_COMMUNITY\",\n    \"DOM_VK_XF86XK_CONTRAST_ADJUST\",\n    \"DOM_VK_XF86XK_COPY\",\n    \"DOM_VK_XF86XK_CUT\",\n    \"DOM_VK_XF86XK_CYCLE_ANGLE\",\n    \"DOM_VK_XF86XK_DISPLAY\",\n    \"DOM_VK_XF86XK_DOCUMENTS\",\n    \"DOM_VK_XF86XK_DOS\",\n    \"DOM_VK_XF86XK_EJECT\",\n    \"DOM_VK_XF86XK_EXCEL\",\n    \"DOM_VK_XF86XK_EXPLORER\",\n    \"DOM_VK_XF86XK_FAVORITES\",\n    \"DOM_VK_XF86XK_FINANCE\",\n    \"DOM_VK_XF86XK_FORWARD\",\n    \"DOM_VK_XF86XK_FRAME_BACK\",\n    \"DOM_VK_XF86XK_FRAME_FORWARD\",\n    \"DOM_VK_XF86XK_GAME\",\n    \"DOM_VK_XF86XK_GO\",\n    \"DOM_VK_XF86XK_GREEN\",\n    \"DOM_VK_XF86XK_HIBERNATE\",\n    \"DOM_VK_XF86XK_HISTORY\",\n    \"DOM_VK_XF86XK_HOME_PAGE\",\n    \"DOM_VK_XF86XK_HOT_LINKS\",\n    \"DOM_VK_XF86XK_I_TOUCH\",\n    \"DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN\",\n    \"DOM_VK_XF86XK_KBD_BRIGHTNESS_UP\",\n    \"DOM_VK_XF86XK_KBD_LIGHT_ON_OFF\",\n    \"DOM_VK_XF86XK_LAUNCH0\",\n    \"DOM_VK_XF86XK_LAUNCH1\",\n    \"DOM_VK_XF86XK_LAUNCH2\",\n    \"DOM_VK_XF86XK_LAUNCH3\",\n    \"DOM_VK_XF86XK_LAUNCH4\",\n    \"DOM_VK_XF86XK_LAUNCH5\",\n    \"DOM_VK_XF86XK_LAUNCH6\",\n    \"DOM_VK_XF86XK_LAUNCH7\",\n    \"DOM_VK_XF86XK_LAUNCH8\",\n    \"DOM_VK_XF86XK_LAUNCH9\",\n    \"DOM_VK_XF86XK_LAUNCH_A\",\n    \"DOM_VK_XF86XK_LAUNCH_B\",\n    \"DOM_VK_XF86XK_LAUNCH_C\",\n    \"DOM_VK_XF86XK_LAUNCH_D\",\n    \"DOM_VK_XF86XK_LAUNCH_E\",\n    \"DOM_VK_XF86XK_LAUNCH_F\",\n    \"DOM_VK_XF86XK_LIGHT_BULB\",\n    \"DOM_VK_XF86XK_LOG_OFF\",\n    \"DOM_VK_XF86XK_MAIL\",\n    \"DOM_VK_XF86XK_MAIL_FORWARD\",\n    \"DOM_VK_XF86XK_MARKET\",\n    \"DOM_VK_XF86XK_MEETING\",\n    \"DOM_VK_XF86XK_MEMO\",\n    \"DOM_VK_XF86XK_MENU_KB\",\n    \"DOM_VK_XF86XK_MENU_PB\",\n    \"DOM_VK_XF86XK_MESSENGER\",\n    \"DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN\",\n    \"DOM_VK_XF86XK_MON_BRIGHTNESS_UP\",\n    \"DOM_VK_XF86XK_MUSIC\",\n    \"DOM_VK_XF86XK_MY_COMPUTER\",\n    \"DOM_VK_XF86XK_MY_SITES\",\n    \"DOM_VK_XF86XK_NEW\",\n    \"DOM_VK_XF86XK_NEWS\",\n    \"DOM_VK_XF86XK_OFFICE_HOME\",\n    \"DOM_VK_XF86XK_OPEN\",\n    \"DOM_VK_XF86XK_OPEN_URL\",\n    \"DOM_VK_XF86XK_OPTION\",\n    \"DOM_VK_XF86XK_PASTE\",\n    \"DOM_VK_XF86XK_PHONE\",\n    \"DOM_VK_XF86XK_PICTURES\",\n    \"DOM_VK_XF86XK_POWER_DOWN\",\n    \"DOM_VK_XF86XK_POWER_OFF\",\n    \"DOM_VK_XF86XK_RED\",\n    \"DOM_VK_XF86XK_REFRESH\",\n    \"DOM_VK_XF86XK_RELOAD\",\n    \"DOM_VK_XF86XK_REPLY\",\n    \"DOM_VK_XF86XK_ROCKER_DOWN\",\n    \"DOM_VK_XF86XK_ROCKER_ENTER\",\n    \"DOM_VK_XF86XK_ROCKER_UP\",\n    \"DOM_VK_XF86XK_ROTATE_WINDOWS\",\n    \"DOM_VK_XF86XK_ROTATION_KB\",\n    \"DOM_VK_XF86XK_ROTATION_PB\",\n    \"DOM_VK_XF86XK_SAVE\",\n    \"DOM_VK_XF86XK_SCREEN_SAVER\",\n    \"DOM_VK_XF86XK_SCROLL_CLICK\",\n    \"DOM_VK_XF86XK_SCROLL_DOWN\",\n    \"DOM_VK_XF86XK_SCROLL_UP\",\n    \"DOM_VK_XF86XK_SEARCH\",\n    \"DOM_VK_XF86XK_SEND\",\n    \"DOM_VK_XF86XK_SHOP\",\n    \"DOM_VK_XF86XK_SPELL\",\n    \"DOM_VK_XF86XK_SPLIT_SCREEN\",\n    \"DOM_VK_XF86XK_STANDBY\",\n    \"DOM_VK_XF86XK_START\",\n    \"DOM_VK_XF86XK_STOP\",\n    \"DOM_VK_XF86XK_SUBTITLE\",\n    \"DOM_VK_XF86XK_SUPPORT\",\n    \"DOM_VK_XF86XK_SUSPEND\",\n    \"DOM_VK_XF86XK_TASK_PANE\",\n    \"DOM_VK_XF86XK_TERMINAL\",\n    \"DOM_VK_XF86XK_TIME\",\n    \"DOM_VK_XF86XK_TOOLS\",\n    \"DOM_VK_XF86XK_TOP_MENU\",\n    \"DOM_VK_XF86XK_TO_DO_LIST\",\n    \"DOM_VK_XF86XK_TRAVEL\",\n    \"DOM_VK_XF86XK_USER1KB\",\n    \"DOM_VK_XF86XK_USER2KB\",\n    \"DOM_VK_XF86XK_USER_PB\",\n    \"DOM_VK_XF86XK_UWB\",\n    \"DOM_VK_XF86XK_VENDOR_HOME\",\n    \"DOM_VK_XF86XK_VIDEO\",\n    \"DOM_VK_XF86XK_VIEW\",\n    \"DOM_VK_XF86XK_WAKE_UP\",\n    \"DOM_VK_XF86XK_WEB_CAM\",\n    \"DOM_VK_XF86XK_WHEEL_BUTTON\",\n    \"DOM_VK_XF86XK_WLAN\",\n    \"DOM_VK_XF86XK_WORD\",\n    \"DOM_VK_XF86XK_WWW\",\n    \"DOM_VK_XF86XK_XFER\",\n    \"DOM_VK_XF86XK_YELLOW\",\n    \"DOM_VK_XF86XK_ZOOM_IN\",\n    \"DOM_VK_XF86XK_ZOOM_OUT\",\n    \"DOM_VK_Y\",\n    \"DOM_VK_Z\",\n    \"DOM_VK_ZOOM\",\n    \"DONE\",\n    \"DONT_CARE\",\n    \"DOWNLOADING\",\n    \"DRAGDROP\",\n    \"DRAW_BUFFER0\",\n    \"DRAW_BUFFER1\",\n    \"DRAW_BUFFER10\",\n    \"DRAW_BUFFER11\",\n    \"DRAW_BUFFER12\",\n    \"DRAW_BUFFER13\",\n    \"DRAW_BUFFER14\",\n    \"DRAW_BUFFER15\",\n    \"DRAW_BUFFER2\",\n    \"DRAW_BUFFER3\",\n    \"DRAW_BUFFER4\",\n    \"DRAW_BUFFER5\",\n    \"DRAW_BUFFER6\",\n    \"DRAW_BUFFER7\",\n    \"DRAW_BUFFER8\",\n    \"DRAW_BUFFER9\",\n    \"DRAW_FRAMEBUFFER\",\n    \"DRAW_FRAMEBUFFER_BINDING\",\n    \"DST_ALPHA\",\n    \"DST_COLOR\",\n    \"DYNAMIC_COPY\",\n    \"DYNAMIC_DRAW\",\n    \"DYNAMIC_READ\",\n    \"DataChannel\",\n    \"DataTransfer\",\n    \"DataTransferItem\",\n    \"DataTransferItemList\",\n    \"DataView\",\n    \"Date\",\n    \"DateTimeFormat\",\n    \"DecompressionStream\",\n    \"DelayNode\",\n    \"DeprecationReportBody\",\n    \"DesktopNotification\",\n    \"DesktopNotificationCenter\",\n    \"DeviceLightEvent\",\n    \"DeviceMotionEvent\",\n    \"DeviceMotionEventAcceleration\",\n    \"DeviceMotionEventRotationRate\",\n    \"DeviceOrientationEvent\",\n    \"DeviceProximityEvent\",\n    \"DeviceStorage\",\n    \"DeviceStorageChangeEvent\",\n    \"Directory\",\n    \"DisplayNames\",\n    \"Document\",\n    \"DocumentFragment\",\n    \"DocumentTimeline\",\n    \"DocumentType\",\n    \"DragEvent\",\n    \"DynamicsCompressorNode\",\n    \"E\",\n    \"ELEMENT_ARRAY_BUFFER\",\n    \"ELEMENT_ARRAY_BUFFER_BINDING\",\n    \"ELEMENT_NODE\",\n    \"EMPTY\",\n    \"ENCODING_ERR\",\n    \"ENDED\",\n    \"END_TO_END\",\n    \"END_TO_START\",\n    \"ENTITY_NODE\",\n    \"ENTITY_REFERENCE_NODE\",\n    \"EPSILON\",\n    \"EQUAL\",\n    \"EQUALPOWER\",\n    \"ERROR\",\n    \"EXPONENTIAL_DISTANCE\",\n    \"Element\",\n    \"ElementInternals\",\n    \"ElementQuery\",\n    \"EnterPictureInPictureEvent\",\n    \"Entity\",\n    \"EntityReference\",\n    \"Error\",\n    \"ErrorEvent\",\n    \"EvalError\",\n    \"Event\",\n    \"EventException\",\n    \"EventSource\",\n    \"EventTarget\",\n    \"External\",\n    \"FASTEST\",\n    \"FIDOSDK\",\n    \"FILTER_ACCEPT\",\n    \"FILTER_INTERRUPT\",\n    \"FILTER_REJECT\",\n    \"FILTER_SKIP\",\n    \"FINISHED_STATE\",\n    \"FIRST_ORDERED_NODE_TYPE\",\n    \"FLOAT\",\n    \"FLOAT_32_UNSIGNED_INT_24_8_REV\",\n    \"FLOAT_MAT2\",\n    \"FLOAT_MAT2x3\",\n    \"FLOAT_MAT2x4\",\n    \"FLOAT_MAT3\",\n    \"FLOAT_MAT3x2\",\n    \"FLOAT_MAT3x4\",\n    \"FLOAT_MAT4\",\n    \"FLOAT_MAT4x2\",\n    \"FLOAT_MAT4x3\",\n    \"FLOAT_VEC2\",\n    \"FLOAT_VEC3\",\n    \"FLOAT_VEC4\",\n    \"FOCUS\",\n    \"FONT_FACE_RULE\",\n    \"FONT_FEATURE_VALUES_RULE\",\n    \"FRAGMENT_SHADER\",\n    \"FRAGMENT_SHADER_DERIVATIVE_HINT\",\n    \"FRAGMENT_SHADER_DERIVATIVE_HINT_OES\",\n    \"FRAMEBUFFER\",\n    \"FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE\",\n    \"FRAMEBUFFER_ATTACHMENT_BLUE_SIZE\",\n    \"FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING\",\n    \"FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE\",\n    \"FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE\",\n    \"FRAMEBUFFER_ATTACHMENT_GREEN_SIZE\",\n    \"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME\",\n    \"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE\",\n    \"FRAMEBUFFER_ATTACHMENT_RED_SIZE\",\n    \"FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE\",\n    \"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE\",\n    \"FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER\",\n    \"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL\",\n    \"FRAMEBUFFER_BINDING\",\n    \"FRAMEBUFFER_COMPLETE\",\n    \"FRAMEBUFFER_DEFAULT\",\n    \"FRAMEBUFFER_INCOMPLETE_ATTACHMENT\",\n    \"FRAMEBUFFER_INCOMPLETE_DIMENSIONS\",\n    \"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\",\n    \"FRAMEBUFFER_INCOMPLETE_MULTISAMPLE\",\n    \"FRAMEBUFFER_UNSUPPORTED\",\n    \"FRONT\",\n    \"FRONT_AND_BACK\",\n    \"FRONT_FACE\",\n    \"FUNC_ADD\",\n    \"FUNC_REVERSE_SUBTRACT\",\n    \"FUNC_SUBTRACT\",\n    \"FeaturePolicy\",\n    \"FeaturePolicyViolationReportBody\",\n    \"FederatedCredential\",\n    \"Feed\",\n    \"FeedEntry\",\n    \"File\",\n    \"FileError\",\n    \"FileList\",\n    \"FileReader\",\n    \"FileSystem\",\n    \"FileSystemDirectoryEntry\",\n    \"FileSystemDirectoryReader\",\n    \"FileSystemEntry\",\n    \"FileSystemFileEntry\",\n    \"FinalizationRegistry\",\n    \"FindInPage\",\n    \"Float32Array\",\n    \"Float64Array\",\n    \"FocusEvent\",\n    \"FontFace\",\n    \"FontFaceSet\",\n    \"FontFaceSetLoadEvent\",\n    \"FormData\",\n    \"FormDataEvent\",\n    \"FragmentDirective\",\n    \"Function\",\n    \"GENERATE_MIPMAP_HINT\",\n    \"GEQUAL\",\n    \"GREATER\",\n    \"GREEN_BITS\",\n    \"GainNode\",\n    \"Gamepad\",\n    \"GamepadAxisMoveEvent\",\n    \"GamepadButton\",\n    \"GamepadButtonEvent\",\n    \"GamepadEvent\",\n    \"GamepadHapticActuator\",\n    \"GamepadPose\",\n    \"Geolocation\",\n    \"GeolocationCoordinates\",\n    \"GeolocationPosition\",\n    \"GeolocationPositionError\",\n    \"GestureEvent\",\n    \"Global\",\n    \"Gyroscope\",\n    \"HALF_FLOAT\",\n    \"HAVE_CURRENT_DATA\",\n    \"HAVE_ENOUGH_DATA\",\n    \"HAVE_FUTURE_DATA\",\n    \"HAVE_METADATA\",\n    \"HAVE_NOTHING\",\n    \"HEADERS_RECEIVED\",\n    \"HIDDEN\",\n    \"HIERARCHY_REQUEST_ERR\",\n    \"HIGHPASS\",\n    \"HIGHSHELF\",\n    \"HIGH_FLOAT\",\n    \"HIGH_INT\",\n    \"HORIZONTAL\",\n    \"HORIZONTAL_AXIS\",\n    \"HRTF\",\n    \"HTMLAllCollection\",\n    \"HTMLAnchorElement\",\n    \"HTMLAppletElement\",\n    \"HTMLAreaElement\",\n    \"HTMLAudioElement\",\n    \"HTMLBRElement\",\n    \"HTMLBaseElement\",\n    \"HTMLBaseFontElement\",\n    \"HTMLBlockquoteElement\",\n    \"HTMLBodyElement\",\n    \"HTMLButtonElement\",\n    \"HTMLCanvasElement\",\n    \"HTMLCollection\",\n    \"HTMLCommandElement\",\n    \"HTMLContentElement\",\n    \"HTMLDListElement\",\n    \"HTMLDataElement\",\n    \"HTMLDataListElement\",\n    \"HTMLDetailsElement\",\n    \"HTMLDialogElement\",\n    \"HTMLDirectoryElement\",\n    \"HTMLDivElement\",\n    \"HTMLDocument\",\n    \"HTMLElement\",\n    \"HTMLEmbedElement\",\n    \"HTMLFieldSetElement\",\n    \"HTMLFontElement\",\n    \"HTMLFormControlsCollection\",\n    \"HTMLFormElement\",\n    \"HTMLFrameElement\",\n    \"HTMLFrameSetElement\",\n    \"HTMLHRElement\",\n    \"HTMLHeadElement\",\n    \"HTMLHeadingElement\",\n    \"HTMLHtmlElement\",\n    \"HTMLIFrameElement\",\n    \"HTMLImageElement\",\n    \"HTMLInputElement\",\n    \"HTMLIsIndexElement\",\n    \"HTMLKeygenElement\",\n    \"HTMLLIElement\",\n    \"HTMLLabelElement\",\n    \"HTMLLegendElement\",\n    \"HTMLLinkElement\",\n    \"HTMLMapElement\",\n    \"HTMLMarqueeElement\",\n    \"HTMLMediaElement\",\n    \"HTMLMenuElement\",\n    \"HTMLMenuItemElement\",\n    \"HTMLMetaElement\",\n    \"HTMLMeterElement\",\n    \"HTMLModElement\",\n    \"HTMLOListElement\",\n    \"HTMLObjectElement\",\n    \"HTMLOptGroupElement\",\n    \"HTMLOptionElement\",\n    \"HTMLOptionsCollection\",\n    \"HTMLOutputElement\",\n    \"HTMLParagraphElement\",\n    \"HTMLParamElement\",\n    \"HTMLPictureElement\",\n    \"HTMLPreElement\",\n    \"HTMLProgressElement\",\n    \"HTMLPropertiesCollection\",\n    \"HTMLQuoteElement\",\n    \"HTMLScriptElement\",\n    \"HTMLSelectElement\",\n    \"HTMLShadowElement\",\n    \"HTMLSlotElement\",\n    \"HTMLSourceElement\",\n    \"HTMLSpanElement\",\n    \"HTMLStyleElement\",\n    \"HTMLTableCaptionElement\",\n    \"HTMLTableCellElement\",\n    \"HTMLTableColElement\",\n    \"HTMLTableElement\",\n    \"HTMLTableRowElement\",\n    \"HTMLTableSectionElement\",\n    \"HTMLTemplateElement\",\n    \"HTMLTextAreaElement\",\n    \"HTMLTimeElement\",\n    \"HTMLTitleElement\",\n    \"HTMLTrackElement\",\n    \"HTMLUListElement\",\n    \"HTMLUnknownElement\",\n    \"HTMLVideoElement\",\n    \"HashChangeEvent\",\n    \"Headers\",\n    \"History\",\n    \"Hz\",\n    \"ICE_CHECKING\",\n    \"ICE_CLOSED\",\n    \"ICE_COMPLETED\",\n    \"ICE_CONNECTED\",\n    \"ICE_FAILED\",\n    \"ICE_GATHERING\",\n    \"ICE_WAITING\",\n    \"IDBCursor\",\n    \"IDBCursorWithValue\",\n    \"IDBDatabase\",\n    \"IDBDatabaseException\",\n    \"IDBFactory\",\n    \"IDBFileHandle\",\n    \"IDBFileRequest\",\n    \"IDBIndex\",\n    \"IDBKeyRange\",\n    \"IDBMutableFile\",\n    \"IDBObjectStore\",\n    \"IDBOpenDBRequest\",\n    \"IDBRequest\",\n    \"IDBTransaction\",\n    \"IDBVersionChangeEvent\",\n    \"IDLE\",\n    \"IIRFilterNode\",\n    \"IMPLEMENTATION_COLOR_READ_FORMAT\",\n    \"IMPLEMENTATION_COLOR_READ_TYPE\",\n    \"IMPORT_RULE\",\n    \"INCR\",\n    \"INCR_WRAP\",\n    \"INDEX_SIZE_ERR\",\n    \"INT\",\n    \"INTERLEAVED_ATTRIBS\",\n    \"INT_2_10_10_10_REV\",\n    \"INT_SAMPLER_2D\",\n    \"INT_SAMPLER_2D_ARRAY\",\n    \"INT_SAMPLER_3D\",\n    \"INT_SAMPLER_CUBE\",\n    \"INT_VEC2\",\n    \"INT_VEC3\",\n    \"INT_VEC4\",\n    \"INUSE_ATTRIBUTE_ERR\",\n    \"INVALID_ACCESS_ERR\",\n    \"INVALID_CHARACTER_ERR\",\n    \"INVALID_ENUM\",\n    \"INVALID_EXPRESSION_ERR\",\n    \"INVALID_FRAMEBUFFER_OPERATION\",\n    \"INVALID_INDEX\",\n    \"INVALID_MODIFICATION_ERR\",\n    \"INVALID_NODE_TYPE_ERR\",\n    \"INVALID_OPERATION\",\n    \"INVALID_STATE_ERR\",\n    \"INVALID_VALUE\",\n    \"INVERSE_DISTANCE\",\n    \"INVERT\",\n    \"IceCandidate\",\n    \"IdleDeadline\",\n    \"Image\",\n    \"ImageBitmap\",\n    \"ImageBitmapRenderingContext\",\n    \"ImageCapture\",\n    \"ImageData\",\n    \"Infinity\",\n    \"InputDeviceCapabilities\",\n    \"InputDeviceInfo\",\n    \"InputEvent\",\n    \"InputMethodContext\",\n    \"InstallTrigger\",\n    \"InstallTriggerImpl\",\n    \"Instance\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Int8Array\",\n    \"Intent\",\n    \"InternalError\",\n    \"IntersectionObserver\",\n    \"IntersectionObserverEntry\",\n    \"Intl\",\n    \"IsSearchProviderInstalled\",\n    \"Iterator\",\n    \"JSON\",\n    \"KEEP\",\n    \"KEYDOWN\",\n    \"KEYFRAMES_RULE\",\n    \"KEYFRAME_RULE\",\n    \"KEYPRESS\",\n    \"KEYUP\",\n    \"KeyEvent\",\n    \"Keyboard\",\n    \"KeyboardEvent\",\n    \"KeyboardLayoutMap\",\n    \"KeyframeEffect\",\n    \"LENGTHADJUST_SPACING\",\n    \"LENGTHADJUST_SPACINGANDGLYPHS\",\n    \"LENGTHADJUST_UNKNOWN\",\n    \"LEQUAL\",\n    \"LESS\",\n    \"LINEAR\",\n    \"LINEAR_DISTANCE\",\n    \"LINEAR_MIPMAP_LINEAR\",\n    \"LINEAR_MIPMAP_NEAREST\",\n    \"LINES\",\n    \"LINE_LOOP\",\n    \"LINE_STRIP\",\n    \"LINE_WIDTH\",\n    \"LINK_STATUS\",\n    \"LIVE\",\n    \"LN10\",\n    \"LN2\",\n    \"LOADED\",\n    \"LOADING\",\n    \"LOG10E\",\n    \"LOG2E\",\n    \"LOWPASS\",\n    \"LOWSHELF\",\n    \"LOW_FLOAT\",\n    \"LOW_INT\",\n    \"LSException\",\n    \"LSParserFilter\",\n    \"LUMINANCE\",\n    \"LUMINANCE_ALPHA\",\n    \"LargestContentfulPaint\",\n    \"LayoutShift\",\n    \"LayoutShiftAttribution\",\n    \"LinearAccelerationSensor\",\n    \"LinkError\",\n    \"ListFormat\",\n    \"LocalMediaStream\",\n    \"Locale\",\n    \"Location\",\n    \"Lock\",\n    \"LockManager\",\n    \"MAX\",\n    \"MAX_3D_TEXTURE_SIZE\",\n    \"MAX_ARRAY_TEXTURE_LAYERS\",\n    \"MAX_CLIENT_WAIT_TIMEOUT_WEBGL\",\n    \"MAX_COLOR_ATTACHMENTS\",\n    \"MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS\",\n    \"MAX_COMBINED_TEXTURE_IMAGE_UNITS\",\n    \"MAX_COMBINED_UNIFORM_BLOCKS\",\n    \"MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS\",\n    \"MAX_CUBE_MAP_TEXTURE_SIZE\",\n    \"MAX_DRAW_BUFFERS\",\n    \"MAX_ELEMENTS_INDICES\",\n    \"MAX_ELEMENTS_VERTICES\",\n    \"MAX_ELEMENT_INDEX\",\n    \"MAX_FRAGMENT_INPUT_COMPONENTS\",\n    \"MAX_FRAGMENT_UNIFORM_BLOCKS\",\n    \"MAX_FRAGMENT_UNIFORM_COMPONENTS\",\n    \"MAX_FRAGMENT_UNIFORM_VECTORS\",\n    \"MAX_PROGRAM_TEXEL_OFFSET\",\n    \"MAX_RENDERBUFFER_SIZE\",\n    \"MAX_SAFE_INTEGER\",\n    \"MAX_SAMPLES\",\n    \"MAX_SERVER_WAIT_TIMEOUT\",\n    \"MAX_TEXTURE_IMAGE_UNITS\",\n    \"MAX_TEXTURE_LOD_BIAS\",\n    \"MAX_TEXTURE_MAX_ANISOTROPY_EXT\",\n    \"MAX_TEXTURE_SIZE\",\n    \"MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS\",\n    \"MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS\",\n    \"MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS\",\n    \"MAX_UNIFORM_BLOCK_SIZE\",\n    \"MAX_UNIFORM_BUFFER_BINDINGS\",\n    \"MAX_VALUE\",\n    \"MAX_VARYING_COMPONENTS\",\n    \"MAX_VARYING_VECTORS\",\n    \"MAX_VERTEX_ATTRIBS\",\n    \"MAX_VERTEX_OUTPUT_COMPONENTS\",\n    \"MAX_VERTEX_TEXTURE_IMAGE_UNITS\",\n    \"MAX_VERTEX_UNIFORM_BLOCKS\",\n    \"MAX_VERTEX_UNIFORM_COMPONENTS\",\n    \"MAX_VERTEX_UNIFORM_VECTORS\",\n    \"MAX_VIEWPORT_DIMS\",\n    \"MEDIA_ERR_ABORTED\",\n    \"MEDIA_ERR_DECODE\",\n    \"MEDIA_ERR_ENCRYPTED\",\n    \"MEDIA_ERR_NETWORK\",\n    \"MEDIA_ERR_SRC_NOT_SUPPORTED\",\n    \"MEDIA_KEYERR_CLIENT\",\n    \"MEDIA_KEYERR_DOMAIN\",\n    \"MEDIA_KEYERR_HARDWARECHANGE\",\n    \"MEDIA_KEYERR_OUTPUT\",\n    \"MEDIA_KEYERR_SERVICE\",\n    \"MEDIA_KEYERR_UNKNOWN\",\n    \"MEDIA_RULE\",\n    \"MEDIUM_FLOAT\",\n    \"MEDIUM_INT\",\n    \"META_MASK\",\n    \"MIDIAccess\",\n    \"MIDIConnectionEvent\",\n    \"MIDIInput\",\n    \"MIDIInputMap\",\n    \"MIDIMessageEvent\",\n    \"MIDIOutput\",\n    \"MIDIOutputMap\",\n    \"MIDIPort\",\n    \"MIN\",\n    \"MIN_PROGRAM_TEXEL_OFFSET\",\n    \"MIN_SAFE_INTEGER\",\n    \"MIN_VALUE\",\n    \"MIRRORED_REPEAT\",\n    \"MODE_ASYNCHRONOUS\",\n    \"MODE_SYNCHRONOUS\",\n    \"MODIFICATION\",\n    \"MOUSEDOWN\",\n    \"MOUSEDRAG\",\n    \"MOUSEMOVE\",\n    \"MOUSEOUT\",\n    \"MOUSEOVER\",\n    \"MOUSEUP\",\n    \"MOZ_KEYFRAMES_RULE\",\n    \"MOZ_KEYFRAME_RULE\",\n    \"MOZ_SOURCE_CURSOR\",\n    \"MOZ_SOURCE_ERASER\",\n    \"MOZ_SOURCE_KEYBOARD\",\n    \"MOZ_SOURCE_MOUSE\",\n    \"MOZ_SOURCE_PEN\",\n    \"MOZ_SOURCE_TOUCH\",\n    \"MOZ_SOURCE_UNKNOWN\",\n    \"MSGESTURE_FLAG_BEGIN\",\n    \"MSGESTURE_FLAG_CANCEL\",\n    \"MSGESTURE_FLAG_END\",\n    \"MSGESTURE_FLAG_INERTIA\",\n    \"MSGESTURE_FLAG_NONE\",\n    \"MSPOINTER_TYPE_MOUSE\",\n    \"MSPOINTER_TYPE_PEN\",\n    \"MSPOINTER_TYPE_TOUCH\",\n    \"MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE\",\n    \"MS_ASYNC_CALLBACK_STATUS_CANCEL\",\n    \"MS_ASYNC_CALLBACK_STATUS_CHOOSEANY\",\n    \"MS_ASYNC_CALLBACK_STATUS_ERROR\",\n    \"MS_ASYNC_CALLBACK_STATUS_JOIN\",\n    \"MS_ASYNC_OP_STATUS_CANCELED\",\n    \"MS_ASYNC_OP_STATUS_ERROR\",\n    \"MS_ASYNC_OP_STATUS_SUCCESS\",\n    \"MS_MANIPULATION_STATE_ACTIVE\",\n    \"MS_MANIPULATION_STATE_CANCELLED\",\n    \"MS_MANIPULATION_STATE_COMMITTED\",\n    \"MS_MANIPULATION_STATE_DRAGGING\",\n    \"MS_MANIPULATION_STATE_INERTIA\",\n    \"MS_MANIPULATION_STATE_PRESELECT\",\n    \"MS_MANIPULATION_STATE_SELECTING\",\n    \"MS_MANIPULATION_STATE_STOPPED\",\n    \"MS_MEDIA_ERR_ENCRYPTED\",\n    \"MS_MEDIA_KEYERR_CLIENT\",\n    \"MS_MEDIA_KEYERR_DOMAIN\",\n    \"MS_MEDIA_KEYERR_HARDWARECHANGE\",\n    \"MS_MEDIA_KEYERR_OUTPUT\",\n    \"MS_MEDIA_KEYERR_SERVICE\",\n    \"MS_MEDIA_KEYERR_UNKNOWN\",\n    \"Map\",\n    \"Math\",\n    \"MathMLElement\",\n    \"MediaCapabilities\",\n    \"MediaCapabilitiesInfo\",\n    \"MediaController\",\n    \"MediaDeviceInfo\",\n    \"MediaDevices\",\n    \"MediaElementAudioSourceNode\",\n    \"MediaEncryptedEvent\",\n    \"MediaError\",\n    \"MediaKeyError\",\n    \"MediaKeyEvent\",\n    \"MediaKeyMessageEvent\",\n    \"MediaKeyNeededEvent\",\n    \"MediaKeySession\",\n    \"MediaKeyStatusMap\",\n    \"MediaKeySystemAccess\",\n    \"MediaKeys\",\n    \"MediaList\",\n    \"MediaMetadata\",\n    \"MediaQueryList\",\n    \"MediaQueryListEvent\",\n    \"MediaRecorder\",\n    \"MediaRecorderErrorEvent\",\n    \"MediaSession\",\n    \"MediaSettingsRange\",\n    \"MediaSource\",\n    \"MediaStream\",\n    \"MediaStreamAudioDestinationNode\",\n    \"MediaStreamAudioSourceNode\",\n    \"MediaStreamEvent\",\n    \"MediaStreamTrack\",\n    \"MediaStreamTrackAudioSourceNode\",\n    \"MediaStreamTrackEvent\",\n    \"Memory\",\n    \"MessageChannel\",\n    \"MessageEvent\",\n    \"MessagePort\",\n    \"Methods\",\n    \"MimeType\",\n    \"MimeTypeArray\",\n    \"Module\",\n    \"MouseEvent\",\n    \"MouseScrollEvent\",\n    \"MozAnimation\",\n    \"MozAnimationDelay\",\n    \"MozAnimationDirection\",\n    \"MozAnimationDuration\",\n    \"MozAnimationFillMode\",\n    \"MozAnimationIterationCount\",\n    \"MozAnimationName\",\n    \"MozAnimationPlayState\",\n    \"MozAnimationTimingFunction\",\n    \"MozAppearance\",\n    \"MozBackfaceVisibility\",\n    \"MozBinding\",\n    \"MozBorderBottomColors\",\n    \"MozBorderEnd\",\n    \"MozBorderEndColor\",\n    \"MozBorderEndStyle\",\n    \"MozBorderEndWidth\",\n    \"MozBorderImage\",\n    \"MozBorderLeftColors\",\n    \"MozBorderRightColors\",\n    \"MozBorderStart\",\n    \"MozBorderStartColor\",\n    \"MozBorderStartStyle\",\n    \"MozBorderStartWidth\",\n    \"MozBorderTopColors\",\n    \"MozBoxAlign\",\n    \"MozBoxDirection\",\n    \"MozBoxFlex\",\n    \"MozBoxOrdinalGroup\",\n    \"MozBoxOrient\",\n    \"MozBoxPack\",\n    \"MozBoxSizing\",\n    \"MozCSSKeyframeRule\",\n    \"MozCSSKeyframesRule\",\n    \"MozColumnCount\",\n    \"MozColumnFill\",\n    \"MozColumnGap\",\n    \"MozColumnRule\",\n    \"MozColumnRuleColor\",\n    \"MozColumnRuleStyle\",\n    \"MozColumnRuleWidth\",\n    \"MozColumnWidth\",\n    \"MozColumns\",\n    \"MozContactChangeEvent\",\n    \"MozFloatEdge\",\n    \"MozFontFeatureSettings\",\n    \"MozFontLanguageOverride\",\n    \"MozForceBrokenImageIcon\",\n    \"MozHyphens\",\n    \"MozImageRegion\",\n    \"MozMarginEnd\",\n    \"MozMarginStart\",\n    \"MozMmsEvent\",\n    \"MozMmsMessage\",\n    \"MozMobileMessageThread\",\n    \"MozOSXFontSmoothing\",\n    \"MozOrient\",\n    \"MozOsxFontSmoothing\",\n    \"MozOutlineRadius\",\n    \"MozOutlineRadiusBottomleft\",\n    \"MozOutlineRadiusBottomright\",\n    \"MozOutlineRadiusTopleft\",\n    \"MozOutlineRadiusTopright\",\n    \"MozPaddingEnd\",\n    \"MozPaddingStart\",\n    \"MozPerspective\",\n    \"MozPerspectiveOrigin\",\n    \"MozPowerManager\",\n    \"MozSettingsEvent\",\n    \"MozSmsEvent\",\n    \"MozSmsMessage\",\n    \"MozStackSizing\",\n    \"MozTabSize\",\n    \"MozTextAlignLast\",\n    \"MozTextDecorationColor\",\n    \"MozTextDecorationLine\",\n    \"MozTextDecorationStyle\",\n    \"MozTextSizeAdjust\",\n    \"MozTransform\",\n    \"MozTransformOrigin\",\n    \"MozTransformStyle\",\n    \"MozTransition\",\n    \"MozTransitionDelay\",\n    \"MozTransitionDuration\",\n    \"MozTransitionProperty\",\n    \"MozTransitionTimingFunction\",\n    \"MozUserFocus\",\n    \"MozUserInput\",\n    \"MozUserModify\",\n    \"MozUserSelect\",\n    \"MozWindowDragging\",\n    \"MozWindowShadow\",\n    \"MutationEvent\",\n    \"MutationObserver\",\n    \"MutationRecord\",\n    \"NAMESPACE_ERR\",\n    \"NAMESPACE_RULE\",\n    \"NEAREST\",\n    \"NEAREST_MIPMAP_LINEAR\",\n    \"NEAREST_MIPMAP_NEAREST\",\n    \"NEGATIVE_INFINITY\",\n    \"NETWORK_EMPTY\",\n    \"NETWORK_ERR\",\n    \"NETWORK_IDLE\",\n    \"NETWORK_LOADED\",\n    \"NETWORK_LOADING\",\n    \"NETWORK_NO_SOURCE\",\n    \"NEVER\",\n    \"NEW\",\n    \"NEXT\",\n    \"NEXT_NO_DUPLICATE\",\n    \"NICEST\",\n    \"NODE_AFTER\",\n    \"NODE_BEFORE\",\n    \"NODE_BEFORE_AND_AFTER\",\n    \"NODE_INSIDE\",\n    \"NONE\",\n    \"NON_TRANSIENT_ERR\",\n    \"NOTATION_NODE\",\n    \"NOTCH\",\n    \"NOTEQUAL\",\n    \"NOT_ALLOWED_ERR\",\n    \"NOT_FOUND_ERR\",\n    \"NOT_READABLE_ERR\",\n    \"NOT_SUPPORTED_ERR\",\n    \"NO_DATA_ALLOWED_ERR\",\n    \"NO_ERR\",\n    \"NO_ERROR\",\n    \"NO_MODIFICATION_ALLOWED_ERR\",\n    \"NUMBER_TYPE\",\n    \"NUM_COMPRESSED_TEXTURE_FORMATS\",\n    \"NaN\",\n    \"NamedNodeMap\",\n    \"NavigationPreloadManager\",\n    \"Navigator\",\n    \"NearbyLinks\",\n    \"NetworkInformation\",\n    \"Node\",\n    \"NodeFilter\",\n    \"NodeIterator\",\n    \"NodeList\",\n    \"Notation\",\n    \"Notification\",\n    \"NotifyPaintEvent\",\n    \"Number\",\n    \"NumberFormat\",\n    \"OBJECT_TYPE\",\n    \"OBSOLETE\",\n    \"OK\",\n    \"ONE\",\n    \"ONE_MINUS_CONSTANT_ALPHA\",\n    \"ONE_MINUS_CONSTANT_COLOR\",\n    \"ONE_MINUS_DST_ALPHA\",\n    \"ONE_MINUS_DST_COLOR\",\n    \"ONE_MINUS_SRC_ALPHA\",\n    \"ONE_MINUS_SRC_COLOR\",\n    \"OPEN\",\n    \"OPENED\",\n    \"OPENING\",\n    \"ORDERED_NODE_ITERATOR_TYPE\",\n    \"ORDERED_NODE_SNAPSHOT_TYPE\",\n    \"OTHER_ERROR\",\n    \"OUT_OF_MEMORY\",\n    \"Object\",\n    \"OfflineAudioCompletionEvent\",\n    \"OfflineAudioContext\",\n    \"OfflineResourceList\",\n    \"OffscreenCanvas\",\n    \"OffscreenCanvasRenderingContext2D\",\n    \"Option\",\n    \"OrientationSensor\",\n    \"OscillatorNode\",\n    \"OverconstrainedError\",\n    \"OverflowEvent\",\n    \"PACK_ALIGNMENT\",\n    \"PACK_ROW_LENGTH\",\n    \"PACK_SKIP_PIXELS\",\n    \"PACK_SKIP_ROWS\",\n    \"PAGE_RULE\",\n    \"PARSE_ERR\",\n    \"PATHSEG_ARC_ABS\",\n    \"PATHSEG_ARC_REL\",\n    \"PATHSEG_CLOSEPATH\",\n    \"PATHSEG_CURVETO_CUBIC_ABS\",\n    \"PATHSEG_CURVETO_CUBIC_REL\",\n    \"PATHSEG_CURVETO_CUBIC_SMOOTH_ABS\",\n    \"PATHSEG_CURVETO_CUBIC_SMOOTH_REL\",\n    \"PATHSEG_CURVETO_QUADRATIC_ABS\",\n    \"PATHSEG_CURVETO_QUADRATIC_REL\",\n    \"PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS\",\n    \"PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL\",\n    \"PATHSEG_LINETO_ABS\",\n    \"PATHSEG_LINETO_HORIZONTAL_ABS\",\n    \"PATHSEG_LINETO_HORIZONTAL_REL\",\n    \"PATHSEG_LINETO_REL\",\n    \"PATHSEG_LINETO_VERTICAL_ABS\",\n    \"PATHSEG_LINETO_VERTICAL_REL\",\n    \"PATHSEG_MOVETO_ABS\",\n    \"PATHSEG_MOVETO_REL\",\n    \"PATHSEG_UNKNOWN\",\n    \"PATH_EXISTS_ERR\",\n    \"PEAKING\",\n    \"PERMISSION_DENIED\",\n    \"PERSISTENT\",\n    \"PI\",\n    \"PIXEL_PACK_BUFFER\",\n    \"PIXEL_PACK_BUFFER_BINDING\",\n    \"PIXEL_UNPACK_BUFFER\",\n    \"PIXEL_UNPACK_BUFFER_BINDING\",\n    \"PLAYING_STATE\",\n    \"POINTS\",\n    \"POLYGON_OFFSET_FACTOR\",\n    \"POLYGON_OFFSET_FILL\",\n    \"POLYGON_OFFSET_UNITS\",\n    \"POSITION_UNAVAILABLE\",\n    \"POSITIVE_INFINITY\",\n    \"PREV\",\n    \"PREV_NO_DUPLICATE\",\n    \"PROCESSING_INSTRUCTION_NODE\",\n    \"PageChangeEvent\",\n    \"PageTransitionEvent\",\n    \"PaintRequest\",\n    \"PaintRequestList\",\n    \"PannerNode\",\n    \"PasswordCredential\",\n    \"Path2D\",\n    \"PaymentAddress\",\n    \"PaymentInstruments\",\n    \"PaymentManager\",\n    \"PaymentMethodChangeEvent\",\n    \"PaymentRequest\",\n    \"PaymentRequestUpdateEvent\",\n    \"PaymentResponse\",\n    \"Performance\",\n    \"PerformanceElementTiming\",\n    \"PerformanceEntry\",\n    \"PerformanceEventTiming\",\n    \"PerformanceLongTaskTiming\",\n    \"PerformanceMark\",\n    \"PerformanceMeasure\",\n    \"PerformanceNavigation\",\n    \"PerformanceNavigationTiming\",\n    \"PerformanceObserver\",\n    \"PerformanceObserverEntryList\",\n    \"PerformancePaintTiming\",\n    \"PerformanceResourceTiming\",\n    \"PerformanceServerTiming\",\n    \"PerformanceTiming\",\n    \"PeriodicSyncManager\",\n    \"PeriodicWave\",\n    \"PermissionStatus\",\n    \"Permissions\",\n    \"PhotoCapabilities\",\n    \"PictureInPictureWindow\",\n    \"Plugin\",\n    \"PluginArray\",\n    \"PluralRules\",\n    \"PointerEvent\",\n    \"PopStateEvent\",\n    \"PopupBlockedEvent\",\n    \"Presentation\",\n    \"PresentationAvailability\",\n    \"PresentationConnection\",\n    \"PresentationConnectionAvailableEvent\",\n    \"PresentationConnectionCloseEvent\",\n    \"PresentationConnectionList\",\n    \"PresentationReceiver\",\n    \"PresentationRequest\",\n    \"ProcessingInstruction\",\n    \"ProgressEvent\",\n    \"Promise\",\n    \"PromiseRejectionEvent\",\n    \"PropertyNodeList\",\n    \"Proxy\",\n    \"PublicKeyCredential\",\n    \"PushManager\",\n    \"PushSubscription\",\n    \"PushSubscriptionOptions\",\n    \"Q\",\n    \"QUERY_RESULT\",\n    \"QUERY_RESULT_AVAILABLE\",\n    \"QUOTA_ERR\",\n    \"QUOTA_EXCEEDED_ERR\",\n    \"QueryInterface\",\n    \"R11F_G11F_B10F\",\n    \"R16F\",\n    \"R16I\",\n    \"R16UI\",\n    \"R32F\",\n    \"R32I\",\n    \"R32UI\",\n    \"R8\",\n    \"R8I\",\n    \"R8UI\",\n    \"R8_SNORM\",\n    \"RASTERIZER_DISCARD\",\n    \"READ_BUFFER\",\n    \"READ_FRAMEBUFFER\",\n    \"READ_FRAMEBUFFER_BINDING\",\n    \"READ_ONLY\",\n    \"READ_ONLY_ERR\",\n    \"READ_WRITE\",\n    \"RED\",\n    \"RED_BITS\",\n    \"RED_INTEGER\",\n    \"REMOVAL\",\n    \"RENDERBUFFER\",\n    \"RENDERBUFFER_ALPHA_SIZE\",\n    \"RENDERBUFFER_BINDING\",\n    \"RENDERBUFFER_BLUE_SIZE\",\n    \"RENDERBUFFER_DEPTH_SIZE\",\n    \"RENDERBUFFER_GREEN_SIZE\",\n    \"RENDERBUFFER_HEIGHT\",\n    \"RENDERBUFFER_INTERNAL_FORMAT\",\n    \"RENDERBUFFER_RED_SIZE\",\n    \"RENDERBUFFER_SAMPLES\",\n    \"RENDERBUFFER_STENCIL_SIZE\",\n    \"RENDERBUFFER_WIDTH\",\n    \"RENDERER\",\n    \"RENDERING_INTENT_ABSOLUTE_COLORIMETRIC\",\n    \"RENDERING_INTENT_AUTO\",\n    \"RENDERING_INTENT_PERCEPTUAL\",\n    \"RENDERING_INTENT_RELATIVE_COLORIMETRIC\",\n    \"RENDERING_INTENT_SATURATION\",\n    \"RENDERING_INTENT_UNKNOWN\",\n    \"REPEAT\",\n    \"REPLACE\",\n    \"RG\",\n    \"RG16F\",\n    \"RG16I\",\n    \"RG16UI\",\n    \"RG32F\",\n    \"RG32I\",\n    \"RG32UI\",\n    \"RG8\",\n    \"RG8I\",\n    \"RG8UI\",\n    \"RG8_SNORM\",\n    \"RGB\",\n    \"RGB10_A2\",\n    \"RGB10_A2UI\",\n    \"RGB16F\",\n    \"RGB16I\",\n    \"RGB16UI\",\n    \"RGB32F\",\n    \"RGB32I\",\n    \"RGB32UI\",\n    \"RGB565\",\n    \"RGB5_A1\",\n    \"RGB8\",\n    \"RGB8I\",\n    \"RGB8UI\",\n    \"RGB8_SNORM\",\n    \"RGB9_E5\",\n    \"RGBA\",\n    \"RGBA16F\",\n    \"RGBA16I\",\n    \"RGBA16UI\",\n    \"RGBA32F\",\n    \"RGBA32I\",\n    \"RGBA32UI\",\n    \"RGBA4\",\n    \"RGBA8\",\n    \"RGBA8I\",\n    \"RGBA8UI\",\n    \"RGBA8_SNORM\",\n    \"RGBA_INTEGER\",\n    \"RGBColor\",\n    \"RGB_INTEGER\",\n    \"RG_INTEGER\",\n    \"ROTATION_CLOCKWISE\",\n    \"ROTATION_COUNTERCLOCKWISE\",\n    \"RTCCertificate\",\n    \"RTCDTMFSender\",\n    \"RTCDTMFToneChangeEvent\",\n    \"RTCDataChannel\",\n    \"RTCDataChannelEvent\",\n    \"RTCDtlsTransport\",\n    \"RTCError\",\n    \"RTCErrorEvent\",\n    \"RTCIceCandidate\",\n    \"RTCIceTransport\",\n    \"RTCPeerConnection\",\n    \"RTCPeerConnectionIceErrorEvent\",\n    \"RTCPeerConnectionIceEvent\",\n    \"RTCRtpReceiver\",\n    \"RTCRtpSender\",\n    \"RTCRtpTransceiver\",\n    \"RTCSctpTransport\",\n    \"RTCSessionDescription\",\n    \"RTCStatsReport\",\n    \"RTCTrackEvent\",\n    \"RadioNodeList\",\n    \"Range\",\n    \"RangeError\",\n    \"RangeException\",\n    \"ReadableStream\",\n    \"ReadableStreamDefaultReader\",\n    \"RecordErrorEvent\",\n    \"Rect\",\n    \"ReferenceError\",\n    \"Reflect\",\n    \"RegExp\",\n    \"RelativeOrientationSensor\",\n    \"RelativeTimeFormat\",\n    \"RemotePlayback\",\n    \"Report\",\n    \"ReportBody\",\n    \"ReportingObserver\",\n    \"Request\",\n    \"ResizeObserver\",\n    \"ResizeObserverEntry\",\n    \"ResizeObserverSize\",\n    \"Response\",\n    \"RuntimeError\",\n    \"SAMPLER_2D\",\n    \"SAMPLER_2D_ARRAY\",\n    \"SAMPLER_2D_ARRAY_SHADOW\",\n    \"SAMPLER_2D_SHADOW\",\n    \"SAMPLER_3D\",\n    \"SAMPLER_BINDING\",\n    \"SAMPLER_CUBE\",\n    \"SAMPLER_CUBE_SHADOW\",\n    \"SAMPLES\",\n    \"SAMPLE_ALPHA_TO_COVERAGE\",\n    \"SAMPLE_BUFFERS\",\n    \"SAMPLE_COVERAGE\",\n    \"SAMPLE_COVERAGE_INVERT\",\n    \"SAMPLE_COVERAGE_VALUE\",\n    \"SAWTOOTH\",\n    \"SCHEDULED_STATE\",\n    \"SCISSOR_BOX\",\n    \"SCISSOR_TEST\",\n    \"SCROLL_PAGE_DOWN\",\n    \"SCROLL_PAGE_UP\",\n    \"SDP_ANSWER\",\n    \"SDP_OFFER\",\n    \"SDP_PRANSWER\",\n    \"SECURITY_ERR\",\n    \"SELECT\",\n    \"SEPARATE_ATTRIBS\",\n    \"SERIALIZE_ERR\",\n    \"SEVERITY_ERROR\",\n    \"SEVERITY_FATAL_ERROR\",\n    \"SEVERITY_WARNING\",\n    \"SHADER_COMPILER\",\n    \"SHADER_TYPE\",\n    \"SHADING_LANGUAGE_VERSION\",\n    \"SHIFT_MASK\",\n    \"SHORT\",\n    \"SHOWING\",\n    \"SHOW_ALL\",\n    \"SHOW_ATTRIBUTE\",\n    \"SHOW_CDATA_SECTION\",\n    \"SHOW_COMMENT\",\n    \"SHOW_DOCUMENT\",\n    \"SHOW_DOCUMENT_FRAGMENT\",\n    \"SHOW_DOCUMENT_TYPE\",\n    \"SHOW_ELEMENT\",\n    \"SHOW_ENTITY\",\n    \"SHOW_ENTITY_REFERENCE\",\n    \"SHOW_NOTATION\",\n    \"SHOW_PROCESSING_INSTRUCTION\",\n    \"SHOW_TEXT\",\n    \"SIGNALED\",\n    \"SIGNED_NORMALIZED\",\n    \"SINE\",\n    \"SOUNDFIELD\",\n    \"SQLException\",\n    \"SQRT1_2\",\n    \"SQRT2\",\n    \"SQUARE\",\n    \"SRC_ALPHA\",\n    \"SRC_ALPHA_SATURATE\",\n    \"SRC_COLOR\",\n    \"SRGB\",\n    \"SRGB8\",\n    \"SRGB8_ALPHA8\",\n    \"START_TO_END\",\n    \"START_TO_START\",\n    \"STATIC_COPY\",\n    \"STATIC_DRAW\",\n    \"STATIC_READ\",\n    \"STENCIL\",\n    \"STENCIL_ATTACHMENT\",\n    \"STENCIL_BACK_FAIL\",\n    \"STENCIL_BACK_FUNC\",\n    \"STENCIL_BACK_PASS_DEPTH_FAIL\",\n    \"STENCIL_BACK_PASS_DEPTH_PASS\",\n    \"STENCIL_BACK_REF\",\n    \"STENCIL_BACK_VALUE_MASK\",\n    \"STENCIL_BACK_WRITEMASK\",\n    \"STENCIL_BITS\",\n    \"STENCIL_BUFFER_BIT\",\n    \"STENCIL_CLEAR_VALUE\",\n    \"STENCIL_FAIL\",\n    \"STENCIL_FUNC\",\n    \"STENCIL_INDEX\",\n    \"STENCIL_INDEX8\",\n    \"STENCIL_PASS_DEPTH_FAIL\",\n    \"STENCIL_PASS_DEPTH_PASS\",\n    \"STENCIL_REF\",\n    \"STENCIL_TEST\",\n    \"STENCIL_VALUE_MASK\",\n    \"STENCIL_WRITEMASK\",\n    \"STREAM_COPY\",\n    \"STREAM_DRAW\",\n    \"STREAM_READ\",\n    \"STRING_TYPE\",\n    \"STYLE_RULE\",\n    \"SUBPIXEL_BITS\",\n    \"SUPPORTS_RULE\",\n    \"SVGAElement\",\n    \"SVGAltGlyphDefElement\",\n    \"SVGAltGlyphElement\",\n    \"SVGAltGlyphItemElement\",\n    \"SVGAngle\",\n    \"SVGAnimateColorElement\",\n    \"SVGAnimateElement\",\n    \"SVGAnimateMotionElement\",\n    \"SVGAnimateTransformElement\",\n    \"SVGAnimatedAngle\",\n    \"SVGAnimatedBoolean\",\n    \"SVGAnimatedEnumeration\",\n    \"SVGAnimatedInteger\",\n    \"SVGAnimatedLength\",\n    \"SVGAnimatedLengthList\",\n    \"SVGAnimatedNumber\",\n    \"SVGAnimatedNumberList\",\n    \"SVGAnimatedPreserveAspectRatio\",\n    \"SVGAnimatedRect\",\n    \"SVGAnimatedString\",\n    \"SVGAnimatedTransformList\",\n    \"SVGAnimationElement\",\n    \"SVGCircleElement\",\n    \"SVGClipPathElement\",\n    \"SVGColor\",\n    \"SVGComponentTransferFunctionElement\",\n    \"SVGCursorElement\",\n    \"SVGDefsElement\",\n    \"SVGDescElement\",\n    \"SVGDiscardElement\",\n    \"SVGDocument\",\n    \"SVGElement\",\n    \"SVGElementInstance\",\n    \"SVGElementInstanceList\",\n    \"SVGEllipseElement\",\n    \"SVGException\",\n    \"SVGFEBlendElement\",\n    \"SVGFEColorMatrixElement\",\n    \"SVGFEComponentTransferElement\",\n    \"SVGFECompositeElement\",\n    \"SVGFEConvolveMatrixElement\",\n    \"SVGFEDiffuseLightingElement\",\n    \"SVGFEDisplacementMapElement\",\n    \"SVGFEDistantLightElement\",\n    \"SVGFEDropShadowElement\",\n    \"SVGFEFloodElement\",\n    \"SVGFEFuncAElement\",\n    \"SVGFEFuncBElement\",\n    \"SVGFEFuncGElement\",\n    \"SVGFEFuncRElement\",\n    \"SVGFEGaussianBlurElement\",\n    \"SVGFEImageElement\",\n    \"SVGFEMergeElement\",\n    \"SVGFEMergeNodeElement\",\n    \"SVGFEMorphologyElement\",\n    \"SVGFEOffsetElement\",\n    \"SVGFEPointLightElement\",\n    \"SVGFESpecularLightingElement\",\n    \"SVGFESpotLightElement\",\n    \"SVGFETileElement\",\n    \"SVGFETurbulenceElement\",\n    \"SVGFilterElement\",\n    \"SVGFontElement\",\n    \"SVGFontFaceElement\",\n    \"SVGFontFaceFormatElement\",\n    \"SVGFontFaceNameElement\",\n    \"SVGFontFaceSrcElement\",\n    \"SVGFontFaceUriElement\",\n    \"SVGForeignObjectElement\",\n    \"SVGGElement\",\n    \"SVGGeometryElement\",\n    \"SVGGlyphElement\",\n    \"SVGGlyphRefElement\",\n    \"SVGGradientElement\",\n    \"SVGGraphicsElement\",\n    \"SVGHKernElement\",\n    \"SVGImageElement\",\n    \"SVGLength\",\n    \"SVGLengthList\",\n    \"SVGLineElement\",\n    \"SVGLinearGradientElement\",\n    \"SVGMPathElement\",\n    \"SVGMarkerElement\",\n    \"SVGMaskElement\",\n    \"SVGMatrix\",\n    \"SVGMetadataElement\",\n    \"SVGMissingGlyphElement\",\n    \"SVGNumber\",\n    \"SVGNumberList\",\n    \"SVGPaint\",\n    \"SVGPathElement\",\n    \"SVGPathSeg\",\n    \"SVGPathSegArcAbs\",\n    \"SVGPathSegArcRel\",\n    \"SVGPathSegClosePath\",\n    \"SVGPathSegCurvetoCubicAbs\",\n    \"SVGPathSegCurvetoCubicRel\",\n    \"SVGPathSegCurvetoCubicSmoothAbs\",\n    \"SVGPathSegCurvetoCubicSmoothRel\",\n    \"SVGPathSegCurvetoQuadraticAbs\",\n    \"SVGPathSegCurvetoQuadraticRel\",\n    \"SVGPathSegCurvetoQuadraticSmoothAbs\",\n    \"SVGPathSegCurvetoQuadraticSmoothRel\",\n    \"SVGPathSegLinetoAbs\",\n    \"SVGPathSegLinetoHorizontalAbs\",\n    \"SVGPathSegLinetoHorizontalRel\",\n    \"SVGPathSegLinetoRel\",\n    \"SVGPathSegLinetoVerticalAbs\",\n    \"SVGPathSegLinetoVerticalRel\",\n    \"SVGPathSegList\",\n    \"SVGPathSegMovetoAbs\",\n    \"SVGPathSegMovetoRel\",\n    \"SVGPatternElement\",\n    \"SVGPoint\",\n    \"SVGPointList\",\n    \"SVGPolygonElement\",\n    \"SVGPolylineElement\",\n    \"SVGPreserveAspectRatio\",\n    \"SVGRadialGradientElement\",\n    \"SVGRect\",\n    \"SVGRectElement\",\n    \"SVGRenderingIntent\",\n    \"SVGSVGElement\",\n    \"SVGScriptElement\",\n    \"SVGSetElement\",\n    \"SVGStopElement\",\n    \"SVGStringList\",\n    \"SVGStyleElement\",\n    \"SVGSwitchElement\",\n    \"SVGSymbolElement\",\n    \"SVGTRefElement\",\n    \"SVGTSpanElement\",\n    \"SVGTextContentElement\",\n    \"SVGTextElement\",\n    \"SVGTextPathElement\",\n    \"SVGTextPositioningElement\",\n    \"SVGTitleElement\",\n    \"SVGTransform\",\n    \"SVGTransformList\",\n    \"SVGUnitTypes\",\n    \"SVGUseElement\",\n    \"SVGVKernElement\",\n    \"SVGViewElement\",\n    \"SVGViewSpec\",\n    \"SVGZoomAndPan\",\n    \"SVGZoomEvent\",\n    \"SVG_ANGLETYPE_DEG\",\n    \"SVG_ANGLETYPE_GRAD\",\n    \"SVG_ANGLETYPE_RAD\",\n    \"SVG_ANGLETYPE_UNKNOWN\",\n    \"SVG_ANGLETYPE_UNSPECIFIED\",\n    \"SVG_CHANNEL_A\",\n    \"SVG_CHANNEL_B\",\n    \"SVG_CHANNEL_G\",\n    \"SVG_CHANNEL_R\",\n    \"SVG_CHANNEL_UNKNOWN\",\n    \"SVG_COLORTYPE_CURRENTCOLOR\",\n    \"SVG_COLORTYPE_RGBCOLOR\",\n    \"SVG_COLORTYPE_RGBCOLOR_ICCCOLOR\",\n    \"SVG_COLORTYPE_UNKNOWN\",\n    \"SVG_EDGEMODE_DUPLICATE\",\n    \"SVG_EDGEMODE_NONE\",\n    \"SVG_EDGEMODE_UNKNOWN\",\n    \"SVG_EDGEMODE_WRAP\",\n    \"SVG_FEBLEND_MODE_COLOR\",\n    \"SVG_FEBLEND_MODE_COLOR_BURN\",\n    \"SVG_FEBLEND_MODE_COLOR_DODGE\",\n    \"SVG_FEBLEND_MODE_DARKEN\",\n    \"SVG_FEBLEND_MODE_DIFFERENCE\",\n    \"SVG_FEBLEND_MODE_EXCLUSION\",\n    \"SVG_FEBLEND_MODE_HARD_LIGHT\",\n    \"SVG_FEBLEND_MODE_HUE\",\n    \"SVG_FEBLEND_MODE_LIGHTEN\",\n    \"SVG_FEBLEND_MODE_LUMINOSITY\",\n    \"SVG_FEBLEND_MODE_MULTIPLY\",\n    \"SVG_FEBLEND_MODE_NORMAL\",\n    \"SVG_FEBLEND_MODE_OVERLAY\",\n    \"SVG_FEBLEND_MODE_SATURATION\",\n    \"SVG_FEBLEND_MODE_SCREEN\",\n    \"SVG_FEBLEND_MODE_SOFT_LIGHT\",\n    \"SVG_FEBLEND_MODE_UNKNOWN\",\n    \"SVG_FECOLORMATRIX_TYPE_HUEROTATE\",\n    \"SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA\",\n    \"SVG_FECOLORMATRIX_TYPE_MATRIX\",\n    \"SVG_FECOLORMATRIX_TYPE_SATURATE\",\n    \"SVG_FECOLORMATRIX_TYPE_UNKNOWN\",\n    \"SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE\",\n    \"SVG_FECOMPONENTTRANSFER_TYPE_GAMMA\",\n    \"SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY\",\n    \"SVG_FECOMPONENTTRANSFER_TYPE_LINEAR\",\n    \"SVG_FECOMPONENTTRANSFER_TYPE_TABLE\",\n    \"SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN\",\n    \"SVG_FECOMPOSITE_OPERATOR_ARITHMETIC\",\n    \"SVG_FECOMPOSITE_OPERATOR_ATOP\",\n    \"SVG_FECOMPOSITE_OPERATOR_IN\",\n    \"SVG_FECOMPOSITE_OPERATOR_OUT\",\n    \"SVG_FECOMPOSITE_OPERATOR_OVER\",\n    \"SVG_FECOMPOSITE_OPERATOR_UNKNOWN\",\n    \"SVG_FECOMPOSITE_OPERATOR_XOR\",\n    \"SVG_INVALID_VALUE_ERR\",\n    \"SVG_LENGTHTYPE_CM\",\n    \"SVG_LENGTHTYPE_EMS\",\n    \"SVG_LENGTHTYPE_EXS\",\n    \"SVG_LENGTHTYPE_IN\",\n    \"SVG_LENGTHTYPE_MM\",\n    \"SVG_LENGTHTYPE_NUMBER\",\n    \"SVG_LENGTHTYPE_PC\",\n    \"SVG_LENGTHTYPE_PERCENTAGE\",\n    \"SVG_LENGTHTYPE_PT\",\n    \"SVG_LENGTHTYPE_PX\",\n    \"SVG_LENGTHTYPE_UNKNOWN\",\n    \"SVG_MARKERUNITS_STROKEWIDTH\",\n    \"SVG_MARKERUNITS_UNKNOWN\",\n    \"SVG_MARKERUNITS_USERSPACEONUSE\",\n    \"SVG_MARKER_ORIENT_ANGLE\",\n    \"SVG_MARKER_ORIENT_AUTO\",\n    \"SVG_MARKER_ORIENT_UNKNOWN\",\n    \"SVG_MASKTYPE_ALPHA\",\n    \"SVG_MASKTYPE_LUMINANCE\",\n    \"SVG_MATRIX_NOT_INVERTABLE\",\n    \"SVG_MEETORSLICE_MEET\",\n    \"SVG_MEETORSLICE_SLICE\",\n    \"SVG_MEETORSLICE_UNKNOWN\",\n    \"SVG_MORPHOLOGY_OPERATOR_DILATE\",\n    \"SVG_MORPHOLOGY_OPERATOR_ERODE\",\n    \"SVG_MORPHOLOGY_OPERATOR_UNKNOWN\",\n    \"SVG_PAINTTYPE_CURRENTCOLOR\",\n    \"SVG_PAINTTYPE_NONE\",\n    \"SVG_PAINTTYPE_RGBCOLOR\",\n    \"SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR\",\n    \"SVG_PAINTTYPE_UNKNOWN\",\n    \"SVG_PAINTTYPE_URI\",\n    \"SVG_PAINTTYPE_URI_CURRENTCOLOR\",\n    \"SVG_PAINTTYPE_URI_NONE\",\n    \"SVG_PAINTTYPE_URI_RGBCOLOR\",\n    \"SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR\",\n    \"SVG_PRESERVEASPECTRATIO_NONE\",\n    \"SVG_PRESERVEASPECTRATIO_UNKNOWN\",\n    \"SVG_PRESERVEASPECTRATIO_XMAXYMAX\",\n    \"SVG_PRESERVEASPECTRATIO_XMAXYMID\",\n    \"SVG_PRESERVEASPECTRATIO_XMAXYMIN\",\n    \"SVG_PRESERVEASPECTRATIO_XMIDYMAX\",\n    \"SVG_PRESERVEASPECTRATIO_XMIDYMID\",\n    \"SVG_PRESERVEASPECTRATIO_XMIDYMIN\",\n    \"SVG_PRESERVEASPECTRATIO_XMINYMAX\",\n    \"SVG_PRESERVEASPECTRATIO_XMINYMID\",\n    \"SVG_PRESERVEASPECTRATIO_XMINYMIN\",\n    \"SVG_SPREADMETHOD_PAD\",\n    \"SVG_SPREADMETHOD_REFLECT\",\n    \"SVG_SPREADMETHOD_REPEAT\",\n    \"SVG_SPREADMETHOD_UNKNOWN\",\n    \"SVG_STITCHTYPE_NOSTITCH\",\n    \"SVG_STITCHTYPE_STITCH\",\n    \"SVG_STITCHTYPE_UNKNOWN\",\n    \"SVG_TRANSFORM_MATRIX\",\n    \"SVG_TRANSFORM_ROTATE\",\n    \"SVG_TRANSFORM_SCALE\",\n    \"SVG_TRANSFORM_SKEWX\",\n    \"SVG_TRANSFORM_SKEWY\",\n    \"SVG_TRANSFORM_TRANSLATE\",\n    \"SVG_TRANSFORM_UNKNOWN\",\n    \"SVG_TURBULENCE_TYPE_FRACTALNOISE\",\n    \"SVG_TURBULENCE_TYPE_TURBULENCE\",\n    \"SVG_TURBULENCE_TYPE_UNKNOWN\",\n    \"SVG_UNIT_TYPE_OBJECTBOUNDINGBOX\",\n    \"SVG_UNIT_TYPE_UNKNOWN\",\n    \"SVG_UNIT_TYPE_USERSPACEONUSE\",\n    \"SVG_WRONG_TYPE_ERR\",\n    \"SVG_ZOOMANDPAN_DISABLE\",\n    \"SVG_ZOOMANDPAN_MAGNIFY\",\n    \"SVG_ZOOMANDPAN_UNKNOWN\",\n    \"SYNC_CONDITION\",\n    \"SYNC_FENCE\",\n    \"SYNC_FLAGS\",\n    \"SYNC_FLUSH_COMMANDS_BIT\",\n    \"SYNC_GPU_COMMANDS_COMPLETE\",\n    \"SYNC_STATUS\",\n    \"SYNTAX_ERR\",\n    \"SavedPages\",\n    \"Screen\",\n    \"ScreenOrientation\",\n    \"Script\",\n    \"ScriptProcessorNode\",\n    \"ScrollAreaEvent\",\n    \"SecurityPolicyViolationEvent\",\n    \"Selection\",\n    \"Sensor\",\n    \"SensorErrorEvent\",\n    \"ServiceWorker\",\n    \"ServiceWorkerContainer\",\n    \"ServiceWorkerRegistration\",\n    \"SessionDescription\",\n    \"Set\",\n    \"ShadowRoot\",\n    \"SharedArrayBuffer\",\n    \"SharedWorker\",\n    \"SimpleGestureEvent\",\n    \"SourceBuffer\",\n    \"SourceBufferList\",\n    \"SpeechSynthesis\",\n    \"SpeechSynthesisErrorEvent\",\n    \"SpeechSynthesisEvent\",\n    \"SpeechSynthesisUtterance\",\n    \"SpeechSynthesisVoice\",\n    \"StaticRange\",\n    \"StereoPannerNode\",\n    \"StopIteration\",\n    \"Storage\",\n    \"StorageEvent\",\n    \"StorageManager\",\n    \"String\",\n    \"StructType\",\n    \"StylePropertyMap\",\n    \"StylePropertyMapReadOnly\",\n    \"StyleSheet\",\n    \"StyleSheetList\",\n    \"SubmitEvent\",\n    \"SubtleCrypto\",\n    \"Symbol\",\n    \"SyncManager\",\n    \"SyntaxError\",\n    \"TEMPORARY\",\n    \"TEXTPATH_METHODTYPE_ALIGN\",\n    \"TEXTPATH_METHODTYPE_STRETCH\",\n    \"TEXTPATH_METHODTYPE_UNKNOWN\",\n    \"TEXTPATH_SPACINGTYPE_AUTO\",\n    \"TEXTPATH_SPACINGTYPE_EXACT\",\n    \"TEXTPATH_SPACINGTYPE_UNKNOWN\",\n    \"TEXTURE\",\n    \"TEXTURE0\",\n    \"TEXTURE1\",\n    \"TEXTURE10\",\n    \"TEXTURE11\",\n    \"TEXTURE12\",\n    \"TEXTURE13\",\n    \"TEXTURE14\",\n    \"TEXTURE15\",\n    \"TEXTURE16\",\n    \"TEXTURE17\",\n    \"TEXTURE18\",\n    \"TEXTURE19\",\n    \"TEXTURE2\",\n    \"TEXTURE20\",\n    \"TEXTURE21\",\n    \"TEXTURE22\",\n    \"TEXTURE23\",\n    \"TEXTURE24\",\n    \"TEXTURE25\",\n    \"TEXTURE26\",\n    \"TEXTURE27\",\n    \"TEXTURE28\",\n    \"TEXTURE29\",\n    \"TEXTURE3\",\n    \"TEXTURE30\",\n    \"TEXTURE31\",\n    \"TEXTURE4\",\n    \"TEXTURE5\",\n    \"TEXTURE6\",\n    \"TEXTURE7\",\n    \"TEXTURE8\",\n    \"TEXTURE9\",\n    \"TEXTURE_2D\",\n    \"TEXTURE_2D_ARRAY\",\n    \"TEXTURE_3D\",\n    \"TEXTURE_BASE_LEVEL\",\n    \"TEXTURE_BINDING_2D\",\n    \"TEXTURE_BINDING_2D_ARRAY\",\n    \"TEXTURE_BINDING_3D\",\n    \"TEXTURE_BINDING_CUBE_MAP\",\n    \"TEXTURE_COMPARE_FUNC\",\n    \"TEXTURE_COMPARE_MODE\",\n    \"TEXTURE_CUBE_MAP\",\n    \"TEXTURE_CUBE_MAP_NEGATIVE_X\",\n    \"TEXTURE_CUBE_MAP_NEGATIVE_Y\",\n    \"TEXTURE_CUBE_MAP_NEGATIVE_Z\",\n    \"TEXTURE_CUBE_MAP_POSITIVE_X\",\n    \"TEXTURE_CUBE_MAP_POSITIVE_Y\",\n    \"TEXTURE_CUBE_MAP_POSITIVE_Z\",\n    \"TEXTURE_IMMUTABLE_FORMAT\",\n    \"TEXTURE_IMMUTABLE_LEVELS\",\n    \"TEXTURE_MAG_FILTER\",\n    \"TEXTURE_MAX_ANISOTROPY_EXT\",\n    \"TEXTURE_MAX_LEVEL\",\n    \"TEXTURE_MAX_LOD\",\n    \"TEXTURE_MIN_FILTER\",\n    \"TEXTURE_MIN_LOD\",\n    \"TEXTURE_WRAP_R\",\n    \"TEXTURE_WRAP_S\",\n    \"TEXTURE_WRAP_T\",\n    \"TEXT_NODE\",\n    \"TIMEOUT\",\n    \"TIMEOUT_ERR\",\n    \"TIMEOUT_EXPIRED\",\n    \"TIMEOUT_IGNORED\",\n    \"TOO_LARGE_ERR\",\n    \"TRANSACTION_INACTIVE_ERR\",\n    \"TRANSFORM_FEEDBACK\",\n    \"TRANSFORM_FEEDBACK_ACTIVE\",\n    \"TRANSFORM_FEEDBACK_BINDING\",\n    \"TRANSFORM_FEEDBACK_BUFFER\",\n    \"TRANSFORM_FEEDBACK_BUFFER_BINDING\",\n    \"TRANSFORM_FEEDBACK_BUFFER_MODE\",\n    \"TRANSFORM_FEEDBACK_BUFFER_SIZE\",\n    \"TRANSFORM_FEEDBACK_BUFFER_START\",\n    \"TRANSFORM_FEEDBACK_PAUSED\",\n    \"TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN\",\n    \"TRANSFORM_FEEDBACK_VARYINGS\",\n    \"TRIANGLE\",\n    \"TRIANGLES\",\n    \"TRIANGLE_FAN\",\n    \"TRIANGLE_STRIP\",\n    \"TYPE_BACK_FORWARD\",\n    \"TYPE_ERR\",\n    \"TYPE_MISMATCH_ERR\",\n    \"TYPE_NAVIGATE\",\n    \"TYPE_RELOAD\",\n    \"TYPE_RESERVED\",\n    \"Table\",\n    \"TaskAttributionTiming\",\n    \"Text\",\n    \"TextDecoder\",\n    \"TextDecoderStream\",\n    \"TextEncoder\",\n    \"TextEncoderStream\",\n    \"TextEvent\",\n    \"TextMetrics\",\n    \"TextTrack\",\n    \"TextTrackCue\",\n    \"TextTrackCueList\",\n    \"TextTrackList\",\n    \"TimeEvent\",\n    \"TimeRanges\",\n    \"Touch\",\n    \"TouchEvent\",\n    \"TouchList\",\n    \"TrackEvent\",\n    \"TransformStream\",\n    \"TransitionEvent\",\n    \"TreeWalker\",\n    \"TrustedHTML\",\n    \"TrustedScript\",\n    \"TrustedScriptURL\",\n    \"TrustedTypePolicy\",\n    \"TrustedTypePolicyFactory\",\n    \"TypeError\",\n    \"TypedObject\",\n    \"U2F\",\n    \"UIEvent\",\n    \"UNCACHED\",\n    \"UNIFORM_ARRAY_STRIDE\",\n    \"UNIFORM_BLOCK_ACTIVE_UNIFORMS\",\n    \"UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES\",\n    \"UNIFORM_BLOCK_BINDING\",\n    \"UNIFORM_BLOCK_DATA_SIZE\",\n    \"UNIFORM_BLOCK_INDEX\",\n    \"UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER\",\n    \"UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER\",\n    \"UNIFORM_BUFFER\",\n    \"UNIFORM_BUFFER_BINDING\",\n    \"UNIFORM_BUFFER_OFFSET_ALIGNMENT\",\n    \"UNIFORM_BUFFER_SIZE\",\n    \"UNIFORM_BUFFER_START\",\n    \"UNIFORM_IS_ROW_MAJOR\",\n    \"UNIFORM_MATRIX_STRIDE\",\n    \"UNIFORM_OFFSET\",\n    \"UNIFORM_SIZE\",\n    \"UNIFORM_TYPE\",\n    \"UNKNOWN_ERR\",\n    \"UNKNOWN_RULE\",\n    \"UNMASKED_RENDERER_WEBGL\",\n    \"UNMASKED_VENDOR_WEBGL\",\n    \"UNORDERED_NODE_ITERATOR_TYPE\",\n    \"UNORDERED_NODE_SNAPSHOT_TYPE\",\n    \"UNPACK_ALIGNMENT\",\n    \"UNPACK_COLORSPACE_CONVERSION_WEBGL\",\n    \"UNPACK_FLIP_Y_WEBGL\",\n    \"UNPACK_IMAGE_HEIGHT\",\n    \"UNPACK_PREMULTIPLY_ALPHA_WEBGL\",\n    \"UNPACK_ROW_LENGTH\",\n    \"UNPACK_SKIP_IMAGES\",\n    \"UNPACK_SKIP_PIXELS\",\n    \"UNPACK_SKIP_ROWS\",\n    \"UNSCHEDULED_STATE\",\n    \"UNSENT\",\n    \"UNSIGNALED\",\n    \"UNSIGNED_BYTE\",\n    \"UNSIGNED_INT\",\n    \"UNSIGNED_INT_10F_11F_11F_REV\",\n    \"UNSIGNED_INT_24_8\",\n    \"UNSIGNED_INT_2_10_10_10_REV\",\n    \"UNSIGNED_INT_5_9_9_9_REV\",\n    \"UNSIGNED_INT_SAMPLER_2D\",\n    \"UNSIGNED_INT_SAMPLER_2D_ARRAY\",\n    \"UNSIGNED_INT_SAMPLER_3D\",\n    \"UNSIGNED_INT_SAMPLER_CUBE\",\n    \"UNSIGNED_INT_VEC2\",\n    \"UNSIGNED_INT_VEC3\",\n    \"UNSIGNED_INT_VEC4\",\n    \"UNSIGNED_NORMALIZED\",\n    \"UNSIGNED_SHORT\",\n    \"UNSIGNED_SHORT_4_4_4_4\",\n    \"UNSIGNED_SHORT_5_5_5_1\",\n    \"UNSIGNED_SHORT_5_6_5\",\n    \"UNSPECIFIED_EVENT_TYPE_ERR\",\n    \"UPDATEREADY\",\n    \"URIError\",\n    \"URL\",\n    \"URLSearchParams\",\n    \"URLUnencoded\",\n    \"URL_MISMATCH_ERR\",\n    \"USB\",\n    \"USBAlternateInterface\",\n    \"USBConfiguration\",\n    \"USBConnectionEvent\",\n    \"USBDevice\",\n    \"USBEndpoint\",\n    \"USBInTransferResult\",\n    \"USBInterface\",\n    \"USBIsochronousInTransferPacket\",\n    \"USBIsochronousInTransferResult\",\n    \"USBIsochronousOutTransferPacket\",\n    \"USBIsochronousOutTransferResult\",\n    \"USBOutTransferResult\",\n    \"UTC\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"UserActivation\",\n    \"UserMessageHandler\",\n    \"UserMessageHandlersNamespace\",\n    \"UserProximityEvent\",\n    \"VALIDATE_STATUS\",\n    \"VALIDATION_ERR\",\n    \"VARIABLES_RULE\",\n    \"VENDOR\",\n    \"VERSION\",\n    \"VERSION_CHANGE\",\n    \"VERSION_ERR\",\n    \"VERTEX_ARRAY_BINDING\",\n    \"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING\",\n    \"VERTEX_ATTRIB_ARRAY_DIVISOR\",\n    \"VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE\",\n    \"VERTEX_ATTRIB_ARRAY_ENABLED\",\n    \"VERTEX_ATTRIB_ARRAY_INTEGER\",\n    \"VERTEX_ATTRIB_ARRAY_NORMALIZED\",\n    \"VERTEX_ATTRIB_ARRAY_POINTER\",\n    \"VERTEX_ATTRIB_ARRAY_SIZE\",\n    \"VERTEX_ATTRIB_ARRAY_STRIDE\",\n    \"VERTEX_ATTRIB_ARRAY_TYPE\",\n    \"VERTEX_SHADER\",\n    \"VERTICAL\",\n    \"VERTICAL_AXIS\",\n    \"VER_ERR\",\n    \"VIEWPORT\",\n    \"VIEWPORT_RULE\",\n    \"VRDisplay\",\n    \"VRDisplayCapabilities\",\n    \"VRDisplayEvent\",\n    \"VREyeParameters\",\n    \"VRFieldOfView\",\n    \"VRFrameData\",\n    \"VRPose\",\n    \"VRStageParameters\",\n    \"VTTCue\",\n    \"VTTRegion\",\n    \"ValidityState\",\n    \"VideoPlaybackQuality\",\n    \"VideoStreamTrack\",\n    \"VisualViewport\",\n    \"WAIT_FAILED\",\n    \"WEBKIT_FILTER_RULE\",\n    \"WEBKIT_KEYFRAMES_RULE\",\n    \"WEBKIT_KEYFRAME_RULE\",\n    \"WEBKIT_REGION_RULE\",\n    \"WRONG_DOCUMENT_ERR\",\n    \"WakeLock\",\n    \"WakeLockSentinel\",\n    \"WasmAnyRef\",\n    \"WaveShaperNode\",\n    \"WeakMap\",\n    \"WeakRef\",\n    \"WeakSet\",\n    \"WebAssembly\",\n    \"WebGL2RenderingContext\",\n    \"WebGLActiveInfo\",\n    \"WebGLBuffer\",\n    \"WebGLContextEvent\",\n    \"WebGLFramebuffer\",\n    \"WebGLProgram\",\n    \"WebGLQuery\",\n    \"WebGLRenderbuffer\",\n    \"WebGLRenderingContext\",\n    \"WebGLSampler\",\n    \"WebGLShader\",\n    \"WebGLShaderPrecisionFormat\",\n    \"WebGLSync\",\n    \"WebGLTexture\",\n    \"WebGLTransformFeedback\",\n    \"WebGLUniformLocation\",\n    \"WebGLVertexArray\",\n    \"WebGLVertexArrayObject\",\n    \"WebKitAnimationEvent\",\n    \"WebKitBlobBuilder\",\n    \"WebKitCSSFilterRule\",\n    \"WebKitCSSFilterValue\",\n    \"WebKitCSSKeyframeRule\",\n    \"WebKitCSSKeyframesRule\",\n    \"WebKitCSSMatrix\",\n    \"WebKitCSSRegionRule\",\n    \"WebKitCSSTransformValue\",\n    \"WebKitDataCue\",\n    \"WebKitGamepad\",\n    \"WebKitMediaKeyError\",\n    \"WebKitMediaKeyMessageEvent\",\n    \"WebKitMediaKeySession\",\n    \"WebKitMediaKeys\",\n    \"WebKitMediaSource\",\n    \"WebKitMutationObserver\",\n    \"WebKitNamespace\",\n    \"WebKitPlaybackTargetAvailabilityEvent\",\n    \"WebKitPoint\",\n    \"WebKitShadowRoot\",\n    \"WebKitSourceBuffer\",\n    \"WebKitSourceBufferList\",\n    \"WebKitTransitionEvent\",\n    \"WebSocket\",\n    \"WebkitAlignContent\",\n    \"WebkitAlignItems\",\n    \"WebkitAlignSelf\",\n    \"WebkitAnimation\",\n    \"WebkitAnimationDelay\",\n    \"WebkitAnimationDirection\",\n    \"WebkitAnimationDuration\",\n    \"WebkitAnimationFillMode\",\n    \"WebkitAnimationIterationCount\",\n    \"WebkitAnimationName\",\n    \"WebkitAnimationPlayState\",\n    \"WebkitAnimationTimingFunction\",\n    \"WebkitAppearance\",\n    \"WebkitBackfaceVisibility\",\n    \"WebkitBackgroundClip\",\n    \"WebkitBackgroundOrigin\",\n    \"WebkitBackgroundSize\",\n    \"WebkitBorderBottomLeftRadius\",\n    \"WebkitBorderBottomRightRadius\",\n    \"WebkitBorderImage\",\n    \"WebkitBorderRadius\",\n    \"WebkitBorderTopLeftRadius\",\n    \"WebkitBorderTopRightRadius\",\n    \"WebkitBoxAlign\",\n    \"WebkitBoxDirection\",\n    \"WebkitBoxFlex\",\n    \"WebkitBoxOrdinalGroup\",\n    \"WebkitBoxOrient\",\n    \"WebkitBoxPack\",\n    \"WebkitBoxShadow\",\n    \"WebkitBoxSizing\",\n    \"WebkitFilter\",\n    \"WebkitFlex\",\n    \"WebkitFlexBasis\",\n    \"WebkitFlexDirection\",\n    \"WebkitFlexFlow\",\n    \"WebkitFlexGrow\",\n    \"WebkitFlexShrink\",\n    \"WebkitFlexWrap\",\n    \"WebkitJustifyContent\",\n    \"WebkitLineClamp\",\n    \"WebkitMask\",\n    \"WebkitMaskClip\",\n    \"WebkitMaskComposite\",\n    \"WebkitMaskImage\",\n    \"WebkitMaskOrigin\",\n    \"WebkitMaskPosition\",\n    \"WebkitMaskPositionX\",\n    \"WebkitMaskPositionY\",\n    \"WebkitMaskRepeat\",\n    \"WebkitMaskSize\",\n    \"WebkitOrder\",\n    \"WebkitPerspective\",\n    \"WebkitPerspectiveOrigin\",\n    \"WebkitTextFillColor\",\n    \"WebkitTextSizeAdjust\",\n    \"WebkitTextStroke\",\n    \"WebkitTextStrokeColor\",\n    \"WebkitTextStrokeWidth\",\n    \"WebkitTransform\",\n    \"WebkitTransformOrigin\",\n    \"WebkitTransformStyle\",\n    \"WebkitTransition\",\n    \"WebkitTransitionDelay\",\n    \"WebkitTransitionDuration\",\n    \"WebkitTransitionProperty\",\n    \"WebkitTransitionTimingFunction\",\n    \"WebkitUserSelect\",\n    \"WheelEvent\",\n    \"Window\",\n    \"Worker\",\n    \"Worklet\",\n    \"WritableStream\",\n    \"WritableStreamDefaultWriter\",\n    \"XMLDocument\",\n    \"XMLHttpRequest\",\n    \"XMLHttpRequestEventTarget\",\n    \"XMLHttpRequestException\",\n    \"XMLHttpRequestProgressEvent\",\n    \"XMLHttpRequestUpload\",\n    \"XMLSerializer\",\n    \"XMLStylesheetProcessingInstruction\",\n    \"XPathEvaluator\",\n    \"XPathException\",\n    \"XPathExpression\",\n    \"XPathNSResolver\",\n    \"XPathResult\",\n    \"XRBoundedReferenceSpace\",\n    \"XRDOMOverlayState\",\n    \"XRFrame\",\n    \"XRHitTestResult\",\n    \"XRHitTestSource\",\n    \"XRInputSource\",\n    \"XRInputSourceArray\",\n    \"XRInputSourceEvent\",\n    \"XRInputSourcesChangeEvent\",\n    \"XRLayer\",\n    \"XRPose\",\n    \"XRRay\",\n    \"XRReferenceSpace\",\n    \"XRReferenceSpaceEvent\",\n    \"XRRenderState\",\n    \"XRRigidTransform\",\n    \"XRSession\",\n    \"XRSessionEvent\",\n    \"XRSpace\",\n    \"XRSystem\",\n    \"XRTransientInputHitTestResult\",\n    \"XRTransientInputHitTestSource\",\n    \"XRView\",\n    \"XRViewerPose\",\n    \"XRViewport\",\n    \"XRWebGLLayer\",\n    \"XSLTProcessor\",\n    \"ZERO\",\n    \"_XD0M_\",\n    \"_YD0M_\",\n    \"__defineGetter__\",\n    \"__defineSetter__\",\n    \"__lookupGetter__\",\n    \"__lookupSetter__\",\n    \"__opera\",\n    \"__proto__\",\n    \"_browserjsran\",\n    \"a\",\n    \"aLink\",\n    \"abbr\",\n    \"abort\",\n    \"aborted\",\n    \"abs\",\n    \"absolute\",\n    \"acceleration\",\n    \"accelerationIncludingGravity\",\n    \"accelerator\",\n    \"accept\",\n    \"acceptCharset\",\n    \"acceptNode\",\n    \"accessKey\",\n    \"accessKeyLabel\",\n    \"accuracy\",\n    \"acos\",\n    \"acosh\",\n    \"action\",\n    \"actionURL\",\n    \"actions\",\n    \"activated\",\n    \"active\",\n    \"activeCues\",\n    \"activeElement\",\n    \"activeSourceBuffers\",\n    \"activeSourceCount\",\n    \"activeTexture\",\n    \"activeVRDisplays\",\n    \"actualBoundingBoxAscent\",\n    \"actualBoundingBoxDescent\",\n    \"actualBoundingBoxLeft\",\n    \"actualBoundingBoxRight\",\n    \"add\",\n    \"addAll\",\n    \"addBehavior\",\n    \"addCandidate\",\n    \"addColorStop\",\n    \"addCue\",\n    \"addElement\",\n    \"addEventListener\",\n    \"addFilter\",\n    \"addFromString\",\n    \"addFromUri\",\n    \"addIceCandidate\",\n    \"addImport\",\n    \"addListener\",\n    \"addModule\",\n    \"addNamed\",\n    \"addPageRule\",\n    \"addPath\",\n    \"addPointer\",\n    \"addRange\",\n    \"addRegion\",\n    \"addRule\",\n    \"addSearchEngine\",\n    \"addSourceBuffer\",\n    \"addStream\",\n    \"addTextTrack\",\n    \"addTrack\",\n    \"addTransceiver\",\n    \"addWakeLockListener\",\n    \"added\",\n    \"addedNodes\",\n    \"additionalName\",\n    \"additiveSymbols\",\n    \"addons\",\n    \"address\",\n    \"addressLine\",\n    \"adoptNode\",\n    \"adoptedStyleSheets\",\n    \"adr\",\n    \"advance\",\n    \"after\",\n    \"album\",\n    \"alert\",\n    \"algorithm\",\n    \"align\",\n    \"align-content\",\n    \"align-items\",\n    \"align-self\",\n    \"alignContent\",\n    \"alignItems\",\n    \"alignSelf\",\n    \"alignmentBaseline\",\n    \"alinkColor\",\n    \"all\",\n    \"allSettled\",\n    \"allow\",\n    \"allowFullscreen\",\n    \"allowPaymentRequest\",\n    \"allowedDirections\",\n    \"allowedFeatures\",\n    \"allowedToPlay\",\n    \"allowsFeature\",\n    \"alpha\",\n    \"alt\",\n    \"altGraphKey\",\n    \"altHtml\",\n    \"altKey\",\n    \"altLeft\",\n    \"alternate\",\n    \"alternateSetting\",\n    \"alternates\",\n    \"altitude\",\n    \"altitudeAccuracy\",\n    \"amplitude\",\n    \"ancestorOrigins\",\n    \"anchor\",\n    \"anchorNode\",\n    \"anchorOffset\",\n    \"anchors\",\n    \"and\",\n    \"angle\",\n    \"angularAcceleration\",\n    \"angularVelocity\",\n    \"animVal\",\n    \"animate\",\n    \"animatedInstanceRoot\",\n    \"animatedNormalizedPathSegList\",\n    \"animatedPathSegList\",\n    \"animatedPoints\",\n    \"animation\",\n    \"animation-delay\",\n    \"animation-direction\",\n    \"animation-duration\",\n    \"animation-fill-mode\",\n    \"animation-iteration-count\",\n    \"animation-name\",\n    \"animation-play-state\",\n    \"animation-timing-function\",\n    \"animationDelay\",\n    \"animationDirection\",\n    \"animationDuration\",\n    \"animationFillMode\",\n    \"animationIterationCount\",\n    \"animationName\",\n    \"animationPlayState\",\n    \"animationStartTime\",\n    \"animationTimingFunction\",\n    \"animationsPaused\",\n    \"anniversary\",\n    \"antialias\",\n    \"anticipatedRemoval\",\n    \"any\",\n    \"app\",\n    \"appCodeName\",\n    \"appMinorVersion\",\n    \"appName\",\n    \"appNotifications\",\n    \"appVersion\",\n    \"appearance\",\n    \"append\",\n    \"appendBuffer\",\n    \"appendChild\",\n    \"appendData\",\n    \"appendItem\",\n    \"appendMedium\",\n    \"appendNamed\",\n    \"appendRule\",\n    \"appendStream\",\n    \"appendWindowEnd\",\n    \"appendWindowStart\",\n    \"applets\",\n    \"applicationCache\",\n    \"applicationServerKey\",\n    \"apply\",\n    \"applyConstraints\",\n    \"applyElement\",\n    \"arc\",\n    \"arcTo\",\n    \"archive\",\n    \"areas\",\n    \"arguments\",\n    \"ariaAtomic\",\n    \"ariaAutoComplete\",\n    \"ariaBusy\",\n    \"ariaChecked\",\n    \"ariaColCount\",\n    \"ariaColIndex\",\n    \"ariaColSpan\",\n    \"ariaCurrent\",\n    \"ariaDescription\",\n    \"ariaDisabled\",\n    \"ariaExpanded\",\n    \"ariaHasPopup\",\n    \"ariaHidden\",\n    \"ariaKeyShortcuts\",\n    \"ariaLabel\",\n    \"ariaLevel\",\n    \"ariaLive\",\n    \"ariaModal\",\n    \"ariaMultiLine\",\n    \"ariaMultiSelectable\",\n    \"ariaOrientation\",\n    \"ariaPlaceholder\",\n    \"ariaPosInSet\",\n    \"ariaPressed\",\n    \"ariaReadOnly\",\n    \"ariaRelevant\",\n    \"ariaRequired\",\n    \"ariaRoleDescription\",\n    \"ariaRowCount\",\n    \"ariaRowIndex\",\n    \"ariaRowSpan\",\n    \"ariaSelected\",\n    \"ariaSetSize\",\n    \"ariaSort\",\n    \"ariaValueMax\",\n    \"ariaValueMin\",\n    \"ariaValueNow\",\n    \"ariaValueText\",\n    \"arrayBuffer\",\n    \"artist\",\n    \"artwork\",\n    \"as\",\n    \"asIntN\",\n    \"asUintN\",\n    \"asin\",\n    \"asinh\",\n    \"assert\",\n    \"assign\",\n    \"assignedElements\",\n    \"assignedNodes\",\n    \"assignedSlot\",\n    \"async\",\n    \"asyncIterator\",\n    \"atEnd\",\n    \"atan\",\n    \"atan2\",\n    \"atanh\",\n    \"atob\",\n    \"attachEvent\",\n    \"attachInternals\",\n    \"attachShader\",\n    \"attachShadow\",\n    \"attachments\",\n    \"attack\",\n    \"attestationObject\",\n    \"attrChange\",\n    \"attrName\",\n    \"attributeFilter\",\n    \"attributeName\",\n    \"attributeNamespace\",\n    \"attributeOldValue\",\n    \"attributeStyleMap\",\n    \"attributes\",\n    \"attribution\",\n    \"audioBitsPerSecond\",\n    \"audioTracks\",\n    \"audioWorklet\",\n    \"authenticatedSignedWrites\",\n    \"authenticatorData\",\n    \"autoIncrement\",\n    \"autobuffer\",\n    \"autocapitalize\",\n    \"autocomplete\",\n    \"autocorrect\",\n    \"autofocus\",\n    \"automationRate\",\n    \"autoplay\",\n    \"availHeight\",\n    \"availLeft\",\n    \"availTop\",\n    \"availWidth\",\n    \"availability\",\n    \"available\",\n    \"aversion\",\n    \"ax\",\n    \"axes\",\n    \"axis\",\n    \"ay\",\n    \"azimuth\",\n    \"b\",\n    \"back\",\n    \"backface-visibility\",\n    \"backfaceVisibility\",\n    \"background\",\n    \"background-attachment\",\n    \"background-blend-mode\",\n    \"background-clip\",\n    \"background-color\",\n    \"background-image\",\n    \"background-origin\",\n    \"background-position\",\n    \"background-position-x\",\n    \"background-position-y\",\n    \"background-repeat\",\n    \"background-size\",\n    \"backgroundAttachment\",\n    \"backgroundBlendMode\",\n    \"backgroundClip\",\n    \"backgroundColor\",\n    \"backgroundFetch\",\n    \"backgroundImage\",\n    \"backgroundOrigin\",\n    \"backgroundPosition\",\n    \"backgroundPositionX\",\n    \"backgroundPositionY\",\n    \"backgroundRepeat\",\n    \"backgroundSize\",\n    \"badInput\",\n    \"badge\",\n    \"balance\",\n    \"baseFrequencyX\",\n    \"baseFrequencyY\",\n    \"baseLatency\",\n    \"baseLayer\",\n    \"baseNode\",\n    \"baseOffset\",\n    \"baseURI\",\n    \"baseVal\",\n    \"baselineShift\",\n    \"battery\",\n    \"bday\",\n    \"before\",\n    \"beginElement\",\n    \"beginElementAt\",\n    \"beginPath\",\n    \"beginQuery\",\n    \"beginTransformFeedback\",\n    \"behavior\",\n    \"behaviorCookie\",\n    \"behaviorPart\",\n    \"behaviorUrns\",\n    \"beta\",\n    \"bezierCurveTo\",\n    \"bgColor\",\n    \"bgProperties\",\n    \"bias\",\n    \"big\",\n    \"bigint64\",\n    \"biguint64\",\n    \"binaryType\",\n    \"bind\",\n    \"bindAttribLocation\",\n    \"bindBuffer\",\n    \"bindBufferBase\",\n    \"bindBufferRange\",\n    \"bindFramebuffer\",\n    \"bindRenderbuffer\",\n    \"bindSampler\",\n    \"bindTexture\",\n    \"bindTransformFeedback\",\n    \"bindVertexArray\",\n    \"blendColor\",\n    \"blendEquation\",\n    \"blendEquationSeparate\",\n    \"blendFunc\",\n    \"blendFuncSeparate\",\n    \"blink\",\n    \"blitFramebuffer\",\n    \"blob\",\n    \"block-size\",\n    \"blockDirection\",\n    \"blockSize\",\n    \"blockedURI\",\n    \"blue\",\n    \"bluetooth\",\n    \"blur\",\n    \"body\",\n    \"bodyUsed\",\n    \"bold\",\n    \"bookmarks\",\n    \"booleanValue\",\n    \"border\",\n    \"border-block\",\n    \"border-block-color\",\n    \"border-block-end\",\n    \"border-block-end-color\",\n    \"border-block-end-style\",\n    \"border-block-end-width\",\n    \"border-block-start\",\n    \"border-block-start-color\",\n    \"border-block-start-style\",\n    \"border-block-start-width\",\n    \"border-block-style\",\n    \"border-block-width\",\n    \"border-bottom\",\n    \"border-bottom-color\",\n    \"border-bottom-left-radius\",\n    \"border-bottom-right-radius\",\n    \"border-bottom-style\",\n    \"border-bottom-width\",\n    \"border-collapse\",\n    \"border-color\",\n    \"border-end-end-radius\",\n    \"border-end-start-radius\",\n    \"border-image\",\n    \"border-image-outset\",\n    \"border-image-repeat\",\n    \"border-image-slice\",\n    \"border-image-source\",\n    \"border-image-width\",\n    \"border-inline\",\n    \"border-inline-color\",\n    \"border-inline-end\",\n    \"border-inline-end-color\",\n    \"border-inline-end-style\",\n    \"border-inline-end-width\",\n    \"border-inline-start\",\n    \"border-inline-start-color\",\n    \"border-inline-start-style\",\n    \"border-inline-start-width\",\n    \"border-inline-style\",\n    \"border-inline-width\",\n    \"border-left\",\n    \"border-left-color\",\n    \"border-left-style\",\n    \"border-left-width\",\n    \"border-radius\",\n    \"border-right\",\n    \"border-right-color\",\n    \"border-right-style\",\n    \"border-right-width\",\n    \"border-spacing\",\n    \"border-start-end-radius\",\n    \"border-start-start-radius\",\n    \"border-style\",\n    \"border-top\",\n    \"border-top-color\",\n    \"border-top-left-radius\",\n    \"border-top-right-radius\",\n    \"border-top-style\",\n    \"border-top-width\",\n    \"border-width\",\n    \"borderBlock\",\n    \"borderBlockColor\",\n    \"borderBlockEnd\",\n    \"borderBlockEndColor\",\n    \"borderBlockEndStyle\",\n    \"borderBlockEndWidth\",\n    \"borderBlockStart\",\n    \"borderBlockStartColor\",\n    \"borderBlockStartStyle\",\n    \"borderBlockStartWidth\",\n    \"borderBlockStyle\",\n    \"borderBlockWidth\",\n    \"borderBottom\",\n    \"borderBottomColor\",\n    \"borderBottomLeftRadius\",\n    \"borderBottomRightRadius\",\n    \"borderBottomStyle\",\n    \"borderBottomWidth\",\n    \"borderBoxSize\",\n    \"borderCollapse\",\n    \"borderColor\",\n    \"borderColorDark\",\n    \"borderColorLight\",\n    \"borderEndEndRadius\",\n    \"borderEndStartRadius\",\n    \"borderImage\",\n    \"borderImageOutset\",\n    \"borderImageRepeat\",\n    \"borderImageSlice\",\n    \"borderImageSource\",\n    \"borderImageWidth\",\n    \"borderInline\",\n    \"borderInlineColor\",\n    \"borderInlineEnd\",\n    \"borderInlineEndColor\",\n    \"borderInlineEndStyle\",\n    \"borderInlineEndWidth\",\n    \"borderInlineStart\",\n    \"borderInlineStartColor\",\n    \"borderInlineStartStyle\",\n    \"borderInlineStartWidth\",\n    \"borderInlineStyle\",\n    \"borderInlineWidth\",\n    \"borderLeft\",\n    \"borderLeftColor\",\n    \"borderLeftStyle\",\n    \"borderLeftWidth\",\n    \"borderRadius\",\n    \"borderRight\",\n    \"borderRightColor\",\n    \"borderRightStyle\",\n    \"borderRightWidth\",\n    \"borderSpacing\",\n    \"borderStartEndRadius\",\n    \"borderStartStartRadius\",\n    \"borderStyle\",\n    \"borderTop\",\n    \"borderTopColor\",\n    \"borderTopLeftRadius\",\n    \"borderTopRightRadius\",\n    \"borderTopStyle\",\n    \"borderTopWidth\",\n    \"borderWidth\",\n    \"bottom\",\n    \"bottomMargin\",\n    \"bound\",\n    \"boundElements\",\n    \"boundingClientRect\",\n    \"boundingHeight\",\n    \"boundingLeft\",\n    \"boundingTop\",\n    \"boundingWidth\",\n    \"bounds\",\n    \"boundsGeometry\",\n    \"box-decoration-break\",\n    \"box-shadow\",\n    \"box-sizing\",\n    \"boxDecorationBreak\",\n    \"boxShadow\",\n    \"boxSizing\",\n    \"break-after\",\n    \"break-before\",\n    \"break-inside\",\n    \"breakAfter\",\n    \"breakBefore\",\n    \"breakInside\",\n    \"broadcast\",\n    \"browserLanguage\",\n    \"btoa\",\n    \"bubbles\",\n    \"buffer\",\n    \"bufferData\",\n    \"bufferDepth\",\n    \"bufferSize\",\n    \"bufferSubData\",\n    \"buffered\",\n    \"bufferedAmount\",\n    \"bufferedAmountLowThreshold\",\n    \"buildID\",\n    \"buildNumber\",\n    \"button\",\n    \"buttonID\",\n    \"buttons\",\n    \"byteLength\",\n    \"byteOffset\",\n    \"bytesWritten\",\n    \"c\",\n    \"cache\",\n    \"caches\",\n    \"call\",\n    \"caller\",\n    \"canBeFormatted\",\n    \"canBeMounted\",\n    \"canBeShared\",\n    \"canHaveChildren\",\n    \"canHaveHTML\",\n    \"canInsertDTMF\",\n    \"canMakePayment\",\n    \"canPlayType\",\n    \"canPresent\",\n    \"canTrickleIceCandidates\",\n    \"cancel\",\n    \"cancelAndHoldAtTime\",\n    \"cancelAnimationFrame\",\n    \"cancelBubble\",\n    \"cancelIdleCallback\",\n    \"cancelScheduledValues\",\n    \"cancelVideoFrameCallback\",\n    \"cancelWatchAvailability\",\n    \"cancelable\",\n    \"candidate\",\n    \"canonicalUUID\",\n    \"canvas\",\n    \"capabilities\",\n    \"caption\",\n    \"caption-side\",\n    \"captionSide\",\n    \"capture\",\n    \"captureEvents\",\n    \"captureStackTrace\",\n    \"captureStream\",\n    \"caret-color\",\n    \"caretBidiLevel\",\n    \"caretColor\",\n    \"caretPositionFromPoint\",\n    \"caretRangeFromPoint\",\n    \"cast\",\n    \"catch\",\n    \"category\",\n    \"cbrt\",\n    \"cd\",\n    \"ceil\",\n    \"cellIndex\",\n    \"cellPadding\",\n    \"cellSpacing\",\n    \"cells\",\n    \"ch\",\n    \"chOff\",\n    \"chain\",\n    \"challenge\",\n    \"changeType\",\n    \"changedTouches\",\n    \"channel\",\n    \"channelCount\",\n    \"channelCountMode\",\n    \"channelInterpretation\",\n    \"char\",\n    \"charAt\",\n    \"charCode\",\n    \"charCodeAt\",\n    \"charIndex\",\n    \"charLength\",\n    \"characterData\",\n    \"characterDataOldValue\",\n    \"characterSet\",\n    \"characteristic\",\n    \"charging\",\n    \"chargingTime\",\n    \"charset\",\n    \"check\",\n    \"checkEnclosure\",\n    \"checkFramebufferStatus\",\n    \"checkIntersection\",\n    \"checkValidity\",\n    \"checked\",\n    \"childElementCount\",\n    \"childList\",\n    \"childNodes\",\n    \"children\",\n    \"chrome\",\n    \"ciphertext\",\n    \"cite\",\n    \"city\",\n    \"claimInterface\",\n    \"claimed\",\n    \"classList\",\n    \"className\",\n    \"classid\",\n    \"clear\",\n    \"clearAppBadge\",\n    \"clearAttributes\",\n    \"clearBufferfi\",\n    \"clearBufferfv\",\n    \"clearBufferiv\",\n    \"clearBufferuiv\",\n    \"clearColor\",\n    \"clearData\",\n    \"clearDepth\",\n    \"clearHalt\",\n    \"clearImmediate\",\n    \"clearInterval\",\n    \"clearLiveSeekableRange\",\n    \"clearMarks\",\n    \"clearMaxGCPauseAccumulator\",\n    \"clearMeasures\",\n    \"clearParameters\",\n    \"clearRect\",\n    \"clearResourceTimings\",\n    \"clearShadow\",\n    \"clearStencil\",\n    \"clearTimeout\",\n    \"clearWatch\",\n    \"click\",\n    \"clickCount\",\n    \"clientDataJSON\",\n    \"clientHeight\",\n    \"clientInformation\",\n    \"clientLeft\",\n    \"clientRect\",\n    \"clientRects\",\n    \"clientTop\",\n    \"clientWaitSync\",\n    \"clientWidth\",\n    \"clientX\",\n    \"clientY\",\n    \"clip\",\n    \"clip-path\",\n    \"clip-rule\",\n    \"clipBottom\",\n    \"clipLeft\",\n    \"clipPath\",\n    \"clipPathUnits\",\n    \"clipRight\",\n    \"clipRule\",\n    \"clipTop\",\n    \"clipboard\",\n    \"clipboardData\",\n    \"clone\",\n    \"cloneContents\",\n    \"cloneNode\",\n    \"cloneRange\",\n    \"close\",\n    \"closePath\",\n    \"closed\",\n    \"closest\",\n    \"clz\",\n    \"clz32\",\n    \"cm\",\n    \"cmp\",\n    \"code\",\n    \"codeBase\",\n    \"codePointAt\",\n    \"codeType\",\n    \"colSpan\",\n    \"collapse\",\n    \"collapseToEnd\",\n    \"collapseToStart\",\n    \"collapsed\",\n    \"collect\",\n    \"colno\",\n    \"color\",\n    \"color-adjust\",\n    \"color-interpolation\",\n    \"color-interpolation-filters\",\n    \"colorAdjust\",\n    \"colorDepth\",\n    \"colorInterpolation\",\n    \"colorInterpolationFilters\",\n    \"colorMask\",\n    \"colorType\",\n    \"cols\",\n    \"column-count\",\n    \"column-fill\",\n    \"column-gap\",\n    \"column-rule\",\n    \"column-rule-color\",\n    \"column-rule-style\",\n    \"column-rule-width\",\n    \"column-span\",\n    \"column-width\",\n    \"columnCount\",\n    \"columnFill\",\n    \"columnGap\",\n    \"columnNumber\",\n    \"columnRule\",\n    \"columnRuleColor\",\n    \"columnRuleStyle\",\n    \"columnRuleWidth\",\n    \"columnSpan\",\n    \"columnWidth\",\n    \"columns\",\n    \"command\",\n    \"commit\",\n    \"commitPreferences\",\n    \"commitStyles\",\n    \"commonAncestorContainer\",\n    \"compact\",\n    \"compareBoundaryPoints\",\n    \"compareDocumentPosition\",\n    \"compareEndPoints\",\n    \"compareExchange\",\n    \"compareNode\",\n    \"comparePoint\",\n    \"compatMode\",\n    \"compatible\",\n    \"compile\",\n    \"compileShader\",\n    \"compileStreaming\",\n    \"complete\",\n    \"component\",\n    \"componentFromPoint\",\n    \"composed\",\n    \"composedPath\",\n    \"composite\",\n    \"compositionEndOffset\",\n    \"compositionStartOffset\",\n    \"compressedTexImage2D\",\n    \"compressedTexImage3D\",\n    \"compressedTexSubImage2D\",\n    \"compressedTexSubImage3D\",\n    \"computedStyleMap\",\n    \"concat\",\n    \"conditionText\",\n    \"coneInnerAngle\",\n    \"coneOuterAngle\",\n    \"coneOuterGain\",\n    \"configuration\",\n    \"configurationName\",\n    \"configurationValue\",\n    \"configurations\",\n    \"confirm\",\n    \"confirmComposition\",\n    \"confirmSiteSpecificTrackingException\",\n    \"confirmWebWideTrackingException\",\n    \"connect\",\n    \"connectEnd\",\n    \"connectShark\",\n    \"connectStart\",\n    \"connected\",\n    \"connection\",\n    \"connectionList\",\n    \"connectionSpeed\",\n    \"connectionState\",\n    \"connections\",\n    \"console\",\n    \"consolidate\",\n    \"constraint\",\n    \"constrictionActive\",\n    \"construct\",\n    \"constructor\",\n    \"contactID\",\n    \"contain\",\n    \"containerId\",\n    \"containerName\",\n    \"containerSrc\",\n    \"containerType\",\n    \"contains\",\n    \"containsNode\",\n    \"content\",\n    \"contentBoxSize\",\n    \"contentDocument\",\n    \"contentEditable\",\n    \"contentHint\",\n    \"contentOverflow\",\n    \"contentRect\",\n    \"contentScriptType\",\n    \"contentStyleType\",\n    \"contentType\",\n    \"contentWindow\",\n    \"context\",\n    \"contextMenu\",\n    \"contextmenu\",\n    \"continue\",\n    \"continuePrimaryKey\",\n    \"continuous\",\n    \"control\",\n    \"controlTransferIn\",\n    \"controlTransferOut\",\n    \"controller\",\n    \"controls\",\n    \"controlsList\",\n    \"convertPointFromNode\",\n    \"convertQuadFromNode\",\n    \"convertRectFromNode\",\n    \"convertToBlob\",\n    \"convertToSpecifiedUnits\",\n    \"cookie\",\n    \"cookieEnabled\",\n    \"coords\",\n    \"copyBufferSubData\",\n    \"copyFromChannel\",\n    \"copyTexImage2D\",\n    \"copyTexSubImage2D\",\n    \"copyTexSubImage3D\",\n    \"copyToChannel\",\n    \"copyWithin\",\n    \"correspondingElement\",\n    \"correspondingUseElement\",\n    \"corruptedVideoFrames\",\n    \"cos\",\n    \"cosh\",\n    \"count\",\n    \"countReset\",\n    \"counter-increment\",\n    \"counter-reset\",\n    \"counter-set\",\n    \"counterIncrement\",\n    \"counterReset\",\n    \"counterSet\",\n    \"country\",\n    \"cpuClass\",\n    \"cpuSleepAllowed\",\n    \"create\",\n    \"createAnalyser\",\n    \"createAnswer\",\n    \"createAttribute\",\n    \"createAttributeNS\",\n    \"createBiquadFilter\",\n    \"createBuffer\",\n    \"createBufferSource\",\n    \"createCDATASection\",\n    \"createCSSStyleSheet\",\n    \"createCaption\",\n    \"createChannelMerger\",\n    \"createChannelSplitter\",\n    \"createComment\",\n    \"createConstantSource\",\n    \"createContextualFragment\",\n    \"createControlRange\",\n    \"createConvolver\",\n    \"createDTMFSender\",\n    \"createDataChannel\",\n    \"createDelay\",\n    \"createDelayNode\",\n    \"createDocument\",\n    \"createDocumentFragment\",\n    \"createDocumentType\",\n    \"createDynamicsCompressor\",\n    \"createElement\",\n    \"createElementNS\",\n    \"createEntityReference\",\n    \"createEvent\",\n    \"createEventObject\",\n    \"createExpression\",\n    \"createFramebuffer\",\n    \"createFunction\",\n    \"createGain\",\n    \"createGainNode\",\n    \"createHTML\",\n    \"createHTMLDocument\",\n    \"createIIRFilter\",\n    \"createImageBitmap\",\n    \"createImageData\",\n    \"createIndex\",\n    \"createJavaScriptNode\",\n    \"createLinearGradient\",\n    \"createMediaElementSource\",\n    \"createMediaKeys\",\n    \"createMediaStreamDestination\",\n    \"createMediaStreamSource\",\n    \"createMediaStreamTrackSource\",\n    \"createMutableFile\",\n    \"createNSResolver\",\n    \"createNodeIterator\",\n    \"createNotification\",\n    \"createObjectStore\",\n    \"createObjectURL\",\n    \"createOffer\",\n    \"createOscillator\",\n    \"createPanner\",\n    \"createPattern\",\n    \"createPeriodicWave\",\n    \"createPolicy\",\n    \"createPopup\",\n    \"createProcessingInstruction\",\n    \"createProgram\",\n    \"createQuery\",\n    \"createRadialGradient\",\n    \"createRange\",\n    \"createRangeCollection\",\n    \"createReader\",\n    \"createRenderbuffer\",\n    \"createSVGAngle\",\n    \"createSVGLength\",\n    \"createSVGMatrix\",\n    \"createSVGNumber\",\n    \"createSVGPathSegArcAbs\",\n    \"createSVGPathSegArcRel\",\n    \"createSVGPathSegClosePath\",\n    \"createSVGPathSegCurvetoCubicAbs\",\n    \"createSVGPathSegCurvetoCubicRel\",\n    \"createSVGPathSegCurvetoCubicSmoothAbs\",\n    \"createSVGPathSegCurvetoCubicSmoothRel\",\n    \"createSVGPathSegCurvetoQuadraticAbs\",\n    \"createSVGPathSegCurvetoQuadraticRel\",\n    \"createSVGPathSegCurvetoQuadraticSmoothAbs\",\n    \"createSVGPathSegCurvetoQuadraticSmoothRel\",\n    \"createSVGPathSegLinetoAbs\",\n    \"createSVGPathSegLinetoHorizontalAbs\",\n    \"createSVGPathSegLinetoHorizontalRel\",\n    \"createSVGPathSegLinetoRel\",\n    \"createSVGPathSegLinetoVerticalAbs\",\n    \"createSVGPathSegLinetoVerticalRel\",\n    \"createSVGPathSegMovetoAbs\",\n    \"createSVGPathSegMovetoRel\",\n    \"createSVGPoint\",\n    \"createSVGRect\",\n    \"createSVGTransform\",\n    \"createSVGTransformFromMatrix\",\n    \"createSampler\",\n    \"createScript\",\n    \"createScriptProcessor\",\n    \"createScriptURL\",\n    \"createSession\",\n    \"createShader\",\n    \"createShadowRoot\",\n    \"createStereoPanner\",\n    \"createStyleSheet\",\n    \"createTBody\",\n    \"createTFoot\",\n    \"createTHead\",\n    \"createTextNode\",\n    \"createTextRange\",\n    \"createTexture\",\n    \"createTouch\",\n    \"createTouchList\",\n    \"createTransformFeedback\",\n    \"createTreeWalker\",\n    \"createVertexArray\",\n    \"createWaveShaper\",\n    \"creationTime\",\n    \"credentials\",\n    \"crossOrigin\",\n    \"crossOriginIsolated\",\n    \"crypto\",\n    \"csi\",\n    \"csp\",\n    \"cssFloat\",\n    \"cssRules\",\n    \"cssText\",\n    \"cssValueType\",\n    \"ctrlKey\",\n    \"ctrlLeft\",\n    \"cues\",\n    \"cullFace\",\n    \"currentDirection\",\n    \"currentLocalDescription\",\n    \"currentNode\",\n    \"currentPage\",\n    \"currentRect\",\n    \"currentRemoteDescription\",\n    \"currentScale\",\n    \"currentScript\",\n    \"currentSrc\",\n    \"currentState\",\n    \"currentStyle\",\n    \"currentTarget\",\n    \"currentTime\",\n    \"currentTranslate\",\n    \"currentView\",\n    \"cursor\",\n    \"curve\",\n    \"customElements\",\n    \"customError\",\n    \"cx\",\n    \"cy\",\n    \"d\",\n    \"data\",\n    \"dataFld\",\n    \"dataFormatAs\",\n    \"dataLoss\",\n    \"dataLossMessage\",\n    \"dataPageSize\",\n    \"dataSrc\",\n    \"dataTransfer\",\n    \"database\",\n    \"databases\",\n    \"dataset\",\n    \"dateTime\",\n    \"db\",\n    \"debug\",\n    \"debuggerEnabled\",\n    \"declare\",\n    \"decode\",\n    \"decodeAudioData\",\n    \"decodeURI\",\n    \"decodeURIComponent\",\n    \"decodedBodySize\",\n    \"decoding\",\n    \"decodingInfo\",\n    \"decrypt\",\n    \"default\",\n    \"defaultCharset\",\n    \"defaultChecked\",\n    \"defaultMuted\",\n    \"defaultPlaybackRate\",\n    \"defaultPolicy\",\n    \"defaultPrevented\",\n    \"defaultRequest\",\n    \"defaultSelected\",\n    \"defaultStatus\",\n    \"defaultURL\",\n    \"defaultValue\",\n    \"defaultView\",\n    \"defaultstatus\",\n    \"defer\",\n    \"define\",\n    \"defineMagicFunction\",\n    \"defineMagicVariable\",\n    \"defineProperties\",\n    \"defineProperty\",\n    \"deg\",\n    \"delay\",\n    \"delayTime\",\n    \"delegatesFocus\",\n    \"delete\",\n    \"deleteBuffer\",\n    \"deleteCaption\",\n    \"deleteCell\",\n    \"deleteContents\",\n    \"deleteData\",\n    \"deleteDatabase\",\n    \"deleteFramebuffer\",\n    \"deleteFromDocument\",\n    \"deleteIndex\",\n    \"deleteMedium\",\n    \"deleteObjectStore\",\n    \"deleteProgram\",\n    \"deleteProperty\",\n    \"deleteQuery\",\n    \"deleteRenderbuffer\",\n    \"deleteRow\",\n    \"deleteRule\",\n    \"deleteSampler\",\n    \"deleteShader\",\n    \"deleteSync\",\n    \"deleteTFoot\",\n    \"deleteTHead\",\n    \"deleteTexture\",\n    \"deleteTransformFeedback\",\n    \"deleteVertexArray\",\n    \"deliverChangeRecords\",\n    \"delivery\",\n    \"deliveryInfo\",\n    \"deliveryStatus\",\n    \"deliveryTimestamp\",\n    \"delta\",\n    \"deltaMode\",\n    \"deltaX\",\n    \"deltaY\",\n    \"deltaZ\",\n    \"dependentLocality\",\n    \"depthFar\",\n    \"depthFunc\",\n    \"depthMask\",\n    \"depthNear\",\n    \"depthRange\",\n    \"deref\",\n    \"deriveBits\",\n    \"deriveKey\",\n    \"description\",\n    \"deselectAll\",\n    \"designMode\",\n    \"desiredSize\",\n    \"destination\",\n    \"destinationURL\",\n    \"detach\",\n    \"detachEvent\",\n    \"detachShader\",\n    \"detail\",\n    \"details\",\n    \"detect\",\n    \"detune\",\n    \"device\",\n    \"deviceClass\",\n    \"deviceId\",\n    \"deviceMemory\",\n    \"devicePixelContentBoxSize\",\n    \"devicePixelRatio\",\n    \"deviceProtocol\",\n    \"deviceSubclass\",\n    \"deviceVersionMajor\",\n    \"deviceVersionMinor\",\n    \"deviceVersionSubminor\",\n    \"deviceXDPI\",\n    \"deviceYDPI\",\n    \"didTimeout\",\n    \"diffuseConstant\",\n    \"digest\",\n    \"dimensions\",\n    \"dir\",\n    \"dirName\",\n    \"direction\",\n    \"dirxml\",\n    \"disable\",\n    \"disablePictureInPicture\",\n    \"disableRemotePlayback\",\n    \"disableVertexAttribArray\",\n    \"disabled\",\n    \"dischargingTime\",\n    \"disconnect\",\n    \"disconnectShark\",\n    \"dispatchEvent\",\n    \"display\",\n    \"displayId\",\n    \"displayName\",\n    \"disposition\",\n    \"distanceModel\",\n    \"div\",\n    \"divisor\",\n    \"djsapi\",\n    \"djsproxy\",\n    \"doImport\",\n    \"doNotTrack\",\n    \"doScroll\",\n    \"doctype\",\n    \"document\",\n    \"documentElement\",\n    \"documentMode\",\n    \"documentURI\",\n    \"dolphin\",\n    \"dolphinGameCenter\",\n    \"dolphininfo\",\n    \"dolphinmeta\",\n    \"domComplete\",\n    \"domContentLoadedEventEnd\",\n    \"domContentLoadedEventStart\",\n    \"domInteractive\",\n    \"domLoading\",\n    \"domOverlayState\",\n    \"domain\",\n    \"domainLookupEnd\",\n    \"domainLookupStart\",\n    \"dominant-baseline\",\n    \"dominantBaseline\",\n    \"done\",\n    \"dopplerFactor\",\n    \"dotAll\",\n    \"downDegrees\",\n    \"downlink\",\n    \"download\",\n    \"downloadTotal\",\n    \"downloaded\",\n    \"dpcm\",\n    \"dpi\",\n    \"dppx\",\n    \"dragDrop\",\n    \"draggable\",\n    \"drawArrays\",\n    \"drawArraysInstanced\",\n    \"drawArraysInstancedANGLE\",\n    \"drawBuffers\",\n    \"drawCustomFocusRing\",\n    \"drawElements\",\n    \"drawElementsInstanced\",\n    \"drawElementsInstancedANGLE\",\n    \"drawFocusIfNeeded\",\n    \"drawImage\",\n    \"drawImageFromRect\",\n    \"drawRangeElements\",\n    \"drawSystemFocusRing\",\n    \"drawingBufferHeight\",\n    \"drawingBufferWidth\",\n    \"dropEffect\",\n    \"droppedVideoFrames\",\n    \"dropzone\",\n    \"dtmf\",\n    \"dump\",\n    \"dumpProfile\",\n    \"duplicate\",\n    \"durability\",\n    \"duration\",\n    \"dvname\",\n    \"dvnum\",\n    \"dx\",\n    \"dy\",\n    \"dynsrc\",\n    \"e\",\n    \"edgeMode\",\n    \"effect\",\n    \"effectAllowed\",\n    \"effectiveDirective\",\n    \"effectiveType\",\n    \"elapsedTime\",\n    \"element\",\n    \"elementFromPoint\",\n    \"elementTiming\",\n    \"elements\",\n    \"elementsFromPoint\",\n    \"elevation\",\n    \"ellipse\",\n    \"em\",\n    \"email\",\n    \"embeds\",\n    \"emma\",\n    \"empty\",\n    \"empty-cells\",\n    \"emptyCells\",\n    \"emptyHTML\",\n    \"emptyScript\",\n    \"emulatedPosition\",\n    \"enable\",\n    \"enableBackground\",\n    \"enableDelegations\",\n    \"enableStyleSheetsForSet\",\n    \"enableVertexAttribArray\",\n    \"enabled\",\n    \"enabledPlugin\",\n    \"encode\",\n    \"encodeInto\",\n    \"encodeURI\",\n    \"encodeURIComponent\",\n    \"encodedBodySize\",\n    \"encoding\",\n    \"encodingInfo\",\n    \"encrypt\",\n    \"enctype\",\n    \"end\",\n    \"endContainer\",\n    \"endElement\",\n    \"endElementAt\",\n    \"endOfStream\",\n    \"endOffset\",\n    \"endQuery\",\n    \"endTime\",\n    \"endTransformFeedback\",\n    \"ended\",\n    \"endpoint\",\n    \"endpointNumber\",\n    \"endpoints\",\n    \"endsWith\",\n    \"enterKeyHint\",\n    \"entities\",\n    \"entries\",\n    \"entryType\",\n    \"enumerate\",\n    \"enumerateDevices\",\n    \"enumerateEditable\",\n    \"environmentBlendMode\",\n    \"equals\",\n    \"error\",\n    \"errorCode\",\n    \"errorDetail\",\n    \"errorText\",\n    \"escape\",\n    \"estimate\",\n    \"eval\",\n    \"evaluate\",\n    \"event\",\n    \"eventPhase\",\n    \"every\",\n    \"ex\",\n    \"exception\",\n    \"exchange\",\n    \"exec\",\n    \"execCommand\",\n    \"execCommandShowHelp\",\n    \"execScript\",\n    \"exitFullscreen\",\n    \"exitPictureInPicture\",\n    \"exitPointerLock\",\n    \"exitPresent\",\n    \"exp\",\n    \"expand\",\n    \"expandEntityReferences\",\n    \"expando\",\n    \"expansion\",\n    \"expiration\",\n    \"expirationTime\",\n    \"expires\",\n    \"expiryDate\",\n    \"explicitOriginalTarget\",\n    \"expm1\",\n    \"exponent\",\n    \"exponentialRampToValueAtTime\",\n    \"exportKey\",\n    \"exports\",\n    \"extend\",\n    \"extensions\",\n    \"extentNode\",\n    \"extentOffset\",\n    \"external\",\n    \"externalResourcesRequired\",\n    \"extractContents\",\n    \"extractable\",\n    \"eye\",\n    \"f\",\n    \"face\",\n    \"factoryReset\",\n    \"failureReason\",\n    \"fallback\",\n    \"family\",\n    \"familyName\",\n    \"farthestViewportElement\",\n    \"fastSeek\",\n    \"fatal\",\n    \"featureId\",\n    \"featurePolicy\",\n    \"featureSettings\",\n    \"features\",\n    \"fenceSync\",\n    \"fetch\",\n    \"fetchStart\",\n    \"fftSize\",\n    \"fgColor\",\n    \"fieldOfView\",\n    \"file\",\n    \"fileCreatedDate\",\n    \"fileHandle\",\n    \"fileModifiedDate\",\n    \"fileName\",\n    \"fileSize\",\n    \"fileUpdatedDate\",\n    \"filename\",\n    \"files\",\n    \"filesystem\",\n    \"fill\",\n    \"fill-opacity\",\n    \"fill-rule\",\n    \"fillLightMode\",\n    \"fillOpacity\",\n    \"fillRect\",\n    \"fillRule\",\n    \"fillStyle\",\n    \"fillText\",\n    \"filter\",\n    \"filterResX\",\n    \"filterResY\",\n    \"filterUnits\",\n    \"filters\",\n    \"finally\",\n    \"find\",\n    \"findIndex\",\n    \"findRule\",\n    \"findText\",\n    \"finish\",\n    \"finished\",\n    \"fireEvent\",\n    \"firesTouchEvents\",\n    \"firstChild\",\n    \"firstElementChild\",\n    \"firstPage\",\n    \"fixed\",\n    \"flags\",\n    \"flat\",\n    \"flatMap\",\n    \"flex\",\n    \"flex-basis\",\n    \"flex-direction\",\n    \"flex-flow\",\n    \"flex-grow\",\n    \"flex-shrink\",\n    \"flex-wrap\",\n    \"flexBasis\",\n    \"flexDirection\",\n    \"flexFlow\",\n    \"flexGrow\",\n    \"flexShrink\",\n    \"flexWrap\",\n    \"flipX\",\n    \"flipY\",\n    \"float\",\n    \"float32\",\n    \"float64\",\n    \"flood-color\",\n    \"flood-opacity\",\n    \"floodColor\",\n    \"floodOpacity\",\n    \"floor\",\n    \"flush\",\n    \"focus\",\n    \"focusNode\",\n    \"focusOffset\",\n    \"font\",\n    \"font-family\",\n    \"font-feature-settings\",\n    \"font-kerning\",\n    \"font-language-override\",\n    \"font-optical-sizing\",\n    \"font-size\",\n    \"font-size-adjust\",\n    \"font-stretch\",\n    \"font-style\",\n    \"font-synthesis\",\n    \"font-variant\",\n    \"font-variant-alternates\",\n    \"font-variant-caps\",\n    \"font-variant-east-asian\",\n    \"font-variant-ligatures\",\n    \"font-variant-numeric\",\n    \"font-variant-position\",\n    \"font-variation-settings\",\n    \"font-weight\",\n    \"fontFamily\",\n    \"fontFeatureSettings\",\n    \"fontKerning\",\n    \"fontLanguageOverride\",\n    \"fontOpticalSizing\",\n    \"fontSize\",\n    \"fontSizeAdjust\",\n    \"fontSmoothingEnabled\",\n    \"fontStretch\",\n    \"fontStyle\",\n    \"fontSynthesis\",\n    \"fontVariant\",\n    \"fontVariantAlternates\",\n    \"fontVariantCaps\",\n    \"fontVariantEastAsian\",\n    \"fontVariantLigatures\",\n    \"fontVariantNumeric\",\n    \"fontVariantPosition\",\n    \"fontVariationSettings\",\n    \"fontWeight\",\n    \"fontcolor\",\n    \"fontfaces\",\n    \"fonts\",\n    \"fontsize\",\n    \"for\",\n    \"forEach\",\n    \"force\",\n    \"forceRedraw\",\n    \"form\",\n    \"formAction\",\n    \"formData\",\n    \"formEnctype\",\n    \"formMethod\",\n    \"formNoValidate\",\n    \"formTarget\",\n    \"format\",\n    \"formatToParts\",\n    \"forms\",\n    \"forward\",\n    \"forwardX\",\n    \"forwardY\",\n    \"forwardZ\",\n    \"foundation\",\n    \"fr\",\n    \"fragmentDirective\",\n    \"frame\",\n    \"frameBorder\",\n    \"frameElement\",\n    \"frameSpacing\",\n    \"framebuffer\",\n    \"framebufferHeight\",\n    \"framebufferRenderbuffer\",\n    \"framebufferTexture2D\",\n    \"framebufferTextureLayer\",\n    \"framebufferWidth\",\n    \"frames\",\n    \"freeSpace\",\n    \"freeze\",\n    \"frequency\",\n    \"frequencyBinCount\",\n    \"from\",\n    \"fromCharCode\",\n    \"fromCodePoint\",\n    \"fromElement\",\n    \"fromEntries\",\n    \"fromFloat32Array\",\n    \"fromFloat64Array\",\n    \"fromMatrix\",\n    \"fromPoint\",\n    \"fromQuad\",\n    \"fromRect\",\n    \"frontFace\",\n    \"fround\",\n    \"fullPath\",\n    \"fullScreen\",\n    \"fullscreen\",\n    \"fullscreenElement\",\n    \"fullscreenEnabled\",\n    \"fx\",\n    \"fy\",\n    \"gain\",\n    \"gamepad\",\n    \"gamma\",\n    \"gap\",\n    \"gatheringState\",\n    \"gatt\",\n    \"genderIdentity\",\n    \"generateCertificate\",\n    \"generateKey\",\n    \"generateMipmap\",\n    \"generateRequest\",\n    \"geolocation\",\n    \"gestureObject\",\n    \"get\",\n    \"getActiveAttrib\",\n    \"getActiveUniform\",\n    \"getActiveUniformBlockName\",\n    \"getActiveUniformBlockParameter\",\n    \"getActiveUniforms\",\n    \"getAdjacentText\",\n    \"getAll\",\n    \"getAllKeys\",\n    \"getAllResponseHeaders\",\n    \"getAllowlistForFeature\",\n    \"getAnimations\",\n    \"getAsFile\",\n    \"getAsString\",\n    \"getAttachedShaders\",\n    \"getAttribLocation\",\n    \"getAttribute\",\n    \"getAttributeNS\",\n    \"getAttributeNames\",\n    \"getAttributeNode\",\n    \"getAttributeNodeNS\",\n    \"getAttributeType\",\n    \"getAudioTracks\",\n    \"getAvailability\",\n    \"getBBox\",\n    \"getBattery\",\n    \"getBigInt64\",\n    \"getBigUint64\",\n    \"getBlob\",\n    \"getBookmark\",\n    \"getBoundingClientRect\",\n    \"getBounds\",\n    \"getBoxQuads\",\n    \"getBufferParameter\",\n    \"getBufferSubData\",\n    \"getByteFrequencyData\",\n    \"getByteTimeDomainData\",\n    \"getCSSCanvasContext\",\n    \"getCTM\",\n    \"getCandidateWindowClientRect\",\n    \"getCanonicalLocales\",\n    \"getCapabilities\",\n    \"getChannelData\",\n    \"getCharNumAtPosition\",\n    \"getCharacteristic\",\n    \"getCharacteristics\",\n    \"getClientExtensionResults\",\n    \"getClientRect\",\n    \"getClientRects\",\n    \"getCoalescedEvents\",\n    \"getCompositionAlternatives\",\n    \"getComputedStyle\",\n    \"getComputedTextLength\",\n    \"getComputedTiming\",\n    \"getConfiguration\",\n    \"getConstraints\",\n    \"getContext\",\n    \"getContextAttributes\",\n    \"getContributingSources\",\n    \"getCounterValue\",\n    \"getCueAsHTML\",\n    \"getCueById\",\n    \"getCurrentPosition\",\n    \"getCurrentTime\",\n    \"getData\",\n    \"getDatabaseNames\",\n    \"getDate\",\n    \"getDay\",\n    \"getDefaultComputedStyle\",\n    \"getDescriptor\",\n    \"getDescriptors\",\n    \"getDestinationInsertionPoints\",\n    \"getDevices\",\n    \"getDirectory\",\n    \"getDisplayMedia\",\n    \"getDistributedNodes\",\n    \"getEditable\",\n    \"getElementById\",\n    \"getElementsByClassName\",\n    \"getElementsByName\",\n    \"getElementsByTagName\",\n    \"getElementsByTagNameNS\",\n    \"getEnclosureList\",\n    \"getEndPositionOfChar\",\n    \"getEntries\",\n    \"getEntriesByName\",\n    \"getEntriesByType\",\n    \"getError\",\n    \"getExtension\",\n    \"getExtentOfChar\",\n    \"getEyeParameters\",\n    \"getFeature\",\n    \"getFile\",\n    \"getFiles\",\n    \"getFilesAndDirectories\",\n    \"getFingerprints\",\n    \"getFloat32\",\n    \"getFloat64\",\n    \"getFloatFrequencyData\",\n    \"getFloatTimeDomainData\",\n    \"getFloatValue\",\n    \"getFragDataLocation\",\n    \"getFrameData\",\n    \"getFramebufferAttachmentParameter\",\n    \"getFrequencyResponse\",\n    \"getFullYear\",\n    \"getGamepads\",\n    \"getHitTestResults\",\n    \"getHitTestResultsForTransientInput\",\n    \"getHours\",\n    \"getIdentityAssertion\",\n    \"getIds\",\n    \"getImageData\",\n    \"getIndexedParameter\",\n    \"getInstalledRelatedApps\",\n    \"getInt16\",\n    \"getInt32\",\n    \"getInt8\",\n    \"getInternalformatParameter\",\n    \"getIntersectionList\",\n    \"getItem\",\n    \"getItems\",\n    \"getKey\",\n    \"getKeyframes\",\n    \"getLayers\",\n    \"getLayoutMap\",\n    \"getLineDash\",\n    \"getLocalCandidates\",\n    \"getLocalParameters\",\n    \"getLocalStreams\",\n    \"getMarks\",\n    \"getMatchedCSSRules\",\n    \"getMaxGCPauseSinceClear\",\n    \"getMeasures\",\n    \"getMetadata\",\n    \"getMilliseconds\",\n    \"getMinutes\",\n    \"getModifierState\",\n    \"getMonth\",\n    \"getNamedItem\",\n    \"getNamedItemNS\",\n    \"getNativeFramebufferScaleFactor\",\n    \"getNotifications\",\n    \"getNotifier\",\n    \"getNumberOfChars\",\n    \"getOffsetReferenceSpace\",\n    \"getOutputTimestamp\",\n    \"getOverrideHistoryNavigationMode\",\n    \"getOverrideStyle\",\n    \"getOwnPropertyDescriptor\",\n    \"getOwnPropertyDescriptors\",\n    \"getOwnPropertyNames\",\n    \"getOwnPropertySymbols\",\n    \"getParameter\",\n    \"getParameters\",\n    \"getParent\",\n    \"getPathSegAtLength\",\n    \"getPhotoCapabilities\",\n    \"getPhotoSettings\",\n    \"getPointAtLength\",\n    \"getPose\",\n    \"getPredictedEvents\",\n    \"getPreference\",\n    \"getPreferenceDefault\",\n    \"getPresentationAttribute\",\n    \"getPreventDefault\",\n    \"getPrimaryService\",\n    \"getPrimaryServices\",\n    \"getProgramInfoLog\",\n    \"getProgramParameter\",\n    \"getPropertyCSSValue\",\n    \"getPropertyPriority\",\n    \"getPropertyShorthand\",\n    \"getPropertyType\",\n    \"getPropertyValue\",\n    \"getPrototypeOf\",\n    \"getQuery\",\n    \"getQueryParameter\",\n    \"getRGBColorValue\",\n    \"getRandomValues\",\n    \"getRangeAt\",\n    \"getReader\",\n    \"getReceivers\",\n    \"getRectValue\",\n    \"getRegistration\",\n    \"getRegistrations\",\n    \"getRemoteCandidates\",\n    \"getRemoteCertificates\",\n    \"getRemoteParameters\",\n    \"getRemoteStreams\",\n    \"getRenderbufferParameter\",\n    \"getResponseHeader\",\n    \"getRoot\",\n    \"getRootNode\",\n    \"getRotationOfChar\",\n    \"getSVGDocument\",\n    \"getSamplerParameter\",\n    \"getScreenCTM\",\n    \"getSeconds\",\n    \"getSelectedCandidatePair\",\n    \"getSelection\",\n    \"getSenders\",\n    \"getService\",\n    \"getSettings\",\n    \"getShaderInfoLog\",\n    \"getShaderParameter\",\n    \"getShaderPrecisionFormat\",\n    \"getShaderSource\",\n    \"getSimpleDuration\",\n    \"getSiteIcons\",\n    \"getSources\",\n    \"getSpeculativeParserUrls\",\n    \"getStartPositionOfChar\",\n    \"getStartTime\",\n    \"getState\",\n    \"getStats\",\n    \"getStatusForPolicy\",\n    \"getStorageUpdates\",\n    \"getStreamById\",\n    \"getStringValue\",\n    \"getSubStringLength\",\n    \"getSubscription\",\n    \"getSupportedConstraints\",\n    \"getSupportedExtensions\",\n    \"getSupportedFormats\",\n    \"getSyncParameter\",\n    \"getSynchronizationSources\",\n    \"getTags\",\n    \"getTargetRanges\",\n    \"getTexParameter\",\n    \"getTime\",\n    \"getTimezoneOffset\",\n    \"getTiming\",\n    \"getTotalLength\",\n    \"getTrackById\",\n    \"getTracks\",\n    \"getTransceivers\",\n    \"getTransform\",\n    \"getTransformFeedbackVarying\",\n    \"getTransformToElement\",\n    \"getTransports\",\n    \"getType\",\n    \"getTypeMapping\",\n    \"getUTCDate\",\n    \"getUTCDay\",\n    \"getUTCFullYear\",\n    \"getUTCHours\",\n    \"getUTCMilliseconds\",\n    \"getUTCMinutes\",\n    \"getUTCMonth\",\n    \"getUTCSeconds\",\n    \"getUint16\",\n    \"getUint32\",\n    \"getUint8\",\n    \"getUniform\",\n    \"getUniformBlockIndex\",\n    \"getUniformIndices\",\n    \"getUniformLocation\",\n    \"getUserMedia\",\n    \"getVRDisplays\",\n    \"getValues\",\n    \"getVarDate\",\n    \"getVariableValue\",\n    \"getVertexAttrib\",\n    \"getVertexAttribOffset\",\n    \"getVideoPlaybackQuality\",\n    \"getVideoTracks\",\n    \"getViewerPose\",\n    \"getViewport\",\n    \"getVoices\",\n    \"getWakeLockState\",\n    \"getWriter\",\n    \"getYear\",\n    \"givenName\",\n    \"global\",\n    \"globalAlpha\",\n    \"globalCompositeOperation\",\n    \"globalThis\",\n    \"glyphOrientationHorizontal\",\n    \"glyphOrientationVertical\",\n    \"glyphRef\",\n    \"go\",\n    \"grabFrame\",\n    \"grad\",\n    \"gradientTransform\",\n    \"gradientUnits\",\n    \"grammars\",\n    \"green\",\n    \"grid\",\n    \"grid-area\",\n    \"grid-auto-columns\",\n    \"grid-auto-flow\",\n    \"grid-auto-rows\",\n    \"grid-column\",\n    \"grid-column-end\",\n    \"grid-column-gap\",\n    \"grid-column-start\",\n    \"grid-gap\",\n    \"grid-row\",\n    \"grid-row-end\",\n    \"grid-row-gap\",\n    \"grid-row-start\",\n    \"grid-template\",\n    \"grid-template-areas\",\n    \"grid-template-columns\",\n    \"grid-template-rows\",\n    \"gridArea\",\n    \"gridAutoColumns\",\n    \"gridAutoFlow\",\n    \"gridAutoRows\",\n    \"gridColumn\",\n    \"gridColumnEnd\",\n    \"gridColumnGap\",\n    \"gridColumnStart\",\n    \"gridGap\",\n    \"gridRow\",\n    \"gridRowEnd\",\n    \"gridRowGap\",\n    \"gridRowStart\",\n    \"gridTemplate\",\n    \"gridTemplateAreas\",\n    \"gridTemplateColumns\",\n    \"gridTemplateRows\",\n    \"gripSpace\",\n    \"group\",\n    \"groupCollapsed\",\n    \"groupEnd\",\n    \"groupId\",\n    \"hadRecentInput\",\n    \"hand\",\n    \"handedness\",\n    \"hapticActuators\",\n    \"hardwareConcurrency\",\n    \"has\",\n    \"hasAttribute\",\n    \"hasAttributeNS\",\n    \"hasAttributes\",\n    \"hasBeenActive\",\n    \"hasChildNodes\",\n    \"hasComposition\",\n    \"hasEnrolledInstrument\",\n    \"hasExtension\",\n    \"hasExternalDisplay\",\n    \"hasFeature\",\n    \"hasFocus\",\n    \"hasInstance\",\n    \"hasLayout\",\n    \"hasOrientation\",\n    \"hasOwnProperty\",\n    \"hasPointerCapture\",\n    \"hasPosition\",\n    \"hasReading\",\n    \"hasStorageAccess\",\n    \"hash\",\n    \"head\",\n    \"headers\",\n    \"heading\",\n    \"height\",\n    \"hidden\",\n    \"hide\",\n    \"hideFocus\",\n    \"high\",\n    \"highWaterMark\",\n    \"hint\",\n    \"history\",\n    \"honorificPrefix\",\n    \"honorificSuffix\",\n    \"horizontalOverflow\",\n    \"host\",\n    \"hostCandidate\",\n    \"hostname\",\n    \"href\",\n    \"hrefTranslate\",\n    \"hreflang\",\n    \"hspace\",\n    \"html5TagCheckInerface\",\n    \"htmlFor\",\n    \"htmlText\",\n    \"httpEquiv\",\n    \"httpRequestStatusCode\",\n    \"hwTimestamp\",\n    \"hyphens\",\n    \"hypot\",\n    \"iccId\",\n    \"iceConnectionState\",\n    \"iceGatheringState\",\n    \"iceTransport\",\n    \"icon\",\n    \"iconURL\",\n    \"id\",\n    \"identifier\",\n    \"identity\",\n    \"idpLoginUrl\",\n    \"ignoreBOM\",\n    \"ignoreCase\",\n    \"ignoreDepthValues\",\n    \"image-orientation\",\n    \"image-rendering\",\n    \"imageHeight\",\n    \"imageOrientation\",\n    \"imageRendering\",\n    \"imageSizes\",\n    \"imageSmoothingEnabled\",\n    \"imageSmoothingQuality\",\n    \"imageSrcset\",\n    \"imageWidth\",\n    \"images\",\n    \"ime-mode\",\n    \"imeMode\",\n    \"implementation\",\n    \"importKey\",\n    \"importNode\",\n    \"importStylesheet\",\n    \"imports\",\n    \"impp\",\n    \"imul\",\n    \"in\",\n    \"in1\",\n    \"in2\",\n    \"inBandMetadataTrackDispatchType\",\n    \"inRange\",\n    \"includes\",\n    \"incremental\",\n    \"indeterminate\",\n    \"index\",\n    \"indexNames\",\n    \"indexOf\",\n    \"indexedDB\",\n    \"indicate\",\n    \"inertiaDestinationX\",\n    \"inertiaDestinationY\",\n    \"info\",\n    \"init\",\n    \"initAnimationEvent\",\n    \"initBeforeLoadEvent\",\n    \"initClipboardEvent\",\n    \"initCloseEvent\",\n    \"initCommandEvent\",\n    \"initCompositionEvent\",\n    \"initCustomEvent\",\n    \"initData\",\n    \"initDataType\",\n    \"initDeviceMotionEvent\",\n    \"initDeviceOrientationEvent\",\n    \"initDragEvent\",\n    \"initErrorEvent\",\n    \"initEvent\",\n    \"initFocusEvent\",\n    \"initGestureEvent\",\n    \"initHashChangeEvent\",\n    \"initKeyEvent\",\n    \"initKeyboardEvent\",\n    \"initMSManipulationEvent\",\n    \"initMessageEvent\",\n    \"initMouseEvent\",\n    \"initMouseScrollEvent\",\n    \"initMouseWheelEvent\",\n    \"initMutationEvent\",\n    \"initNSMouseEvent\",\n    \"initOverflowEvent\",\n    \"initPageEvent\",\n    \"initPageTransitionEvent\",\n    \"initPointerEvent\",\n    \"initPopStateEvent\",\n    \"initProgressEvent\",\n    \"initScrollAreaEvent\",\n    \"initSimpleGestureEvent\",\n    \"initStorageEvent\",\n    \"initTextEvent\",\n    \"initTimeEvent\",\n    \"initTouchEvent\",\n    \"initTransitionEvent\",\n    \"initUIEvent\",\n    \"initWebKitAnimationEvent\",\n    \"initWebKitTransitionEvent\",\n    \"initWebKitWheelEvent\",\n    \"initWheelEvent\",\n    \"initialTime\",\n    \"initialize\",\n    \"initiatorType\",\n    \"inline-size\",\n    \"inlineSize\",\n    \"inlineVerticalFieldOfView\",\n    \"inner\",\n    \"innerHTML\",\n    \"innerHeight\",\n    \"innerText\",\n    \"innerWidth\",\n    \"input\",\n    \"inputBuffer\",\n    \"inputEncoding\",\n    \"inputMethod\",\n    \"inputMode\",\n    \"inputSource\",\n    \"inputSources\",\n    \"inputType\",\n    \"inputs\",\n    \"insertAdjacentElement\",\n    \"insertAdjacentHTML\",\n    \"insertAdjacentText\",\n    \"insertBefore\",\n    \"insertCell\",\n    \"insertDTMF\",\n    \"insertData\",\n    \"insertItemBefore\",\n    \"insertNode\",\n    \"insertRow\",\n    \"insertRule\",\n    \"inset\",\n    \"inset-block\",\n    \"inset-block-end\",\n    \"inset-block-start\",\n    \"inset-inline\",\n    \"inset-inline-end\",\n    \"inset-inline-start\",\n    \"insetBlock\",\n    \"insetBlockEnd\",\n    \"insetBlockStart\",\n    \"insetInline\",\n    \"insetInlineEnd\",\n    \"insetInlineStart\",\n    \"installing\",\n    \"instanceRoot\",\n    \"instantiate\",\n    \"instantiateStreaming\",\n    \"instruments\",\n    \"int16\",\n    \"int32\",\n    \"int8\",\n    \"integrity\",\n    \"interactionMode\",\n    \"intercept\",\n    \"interfaceClass\",\n    \"interfaceName\",\n    \"interfaceNumber\",\n    \"interfaceProtocol\",\n    \"interfaceSubclass\",\n    \"interfaces\",\n    \"interimResults\",\n    \"internalSubset\",\n    \"interpretation\",\n    \"intersectionRatio\",\n    \"intersectionRect\",\n    \"intersectsNode\",\n    \"interval\",\n    \"invalidIteratorState\",\n    \"invalidateFramebuffer\",\n    \"invalidateSubFramebuffer\",\n    \"inverse\",\n    \"invertSelf\",\n    \"is\",\n    \"is2D\",\n    \"isActive\",\n    \"isAlternate\",\n    \"isArray\",\n    \"isBingCurrentSearchDefault\",\n    \"isBuffer\",\n    \"isCandidateWindowVisible\",\n    \"isChar\",\n    \"isCollapsed\",\n    \"isComposing\",\n    \"isConcatSpreadable\",\n    \"isConnected\",\n    \"isContentEditable\",\n    \"isContentHandlerRegistered\",\n    \"isContextLost\",\n    \"isDefaultNamespace\",\n    \"isDirectory\",\n    \"isDisabled\",\n    \"isEnabled\",\n    \"isEqual\",\n    \"isEqualNode\",\n    \"isExtensible\",\n    \"isExternalCTAP2SecurityKeySupported\",\n    \"isFile\",\n    \"isFinite\",\n    \"isFramebuffer\",\n    \"isFrozen\",\n    \"isGenerator\",\n    \"isHTML\",\n    \"isHistoryNavigation\",\n    \"isId\",\n    \"isIdentity\",\n    \"isInjected\",\n    \"isInteger\",\n    \"isIntersecting\",\n    \"isLockFree\",\n    \"isMap\",\n    \"isMultiLine\",\n    \"isNaN\",\n    \"isOpen\",\n    \"isPointInFill\",\n    \"isPointInPath\",\n    \"isPointInRange\",\n    \"isPointInStroke\",\n    \"isPrefAlternate\",\n    \"isPresenting\",\n    \"isPrimary\",\n    \"isProgram\",\n    \"isPropertyImplicit\",\n    \"isProtocolHandlerRegistered\",\n    \"isPrototypeOf\",\n    \"isQuery\",\n    \"isRenderbuffer\",\n    \"isSafeInteger\",\n    \"isSameNode\",\n    \"isSampler\",\n    \"isScript\",\n    \"isScriptURL\",\n    \"isSealed\",\n    \"isSecureContext\",\n    \"isSessionSupported\",\n    \"isShader\",\n    \"isSupported\",\n    \"isSync\",\n    \"isTextEdit\",\n    \"isTexture\",\n    \"isTransformFeedback\",\n    \"isTrusted\",\n    \"isTypeSupported\",\n    \"isUserVerifyingPlatformAuthenticatorAvailable\",\n    \"isVertexArray\",\n    \"isView\",\n    \"isVisible\",\n    \"isochronousTransferIn\",\n    \"isochronousTransferOut\",\n    \"isolation\",\n    \"italics\",\n    \"item\",\n    \"itemId\",\n    \"itemProp\",\n    \"itemRef\",\n    \"itemScope\",\n    \"itemType\",\n    \"itemValue\",\n    \"items\",\n    \"iterateNext\",\n    \"iterationComposite\",\n    \"iterator\",\n    \"javaEnabled\",\n    \"jobTitle\",\n    \"join\",\n    \"json\",\n    \"justify-content\",\n    \"justify-items\",\n    \"justify-self\",\n    \"justifyContent\",\n    \"justifyItems\",\n    \"justifySelf\",\n    \"k1\",\n    \"k2\",\n    \"k3\",\n    \"k4\",\n    \"kHz\",\n    \"keepalive\",\n    \"kernelMatrix\",\n    \"kernelUnitLengthX\",\n    \"kernelUnitLengthY\",\n    \"kerning\",\n    \"key\",\n    \"keyCode\",\n    \"keyFor\",\n    \"keyIdentifier\",\n    \"keyLightEnabled\",\n    \"keyLocation\",\n    \"keyPath\",\n    \"keyStatuses\",\n    \"keySystem\",\n    \"keyText\",\n    \"keyUsage\",\n    \"keyboard\",\n    \"keys\",\n    \"keytype\",\n    \"kind\",\n    \"knee\",\n    \"label\",\n    \"labels\",\n    \"lang\",\n    \"language\",\n    \"languages\",\n    \"largeArcFlag\",\n    \"lastChild\",\n    \"lastElementChild\",\n    \"lastEventId\",\n    \"lastIndex\",\n    \"lastIndexOf\",\n    \"lastInputTime\",\n    \"lastMatch\",\n    \"lastMessageSubject\",\n    \"lastMessageType\",\n    \"lastModified\",\n    \"lastModifiedDate\",\n    \"lastPage\",\n    \"lastParen\",\n    \"lastState\",\n    \"lastStyleSheetSet\",\n    \"latitude\",\n    \"layerX\",\n    \"layerY\",\n    \"layoutFlow\",\n    \"layoutGrid\",\n    \"layoutGridChar\",\n    \"layoutGridLine\",\n    \"layoutGridMode\",\n    \"layoutGridType\",\n    \"lbound\",\n    \"left\",\n    \"leftContext\",\n    \"leftDegrees\",\n    \"leftMargin\",\n    \"leftProjectionMatrix\",\n    \"leftViewMatrix\",\n    \"length\",\n    \"lengthAdjust\",\n    \"lengthComputable\",\n    \"letter-spacing\",\n    \"letterSpacing\",\n    \"level\",\n    \"lighting-color\",\n    \"lightingColor\",\n    \"limitingConeAngle\",\n    \"line\",\n    \"line-break\",\n    \"line-height\",\n    \"lineAlign\",\n    \"lineBreak\",\n    \"lineCap\",\n    \"lineDashOffset\",\n    \"lineHeight\",\n    \"lineJoin\",\n    \"lineNumber\",\n    \"lineTo\",\n    \"lineWidth\",\n    \"linearAcceleration\",\n    \"linearRampToValueAtTime\",\n    \"linearVelocity\",\n    \"lineno\",\n    \"lines\",\n    \"link\",\n    \"linkColor\",\n    \"linkProgram\",\n    \"links\",\n    \"list\",\n    \"list-style\",\n    \"list-style-image\",\n    \"list-style-position\",\n    \"list-style-type\",\n    \"listStyle\",\n    \"listStyleImage\",\n    \"listStylePosition\",\n    \"listStyleType\",\n    \"listener\",\n    \"load\",\n    \"loadEventEnd\",\n    \"loadEventStart\",\n    \"loadTime\",\n    \"loadTimes\",\n    \"loaded\",\n    \"loading\",\n    \"localDescription\",\n    \"localName\",\n    \"localService\",\n    \"localStorage\",\n    \"locale\",\n    \"localeCompare\",\n    \"location\",\n    \"locationbar\",\n    \"lock\",\n    \"locked\",\n    \"lockedFile\",\n    \"locks\",\n    \"log\",\n    \"log10\",\n    \"log1p\",\n    \"log2\",\n    \"logicalXDPI\",\n    \"logicalYDPI\",\n    \"longDesc\",\n    \"longitude\",\n    \"lookupNamespaceURI\",\n    \"lookupPrefix\",\n    \"loop\",\n    \"loopEnd\",\n    \"loopStart\",\n    \"looping\",\n    \"low\",\n    \"lower\",\n    \"lowerBound\",\n    \"lowerOpen\",\n    \"lowsrc\",\n    \"m11\",\n    \"m12\",\n    \"m13\",\n    \"m14\",\n    \"m21\",\n    \"m22\",\n    \"m23\",\n    \"m24\",\n    \"m31\",\n    \"m32\",\n    \"m33\",\n    \"m34\",\n    \"m41\",\n    \"m42\",\n    \"m43\",\n    \"m44\",\n    \"makeXRCompatible\",\n    \"manifest\",\n    \"manufacturer\",\n    \"manufacturerName\",\n    \"map\",\n    \"mapping\",\n    \"margin\",\n    \"margin-block\",\n    \"margin-block-end\",\n    \"margin-block-start\",\n    \"margin-bottom\",\n    \"margin-inline\",\n    \"margin-inline-end\",\n    \"margin-inline-start\",\n    \"margin-left\",\n    \"margin-right\",\n    \"margin-top\",\n    \"marginBlock\",\n    \"marginBlockEnd\",\n    \"marginBlockStart\",\n    \"marginBottom\",\n    \"marginHeight\",\n    \"marginInline\",\n    \"marginInlineEnd\",\n    \"marginInlineStart\",\n    \"marginLeft\",\n    \"marginRight\",\n    \"marginTop\",\n    \"marginWidth\",\n    \"mark\",\n    \"marker\",\n    \"marker-end\",\n    \"marker-mid\",\n    \"marker-offset\",\n    \"marker-start\",\n    \"markerEnd\",\n    \"markerHeight\",\n    \"markerMid\",\n    \"markerOffset\",\n    \"markerStart\",\n    \"markerUnits\",\n    \"markerWidth\",\n    \"marks\",\n    \"mask\",\n    \"mask-clip\",\n    \"mask-composite\",\n    \"mask-image\",\n    \"mask-mode\",\n    \"mask-origin\",\n    \"mask-position\",\n    \"mask-position-x\",\n    \"mask-position-y\",\n    \"mask-repeat\",\n    \"mask-size\",\n    \"mask-type\",\n    \"maskClip\",\n    \"maskComposite\",\n    \"maskContentUnits\",\n    \"maskImage\",\n    \"maskMode\",\n    \"maskOrigin\",\n    \"maskPosition\",\n    \"maskPositionX\",\n    \"maskPositionY\",\n    \"maskRepeat\",\n    \"maskSize\",\n    \"maskType\",\n    \"maskUnits\",\n    \"match\",\n    \"matchAll\",\n    \"matchMedia\",\n    \"matchMedium\",\n    \"matches\",\n    \"matrix\",\n    \"matrixTransform\",\n    \"max\",\n    \"max-block-size\",\n    \"max-height\",\n    \"max-inline-size\",\n    \"max-width\",\n    \"maxActions\",\n    \"maxAlternatives\",\n    \"maxBlockSize\",\n    \"maxChannelCount\",\n    \"maxChannels\",\n    \"maxConnectionsPerServer\",\n    \"maxDecibels\",\n    \"maxDistance\",\n    \"maxHeight\",\n    \"maxInlineSize\",\n    \"maxLayers\",\n    \"maxLength\",\n    \"maxMessageSize\",\n    \"maxPacketLifeTime\",\n    \"maxRetransmits\",\n    \"maxTouchPoints\",\n    \"maxValue\",\n    \"maxWidth\",\n    \"measure\",\n    \"measureText\",\n    \"media\",\n    \"mediaCapabilities\",\n    \"mediaDevices\",\n    \"mediaElement\",\n    \"mediaGroup\",\n    \"mediaKeys\",\n    \"mediaSession\",\n    \"mediaStream\",\n    \"mediaText\",\n    \"meetOrSlice\",\n    \"memory\",\n    \"menubar\",\n    \"mergeAttributes\",\n    \"message\",\n    \"messageClass\",\n    \"messageHandlers\",\n    \"messageType\",\n    \"metaKey\",\n    \"metadata\",\n    \"method\",\n    \"methodDetails\",\n    \"methodName\",\n    \"mid\",\n    \"mimeType\",\n    \"mimeTypes\",\n    \"min\",\n    \"min-block-size\",\n    \"min-height\",\n    \"min-inline-size\",\n    \"min-width\",\n    \"minBlockSize\",\n    \"minDecibels\",\n    \"minHeight\",\n    \"minInlineSize\",\n    \"minLength\",\n    \"minValue\",\n    \"minWidth\",\n    \"miterLimit\",\n    \"mix-blend-mode\",\n    \"mixBlendMode\",\n    \"mm\",\n    \"mode\",\n    \"modify\",\n    \"mount\",\n    \"move\",\n    \"moveBy\",\n    \"moveEnd\",\n    \"moveFirst\",\n    \"moveFocusDown\",\n    \"moveFocusLeft\",\n    \"moveFocusRight\",\n    \"moveFocusUp\",\n    \"moveNext\",\n    \"moveRow\",\n    \"moveStart\",\n    \"moveTo\",\n    \"moveToBookmark\",\n    \"moveToElementText\",\n    \"moveToPoint\",\n    \"movementX\",\n    \"movementY\",\n    \"mozAdd\",\n    \"mozAnimationStartTime\",\n    \"mozAnon\",\n    \"mozApps\",\n    \"mozAudioCaptured\",\n    \"mozAudioChannelType\",\n    \"mozAutoplayEnabled\",\n    \"mozCancelAnimationFrame\",\n    \"mozCancelFullScreen\",\n    \"mozCancelRequestAnimationFrame\",\n    \"mozCaptureStream\",\n    \"mozCaptureStreamUntilEnded\",\n    \"mozClearDataAt\",\n    \"mozContact\",\n    \"mozContacts\",\n    \"mozCreateFileHandle\",\n    \"mozCurrentTransform\",\n    \"mozCurrentTransformInverse\",\n    \"mozCursor\",\n    \"mozDash\",\n    \"mozDashOffset\",\n    \"mozDecodedFrames\",\n    \"mozExitPointerLock\",\n    \"mozFillRule\",\n    \"mozFragmentEnd\",\n    \"mozFrameDelay\",\n    \"mozFullScreen\",\n    \"mozFullScreenElement\",\n    \"mozFullScreenEnabled\",\n    \"mozGetAll\",\n    \"mozGetAllKeys\",\n    \"mozGetAsFile\",\n    \"mozGetDataAt\",\n    \"mozGetMetadata\",\n    \"mozGetUserMedia\",\n    \"mozHasAudio\",\n    \"mozHasItem\",\n    \"mozHidden\",\n    \"mozImageSmoothingEnabled\",\n    \"mozIndexedDB\",\n    \"mozInnerScreenX\",\n    \"mozInnerScreenY\",\n    \"mozInputSource\",\n    \"mozIsTextField\",\n    \"mozItem\",\n    \"mozItemCount\",\n    \"mozItems\",\n    \"mozLength\",\n    \"mozLockOrientation\",\n    \"mozMatchesSelector\",\n    \"mozMovementX\",\n    \"mozMovementY\",\n    \"mozOpaque\",\n    \"mozOrientation\",\n    \"mozPaintCount\",\n    \"mozPaintedFrames\",\n    \"mozParsedFrames\",\n    \"mozPay\",\n    \"mozPointerLockElement\",\n    \"mozPresentedFrames\",\n    \"mozPreservesPitch\",\n    \"mozPressure\",\n    \"mozPrintCallback\",\n    \"mozRTCIceCandidate\",\n    \"mozRTCPeerConnection\",\n    \"mozRTCSessionDescription\",\n    \"mozRemove\",\n    \"mozRequestAnimationFrame\",\n    \"mozRequestFullScreen\",\n    \"mozRequestPointerLock\",\n    \"mozSetDataAt\",\n    \"mozSetImageElement\",\n    \"mozSourceNode\",\n    \"mozSrcObject\",\n    \"mozSystem\",\n    \"mozTCPSocket\",\n    \"mozTextStyle\",\n    \"mozTypesAt\",\n    \"mozUnlockOrientation\",\n    \"mozUserCancelled\",\n    \"mozVisibilityState\",\n    \"ms\",\n    \"msAnimation\",\n    \"msAnimationDelay\",\n    \"msAnimationDirection\",\n    \"msAnimationDuration\",\n    \"msAnimationFillMode\",\n    \"msAnimationIterationCount\",\n    \"msAnimationName\",\n    \"msAnimationPlayState\",\n    \"msAnimationStartTime\",\n    \"msAnimationTimingFunction\",\n    \"msBackfaceVisibility\",\n    \"msBlockProgression\",\n    \"msCSSOMElementFloatMetrics\",\n    \"msCaching\",\n    \"msCachingEnabled\",\n    \"msCancelRequestAnimationFrame\",\n    \"msCapsLockWarningOff\",\n    \"msClearImmediate\",\n    \"msClose\",\n    \"msContentZoomChaining\",\n    \"msContentZoomFactor\",\n    \"msContentZoomLimit\",\n    \"msContentZoomLimitMax\",\n    \"msContentZoomLimitMin\",\n    \"msContentZoomSnap\",\n    \"msContentZoomSnapPoints\",\n    \"msContentZoomSnapType\",\n    \"msContentZooming\",\n    \"msConvertURL\",\n    \"msCrypto\",\n    \"msDoNotTrack\",\n    \"msElementsFromPoint\",\n    \"msElementsFromRect\",\n    \"msExitFullscreen\",\n    \"msExtendedCode\",\n    \"msFillRule\",\n    \"msFirstPaint\",\n    \"msFlex\",\n    \"msFlexAlign\",\n    \"msFlexDirection\",\n    \"msFlexFlow\",\n    \"msFlexItemAlign\",\n    \"msFlexLinePack\",\n    \"msFlexNegative\",\n    \"msFlexOrder\",\n    \"msFlexPack\",\n    \"msFlexPositive\",\n    \"msFlexPreferredSize\",\n    \"msFlexWrap\",\n    \"msFlowFrom\",\n    \"msFlowInto\",\n    \"msFontFeatureSettings\",\n    \"msFullscreenElement\",\n    \"msFullscreenEnabled\",\n    \"msGetInputContext\",\n    \"msGetRegionContent\",\n    \"msGetUntransformedBounds\",\n    \"msGraphicsTrustStatus\",\n    \"msGridColumn\",\n    \"msGridColumnAlign\",\n    \"msGridColumnSpan\",\n    \"msGridColumns\",\n    \"msGridRow\",\n    \"msGridRowAlign\",\n    \"msGridRowSpan\",\n    \"msGridRows\",\n    \"msHidden\",\n    \"msHighContrastAdjust\",\n    \"msHyphenateLimitChars\",\n    \"msHyphenateLimitLines\",\n    \"msHyphenateLimitZone\",\n    \"msHyphens\",\n    \"msImageSmoothingEnabled\",\n    \"msImeAlign\",\n    \"msIndexedDB\",\n    \"msInterpolationMode\",\n    \"msIsStaticHTML\",\n    \"msKeySystem\",\n    \"msKeys\",\n    \"msLaunchUri\",\n    \"msLockOrientation\",\n    \"msManipulationViewsEnabled\",\n    \"msMatchMedia\",\n    \"msMatchesSelector\",\n    \"msMaxTouchPoints\",\n    \"msOrientation\",\n    \"msOverflowStyle\",\n    \"msPerspective\",\n    \"msPerspectiveOrigin\",\n    \"msPlayToDisabled\",\n    \"msPlayToPreferredSourceUri\",\n    \"msPlayToPrimary\",\n    \"msPointerEnabled\",\n    \"msRegionOverflow\",\n    \"msReleasePointerCapture\",\n    \"msRequestAnimationFrame\",\n    \"msRequestFullscreen\",\n    \"msSaveBlob\",\n    \"msSaveOrOpenBlob\",\n    \"msScrollChaining\",\n    \"msScrollLimit\",\n    \"msScrollLimitXMax\",\n    \"msScrollLimitXMin\",\n    \"msScrollLimitYMax\",\n    \"msScrollLimitYMin\",\n    \"msScrollRails\",\n    \"msScrollSnapPointsX\",\n    \"msScrollSnapPointsY\",\n    \"msScrollSnapType\",\n    \"msScrollSnapX\",\n    \"msScrollSnapY\",\n    \"msScrollTranslation\",\n    \"msSetImmediate\",\n    \"msSetMediaKeys\",\n    \"msSetPointerCapture\",\n    \"msTextCombineHorizontal\",\n    \"msTextSizeAdjust\",\n    \"msToBlob\",\n    \"msTouchAction\",\n    \"msTouchSelect\",\n    \"msTraceAsyncCallbackCompleted\",\n    \"msTraceAsyncCallbackStarting\",\n    \"msTraceAsyncOperationCompleted\",\n    \"msTraceAsyncOperationStarting\",\n    \"msTransform\",\n    \"msTransformOrigin\",\n    \"msTransformStyle\",\n    \"msTransition\",\n    \"msTransitionDelay\",\n    \"msTransitionDuration\",\n    \"msTransitionProperty\",\n    \"msTransitionTimingFunction\",\n    \"msUnlockOrientation\",\n    \"msUpdateAsyncCallbackRelation\",\n    \"msUserSelect\",\n    \"msVisibilityState\",\n    \"msWrapFlow\",\n    \"msWrapMargin\",\n    \"msWrapThrough\",\n    \"msWriteProfilerMark\",\n    \"msZoom\",\n    \"msZoomTo\",\n    \"mt\",\n    \"mul\",\n    \"multiEntry\",\n    \"multiSelectionObj\",\n    \"multiline\",\n    \"multiple\",\n    \"multiply\",\n    \"multiplySelf\",\n    \"mutableFile\",\n    \"muted\",\n    \"n\",\n    \"name\",\n    \"nameProp\",\n    \"namedItem\",\n    \"namedRecordset\",\n    \"names\",\n    \"namespaceURI\",\n    \"namespaces\",\n    \"naturalHeight\",\n    \"naturalWidth\",\n    \"navigate\",\n    \"navigation\",\n    \"navigationMode\",\n    \"navigationPreload\",\n    \"navigationStart\",\n    \"navigator\",\n    \"near\",\n    \"nearestViewportElement\",\n    \"negative\",\n    \"negotiated\",\n    \"netscape\",\n    \"networkState\",\n    \"newScale\",\n    \"newTranslate\",\n    \"newURL\",\n    \"newValue\",\n    \"newValueSpecifiedUnits\",\n    \"newVersion\",\n    \"newhome\",\n    \"next\",\n    \"nextElementSibling\",\n    \"nextHopProtocol\",\n    \"nextNode\",\n    \"nextPage\",\n    \"nextSibling\",\n    \"nickname\",\n    \"noHref\",\n    \"noModule\",\n    \"noResize\",\n    \"noShade\",\n    \"noValidate\",\n    \"noWrap\",\n    \"node\",\n    \"nodeName\",\n    \"nodeType\",\n    \"nodeValue\",\n    \"nonce\",\n    \"normalize\",\n    \"normalizedPathSegList\",\n    \"notationName\",\n    \"notations\",\n    \"note\",\n    \"noteGrainOn\",\n    \"noteOff\",\n    \"noteOn\",\n    \"notify\",\n    \"now\",\n    \"numOctaves\",\n    \"number\",\n    \"numberOfChannels\",\n    \"numberOfInputs\",\n    \"numberOfItems\",\n    \"numberOfOutputs\",\n    \"numberValue\",\n    \"oMatchesSelector\",\n    \"object\",\n    \"object-fit\",\n    \"object-position\",\n    \"objectFit\",\n    \"objectPosition\",\n    \"objectStore\",\n    \"objectStoreNames\",\n    \"objectType\",\n    \"observe\",\n    \"of\",\n    \"offscreenBuffering\",\n    \"offset\",\n    \"offset-anchor\",\n    \"offset-distance\",\n    \"offset-path\",\n    \"offset-rotate\",\n    \"offsetAnchor\",\n    \"offsetDistance\",\n    \"offsetHeight\",\n    \"offsetLeft\",\n    \"offsetNode\",\n    \"offsetParent\",\n    \"offsetPath\",\n    \"offsetRotate\",\n    \"offsetTop\",\n    \"offsetWidth\",\n    \"offsetX\",\n    \"offsetY\",\n    \"ok\",\n    \"oldURL\",\n    \"oldValue\",\n    \"oldVersion\",\n    \"olderShadowRoot\",\n    \"onLine\",\n    \"onabort\",\n    \"onabsolutedeviceorientation\",\n    \"onactivate\",\n    \"onactive\",\n    \"onaddsourcebuffer\",\n    \"onaddstream\",\n    \"onaddtrack\",\n    \"onafterprint\",\n    \"onafterscriptexecute\",\n    \"onafterupdate\",\n    \"onanimationcancel\",\n    \"onanimationend\",\n    \"onanimationiteration\",\n    \"onanimationstart\",\n    \"onappinstalled\",\n    \"onaudioend\",\n    \"onaudioprocess\",\n    \"onaudiostart\",\n    \"onautocomplete\",\n    \"onautocompleteerror\",\n    \"onauxclick\",\n    \"onbeforeactivate\",\n    \"onbeforecopy\",\n    \"onbeforecut\",\n    \"onbeforedeactivate\",\n    \"onbeforeeditfocus\",\n    \"onbeforeinstallprompt\",\n    \"onbeforepaste\",\n    \"onbeforeprint\",\n    \"onbeforescriptexecute\",\n    \"onbeforeunload\",\n    \"onbeforeupdate\",\n    \"onbeforexrselect\",\n    \"onbegin\",\n    \"onblocked\",\n    \"onblur\",\n    \"onbounce\",\n    \"onboundary\",\n    \"onbufferedamountlow\",\n    \"oncached\",\n    \"oncancel\",\n    \"oncandidatewindowhide\",\n    \"oncandidatewindowshow\",\n    \"oncandidatewindowupdate\",\n    \"oncanplay\",\n    \"oncanplaythrough\",\n    \"once\",\n    \"oncellchange\",\n    \"onchange\",\n    \"oncharacteristicvaluechanged\",\n    \"onchargingchange\",\n    \"onchargingtimechange\",\n    \"onchecking\",\n    \"onclick\",\n    \"onclose\",\n    \"onclosing\",\n    \"oncompassneedscalibration\",\n    \"oncomplete\",\n    \"onconnect\",\n    \"onconnecting\",\n    \"onconnectionavailable\",\n    \"onconnectionstatechange\",\n    \"oncontextmenu\",\n    \"oncontrollerchange\",\n    \"oncontrolselect\",\n    \"oncopy\",\n    \"oncuechange\",\n    \"oncut\",\n    \"ondataavailable\",\n    \"ondatachannel\",\n    \"ondatasetchanged\",\n    \"ondatasetcomplete\",\n    \"ondblclick\",\n    \"ondeactivate\",\n    \"ondevicechange\",\n    \"ondevicelight\",\n    \"ondevicemotion\",\n    \"ondeviceorientation\",\n    \"ondeviceorientationabsolute\",\n    \"ondeviceproximity\",\n    \"ondischargingtimechange\",\n    \"ondisconnect\",\n    \"ondisplay\",\n    \"ondownloading\",\n    \"ondrag\",\n    \"ondragend\",\n    \"ondragenter\",\n    \"ondragexit\",\n    \"ondragleave\",\n    \"ondragover\",\n    \"ondragstart\",\n    \"ondrop\",\n    \"ondurationchange\",\n    \"onemptied\",\n    \"onencrypted\",\n    \"onend\",\n    \"onended\",\n    \"onenter\",\n    \"onenterpictureinpicture\",\n    \"onerror\",\n    \"onerrorupdate\",\n    \"onexit\",\n    \"onfilterchange\",\n    \"onfinish\",\n    \"onfocus\",\n    \"onfocusin\",\n    \"onfocusout\",\n    \"onformdata\",\n    \"onfreeze\",\n    \"onfullscreenchange\",\n    \"onfullscreenerror\",\n    \"ongatheringstatechange\",\n    \"ongattserverdisconnected\",\n    \"ongesturechange\",\n    \"ongestureend\",\n    \"ongesturestart\",\n    \"ongotpointercapture\",\n    \"onhashchange\",\n    \"onhelp\",\n    \"onicecandidate\",\n    \"onicecandidateerror\",\n    \"oniceconnectionstatechange\",\n    \"onicegatheringstatechange\",\n    \"oninactive\",\n    \"oninput\",\n    \"oninputsourceschange\",\n    \"oninvalid\",\n    \"onkeydown\",\n    \"onkeypress\",\n    \"onkeystatuseschange\",\n    \"onkeyup\",\n    \"onlanguagechange\",\n    \"onlayoutcomplete\",\n    \"onleavepictureinpicture\",\n    \"onlevelchange\",\n    \"onload\",\n    \"onloadeddata\",\n    \"onloadedmetadata\",\n    \"onloadend\",\n    \"onloading\",\n    \"onloadingdone\",\n    \"onloadingerror\",\n    \"onloadstart\",\n    \"onlosecapture\",\n    \"onlostpointercapture\",\n    \"only\",\n    \"onmark\",\n    \"onmessage\",\n    \"onmessageerror\",\n    \"onmidimessage\",\n    \"onmousedown\",\n    \"onmouseenter\",\n    \"onmouseleave\",\n    \"onmousemove\",\n    \"onmouseout\",\n    \"onmouseover\",\n    \"onmouseup\",\n    \"onmousewheel\",\n    \"onmove\",\n    \"onmoveend\",\n    \"onmovestart\",\n    \"onmozfullscreenchange\",\n    \"onmozfullscreenerror\",\n    \"onmozorientationchange\",\n    \"onmozpointerlockchange\",\n    \"onmozpointerlockerror\",\n    \"onmscontentzoom\",\n    \"onmsfullscreenchange\",\n    \"onmsfullscreenerror\",\n    \"onmsgesturechange\",\n    \"onmsgesturedoubletap\",\n    \"onmsgestureend\",\n    \"onmsgesturehold\",\n    \"onmsgesturestart\",\n    \"onmsgesturetap\",\n    \"onmsgotpointercapture\",\n    \"onmsinertiastart\",\n    \"onmslostpointercapture\",\n    \"onmsmanipulationstatechanged\",\n    \"onmsneedkey\",\n    \"onmsorientationchange\",\n    \"onmspointercancel\",\n    \"onmspointerdown\",\n    \"onmspointerenter\",\n    \"onmspointerhover\",\n    \"onmspointerleave\",\n    \"onmspointermove\",\n    \"onmspointerout\",\n    \"onmspointerover\",\n    \"onmspointerup\",\n    \"onmssitemodejumplistitemremoved\",\n    \"onmsthumbnailclick\",\n    \"onmute\",\n    \"onnegotiationneeded\",\n    \"onnomatch\",\n    \"onnoupdate\",\n    \"onobsolete\",\n    \"onoffline\",\n    \"ononline\",\n    \"onopen\",\n    \"onorientationchange\",\n    \"onpagechange\",\n    \"onpagehide\",\n    \"onpageshow\",\n    \"onpaste\",\n    \"onpause\",\n    \"onpayerdetailchange\",\n    \"onpaymentmethodchange\",\n    \"onplay\",\n    \"onplaying\",\n    \"onpluginstreamstart\",\n    \"onpointercancel\",\n    \"onpointerdown\",\n    \"onpointerenter\",\n    \"onpointerleave\",\n    \"onpointerlockchange\",\n    \"onpointerlockerror\",\n    \"onpointermove\",\n    \"onpointerout\",\n    \"onpointerover\",\n    \"onpointerrawupdate\",\n    \"onpointerup\",\n    \"onpopstate\",\n    \"onprocessorerror\",\n    \"onprogress\",\n    \"onpropertychange\",\n    \"onratechange\",\n    \"onreading\",\n    \"onreadystatechange\",\n    \"onrejectionhandled\",\n    \"onrelease\",\n    \"onremove\",\n    \"onremovesourcebuffer\",\n    \"onremovestream\",\n    \"onremovetrack\",\n    \"onrepeat\",\n    \"onreset\",\n    \"onresize\",\n    \"onresizeend\",\n    \"onresizestart\",\n    \"onresourcetimingbufferfull\",\n    \"onresult\",\n    \"onresume\",\n    \"onrowenter\",\n    \"onrowexit\",\n    \"onrowsdelete\",\n    \"onrowsinserted\",\n    \"onscroll\",\n    \"onsearch\",\n    \"onsecuritypolicyviolation\",\n    \"onseeked\",\n    \"onseeking\",\n    \"onselect\",\n    \"onselectedcandidatepairchange\",\n    \"onselectend\",\n    \"onselectionchange\",\n    \"onselectstart\",\n    \"onshippingaddresschange\",\n    \"onshippingoptionchange\",\n    \"onshow\",\n    \"onsignalingstatechange\",\n    \"onsoundend\",\n    \"onsoundstart\",\n    \"onsourceclose\",\n    \"onsourceclosed\",\n    \"onsourceended\",\n    \"onsourceopen\",\n    \"onspeechend\",\n    \"onspeechstart\",\n    \"onsqueeze\",\n    \"onsqueezeend\",\n    \"onsqueezestart\",\n    \"onstalled\",\n    \"onstart\",\n    \"onstatechange\",\n    \"onstop\",\n    \"onstorage\",\n    \"onstoragecommit\",\n    \"onsubmit\",\n    \"onsuccess\",\n    \"onsuspend\",\n    \"onterminate\",\n    \"ontextinput\",\n    \"ontimeout\",\n    \"ontimeupdate\",\n    \"ontoggle\",\n    \"ontonechange\",\n    \"ontouchcancel\",\n    \"ontouchend\",\n    \"ontouchmove\",\n    \"ontouchstart\",\n    \"ontrack\",\n    \"ontransitioncancel\",\n    \"ontransitionend\",\n    \"ontransitionrun\",\n    \"ontransitionstart\",\n    \"onunhandledrejection\",\n    \"onunload\",\n    \"onunmute\",\n    \"onupdate\",\n    \"onupdateend\",\n    \"onupdatefound\",\n    \"onupdateready\",\n    \"onupdatestart\",\n    \"onupgradeneeded\",\n    \"onuserproximity\",\n    \"onversionchange\",\n    \"onvisibilitychange\",\n    \"onvoiceschanged\",\n    \"onvolumechange\",\n    \"onvrdisplayactivate\",\n    \"onvrdisplayconnect\",\n    \"onvrdisplaydeactivate\",\n    \"onvrdisplaydisconnect\",\n    \"onvrdisplaypresentchange\",\n    \"onwaiting\",\n    \"onwaitingforkey\",\n    \"onwarning\",\n    \"onwebkitanimationend\",\n    \"onwebkitanimationiteration\",\n    \"onwebkitanimationstart\",\n    \"onwebkitcurrentplaybacktargetiswirelesschanged\",\n    \"onwebkitfullscreenchange\",\n    \"onwebkitfullscreenerror\",\n    \"onwebkitkeyadded\",\n    \"onwebkitkeyerror\",\n    \"onwebkitkeymessage\",\n    \"onwebkitneedkey\",\n    \"onwebkitorientationchange\",\n    \"onwebkitplaybacktargetavailabilitychanged\",\n    \"onwebkitpointerlockchange\",\n    \"onwebkitpointerlockerror\",\n    \"onwebkitresourcetimingbufferfull\",\n    \"onwebkittransitionend\",\n    \"onwheel\",\n    \"onzoom\",\n    \"opacity\",\n    \"open\",\n    \"openCursor\",\n    \"openDatabase\",\n    \"openKeyCursor\",\n    \"opened\",\n    \"opener\",\n    \"opera\",\n    \"operationType\",\n    \"operator\",\n    \"opr\",\n    \"optimum\",\n    \"options\",\n    \"or\",\n    \"order\",\n    \"orderX\",\n    \"orderY\",\n    \"ordered\",\n    \"org\",\n    \"organization\",\n    \"orient\",\n    \"orientAngle\",\n    \"orientType\",\n    \"orientation\",\n    \"orientationX\",\n    \"orientationY\",\n    \"orientationZ\",\n    \"origin\",\n    \"originalPolicy\",\n    \"originalTarget\",\n    \"orphans\",\n    \"oscpu\",\n    \"outerHTML\",\n    \"outerHeight\",\n    \"outerText\",\n    \"outerWidth\",\n    \"outline\",\n    \"outline-color\",\n    \"outline-offset\",\n    \"outline-style\",\n    \"outline-width\",\n    \"outlineColor\",\n    \"outlineOffset\",\n    \"outlineStyle\",\n    \"outlineWidth\",\n    \"outputBuffer\",\n    \"outputLatency\",\n    \"outputs\",\n    \"overflow\",\n    \"overflow-anchor\",\n    \"overflow-block\",\n    \"overflow-inline\",\n    \"overflow-wrap\",\n    \"overflow-x\",\n    \"overflow-y\",\n    \"overflowAnchor\",\n    \"overflowBlock\",\n    \"overflowInline\",\n    \"overflowWrap\",\n    \"overflowX\",\n    \"overflowY\",\n    \"overrideMimeType\",\n    \"oversample\",\n    \"overscroll-behavior\",\n    \"overscroll-behavior-block\",\n    \"overscroll-behavior-inline\",\n    \"overscroll-behavior-x\",\n    \"overscroll-behavior-y\",\n    \"overscrollBehavior\",\n    \"overscrollBehaviorBlock\",\n    \"overscrollBehaviorInline\",\n    \"overscrollBehaviorX\",\n    \"overscrollBehaviorY\",\n    \"ownKeys\",\n    \"ownerDocument\",\n    \"ownerElement\",\n    \"ownerNode\",\n    \"ownerRule\",\n    \"ownerSVGElement\",\n    \"owningElement\",\n    \"p1\",\n    \"p2\",\n    \"p3\",\n    \"p4\",\n    \"packetSize\",\n    \"packets\",\n    \"pad\",\n    \"padEnd\",\n    \"padStart\",\n    \"padding\",\n    \"padding-block\",\n    \"padding-block-end\",\n    \"padding-block-start\",\n    \"padding-bottom\",\n    \"padding-inline\",\n    \"padding-inline-end\",\n    \"padding-inline-start\",\n    \"padding-left\",\n    \"padding-right\",\n    \"padding-top\",\n    \"paddingBlock\",\n    \"paddingBlockEnd\",\n    \"paddingBlockStart\",\n    \"paddingBottom\",\n    \"paddingInline\",\n    \"paddingInlineEnd\",\n    \"paddingInlineStart\",\n    \"paddingLeft\",\n    \"paddingRight\",\n    \"paddingTop\",\n    \"page\",\n    \"page-break-after\",\n    \"page-break-before\",\n    \"page-break-inside\",\n    \"pageBreakAfter\",\n    \"pageBreakBefore\",\n    \"pageBreakInside\",\n    \"pageCount\",\n    \"pageLeft\",\n    \"pageTop\",\n    \"pageX\",\n    \"pageXOffset\",\n    \"pageY\",\n    \"pageYOffset\",\n    \"pages\",\n    \"paint-order\",\n    \"paintOrder\",\n    \"paintRequests\",\n    \"paintType\",\n    \"paintWorklet\",\n    \"palette\",\n    \"pan\",\n    \"panningModel\",\n    \"parameters\",\n    \"parent\",\n    \"parentElement\",\n    \"parentNode\",\n    \"parentRule\",\n    \"parentStyleSheet\",\n    \"parentTextEdit\",\n    \"parentWindow\",\n    \"parse\",\n    \"parseAll\",\n    \"parseFloat\",\n    \"parseFromString\",\n    \"parseInt\",\n    \"part\",\n    \"participants\",\n    \"passive\",\n    \"password\",\n    \"pasteHTML\",\n    \"path\",\n    \"pathLength\",\n    \"pathSegList\",\n    \"pathSegType\",\n    \"pathSegTypeAsLetter\",\n    \"pathname\",\n    \"pattern\",\n    \"patternContentUnits\",\n    \"patternMismatch\",\n    \"patternTransform\",\n    \"patternUnits\",\n    \"pause\",\n    \"pauseAnimations\",\n    \"pauseOnExit\",\n    \"pauseProfilers\",\n    \"pauseTransformFeedback\",\n    \"paused\",\n    \"payerEmail\",\n    \"payerName\",\n    \"payerPhone\",\n    \"paymentManager\",\n    \"pc\",\n    \"peerIdentity\",\n    \"pending\",\n    \"pendingLocalDescription\",\n    \"pendingRemoteDescription\",\n    \"percent\",\n    \"performance\",\n    \"periodicSync\",\n    \"permission\",\n    \"permissionState\",\n    \"permissions\",\n    \"persist\",\n    \"persisted\",\n    \"personalbar\",\n    \"perspective\",\n    \"perspective-origin\",\n    \"perspectiveOrigin\",\n    \"phone\",\n    \"phoneticFamilyName\",\n    \"phoneticGivenName\",\n    \"photo\",\n    \"pictureInPictureElement\",\n    \"pictureInPictureEnabled\",\n    \"pictureInPictureWindow\",\n    \"ping\",\n    \"pipeThrough\",\n    \"pipeTo\",\n    \"pitch\",\n    \"pixelBottom\",\n    \"pixelDepth\",\n    \"pixelHeight\",\n    \"pixelLeft\",\n    \"pixelRight\",\n    \"pixelStorei\",\n    \"pixelTop\",\n    \"pixelUnitToMillimeterX\",\n    \"pixelUnitToMillimeterY\",\n    \"pixelWidth\",\n    \"place-content\",\n    \"place-items\",\n    \"place-self\",\n    \"placeContent\",\n    \"placeItems\",\n    \"placeSelf\",\n    \"placeholder\",\n    \"platform\",\n    \"platforms\",\n    \"play\",\n    \"playEffect\",\n    \"playState\",\n    \"playbackRate\",\n    \"playbackState\",\n    \"playbackTime\",\n    \"played\",\n    \"playoutDelayHint\",\n    \"playsInline\",\n    \"plugins\",\n    \"pluginspage\",\n    \"pname\",\n    \"pointer-events\",\n    \"pointerBeforeReferenceNode\",\n    \"pointerEnabled\",\n    \"pointerEvents\",\n    \"pointerId\",\n    \"pointerLockElement\",\n    \"pointerType\",\n    \"points\",\n    \"pointsAtX\",\n    \"pointsAtY\",\n    \"pointsAtZ\",\n    \"polygonOffset\",\n    \"pop\",\n    \"populateMatrix\",\n    \"popupWindowFeatures\",\n    \"popupWindowName\",\n    \"popupWindowURI\",\n    \"port\",\n    \"port1\",\n    \"port2\",\n    \"ports\",\n    \"posBottom\",\n    \"posHeight\",\n    \"posLeft\",\n    \"posRight\",\n    \"posTop\",\n    \"posWidth\",\n    \"pose\",\n    \"position\",\n    \"positionAlign\",\n    \"positionX\",\n    \"positionY\",\n    \"positionZ\",\n    \"postError\",\n    \"postMessage\",\n    \"postalCode\",\n    \"poster\",\n    \"pow\",\n    \"powerEfficient\",\n    \"powerOff\",\n    \"preMultiplySelf\",\n    \"precision\",\n    \"preferredStyleSheetSet\",\n    \"preferredStylesheetSet\",\n    \"prefix\",\n    \"preload\",\n    \"prepend\",\n    \"presentation\",\n    \"preserveAlpha\",\n    \"preserveAspectRatio\",\n    \"preserveAspectRatioString\",\n    \"pressed\",\n    \"pressure\",\n    \"prevValue\",\n    \"preventDefault\",\n    \"preventExtensions\",\n    \"preventSilentAccess\",\n    \"previousElementSibling\",\n    \"previousNode\",\n    \"previousPage\",\n    \"previousRect\",\n    \"previousScale\",\n    \"previousSibling\",\n    \"previousTranslate\",\n    \"primaryKey\",\n    \"primitiveType\",\n    \"primitiveUnits\",\n    \"principals\",\n    \"print\",\n    \"priority\",\n    \"privateKey\",\n    \"probablySupportsContext\",\n    \"process\",\n    \"processIceMessage\",\n    \"processingEnd\",\n    \"processingStart\",\n    \"product\",\n    \"productId\",\n    \"productName\",\n    \"productSub\",\n    \"profile\",\n    \"profileEnd\",\n    \"profiles\",\n    \"projectionMatrix\",\n    \"promise\",\n    \"prompt\",\n    \"properties\",\n    \"propertyIsEnumerable\",\n    \"propertyName\",\n    \"protocol\",\n    \"protocolLong\",\n    \"prototype\",\n    \"provider\",\n    \"pseudoClass\",\n    \"pseudoElement\",\n    \"pt\",\n    \"publicId\",\n    \"publicKey\",\n    \"published\",\n    \"pulse\",\n    \"push\",\n    \"pushManager\",\n    \"pushNotification\",\n    \"pushState\",\n    \"put\",\n    \"putImageData\",\n    \"px\",\n    \"quadraticCurveTo\",\n    \"qualifier\",\n    \"quaternion\",\n    \"query\",\n    \"queryCommandEnabled\",\n    \"queryCommandIndeterm\",\n    \"queryCommandState\",\n    \"queryCommandSupported\",\n    \"queryCommandText\",\n    \"queryCommandValue\",\n    \"querySelector\",\n    \"querySelectorAll\",\n    \"queueMicrotask\",\n    \"quote\",\n    \"quotes\",\n    \"r\",\n    \"r1\",\n    \"r2\",\n    \"race\",\n    \"rad\",\n    \"radiogroup\",\n    \"radiusX\",\n    \"radiusY\",\n    \"random\",\n    \"range\",\n    \"rangeCount\",\n    \"rangeMax\",\n    \"rangeMin\",\n    \"rangeOffset\",\n    \"rangeOverflow\",\n    \"rangeParent\",\n    \"rangeUnderflow\",\n    \"rate\",\n    \"ratio\",\n    \"raw\",\n    \"rawId\",\n    \"read\",\n    \"readAsArrayBuffer\",\n    \"readAsBinaryString\",\n    \"readAsBlob\",\n    \"readAsDataURL\",\n    \"readAsText\",\n    \"readBuffer\",\n    \"readEntries\",\n    \"readOnly\",\n    \"readPixels\",\n    \"readReportRequested\",\n    \"readText\",\n    \"readValue\",\n    \"readable\",\n    \"ready\",\n    \"readyState\",\n    \"reason\",\n    \"reboot\",\n    \"receivedAlert\",\n    \"receiver\",\n    \"receivers\",\n    \"recipient\",\n    \"reconnect\",\n    \"recordNumber\",\n    \"recordsAvailable\",\n    \"recordset\",\n    \"rect\",\n    \"red\",\n    \"redEyeReduction\",\n    \"redirect\",\n    \"redirectCount\",\n    \"redirectEnd\",\n    \"redirectStart\",\n    \"redirected\",\n    \"reduce\",\n    \"reduceRight\",\n    \"reduction\",\n    \"refDistance\",\n    \"refX\",\n    \"refY\",\n    \"referenceNode\",\n    \"referenceSpace\",\n    \"referrer\",\n    \"referrerPolicy\",\n    \"refresh\",\n    \"region\",\n    \"regionAnchorX\",\n    \"regionAnchorY\",\n    \"regionId\",\n    \"regions\",\n    \"register\",\n    \"registerContentHandler\",\n    \"registerElement\",\n    \"registerProperty\",\n    \"registerProtocolHandler\",\n    \"reject\",\n    \"rel\",\n    \"relList\",\n    \"relatedAddress\",\n    \"relatedNode\",\n    \"relatedPort\",\n    \"relatedTarget\",\n    \"release\",\n    \"releaseCapture\",\n    \"releaseEvents\",\n    \"releaseInterface\",\n    \"releaseLock\",\n    \"releasePointerCapture\",\n    \"releaseShaderCompiler\",\n    \"reliable\",\n    \"reliableWrite\",\n    \"reload\",\n    \"rem\",\n    \"remainingSpace\",\n    \"remote\",\n    \"remoteDescription\",\n    \"remove\",\n    \"removeAllRanges\",\n    \"removeAttribute\",\n    \"removeAttributeNS\",\n    \"removeAttributeNode\",\n    \"removeBehavior\",\n    \"removeChild\",\n    \"removeCue\",\n    \"removeEventListener\",\n    \"removeFilter\",\n    \"removeImport\",\n    \"removeItem\",\n    \"removeListener\",\n    \"removeNamedItem\",\n    \"removeNamedItemNS\",\n    \"removeNode\",\n    \"removeParameter\",\n    \"removeProperty\",\n    \"removeRange\",\n    \"removeRegion\",\n    \"removeRule\",\n    \"removeSiteSpecificTrackingException\",\n    \"removeSourceBuffer\",\n    \"removeStream\",\n    \"removeTrack\",\n    \"removeVariable\",\n    \"removeWakeLockListener\",\n    \"removeWebWideTrackingException\",\n    \"removed\",\n    \"removedNodes\",\n    \"renderHeight\",\n    \"renderState\",\n    \"renderTime\",\n    \"renderWidth\",\n    \"renderbufferStorage\",\n    \"renderbufferStorageMultisample\",\n    \"renderedBuffer\",\n    \"renderingMode\",\n    \"renotify\",\n    \"repeat\",\n    \"replace\",\n    \"replaceAdjacentText\",\n    \"replaceAll\",\n    \"replaceChild\",\n    \"replaceChildren\",\n    \"replaceData\",\n    \"replaceId\",\n    \"replaceItem\",\n    \"replaceNode\",\n    \"replaceState\",\n    \"replaceSync\",\n    \"replaceTrack\",\n    \"replaceWholeText\",\n    \"replaceWith\",\n    \"reportValidity\",\n    \"request\",\n    \"requestAnimationFrame\",\n    \"requestAutocomplete\",\n    \"requestData\",\n    \"requestDevice\",\n    \"requestFrame\",\n    \"requestFullscreen\",\n    \"requestHitTestSource\",\n    \"requestHitTestSourceForTransientInput\",\n    \"requestId\",\n    \"requestIdleCallback\",\n    \"requestMIDIAccess\",\n    \"requestMediaKeySystemAccess\",\n    \"requestPermission\",\n    \"requestPictureInPicture\",\n    \"requestPointerLock\",\n    \"requestPresent\",\n    \"requestReferenceSpace\",\n    \"requestSession\",\n    \"requestStart\",\n    \"requestStorageAccess\",\n    \"requestSubmit\",\n    \"requestVideoFrameCallback\",\n    \"requestingWindow\",\n    \"requireInteraction\",\n    \"required\",\n    \"requiredExtensions\",\n    \"requiredFeatures\",\n    \"reset\",\n    \"resetPose\",\n    \"resetTransform\",\n    \"resize\",\n    \"resizeBy\",\n    \"resizeTo\",\n    \"resolve\",\n    \"response\",\n    \"responseBody\",\n    \"responseEnd\",\n    \"responseReady\",\n    \"responseStart\",\n    \"responseText\",\n    \"responseType\",\n    \"responseURL\",\n    \"responseXML\",\n    \"restartIce\",\n    \"restore\",\n    \"result\",\n    \"resultIndex\",\n    \"resultType\",\n    \"results\",\n    \"resume\",\n    \"resumeProfilers\",\n    \"resumeTransformFeedback\",\n    \"retry\",\n    \"returnValue\",\n    \"rev\",\n    \"reverse\",\n    \"reversed\",\n    \"revocable\",\n    \"revokeObjectURL\",\n    \"rgbColor\",\n    \"right\",\n    \"rightContext\",\n    \"rightDegrees\",\n    \"rightMargin\",\n    \"rightProjectionMatrix\",\n    \"rightViewMatrix\",\n    \"role\",\n    \"rolloffFactor\",\n    \"root\",\n    \"rootBounds\",\n    \"rootElement\",\n    \"rootMargin\",\n    \"rotate\",\n    \"rotateAxisAngle\",\n    \"rotateAxisAngleSelf\",\n    \"rotateFromVector\",\n    \"rotateFromVectorSelf\",\n    \"rotateSelf\",\n    \"rotation\",\n    \"rotationAngle\",\n    \"rotationRate\",\n    \"round\",\n    \"row-gap\",\n    \"rowGap\",\n    \"rowIndex\",\n    \"rowSpan\",\n    \"rows\",\n    \"rtcpTransport\",\n    \"rtt\",\n    \"ruby-align\",\n    \"ruby-position\",\n    \"rubyAlign\",\n    \"rubyOverhang\",\n    \"rubyPosition\",\n    \"rules\",\n    \"runtime\",\n    \"runtimeStyle\",\n    \"rx\",\n    \"ry\",\n    \"s\",\n    \"safari\",\n    \"sample\",\n    \"sampleCoverage\",\n    \"sampleRate\",\n    \"samplerParameterf\",\n    \"samplerParameteri\",\n    \"sandbox\",\n    \"save\",\n    \"saveData\",\n    \"scale\",\n    \"scale3d\",\n    \"scale3dSelf\",\n    \"scaleNonUniform\",\n    \"scaleNonUniformSelf\",\n    \"scaleSelf\",\n    \"scheme\",\n    \"scissor\",\n    \"scope\",\n    \"scopeName\",\n    \"scoped\",\n    \"screen\",\n    \"screenBrightness\",\n    \"screenEnabled\",\n    \"screenLeft\",\n    \"screenPixelToMillimeterX\",\n    \"screenPixelToMillimeterY\",\n    \"screenTop\",\n    \"screenX\",\n    \"screenY\",\n    \"scriptURL\",\n    \"scripts\",\n    \"scroll\",\n    \"scroll-behavior\",\n    \"scroll-margin\",\n    \"scroll-margin-block\",\n    \"scroll-margin-block-end\",\n    \"scroll-margin-block-start\",\n    \"scroll-margin-bottom\",\n    \"scroll-margin-inline\",\n    \"scroll-margin-inline-end\",\n    \"scroll-margin-inline-start\",\n    \"scroll-margin-left\",\n    \"scroll-margin-right\",\n    \"scroll-margin-top\",\n    \"scroll-padding\",\n    \"scroll-padding-block\",\n    \"scroll-padding-block-end\",\n    \"scroll-padding-block-start\",\n    \"scroll-padding-bottom\",\n    \"scroll-padding-inline\",\n    \"scroll-padding-inline-end\",\n    \"scroll-padding-inline-start\",\n    \"scroll-padding-left\",\n    \"scroll-padding-right\",\n    \"scroll-padding-top\",\n    \"scroll-snap-align\",\n    \"scroll-snap-type\",\n    \"scrollAmount\",\n    \"scrollBehavior\",\n    \"scrollBy\",\n    \"scrollByLines\",\n    \"scrollByPages\",\n    \"scrollDelay\",\n    \"scrollHeight\",\n    \"scrollIntoView\",\n    \"scrollIntoViewIfNeeded\",\n    \"scrollLeft\",\n    \"scrollLeftMax\",\n    \"scrollMargin\",\n    \"scrollMarginBlock\",\n    \"scrollMarginBlockEnd\",\n    \"scrollMarginBlockStart\",\n    \"scrollMarginBottom\",\n    \"scrollMarginInline\",\n    \"scrollMarginInlineEnd\",\n    \"scrollMarginInlineStart\",\n    \"scrollMarginLeft\",\n    \"scrollMarginRight\",\n    \"scrollMarginTop\",\n    \"scrollMaxX\",\n    \"scrollMaxY\",\n    \"scrollPadding\",\n    \"scrollPaddingBlock\",\n    \"scrollPaddingBlockEnd\",\n    \"scrollPaddingBlockStart\",\n    \"scrollPaddingBottom\",\n    \"scrollPaddingInline\",\n    \"scrollPaddingInlineEnd\",\n    \"scrollPaddingInlineStart\",\n    \"scrollPaddingLeft\",\n    \"scrollPaddingRight\",\n    \"scrollPaddingTop\",\n    \"scrollRestoration\",\n    \"scrollSnapAlign\",\n    \"scrollSnapType\",\n    \"scrollTo\",\n    \"scrollTop\",\n    \"scrollTopMax\",\n    \"scrollWidth\",\n    \"scrollX\",\n    \"scrollY\",\n    \"scrollbar-color\",\n    \"scrollbar-width\",\n    \"scrollbar3dLightColor\",\n    \"scrollbarArrowColor\",\n    \"scrollbarBaseColor\",\n    \"scrollbarColor\",\n    \"scrollbarDarkShadowColor\",\n    \"scrollbarFaceColor\",\n    \"scrollbarHighlightColor\",\n    \"scrollbarShadowColor\",\n    \"scrollbarTrackColor\",\n    \"scrollbarWidth\",\n    \"scrollbars\",\n    \"scrolling\",\n    \"scrollingElement\",\n    \"sctp\",\n    \"sctpCauseCode\",\n    \"sdp\",\n    \"sdpLineNumber\",\n    \"sdpMLineIndex\",\n    \"sdpMid\",\n    \"seal\",\n    \"search\",\n    \"searchBox\",\n    \"searchBoxJavaBridge_\",\n    \"searchParams\",\n    \"sectionRowIndex\",\n    \"secureConnectionStart\",\n    \"security\",\n    \"seed\",\n    \"seekToNextFrame\",\n    \"seekable\",\n    \"seeking\",\n    \"select\",\n    \"selectAllChildren\",\n    \"selectAlternateInterface\",\n    \"selectConfiguration\",\n    \"selectNode\",\n    \"selectNodeContents\",\n    \"selectNodes\",\n    \"selectSingleNode\",\n    \"selectSubString\",\n    \"selected\",\n    \"selectedIndex\",\n    \"selectedOptions\",\n    \"selectedStyleSheetSet\",\n    \"selectedStylesheetSet\",\n    \"selection\",\n    \"selectionDirection\",\n    \"selectionEnd\",\n    \"selectionStart\",\n    \"selector\",\n    \"selectorText\",\n    \"self\",\n    \"send\",\n    \"sendAsBinary\",\n    \"sendBeacon\",\n    \"sender\",\n    \"sentAlert\",\n    \"sentTimestamp\",\n    \"separator\",\n    \"serialNumber\",\n    \"serializeToString\",\n    \"serverTiming\",\n    \"service\",\n    \"serviceWorker\",\n    \"session\",\n    \"sessionId\",\n    \"sessionStorage\",\n    \"set\",\n    \"setActionHandler\",\n    \"setActive\",\n    \"setAlpha\",\n    \"setAppBadge\",\n    \"setAttribute\",\n    \"setAttributeNS\",\n    \"setAttributeNode\",\n    \"setAttributeNodeNS\",\n    \"setBaseAndExtent\",\n    \"setBigInt64\",\n    \"setBigUint64\",\n    \"setBingCurrentSearchDefault\",\n    \"setCapture\",\n    \"setCodecPreferences\",\n    \"setColor\",\n    \"setCompositeOperation\",\n    \"setConfiguration\",\n    \"setCurrentTime\",\n    \"setCustomValidity\",\n    \"setData\",\n    \"setDate\",\n    \"setDragImage\",\n    \"setEnd\",\n    \"setEndAfter\",\n    \"setEndBefore\",\n    \"setEndPoint\",\n    \"setFillColor\",\n    \"setFilterRes\",\n    \"setFloat32\",\n    \"setFloat64\",\n    \"setFloatValue\",\n    \"setFormValue\",\n    \"setFullYear\",\n    \"setHeaderValue\",\n    \"setHours\",\n    \"setIdentityProvider\",\n    \"setImmediate\",\n    \"setInt16\",\n    \"setInt32\",\n    \"setInt8\",\n    \"setInterval\",\n    \"setItem\",\n    \"setKeyframes\",\n    \"setLineCap\",\n    \"setLineDash\",\n    \"setLineJoin\",\n    \"setLineWidth\",\n    \"setLiveSeekableRange\",\n    \"setLocalDescription\",\n    \"setMatrix\",\n    \"setMatrixValue\",\n    \"setMediaKeys\",\n    \"setMilliseconds\",\n    \"setMinutes\",\n    \"setMiterLimit\",\n    \"setMonth\",\n    \"setNamedItem\",\n    \"setNamedItemNS\",\n    \"setNonUserCodeExceptions\",\n    \"setOrientToAngle\",\n    \"setOrientToAuto\",\n    \"setOrientation\",\n    \"setOverrideHistoryNavigationMode\",\n    \"setPaint\",\n    \"setParameter\",\n    \"setParameters\",\n    \"setPeriodicWave\",\n    \"setPointerCapture\",\n    \"setPosition\",\n    \"setPositionState\",\n    \"setPreference\",\n    \"setProperty\",\n    \"setPrototypeOf\",\n    \"setRGBColor\",\n    \"setRGBColorICCColor\",\n    \"setRadius\",\n    \"setRangeText\",\n    \"setRemoteDescription\",\n    \"setRequestHeader\",\n    \"setResizable\",\n    \"setResourceTimingBufferSize\",\n    \"setRotate\",\n    \"setScale\",\n    \"setSeconds\",\n    \"setSelectionRange\",\n    \"setServerCertificate\",\n    \"setShadow\",\n    \"setSinkId\",\n    \"setSkewX\",\n    \"setSkewY\",\n    \"setStart\",\n    \"setStartAfter\",\n    \"setStartBefore\",\n    \"setStdDeviation\",\n    \"setStreams\",\n    \"setStringValue\",\n    \"setStrokeColor\",\n    \"setSuggestResult\",\n    \"setTargetAtTime\",\n    \"setTargetValueAtTime\",\n    \"setTime\",\n    \"setTimeout\",\n    \"setTransform\",\n    \"setTranslate\",\n    \"setUTCDate\",\n    \"setUTCFullYear\",\n    \"setUTCHours\",\n    \"setUTCMilliseconds\",\n    \"setUTCMinutes\",\n    \"setUTCMonth\",\n    \"setUTCSeconds\",\n    \"setUint16\",\n    \"setUint32\",\n    \"setUint8\",\n    \"setUri\",\n    \"setValidity\",\n    \"setValueAtTime\",\n    \"setValueCurveAtTime\",\n    \"setVariable\",\n    \"setVelocity\",\n    \"setVersion\",\n    \"setYear\",\n    \"settingName\",\n    \"settingValue\",\n    \"sex\",\n    \"shaderSource\",\n    \"shadowBlur\",\n    \"shadowColor\",\n    \"shadowOffsetX\",\n    \"shadowOffsetY\",\n    \"shadowRoot\",\n    \"shape\",\n    \"shape-image-threshold\",\n    \"shape-margin\",\n    \"shape-outside\",\n    \"shape-rendering\",\n    \"shapeImageThreshold\",\n    \"shapeMargin\",\n    \"shapeOutside\",\n    \"shapeRendering\",\n    \"sheet\",\n    \"shift\",\n    \"shiftKey\",\n    \"shiftLeft\",\n    \"shippingAddress\",\n    \"shippingOption\",\n    \"shippingType\",\n    \"show\",\n    \"showHelp\",\n    \"showModal\",\n    \"showModalDialog\",\n    \"showModelessDialog\",\n    \"showNotification\",\n    \"sidebar\",\n    \"sign\",\n    \"signal\",\n    \"signalingState\",\n    \"signature\",\n    \"silent\",\n    \"sin\",\n    \"singleNodeValue\",\n    \"sinh\",\n    \"sinkId\",\n    \"sittingToStandingTransform\",\n    \"size\",\n    \"sizeToContent\",\n    \"sizeX\",\n    \"sizeZ\",\n    \"sizes\",\n    \"skewX\",\n    \"skewXSelf\",\n    \"skewY\",\n    \"skewYSelf\",\n    \"slice\",\n    \"slope\",\n    \"slot\",\n    \"small\",\n    \"smil\",\n    \"smooth\",\n    \"smoothingTimeConstant\",\n    \"snapToLines\",\n    \"snapshotItem\",\n    \"snapshotLength\",\n    \"some\",\n    \"sort\",\n    \"sortingCode\",\n    \"source\",\n    \"sourceBuffer\",\n    \"sourceBuffers\",\n    \"sourceCapabilities\",\n    \"sourceFile\",\n    \"sourceIndex\",\n    \"sources\",\n    \"spacing\",\n    \"span\",\n    \"speak\",\n    \"speakAs\",\n    \"speaking\",\n    \"species\",\n    \"specified\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"speechSynthesis\",\n    \"speed\",\n    \"speedOfSound\",\n    \"spellcheck\",\n    \"splice\",\n    \"split\",\n    \"splitText\",\n    \"spreadMethod\",\n    \"sqrt\",\n    \"src\",\n    \"srcElement\",\n    \"srcFilter\",\n    \"srcObject\",\n    \"srcUrn\",\n    \"srcdoc\",\n    \"srclang\",\n    \"srcset\",\n    \"stack\",\n    \"stackTraceLimit\",\n    \"stacktrace\",\n    \"stageParameters\",\n    \"standalone\",\n    \"standby\",\n    \"start\",\n    \"startContainer\",\n    \"startIce\",\n    \"startMessages\",\n    \"startNotifications\",\n    \"startOffset\",\n    \"startProfiling\",\n    \"startRendering\",\n    \"startShark\",\n    \"startTime\",\n    \"startsWith\",\n    \"state\",\n    \"status\",\n    \"statusCode\",\n    \"statusMessage\",\n    \"statusText\",\n    \"statusbar\",\n    \"stdDeviationX\",\n    \"stdDeviationY\",\n    \"stencilFunc\",\n    \"stencilFuncSeparate\",\n    \"stencilMask\",\n    \"stencilMaskSeparate\",\n    \"stencilOp\",\n    \"stencilOpSeparate\",\n    \"step\",\n    \"stepDown\",\n    \"stepMismatch\",\n    \"stepUp\",\n    \"sticky\",\n    \"stitchTiles\",\n    \"stop\",\n    \"stop-color\",\n    \"stop-opacity\",\n    \"stopColor\",\n    \"stopImmediatePropagation\",\n    \"stopNotifications\",\n    \"stopOpacity\",\n    \"stopProfiling\",\n    \"stopPropagation\",\n    \"stopShark\",\n    \"stopped\",\n    \"storage\",\n    \"storageArea\",\n    \"storageName\",\n    \"storageStatus\",\n    \"store\",\n    \"storeSiteSpecificTrackingException\",\n    \"storeWebWideTrackingException\",\n    \"stpVersion\",\n    \"stream\",\n    \"streams\",\n    \"stretch\",\n    \"strike\",\n    \"string\",\n    \"stringValue\",\n    \"stringify\",\n    \"stroke\",\n    \"stroke-dasharray\",\n    \"stroke-dashoffset\",\n    \"stroke-linecap\",\n    \"stroke-linejoin\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke-width\",\n    \"strokeDasharray\",\n    \"strokeDashoffset\",\n    \"strokeLinecap\",\n    \"strokeLinejoin\",\n    \"strokeMiterlimit\",\n    \"strokeOpacity\",\n    \"strokeRect\",\n    \"strokeStyle\",\n    \"strokeText\",\n    \"strokeWidth\",\n    \"style\",\n    \"styleFloat\",\n    \"styleMap\",\n    \"styleMedia\",\n    \"styleSheet\",\n    \"styleSheetSets\",\n    \"styleSheets\",\n    \"sub\",\n    \"subarray\",\n    \"subject\",\n    \"submit\",\n    \"submitFrame\",\n    \"submitter\",\n    \"subscribe\",\n    \"substr\",\n    \"substring\",\n    \"substringData\",\n    \"subtle\",\n    \"subtree\",\n    \"suffix\",\n    \"suffixes\",\n    \"summary\",\n    \"sup\",\n    \"supported\",\n    \"supportedContentEncodings\",\n    \"supportedEntryTypes\",\n    \"supports\",\n    \"supportsSession\",\n    \"surfaceScale\",\n    \"surroundContents\",\n    \"suspend\",\n    \"suspendRedraw\",\n    \"swapCache\",\n    \"swapNode\",\n    \"sweepFlag\",\n    \"symbols\",\n    \"sync\",\n    \"sysexEnabled\",\n    \"system\",\n    \"systemCode\",\n    \"systemId\",\n    \"systemLanguage\",\n    \"systemXDPI\",\n    \"systemYDPI\",\n    \"tBodies\",\n    \"tFoot\",\n    \"tHead\",\n    \"tabIndex\",\n    \"table\",\n    \"table-layout\",\n    \"tableLayout\",\n    \"tableValues\",\n    \"tag\",\n    \"tagName\",\n    \"tagUrn\",\n    \"tags\",\n    \"taintEnabled\",\n    \"takePhoto\",\n    \"takeRecords\",\n    \"tan\",\n    \"tangentialPressure\",\n    \"tanh\",\n    \"target\",\n    \"targetElement\",\n    \"targetRayMode\",\n    \"targetRaySpace\",\n    \"targetTouches\",\n    \"targetX\",\n    \"targetY\",\n    \"tcpType\",\n    \"tee\",\n    \"tel\",\n    \"terminate\",\n    \"test\",\n    \"texImage2D\",\n    \"texImage3D\",\n    \"texParameterf\",\n    \"texParameteri\",\n    \"texStorage2D\",\n    \"texStorage3D\",\n    \"texSubImage2D\",\n    \"texSubImage3D\",\n    \"text\",\n    \"text-align\",\n    \"text-align-last\",\n    \"text-anchor\",\n    \"text-combine-upright\",\n    \"text-decoration\",\n    \"text-decoration-color\",\n    \"text-decoration-line\",\n    \"text-decoration-skip-ink\",\n    \"text-decoration-style\",\n    \"text-decoration-thickness\",\n    \"text-emphasis\",\n    \"text-emphasis-color\",\n    \"text-emphasis-position\",\n    \"text-emphasis-style\",\n    \"text-indent\",\n    \"text-justify\",\n    \"text-orientation\",\n    \"text-overflow\",\n    \"text-rendering\",\n    \"text-shadow\",\n    \"text-transform\",\n    \"text-underline-offset\",\n    \"text-underline-position\",\n    \"textAlign\",\n    \"textAlignLast\",\n    \"textAnchor\",\n    \"textAutospace\",\n    \"textBaseline\",\n    \"textCombineUpright\",\n    \"textContent\",\n    \"textDecoration\",\n    \"textDecorationBlink\",\n    \"textDecorationColor\",\n    \"textDecorationLine\",\n    \"textDecorationLineThrough\",\n    \"textDecorationNone\",\n    \"textDecorationOverline\",\n    \"textDecorationSkipInk\",\n    \"textDecorationStyle\",\n    \"textDecorationThickness\",\n    \"textDecorationUnderline\",\n    \"textEmphasis\",\n    \"textEmphasisColor\",\n    \"textEmphasisPosition\",\n    \"textEmphasisStyle\",\n    \"textIndent\",\n    \"textJustify\",\n    \"textJustifyTrim\",\n    \"textKashida\",\n    \"textKashidaSpace\",\n    \"textLength\",\n    \"textOrientation\",\n    \"textOverflow\",\n    \"textRendering\",\n    \"textShadow\",\n    \"textTracks\",\n    \"textTransform\",\n    \"textUnderlineOffset\",\n    \"textUnderlinePosition\",\n    \"then\",\n    \"threadId\",\n    \"threshold\",\n    \"thresholds\",\n    \"tiltX\",\n    \"tiltY\",\n    \"time\",\n    \"timeEnd\",\n    \"timeLog\",\n    \"timeOrigin\",\n    \"timeRemaining\",\n    \"timeStamp\",\n    \"timecode\",\n    \"timeline\",\n    \"timelineTime\",\n    \"timeout\",\n    \"timestamp\",\n    \"timestampOffset\",\n    \"timing\",\n    \"title\",\n    \"to\",\n    \"toArray\",\n    \"toBlob\",\n    \"toDataURL\",\n    \"toDateString\",\n    \"toElement\",\n    \"toExponential\",\n    \"toFixed\",\n    \"toFloat32Array\",\n    \"toFloat64Array\",\n    \"toGMTString\",\n    \"toISOString\",\n    \"toJSON\",\n    \"toLocaleDateString\",\n    \"toLocaleFormat\",\n    \"toLocaleLowerCase\",\n    \"toLocaleString\",\n    \"toLocaleTimeString\",\n    \"toLocaleUpperCase\",\n    \"toLowerCase\",\n    \"toMatrix\",\n    \"toMethod\",\n    \"toPrecision\",\n    \"toPrimitive\",\n    \"toSdp\",\n    \"toSource\",\n    \"toStaticHTML\",\n    \"toString\",\n    \"toStringTag\",\n    \"toSum\",\n    \"toTimeString\",\n    \"toUTCString\",\n    \"toUpperCase\",\n    \"toggle\",\n    \"toggleAttribute\",\n    \"toggleLongPressEnabled\",\n    \"tone\",\n    \"toneBuffer\",\n    \"tooLong\",\n    \"tooShort\",\n    \"toolbar\",\n    \"top\",\n    \"topMargin\",\n    \"total\",\n    \"totalFrameDelay\",\n    \"totalVideoFrames\",\n    \"touch-action\",\n    \"touchAction\",\n    \"touched\",\n    \"touches\",\n    \"trace\",\n    \"track\",\n    \"trackVisibility\",\n    \"transaction\",\n    \"transactions\",\n    \"transceiver\",\n    \"transferControlToOffscreen\",\n    \"transferFromImageBitmap\",\n    \"transferImageBitmap\",\n    \"transferIn\",\n    \"transferOut\",\n    \"transferSize\",\n    \"transferToImageBitmap\",\n    \"transform\",\n    \"transform-box\",\n    \"transform-origin\",\n    \"transform-style\",\n    \"transformBox\",\n    \"transformFeedbackVaryings\",\n    \"transformOrigin\",\n    \"transformPoint\",\n    \"transformString\",\n    \"transformStyle\",\n    \"transformToDocument\",\n    \"transformToFragment\",\n    \"transition\",\n    \"transition-delay\",\n    \"transition-duration\",\n    \"transition-property\",\n    \"transition-timing-function\",\n    \"transitionDelay\",\n    \"transitionDuration\",\n    \"transitionProperty\",\n    \"transitionTimingFunction\",\n    \"translate\",\n    \"translateSelf\",\n    \"translationX\",\n    \"translationY\",\n    \"transport\",\n    \"trim\",\n    \"trimEnd\",\n    \"trimLeft\",\n    \"trimRight\",\n    \"trimStart\",\n    \"trueSpeed\",\n    \"trunc\",\n    \"truncate\",\n    \"trustedTypes\",\n    \"turn\",\n    \"twist\",\n    \"type\",\n    \"typeDetail\",\n    \"typeMismatch\",\n    \"typeMustMatch\",\n    \"types\",\n    \"u2f\",\n    \"ubound\",\n    \"uint16\",\n    \"uint32\",\n    \"uint8\",\n    \"uint8Clamped\",\n    \"undefined\",\n    \"unescape\",\n    \"uneval\",\n    \"unicode\",\n    \"unicode-bidi\",\n    \"unicodeBidi\",\n    \"unicodeRange\",\n    \"uniform1f\",\n    \"uniform1fv\",\n    \"uniform1i\",\n    \"uniform1iv\",\n    \"uniform1ui\",\n    \"uniform1uiv\",\n    \"uniform2f\",\n    \"uniform2fv\",\n    \"uniform2i\",\n    \"uniform2iv\",\n    \"uniform2ui\",\n    \"uniform2uiv\",\n    \"uniform3f\",\n    \"uniform3fv\",\n    \"uniform3i\",\n    \"uniform3iv\",\n    \"uniform3ui\",\n    \"uniform3uiv\",\n    \"uniform4f\",\n    \"uniform4fv\",\n    \"uniform4i\",\n    \"uniform4iv\",\n    \"uniform4ui\",\n    \"uniform4uiv\",\n    \"uniformBlockBinding\",\n    \"uniformMatrix2fv\",\n    \"uniformMatrix2x3fv\",\n    \"uniformMatrix2x4fv\",\n    \"uniformMatrix3fv\",\n    \"uniformMatrix3x2fv\",\n    \"uniformMatrix3x4fv\",\n    \"uniformMatrix4fv\",\n    \"uniformMatrix4x2fv\",\n    \"uniformMatrix4x3fv\",\n    \"unique\",\n    \"uniqueID\",\n    \"uniqueNumber\",\n    \"unit\",\n    \"unitType\",\n    \"units\",\n    \"unloadEventEnd\",\n    \"unloadEventStart\",\n    \"unlock\",\n    \"unmount\",\n    \"unobserve\",\n    \"unpause\",\n    \"unpauseAnimations\",\n    \"unreadCount\",\n    \"unregister\",\n    \"unregisterContentHandler\",\n    \"unregisterProtocolHandler\",\n    \"unscopables\",\n    \"unselectable\",\n    \"unshift\",\n    \"unsubscribe\",\n    \"unsuspendRedraw\",\n    \"unsuspendRedrawAll\",\n    \"unwatch\",\n    \"unwrapKey\",\n    \"upDegrees\",\n    \"upX\",\n    \"upY\",\n    \"upZ\",\n    \"update\",\n    \"updateCommands\",\n    \"updateIce\",\n    \"updateInterval\",\n    \"updatePlaybackRate\",\n    \"updateRenderState\",\n    \"updateSettings\",\n    \"updateTiming\",\n    \"updateViaCache\",\n    \"updateWith\",\n    \"updated\",\n    \"updating\",\n    \"upgrade\",\n    \"upload\",\n    \"uploadTotal\",\n    \"uploaded\",\n    \"upper\",\n    \"upperBound\",\n    \"upperOpen\",\n    \"uri\",\n    \"url\",\n    \"urn\",\n    \"urns\",\n    \"usages\",\n    \"usb\",\n    \"usbVersionMajor\",\n    \"usbVersionMinor\",\n    \"usbVersionSubminor\",\n    \"useCurrentView\",\n    \"useMap\",\n    \"useProgram\",\n    \"usedSpace\",\n    \"user-select\",\n    \"userActivation\",\n    \"userAgent\",\n    \"userChoice\",\n    \"userHandle\",\n    \"userHint\",\n    \"userLanguage\",\n    \"userSelect\",\n    \"userVisibleOnly\",\n    \"username\",\n    \"usernameFragment\",\n    \"utterance\",\n    \"uuid\",\n    \"v8BreakIterator\",\n    \"vAlign\",\n    \"vLink\",\n    \"valid\",\n    \"validate\",\n    \"validateProgram\",\n    \"validationMessage\",\n    \"validity\",\n    \"value\",\n    \"valueAsDate\",\n    \"valueAsNumber\",\n    \"valueAsString\",\n    \"valueInSpecifiedUnits\",\n    \"valueMissing\",\n    \"valueOf\",\n    \"valueText\",\n    \"valueType\",\n    \"values\",\n    \"variable\",\n    \"variant\",\n    \"variationSettings\",\n    \"vector-effect\",\n    \"vectorEffect\",\n    \"velocityAngular\",\n    \"velocityExpansion\",\n    \"velocityX\",\n    \"velocityY\",\n    \"vendor\",\n    \"vendorId\",\n    \"vendorSub\",\n    \"verify\",\n    \"version\",\n    \"vertexAttrib1f\",\n    \"vertexAttrib1fv\",\n    \"vertexAttrib2f\",\n    \"vertexAttrib2fv\",\n    \"vertexAttrib3f\",\n    \"vertexAttrib3fv\",\n    \"vertexAttrib4f\",\n    \"vertexAttrib4fv\",\n    \"vertexAttribDivisor\",\n    \"vertexAttribDivisorANGLE\",\n    \"vertexAttribI4i\",\n    \"vertexAttribI4iv\",\n    \"vertexAttribI4ui\",\n    \"vertexAttribI4uiv\",\n    \"vertexAttribIPointer\",\n    \"vertexAttribPointer\",\n    \"vertical\",\n    \"vertical-align\",\n    \"verticalAlign\",\n    \"verticalOverflow\",\n    \"vh\",\n    \"vibrate\",\n    \"vibrationActuator\",\n    \"videoBitsPerSecond\",\n    \"videoHeight\",\n    \"videoTracks\",\n    \"videoWidth\",\n    \"view\",\n    \"viewBox\",\n    \"viewBoxString\",\n    \"viewTarget\",\n    \"viewTargetString\",\n    \"viewport\",\n    \"viewportAnchorX\",\n    \"viewportAnchorY\",\n    \"viewportElement\",\n    \"views\",\n    \"violatedDirective\",\n    \"visibility\",\n    \"visibilityState\",\n    \"visible\",\n    \"visualViewport\",\n    \"vlinkColor\",\n    \"vmax\",\n    \"vmin\",\n    \"voice\",\n    \"voiceURI\",\n    \"volume\",\n    \"vrml\",\n    \"vspace\",\n    \"vw\",\n    \"w\",\n    \"wait\",\n    \"waitSync\",\n    \"waiting\",\n    \"wake\",\n    \"wakeLock\",\n    \"wand\",\n    \"warn\",\n    \"wasClean\",\n    \"wasDiscarded\",\n    \"watch\",\n    \"watchAvailability\",\n    \"watchPosition\",\n    \"webdriver\",\n    \"webkitAddKey\",\n    \"webkitAlignContent\",\n    \"webkitAlignItems\",\n    \"webkitAlignSelf\",\n    \"webkitAnimation\",\n    \"webkitAnimationDelay\",\n    \"webkitAnimationDirection\",\n    \"webkitAnimationDuration\",\n    \"webkitAnimationFillMode\",\n    \"webkitAnimationIterationCount\",\n    \"webkitAnimationName\",\n    \"webkitAnimationPlayState\",\n    \"webkitAnimationTimingFunction\",\n    \"webkitAppearance\",\n    \"webkitAudioContext\",\n    \"webkitAudioDecodedByteCount\",\n    \"webkitAudioPannerNode\",\n    \"webkitBackfaceVisibility\",\n    \"webkitBackground\",\n    \"webkitBackgroundAttachment\",\n    \"webkitBackgroundClip\",\n    \"webkitBackgroundColor\",\n    \"webkitBackgroundImage\",\n    \"webkitBackgroundOrigin\",\n    \"webkitBackgroundPosition\",\n    \"webkitBackgroundPositionX\",\n    \"webkitBackgroundPositionY\",\n    \"webkitBackgroundRepeat\",\n    \"webkitBackgroundSize\",\n    \"webkitBackingStorePixelRatio\",\n    \"webkitBorderBottomLeftRadius\",\n    \"webkitBorderBottomRightRadius\",\n    \"webkitBorderImage\",\n    \"webkitBorderImageOutset\",\n    \"webkitBorderImageRepeat\",\n    \"webkitBorderImageSlice\",\n    \"webkitBorderImageSource\",\n    \"webkitBorderImageWidth\",\n    \"webkitBorderRadius\",\n    \"webkitBorderTopLeftRadius\",\n    \"webkitBorderTopRightRadius\",\n    \"webkitBoxAlign\",\n    \"webkitBoxDirection\",\n    \"webkitBoxFlex\",\n    \"webkitBoxOrdinalGroup\",\n    \"webkitBoxOrient\",\n    \"webkitBoxPack\",\n    \"webkitBoxShadow\",\n    \"webkitBoxSizing\",\n    \"webkitCancelAnimationFrame\",\n    \"webkitCancelFullScreen\",\n    \"webkitCancelKeyRequest\",\n    \"webkitCancelRequestAnimationFrame\",\n    \"webkitClearResourceTimings\",\n    \"webkitClosedCaptionsVisible\",\n    \"webkitConvertPointFromNodeToPage\",\n    \"webkitConvertPointFromPageToNode\",\n    \"webkitCreateShadowRoot\",\n    \"webkitCurrentFullScreenElement\",\n    \"webkitCurrentPlaybackTargetIsWireless\",\n    \"webkitDecodedFrameCount\",\n    \"webkitDirectionInvertedFromDevice\",\n    \"webkitDisplayingFullscreen\",\n    \"webkitDroppedFrameCount\",\n    \"webkitEnterFullScreen\",\n    \"webkitEnterFullscreen\",\n    \"webkitEntries\",\n    \"webkitExitFullScreen\",\n    \"webkitExitFullscreen\",\n    \"webkitExitPointerLock\",\n    \"webkitFilter\",\n    \"webkitFlex\",\n    \"webkitFlexBasis\",\n    \"webkitFlexDirection\",\n    \"webkitFlexFlow\",\n    \"webkitFlexGrow\",\n    \"webkitFlexShrink\",\n    \"webkitFlexWrap\",\n    \"webkitFullScreenKeyboardInputAllowed\",\n    \"webkitFullscreenElement\",\n    \"webkitFullscreenEnabled\",\n    \"webkitGenerateKeyRequest\",\n    \"webkitGetAsEntry\",\n    \"webkitGetDatabaseNames\",\n    \"webkitGetEntries\",\n    \"webkitGetEntriesByName\",\n    \"webkitGetEntriesByType\",\n    \"webkitGetFlowByName\",\n    \"webkitGetGamepads\",\n    \"webkitGetImageDataHD\",\n    \"webkitGetNamedFlows\",\n    \"webkitGetRegionFlowRanges\",\n    \"webkitGetUserMedia\",\n    \"webkitHasClosedCaptions\",\n    \"webkitHidden\",\n    \"webkitIDBCursor\",\n    \"webkitIDBDatabase\",\n    \"webkitIDBDatabaseError\",\n    \"webkitIDBDatabaseException\",\n    \"webkitIDBFactory\",\n    \"webkitIDBIndex\",\n    \"webkitIDBKeyRange\",\n    \"webkitIDBObjectStore\",\n    \"webkitIDBRequest\",\n    \"webkitIDBTransaction\",\n    \"webkitImageSmoothingEnabled\",\n    \"webkitIndexedDB\",\n    \"webkitInitMessageEvent\",\n    \"webkitIsFullScreen\",\n    \"webkitJustifyContent\",\n    \"webkitKeys\",\n    \"webkitLineClamp\",\n    \"webkitLineDashOffset\",\n    \"webkitLockOrientation\",\n    \"webkitMask\",\n    \"webkitMaskClip\",\n    \"webkitMaskComposite\",\n    \"webkitMaskImage\",\n    \"webkitMaskOrigin\",\n    \"webkitMaskPosition\",\n    \"webkitMaskPositionX\",\n    \"webkitMaskPositionY\",\n    \"webkitMaskRepeat\",\n    \"webkitMaskSize\",\n    \"webkitMatchesSelector\",\n    \"webkitMediaStream\",\n    \"webkitNotifications\",\n    \"webkitOfflineAudioContext\",\n    \"webkitOrder\",\n    \"webkitOrientation\",\n    \"webkitPeerConnection00\",\n    \"webkitPersistentStorage\",\n    \"webkitPerspective\",\n    \"webkitPerspectiveOrigin\",\n    \"webkitPointerLockElement\",\n    \"webkitPostMessage\",\n    \"webkitPreservesPitch\",\n    \"webkitPutImageDataHD\",\n    \"webkitRTCPeerConnection\",\n    \"webkitRegionOverset\",\n    \"webkitRelativePath\",\n    \"webkitRequestAnimationFrame\",\n    \"webkitRequestFileSystem\",\n    \"webkitRequestFullScreen\",\n    \"webkitRequestFullscreen\",\n    \"webkitRequestPointerLock\",\n    \"webkitResolveLocalFileSystemURL\",\n    \"webkitSetMediaKeys\",\n    \"webkitSetResourceTimingBufferSize\",\n    \"webkitShadowRoot\",\n    \"webkitShowPlaybackTargetPicker\",\n    \"webkitSlice\",\n    \"webkitSpeechGrammar\",\n    \"webkitSpeechGrammarList\",\n    \"webkitSpeechRecognition\",\n    \"webkitSpeechRecognitionError\",\n    \"webkitSpeechRecognitionEvent\",\n    \"webkitStorageInfo\",\n    \"webkitSupportsFullscreen\",\n    \"webkitTemporaryStorage\",\n    \"webkitTextFillColor\",\n    \"webkitTextSizeAdjust\",\n    \"webkitTextStroke\",\n    \"webkitTextStrokeColor\",\n    \"webkitTextStrokeWidth\",\n    \"webkitTransform\",\n    \"webkitTransformOrigin\",\n    \"webkitTransformStyle\",\n    \"webkitTransition\",\n    \"webkitTransitionDelay\",\n    \"webkitTransitionDuration\",\n    \"webkitTransitionProperty\",\n    \"webkitTransitionTimingFunction\",\n    \"webkitURL\",\n    \"webkitUnlockOrientation\",\n    \"webkitUserSelect\",\n    \"webkitVideoDecodedByteCount\",\n    \"webkitVisibilityState\",\n    \"webkitWirelessVideoPlaybackDisabled\",\n    \"webkitdirectory\",\n    \"webkitdropzone\",\n    \"webstore\",\n    \"weight\",\n    \"whatToShow\",\n    \"wheelDelta\",\n    \"wheelDeltaX\",\n    \"wheelDeltaY\",\n    \"whenDefined\",\n    \"which\",\n    \"white-space\",\n    \"whiteSpace\",\n    \"wholeText\",\n    \"widows\",\n    \"width\",\n    \"will-change\",\n    \"willChange\",\n    \"willValidate\",\n    \"window\",\n    \"withCredentials\",\n    \"word-break\",\n    \"word-spacing\",\n    \"word-wrap\",\n    \"wordBreak\",\n    \"wordSpacing\",\n    \"wordWrap\",\n    \"workerStart\",\n    \"wrap\",\n    \"wrapKey\",\n    \"writable\",\n    \"writableAuxiliaries\",\n    \"write\",\n    \"writeText\",\n    \"writeValue\",\n    \"writeWithoutResponse\",\n    \"writeln\",\n    \"writing-mode\",\n    \"writingMode\",\n    \"x\",\n    \"x1\",\n    \"x2\",\n    \"xChannelSelector\",\n    \"xmlEncoding\",\n    \"xmlStandalone\",\n    \"xmlVersion\",\n    \"xmlbase\",\n    \"xmllang\",\n    \"xmlspace\",\n    \"xor\",\n    \"xr\",\n    \"y\",\n    \"y1\",\n    \"y2\",\n    \"yChannelSelector\",\n    \"yandex\",\n    \"z\",\n    \"z-index\",\n    \"zIndex\",\n    \"zoom\",\n    \"zoomAndPan\",\n    \"zoomRectScreen\",\n];\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nfunction find_builtins(reserved) {\n    domprops.forEach(add);\n\n    // Compatibility fix for some standard defined globals not defined on every js environment\n    var new_globals = [\"Symbol\", \"Map\", \"Promise\", \"Proxy\", \"Reflect\", \"Set\", \"WeakMap\", \"WeakSet\"];\n    var objects = {};\n    var global_ref = typeof __webpack_require__.g === \"object\" ? __webpack_require__.g : self;\n\n    new_globals.forEach(function (new_global) {\n        objects[new_global] = global_ref[new_global] || new Function();\n    });\n\n    [\n        \"null\",\n        \"true\",\n        \"false\",\n        \"NaN\",\n        \"Infinity\",\n        \"-Infinity\",\n        \"undefined\",\n    ].forEach(add);\n    [ Object, Array, Function, Number,\n      String, Boolean, Error, Math,\n      Date, RegExp, objects.Symbol, ArrayBuffer,\n      DataView, decodeURI, decodeURIComponent,\n      encodeURI, encodeURIComponent, eval, EvalError,\n      Float32Array, Float64Array, Int8Array, Int16Array,\n      Int32Array, isFinite, isNaN, JSON, objects.Map, parseFloat,\n      parseInt, objects.Promise, objects.Proxy, RangeError, ReferenceError,\n      objects.Reflect, objects.Set, SyntaxError, TypeError, Uint8Array,\n      Uint8ClampedArray, Uint16Array, Uint32Array, URIError,\n      objects.WeakMap, objects.WeakSet\n    ].forEach(function(ctor) {\n        Object.getOwnPropertyNames(ctor).map(add);\n        if (ctor.prototype) {\n            Object.getOwnPropertyNames(ctor.prototype).map(add);\n        }\n    });\n    function add(name) {\n        reserved.add(name);\n    }\n}\n\nfunction reserve_quoted_keys(ast, reserved) {\n    function add(name) {\n        push_uniq(reserved, name);\n    }\n\n    ast.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_ObjectKeyVal && node.quote) {\n            add(node.key);\n        } else if (node instanceof AST_ObjectProperty && node.quote) {\n            add(node.key.name);\n        } else if (node instanceof AST_Sub) {\n            addStrings(node.property, add);\n        }\n    }));\n}\n\nfunction addStrings(node, add) {\n    node.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_Sequence) {\n            addStrings(node.tail_node(), add);\n        } else if (node instanceof AST_String) {\n            add(node.value);\n        } else if (node instanceof AST_Conditional) {\n            addStrings(node.consequent, add);\n            addStrings(node.alternative, add);\n        }\n        return true;\n    }));\n}\n\nfunction mangle_properties(ast, options) {\n    options = defaults(options, {\n        builtins: false,\n        cache: null,\n        debug: false,\n        keep_quoted: false,\n        only_cache: false,\n        regex: null,\n        reserved: null,\n        undeclared: false,\n    }, true);\n\n    var reserved_option = options.reserved;\n    if (!Array.isArray(reserved_option)) reserved_option = [reserved_option];\n    var reserved = new Set(reserved_option);\n    if (!options.builtins) find_builtins(reserved);\n\n    var cname = -1;\n    var cprivate = -1;\n\n    var cache;\n    var private_cache = new Map();\n    if (options.cache) {\n        cache = options.cache.props;\n        cache.forEach(function(mangled_name) {\n            reserved.add(mangled_name);\n        });\n    } else {\n        cache = new Map();\n    }\n\n    var regex = options.regex && new RegExp(options.regex);\n\n    // note debug is either false (disabled), or a string of the debug suffix to use (enabled).\n    // note debug may be enabled as an empty string, which is falsey. Also treat passing 'true'\n    // the same as passing an empty string.\n    var debug = options.debug !== false;\n    var debug_name_suffix;\n    if (debug) {\n        debug_name_suffix = (options.debug === true ? \"\" : options.debug);\n    }\n\n    var names_to_mangle = new Set();\n    var unmangleable = new Set();\n    var private_properties = new Set();\n\n    var keep_quoted_strict = options.keep_quoted === \"strict\";\n\n    // step 1: find candidates to mangle\n    ast.walk(new TreeWalker(function(node) {\n        if (\n            node instanceof AST_ClassPrivateProperty\n            || node instanceof AST_PrivateMethod\n        ) {\n            private_properties.add(node.key.name);\n        } else if (node instanceof AST_DotHash) {\n            private_properties.add(node.property);\n        } else if (node instanceof AST_ObjectKeyVal) {\n            if (typeof node.key == \"string\" &&\n                (!keep_quoted_strict || !node.quote)) {\n                add(node.key);\n            }\n        } else if (node instanceof AST_ObjectProperty) {\n            // setter or getter, since KeyVal is handled above\n            if (!keep_quoted_strict || !node.key.end.quote) {\n                add(node.key.name);\n            }\n        } else if (node instanceof AST_Dot) {\n            var declared = !!options.undeclared;\n            if (!declared) {\n                var root = node;\n                while (root.expression) {\n                    root = root.expression;\n                }\n                declared = !(root.thedef && root.thedef.undeclared);\n            }\n            if (declared &&\n                (!keep_quoted_strict || !node.quote)) {\n                add(node.property);\n            }\n        } else if (node instanceof AST_Sub) {\n            if (!keep_quoted_strict) {\n                addStrings(node.property, add);\n            }\n        } else if (node instanceof AST_Call\n            && node.expression.print_to_string() == \"Object.defineProperty\") {\n            addStrings(node.args[1], add);\n        } else if (node instanceof AST_Binary && node.operator === \"in\") {\n            addStrings(node.left, add);\n        }\n    }));\n\n    // step 2: transform the tree, renaming properties\n    return ast.transform(new TreeTransformer(function(node) {\n        if (\n            node instanceof AST_ClassPrivateProperty\n            || node instanceof AST_PrivateMethod\n        ) {\n            node.key.name = mangle_private(node.key.name);\n        } else if (node instanceof AST_DotHash) {\n            node.property = mangle_private(node.property);\n        } else if (node instanceof AST_ObjectKeyVal) {\n            if (typeof node.key == \"string\" &&\n                (!keep_quoted_strict || !node.quote)) {\n                node.key = mangle(node.key);\n            }\n        } else if (node instanceof AST_ObjectProperty) {\n            // setter, getter, method or class field\n            if (!keep_quoted_strict || !node.key.end.quote) {\n                node.key.name = mangle(node.key.name);\n            }\n        } else if (node instanceof AST_Dot) {\n            if (!keep_quoted_strict || !node.quote) {\n                node.property = mangle(node.property);\n            }\n        } else if (!options.keep_quoted && node instanceof AST_Sub) {\n            node.property = mangleStrings(node.property);\n        } else if (node instanceof AST_Call\n            && node.expression.print_to_string() == \"Object.defineProperty\") {\n            node.args[1] = mangleStrings(node.args[1]);\n        } else if (node instanceof AST_Binary && node.operator === \"in\") {\n            node.left = mangleStrings(node.left);\n        }\n    }));\n\n    // only function declarations after this line\n\n    function can_mangle(name) {\n        if (unmangleable.has(name)) return false;\n        if (reserved.has(name)) return false;\n        if (options.only_cache) {\n            return cache.has(name);\n        }\n        if (/^-?[0-9]+(\\.[0-9]+)?(e[+-][0-9]+)?$/.test(name)) return false;\n        return true;\n    }\n\n    function should_mangle(name) {\n        if (regex && !regex.test(name)) return false;\n        if (reserved.has(name)) return false;\n        return cache.has(name)\n            || names_to_mangle.has(name);\n    }\n\n    function add(name) {\n        if (can_mangle(name))\n            names_to_mangle.add(name);\n\n        if (!should_mangle(name)) {\n            unmangleable.add(name);\n        }\n    }\n\n    function mangle(name) {\n        if (!should_mangle(name)) {\n            return name;\n        }\n\n        var mangled = cache.get(name);\n        if (!mangled) {\n            if (debug) {\n                // debug mode: use a prefix and suffix to preserve readability, e.g. o.foo -> o._$foo$NNN_.\n                var debug_mangled = \"_$\" + name + \"$\" + debug_name_suffix + \"_\";\n\n                if (can_mangle(debug_mangled)) {\n                    mangled = debug_mangled;\n                }\n            }\n\n            // either debug mode is off, or it is on and we could not use the mangled name\n            if (!mangled) {\n                do {\n                    mangled = base54(++cname);\n                } while (!can_mangle(mangled));\n            }\n\n            cache.set(name, mangled);\n        }\n        return mangled;\n    }\n\n    function mangle_private(name) {\n        let mangled = private_cache.get(name);\n        if (!mangled) {\n            mangled = base54(++cprivate);\n            private_cache.set(name, mangled);\n        }\n\n        return mangled;\n    }\n\n    function mangleStrings(node) {\n        return node.transform(new TreeTransformer(function(node) {\n            if (node instanceof AST_Sequence) {\n                var last = node.expressions.length - 1;\n                node.expressions[last] = mangleStrings(node.expressions[last]);\n            } else if (node instanceof AST_String) {\n                node.value = mangle(node.value);\n            } else if (node instanceof AST_Conditional) {\n                node.consequent = mangleStrings(node.consequent);\n                node.alternative = mangleStrings(node.alternative);\n            }\n            return node;\n        }));\n    }\n}\n\nvar to_ascii = typeof atob == \"undefined\" ? function(b64) {\n    return Buffer.from(b64, \"base64\").toString();\n} : atob;\nvar to_base64 = typeof btoa == \"undefined\" ? function(str) {\n    return Buffer.from(str).toString(\"base64\");\n} : btoa;\n\nfunction read_source_map(code) {\n    var match = /(?:^|[^.])\\/\\/# sourceMappingURL=data:application\\/json(;[\\w=-]*)?;base64,([+/0-9A-Za-z]*=*)\\s*$/.exec(code);\n    if (!match) {\n        console.warn(\"inline source map not found\");\n        return null;\n    }\n    return to_ascii(match[2]);\n}\n\nfunction set_shorthand(name, options, keys) {\n    if (options[name]) {\n        keys.forEach(function(key) {\n            if (options[key]) {\n                if (typeof options[key] != \"object\") options[key] = {};\n                if (!(name in options[key])) options[key][name] = options[name];\n            }\n        });\n    }\n}\n\nfunction init_cache(cache) {\n    if (!cache) return;\n    if (!(\"props\" in cache)) {\n        cache.props = new Map();\n    } else if (!(cache.props instanceof Map)) {\n        cache.props = map_from_object(cache.props);\n    }\n}\n\nfunction cache_to_json(cache) {\n    return {\n        props: map_to_object(cache.props)\n    };\n}\n\nasync function minify(files, options) {\n    options = defaults(options, {\n        compress: {},\n        ecma: undefined,\n        enclose: false,\n        ie8: false,\n        keep_classnames: undefined,\n        keep_fnames: false,\n        mangle: {},\n        module: false,\n        nameCache: null,\n        output: null,\n        format: null,\n        parse: {},\n        rename: undefined,\n        safari10: false,\n        sourceMap: false,\n        spidermonkey: false,\n        timings: false,\n        toplevel: false,\n        warnings: false,\n        wrap: false,\n    }, true);\n    var timings = options.timings && {\n        start: Date.now()\n    };\n    if (options.keep_classnames === undefined) {\n        options.keep_classnames = options.keep_fnames;\n    }\n    if (options.rename === undefined) {\n        options.rename = options.compress && options.mangle;\n    }\n    if (options.output && options.format) {\n        throw new Error(\"Please only specify either output or format option, preferrably format.\");\n    }\n    options.format = options.format || options.output || {};\n    set_shorthand(\"ecma\", options, [ \"parse\", \"compress\", \"format\" ]);\n    set_shorthand(\"ie8\", options, [ \"compress\", \"mangle\", \"format\" ]);\n    set_shorthand(\"keep_classnames\", options, [ \"compress\", \"mangle\" ]);\n    set_shorthand(\"keep_fnames\", options, [ \"compress\", \"mangle\" ]);\n    set_shorthand(\"module\", options, [ \"parse\", \"compress\", \"mangle\" ]);\n    set_shorthand(\"safari10\", options, [ \"mangle\", \"format\" ]);\n    set_shorthand(\"toplevel\", options, [ \"compress\", \"mangle\" ]);\n    set_shorthand(\"warnings\", options, [ \"compress\" ]); // legacy\n    var quoted_props;\n    if (options.mangle) {\n        options.mangle = defaults(options.mangle, {\n            cache: options.nameCache && (options.nameCache.vars || {}),\n            eval: false,\n            ie8: false,\n            keep_classnames: false,\n            keep_fnames: false,\n            module: false,\n            properties: false,\n            reserved: [],\n            safari10: false,\n            toplevel: false,\n        }, true);\n        if (options.mangle.properties) {\n            if (typeof options.mangle.properties != \"object\") {\n                options.mangle.properties = {};\n            }\n            if (options.mangle.properties.keep_quoted) {\n                quoted_props = options.mangle.properties.reserved;\n                if (!Array.isArray(quoted_props)) quoted_props = [];\n                options.mangle.properties.reserved = quoted_props;\n            }\n            if (options.nameCache && !(\"cache\" in options.mangle.properties)) {\n                options.mangle.properties.cache = options.nameCache.props || {};\n            }\n        }\n        init_cache(options.mangle.cache);\n        init_cache(options.mangle.properties.cache);\n    }\n    if (options.sourceMap) {\n        options.sourceMap = defaults(options.sourceMap, {\n            asObject: false,\n            content: null,\n            filename: null,\n            includeSources: false,\n            root: null,\n            url: null,\n        }, true);\n    }\n    if (timings) timings.parse = Date.now();\n    var toplevel;\n    if (files instanceof AST_Toplevel) {\n        toplevel = files;\n    } else {\n        if (typeof files == \"string\" || (options.parse.spidermonkey && !Array.isArray(files))) {\n            files = [ files ];\n        }\n        options.parse = options.parse || {};\n        options.parse.toplevel = null;\n\n        if (options.parse.spidermonkey) {\n            options.parse.toplevel = AST_Node.from_mozilla_ast(Object.keys(files).reduce(function(toplevel, name) {\n                if (!toplevel) return files[name];\n                toplevel.body = toplevel.body.concat(files[name].body);\n                return toplevel;\n            }, null));\n        } else {\n            delete options.parse.spidermonkey;\n\n            for (var name in files) if (HOP(files, name)) {\n                options.parse.filename = name;\n                options.parse.toplevel = parse(files[name], options.parse);\n                if (options.sourceMap && options.sourceMap.content == \"inline\") {\n                    if (Object.keys(files).length > 1)\n                        throw new Error(\"inline source map only works with singular input\");\n                    options.sourceMap.content = read_source_map(files[name]);\n                }\n            }\n        }\n\n        toplevel = options.parse.toplevel;\n    }\n    if (quoted_props && options.mangle.properties.keep_quoted !== \"strict\") {\n        reserve_quoted_keys(toplevel, quoted_props);\n    }\n    if (options.wrap) {\n        toplevel = toplevel.wrap_commonjs(options.wrap);\n    }\n    if (options.enclose) {\n        toplevel = toplevel.wrap_enclose(options.enclose);\n    }\n    if (timings) timings.rename = Date.now();\n    if (timings) timings.compress = Date.now();\n    if (options.compress) {\n        toplevel = new Compressor(options.compress, {\n            mangle_options: options.mangle\n        }).compress(toplevel);\n    }\n    if (timings) timings.scope = Date.now();\n    if (options.mangle) toplevel.figure_out_scope(options.mangle);\n    if (timings) timings.mangle = Date.now();\n    if (options.mangle) {\n        base54.reset();\n        toplevel.compute_char_frequency(options.mangle);\n        toplevel.mangle_names(options.mangle);\n    }\n    if (timings) timings.properties = Date.now();\n    if (options.mangle && options.mangle.properties) {\n        toplevel = mangle_properties(toplevel, options.mangle.properties);\n    }\n    if (timings) timings.format = Date.now();\n    var result = {};\n    if (options.format.ast) {\n        result.ast = toplevel;\n    }\n    if (options.format.spidermonkey) {\n        result.ast = toplevel.to_mozilla_ast();\n    }\n    if (!HOP(options.format, \"code\") || options.format.code) {\n        if (options.sourceMap) {\n            options.format.source_map = await SourceMap({\n                file: options.sourceMap.filename,\n                orig: options.sourceMap.content,\n                root: options.sourceMap.root\n            });\n            if (options.sourceMap.includeSources) {\n                if (files instanceof AST_Toplevel) {\n                    throw new Error(\"original source content unavailable\");\n                } else for (var name in files) if (HOP(files, name)) {\n                    options.format.source_map.get().setSourceContent(name, files[name]);\n                }\n            }\n        }\n        delete options.format.ast;\n        delete options.format.code;\n        delete options.format.spidermonkey;\n        var stream = OutputStream(options.format);\n        toplevel.print(stream);\n        result.code = stream.get();\n        if (options.sourceMap) {\n            if(options.sourceMap.asObject) {\n                result.map = options.format.source_map.get().toJSON();\n            } else {\n                result.map = options.format.source_map.toString();\n            }\n            if (options.sourceMap.url == \"inline\") {\n                var sourceMap = typeof result.map === \"object\" ? JSON.stringify(result.map) : result.map;\n                result.code += \"\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,\" + to_base64(sourceMap);\n            } else if (options.sourceMap.url) {\n                result.code += \"\\n//# sourceMappingURL=\" + options.sourceMap.url;\n            }\n        }\n    }\n    if (options.nameCache && options.mangle) {\n        if (options.mangle.cache) options.nameCache.vars = cache_to_json(options.mangle.cache);\n        if (options.mangle.properties && options.mangle.properties.cache) {\n            options.nameCache.props = cache_to_json(options.mangle.properties.cache);\n        }\n    }\n    if (options.format && options.format.source_map) {\n        options.format.source_map.destroy();\n    }\n    if (timings) {\n        timings.end = Date.now();\n        result.timings = {\n            parse: 1e-3 * (timings.rename - timings.parse),\n            rename: 1e-3 * (timings.compress - timings.rename),\n            compress: 1e-3 * (timings.scope - timings.compress),\n            scope: 1e-3 * (timings.mangle - timings.scope),\n            mangle: 1e-3 * (timings.properties - timings.mangle),\n            properties: 1e-3 * (timings.format - timings.properties),\n            format: 1e-3 * (timings.end - timings.format),\n            total: 1e-3 * (timings.end - timings.start)\n        };\n    }\n    return result;\n}\n\nasync function run_cli({ program, packageJson, fs, path }) {\n    const skip_keys = new Set([ \"cname\", \"parent_scope\", \"scope\", \"uses_eval\", \"uses_with\" ]);\n    var files = {};\n    var options = {\n        compress: false,\n        mangle: false\n    };\n    const default_options = await _default_options();\n    program.version(packageJson.name + \" \" + packageJson.version);\n    program.parseArgv = program.parse;\n    program.parse = undefined;\n\n    if (process.argv.includes(\"ast\")) program.helpInformation = describe_ast;\n    else if (process.argv.includes(\"options\")) program.helpInformation = function() {\n        var text = [];\n        for (var option in default_options) {\n            text.push(\"--\" + (option === \"sourceMap\" ? \"source-map\" : option) + \" options:\");\n            text.push(format_object(default_options[option]));\n            text.push(\"\");\n        }\n        return text.join(\"\\n\");\n    };\n\n    program.option(\"-p, --parse <options>\", \"Specify parser options.\", parse_js());\n    program.option(\"-c, --compress [options]\", \"Enable compressor/specify compressor options.\", parse_js());\n    program.option(\"-m, --mangle [options]\", \"Mangle names/specify mangler options.\", parse_js());\n    program.option(\"--mangle-props [options]\", \"Mangle properties/specify mangler options.\", parse_js());\n    program.option(\"-f, --format [options]\", \"Format options.\", parse_js());\n    program.option(\"-b, --beautify [options]\", \"Alias for --format.\", parse_js());\n    program.option(\"-o, --output <file>\", \"Output file (default STDOUT).\");\n    program.option(\"--comments [filter]\", \"Preserve copyright comments in the output.\");\n    program.option(\"--config-file <file>\", \"Read minify() options from JSON file.\");\n    program.option(\"-d, --define <expr>[=value]\", \"Global definitions.\", parse_js(\"define\"));\n    program.option(\"--ecma <version>\", \"Specify ECMAScript release: 5, 2015, 2016 or 2017...\");\n    program.option(\"-e, --enclose [arg[,...][:value[,...]]]\", \"Embed output in a big function with configurable arguments and values.\");\n    program.option(\"--ie8\", \"Support non-standard Internet Explorer 8.\");\n    program.option(\"--keep-classnames\", \"Do not mangle/drop class names.\");\n    program.option(\"--keep-fnames\", \"Do not mangle/drop function names. Useful for code relying on Function.prototype.name.\");\n    program.option(\"--module\", \"Input is an ES6 module\");\n    program.option(\"--name-cache <file>\", \"File to hold mangled name mappings.\");\n    program.option(\"--rename\", \"Force symbol expansion.\");\n    program.option(\"--no-rename\", \"Disable symbol expansion.\");\n    program.option(\"--safari10\", \"Support non-standard Safari 10.\");\n    program.option(\"--source-map [options]\", \"Enable source map/specify source map options.\", parse_js());\n    program.option(\"--timings\", \"Display operations run time on STDERR.\");\n    program.option(\"--toplevel\", \"Compress and/or mangle variables in toplevel scope.\");\n    program.option(\"--wrap <name>\", \"Embed everything as a function with “exports” corresponding to “name” globally.\");\n    program.arguments(\"[files...]\").parseArgv(process.argv);\n    if (program.configFile) {\n        options = JSON.parse(read_file(program.configFile));\n    }\n    if (!program.output && program.sourceMap && program.sourceMap.url != \"inline\") {\n        fatal(\"ERROR: cannot write source map to STDOUT\");\n    }\n\n    [\n        \"compress\",\n        \"enclose\",\n        \"ie8\",\n        \"mangle\",\n        \"module\",\n        \"safari10\",\n        \"sourceMap\",\n        \"toplevel\",\n        \"wrap\"\n    ].forEach(function(name) {\n        if (name in program) {\n            options[name] = program[name];\n        }\n    });\n\n    if (\"ecma\" in program) {\n        if (program.ecma != (program.ecma | 0)) fatal(\"ERROR: ecma must be an integer\");\n        const ecma = program.ecma | 0;\n        if (ecma > 5 && ecma < 2015)\n            options.ecma = ecma + 2009;\n        else\n            options.ecma = ecma;\n    }\n    if (program.format || program.beautify) {\n        const chosenOption = program.format || program.beautify;\n        options.format = typeof chosenOption === \"object\" ? chosenOption : {};\n    }\n    if (program.comments) {\n        if (typeof options.format != \"object\") options.format = {};\n        options.format.comments = typeof program.comments == \"string\" ? (program.comments == \"false\" ? false : program.comments) : \"some\";\n    }\n    if (program.define) {\n        if (typeof options.compress != \"object\") options.compress = {};\n        if (typeof options.compress.global_defs != \"object\") options.compress.global_defs = {};\n        for (var expr in program.define) {\n            options.compress.global_defs[expr] = program.define[expr];\n        }\n    }\n    if (program.keepClassnames) {\n        options.keep_classnames = true;\n    }\n    if (program.keepFnames) {\n        options.keep_fnames = true;\n    }\n    if (program.mangleProps) {\n        if (program.mangleProps.domprops) {\n            delete program.mangleProps.domprops;\n        } else {\n            if (typeof program.mangleProps != \"object\") program.mangleProps = {};\n            if (!Array.isArray(program.mangleProps.reserved)) program.mangleProps.reserved = [];\n        }\n        if (typeof options.mangle != \"object\") options.mangle = {};\n        options.mangle.properties = program.mangleProps;\n    }\n    if (program.nameCache) {\n        options.nameCache = JSON.parse(read_file(program.nameCache, \"{}\"));\n    }\n    if (program.output == \"ast\") {\n        options.format = {\n            ast: true,\n            code: false\n        };\n    }\n    if (program.parse) {\n        if (!program.parse.acorn && !program.parse.spidermonkey) {\n            options.parse = program.parse;\n        } else if (program.sourceMap && program.sourceMap.content == \"inline\") {\n            fatal(\"ERROR: inline source map only works with built-in parser\");\n        }\n    }\n    if (~program.rawArgs.indexOf(\"--rename\")) {\n        options.rename = true;\n    } else if (!program.rename) {\n        options.rename = false;\n    }\n\n    let convert_path = name => name;\n    if (typeof program.sourceMap == \"object\" && \"base\" in program.sourceMap) {\n        convert_path = function() {\n            var base = program.sourceMap.base;\n            delete options.sourceMap.base;\n            return function(name) {\n                return path.relative(base, name);\n            };\n        }();\n    }\n\n    let filesList;\n    if (options.files && options.files.length) {\n        filesList = options.files;\n\n        delete options.files;\n    } else if (program.args.length) {\n        filesList = program.args;\n    }\n\n    if (filesList) {\n        simple_glob(filesList).forEach(function(name) {\n            files[convert_path(name)] = read_file(name);\n        });\n    } else {\n        await new Promise((resolve) => {\n            var chunks = [];\n            process.stdin.setEncoding(\"utf8\");\n            process.stdin.on(\"data\", function(chunk) {\n                chunks.push(chunk);\n            }).on(\"end\", function() {\n                files = [ chunks.join(\"\") ];\n                resolve();\n            });\n            process.stdin.resume();\n        });\n    }\n\n    await run_cli();\n\n    function convert_ast(fn) {\n        return AST_Node.from_mozilla_ast(Object.keys(files).reduce(fn, null));\n    }\n\n    async function run_cli() {\n        var content = program.sourceMap && program.sourceMap.content;\n        if (content && content !== \"inline\") {\n            options.sourceMap.content = read_file(content, content);\n        }\n        if (program.timings) options.timings = true;\n\n        try {\n            if (program.parse) {\n                if (program.parse.acorn) {\n                    files = convert_ast(function(toplevel, name) {\n                        return __webpack_require__(/*! acorn */ \"./node_modules/acorn/dist/acorn.mjs\").parse(files[name], {\n                            ecmaVersion: 2018,\n                            locations: true,\n                            program: toplevel,\n                            sourceFile: name,\n                            sourceType: options.module || program.parse.module ? \"module\" : \"script\"\n                        });\n                    });\n                } else if (program.parse.spidermonkey) {\n                    files = convert_ast(function(toplevel, name) {\n                        var obj = JSON.parse(files[name]);\n                        if (!toplevel) return obj;\n                        toplevel.body = toplevel.body.concat(obj.body);\n                        return toplevel;\n                    });\n                }\n            }\n        } catch (ex) {\n            fatal(ex);\n        }\n\n        let result;\n        try {\n            result = await minify(files, options);\n        } catch (ex) {\n            if (ex.name == \"SyntaxError\") {\n                print_error(\"Parse error at \" + ex.filename + \":\" + ex.line + \",\" + ex.col);\n                var col = ex.col;\n                var lines = files[ex.filename].split(/\\r?\\n/);\n                var line = lines[ex.line - 1];\n                if (!line && !col) {\n                    line = lines[ex.line - 2];\n                    col = line.length;\n                }\n                if (line) {\n                    var limit = 70;\n                    if (col > limit) {\n                        line = line.slice(col - limit);\n                        col = limit;\n                    }\n                    print_error(line.slice(0, 80));\n                    print_error(line.slice(0, col).replace(/\\S/g, \" \") + \"^\");\n                }\n            }\n            if (ex.defs) {\n                print_error(\"Supported options:\");\n                print_error(format_object(ex.defs));\n            }\n            fatal(ex);\n            return;\n        }\n\n        if (program.output == \"ast\") {\n            if (!options.compress && !options.mangle) {\n                result.ast.figure_out_scope({});\n            }\n            console.log(JSON.stringify(result.ast, function(key, value) {\n                if (value) switch (key) {\n                  case \"thedef\":\n                    return symdef(value);\n                  case \"enclosed\":\n                    return value.length ? value.map(symdef) : undefined;\n                  case \"variables\":\n                  case \"globals\":\n                    return value.size ? collect_from_map(value, symdef) : undefined;\n                }\n                if (skip_keys.has(key)) return;\n                if (value instanceof AST_Token) return;\n                if (value instanceof Map) return;\n                if (value instanceof AST_Node) {\n                    var result = {\n                        _class: \"AST_\" + value.TYPE\n                    };\n                    if (value.block_scope) {\n                        result.variables = value.block_scope.variables;\n                        result.enclosed = value.block_scope.enclosed;\n                    }\n                    value.CTOR.PROPS.forEach(function(prop) {\n                        result[prop] = value[prop];\n                    });\n                    return result;\n                }\n                return value;\n            }, 2));\n        } else if (program.output == \"spidermonkey\") {\n            try {\n                const minified = await minify(result.code, {\n                    compress: false,\n                    mangle: false,\n                    format: {\n                        ast: true,\n                        code: false\n                    }\n                });\n                console.log(JSON.stringify(minified.ast.to_mozilla_ast(), null, 2));\n            } catch (ex) {\n                fatal(ex);\n                return;\n            }\n        } else if (program.output) {\n            fs.writeFileSync(program.output, result.code);\n            if (options.sourceMap && options.sourceMap.url !== \"inline\" && result.map) {\n                fs.writeFileSync(program.output + \".map\", result.map);\n            }\n        } else {\n            console.log(result.code);\n        }\n        if (program.nameCache) {\n            fs.writeFileSync(program.nameCache, JSON.stringify(options.nameCache));\n        }\n        if (result.timings) for (var phase in result.timings) {\n            print_error(\"- \" + phase + \": \" + result.timings[phase].toFixed(3) + \"s\");\n        }\n    }\n\n    function fatal(message) {\n        if (message instanceof Error) message = message.stack.replace(/^\\S*?Error:/, \"ERROR:\");\n        print_error(message);\n        process.exit(1);\n    }\n\n    // A file glob function that only supports \"*\" and \"?\" wildcards in the basename.\n    // Example: \"foo/bar/*baz??.*.js\"\n    // Argument `glob` may be a string or an array of strings.\n    // Returns an array of strings. Garbage in, garbage out.\n    function simple_glob(glob) {\n        if (Array.isArray(glob)) {\n            return [].concat.apply([], glob.map(simple_glob));\n        }\n        if (glob && glob.match(/[*?]/)) {\n            var dir = path.dirname(glob);\n            try {\n                var entries = fs.readdirSync(dir);\n            } catch (ex) {}\n            if (entries) {\n                var pattern = \"^\" + path.basename(glob)\n                    .replace(/[.+^$[\\]\\\\(){}]/g, \"\\\\$&\")\n                    .replace(/\\*/g, \"[^/\\\\\\\\]*\")\n                    .replace(/\\?/g, \"[^/\\\\\\\\]\") + \"$\";\n                var mod = process.platform === \"win32\" ? \"i\" : \"\";\n                var rx = new RegExp(pattern, mod);\n                var results = entries.filter(function(name) {\n                    return rx.test(name);\n                }).map(function(name) {\n                    return path.join(dir, name);\n                });\n                if (results.length) return results;\n            }\n        }\n        return [ glob ];\n    }\n\n    function read_file(path, default_value) {\n        try {\n            return fs.readFileSync(path, \"utf8\");\n        } catch (ex) {\n            if ((ex.code == \"ENOENT\" || ex.code == \"ENAMETOOLONG\") && default_value != null) return default_value;\n            fatal(ex);\n        }\n    }\n\n    function parse_js(flag) {\n        return function(value, options) {\n            options = options || {};\n            try {\n                walk(parse(value, { expression: true }), node => {\n                    if (node instanceof AST_Assign) {\n                        var name = node.left.print_to_string();\n                        var value = node.right;\n                        if (flag) {\n                            options[name] = value;\n                        } else if (value instanceof AST_Array) {\n                            options[name] = value.elements.map(to_string);\n                        } else if (value instanceof AST_RegExp) {\n                            value = value.value;\n                            options[name] = new RegExp(value.source, value.flags);\n                        } else {\n                            options[name] = to_string(value);\n                        }\n                        return true;\n                    }\n                    if (node instanceof AST_Symbol || node instanceof AST_PropAccess) {\n                        var name = node.print_to_string();\n                        options[name] = true;\n                        return true;\n                    }\n                    if (!(node instanceof AST_Sequence)) throw node;\n\n                    function to_string(value) {\n                        return value instanceof AST_Constant ? value.getValue() : value.print_to_string({\n                            quote_keys: true\n                        });\n                    }\n                });\n            } catch(ex) {\n                if (flag) {\n                    fatal(\"Error parsing arguments for '\" + flag + \"': \" + value);\n                } else {\n                    options[value] = null;\n                }\n            }\n            return options;\n        };\n    }\n\n    function symdef(def) {\n        var ret = (1e6 + def.id) + \" \" + def.name;\n        if (def.mangled_name) ret += \" \" + def.mangled_name;\n        return ret;\n    }\n\n    function collect_from_map(map, callback) {\n        var result = [];\n        map.forEach(function (def) {\n            result.push(callback(def));\n        });\n        return result;\n    }\n\n    function format_object(obj) {\n        var lines = [];\n        var padding = \"\";\n        Object.keys(obj).map(function(name) {\n            if (padding.length < name.length) padding = Array(name.length + 1).join(\" \");\n            return [ name, JSON.stringify(obj[name]) ];\n        }).forEach(function(tokens) {\n            lines.push(\"  \" + tokens[0] + padding.slice(tokens[0].length - 2) + tokens[1]);\n        });\n        return lines.join(\"\\n\");\n    }\n\n    function print_error(msg) {\n        process.stderr.write(msg);\n        process.stderr.write(\"\\n\");\n    }\n\n    function describe_ast() {\n        var out = OutputStream({ beautify: true });\n        function doitem(ctor) {\n            out.print(\"AST_\" + ctor.TYPE);\n            const props = ctor.SELF_PROPS.filter(prop => !/^\\$/.test(prop));\n\n            if (props.length > 0) {\n                out.space();\n                out.with_parens(function() {\n                    props.forEach(function(prop, i) {\n                        if (i) out.space();\n                        out.print(prop);\n                    });\n                });\n            }\n\n            if (ctor.documentation) {\n                out.space();\n                out.print_string(ctor.documentation);\n            }\n\n            if (ctor.SUBCLASSES.length > 0) {\n                out.space();\n                out.with_block(function() {\n                    ctor.SUBCLASSES.forEach(function(ctor) {\n                        out.indent();\n                        doitem(ctor);\n                        out.newline();\n                    });\n                });\n            }\n        }\n        doitem(AST_Node);\n        return out + \"\\n\";\n    }\n}\n\nasync function _default_options() {\n    const defs = {};\n\n    Object.keys(infer_options({ 0: 0 })).forEach((component) => {\n        const options = infer_options({\n            [component]: {0: 0}\n        });\n\n        if (options) defs[component] = options;\n    });\n    return defs;\n}\n\nasync function infer_options(options) {\n    try {\n        await minify(\"\", options);\n    } catch (error) {\n        return error.defs;\n    }\n}\n\nexports._default_options = _default_options;\nexports._run_cli = run_cli;\nexports.minify = minify;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL2Rpc3QvYnVuZGxlLm1pbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3BHLENBQ3lIO0FBQ3pILENBQUMsNENBQTRDOztBQUU3QyxxQ0FBcUMsNERBQTREOztBQUVqRzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZ0JBQWdCO0FBQ2hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQjtBQUNBLDBCQUEwQjtBQUMxQiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsRUFBRTtBQUNuQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx1REFBdUQ7O0FBRXZELHlEQUF5RCxHQUFHOztBQUU1RCwrQ0FBK0MsSUFBSTs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLGlDQUFpQztBQUNqQyxtRUFBbUU7QUFDbkUsa0RBQWtEO0FBQ2xELDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0NBQWtDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLEtBQUs7QUFDaEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQsMEJBQTBCO0FBQzFCLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0NBQWdDO0FBQ3JGLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQ0FBMEMsMEJBQTBCO0FBQ3BFOztBQUVBO0FBQ0EseUNBQXlDLGtEQUFrRDtBQUMzRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixnQ0FBZ0M7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQ0FBZ0M7QUFDN0UsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQ0FBZ0M7QUFDMUUsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQ0FBZ0M7QUFDMUUsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVUsc0JBQXNCO0FBQ2hDO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qyw4QkFBOEI7QUFDOUIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyx3Q0FBd0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLG1DQUFtQywrQkFBK0IsaUJBQWlCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQjtBQUMzRDtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxzQ0FBc0MsOEJBQThCO0FBQ3BFLGNBQWM7QUFDZDtBQUNBLDBDQUEwQyxxREFBcUQ7QUFDL0YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsNkJBQTZCO0FBQzdCLHNDQUFzQztBQUN0QyxnREFBZ0Q7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQyxLQUFLOztBQUVMO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakIsNEJBQTRCLE1BQU0sV0FBVztBQUM3Qyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0U7O0FBRWxFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0NBQWdDO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWOztBQUVBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQ0FBMEMsb0NBQW9DO0FBQzlFO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsYUFBYTtBQUN0RSwrQkFBK0IsU0FBUztBQUN4QyxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGNBQWM7QUFDZCw0QkFBNEI7QUFDNUIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9DQUFvQztBQUNwQyxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUyxtREFBbUQsZ0JBQWdCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0EsdUNBQXVDO0FBQ3ZDLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFNBQVM7QUFDL0Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixDQUFDOztBQUVEO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBZ0MsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLElBQUkseUJBQXlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdCQUFnQjtBQUN0RSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsaUNBQWlDO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQiwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFdBQVc7QUFDL0U7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsV0FBVztBQUN2RSxvRUFBb0UsV0FBVztBQUMvRSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUNBQXFDO0FBQzlGO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1RUFBdUUsY0FBYzs7QUFFckY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEO0FBQzlELHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBLDREQUE0RDtBQUM1RCw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQseUJBQXlCLElBQUk7QUFDN0IseUJBQXlCLEdBQUc7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQ0FBb0M7QUFDNUQsb0NBQW9DLHVDQUF1QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsaUJBQWlCLDhCQUE4QjtBQUN4RjtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdCQUF3Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLGdCQUFnQjtBQUNoQixNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQkFBcUI7QUFDNUQsdUNBQXVDLG1DQUFtQztBQUMxRSx1Q0FBdUMsZ0VBQWdFO0FBQ3ZHLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlCQUF5QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDhEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdELHVDQUF1QyxxQkFBcUI7QUFDNUQsdUNBQXVDLHFCQUFxQjtBQUM1RCwyQ0FBMkMsbUJBQW1CO0FBQzlELHVDQUF1QyxxQkFBcUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUYsc0VBQXNFLE1BQU0sY0FBYyxNQUFNO0FBQ2hHO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNLEdBQUcsV0FBVztBQUNqQztBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw2Q0FBNkM7QUFDN0MsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGNBQWM7QUFDZCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsY0FBYztBQUNkLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx5Q0FBeUM7QUFDekMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsK0JBQStCO0FBQy9CLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCw2QkFBNkI7QUFDN0IsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU8sR0FBRyxNQUFNOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLLFlBQVksSUFBSTtBQUNwRCxjQUFjO0FBQ2QsZ0NBQWdDLEtBQUssa0JBQWtCLEtBQUssaUJBQWlCLEtBQUssWUFBWSxJQUFJO0FBQ2xHLGNBQWM7QUFDZCxzRUFBc0UsV0FBVztBQUNqRjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrREFBa0QsYUFBYTs7QUFFL0Q7O0FBRUE7O0FBRUE7O0FBRUEseURBQXlELG9CQUFvQjs7QUFFN0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDREQUE0RCx1Q0FBdUMsSUFBSTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE1BQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHdFQUF3RSxNQUFNLEVBQUUsS0FBSyxFQUFFLElBQUk7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSx3Q0FBd0MsK0RBQStEO0FBQ3ZHLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLDREQUE0RCxJQUFJO0FBQ2hFOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLCtCQUErQixzQkFBc0I7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlEQUFpRDs7QUFFakQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0REFBNEQsT0FBTztBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZUFBZTs7QUFFM0I7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUM7O0FBRXpDLHFDQUFxQzs7QUFFckM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DLHFDQUFxQzs7QUFFckM7QUFDQSwyQkFBMkIsa0RBQWtEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrREFBK0QsU0FBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSSx1QkFBdUIsYUFBYSxJQUFJO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGFBQWE7QUFDdkUsYUFBYSxrQ0FBa0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsYUFBYTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHlFQUF5RSxLQUFLO0FBQzlFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsVUFBVTtBQUM3RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDJCQUEyQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxpQ0FBaUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVEsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUJBQWlCLEdBQUc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxZQUFZO0FBQ2pGO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHdCQUF3QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLCtCQUErQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1RUFBdUUsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJO0FBQ3pGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELDZEQUE2RDtBQUM3RCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELHVEQUF1RDtBQUN2RCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxZQUFZO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiw2REFBNkQsWUFBWTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHlEQUF5RCxZQUFZO0FBQ3JFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsWUFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlCQUF5QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBLGdDQUFnQyx3QkFBd0I7QUFDeEQsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFdBQVc7QUFDbkU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsU0FBUztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsK0VBQStFLFdBQVc7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFdBQVc7QUFDNUU7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDhEQUE4RCxXQUFXO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCLDhDQUE4QztBQUNoRjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0EscURBQXFELEVBQUU7QUFDdkQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0EsNERBQTRELFVBQVU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxrQkFBa0IsSUFBSTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUksZUFBZSxJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSSxXQUFXLElBQUksWUFBWSxJQUFJLE1BQU0sSUFBSTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdUJBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsU0FBUztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWUsS0FBSyxhQUFhLGdDQUFnQyxLQUFLO0FBQy9GO0FBQ0EseUJBQXlCLGNBQWMsZ0NBQWdDLEtBQUs7QUFDNUUseUJBQXlCLGFBQWEsZ0NBQWdDLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1CQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsY0FBYyxJQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCLGdCQUFnQjtBQUNoQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMERBQTBEO0FBQ3BGLDBCQUEwQiw0REFBNEQ7QUFDdEY7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFtQjtBQUNyRCxrQ0FBa0MsOEJBQThCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBTSxnQkFBZ0IscUJBQU07O0FBRXhEO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLDBFQUEwRSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsY0FBYztBQUMzRixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkVBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQSwwQkFBMEI7QUFDMUIsU0FBUzs7QUFFVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbS1sZXZpdHkvLi9ub2RlX21vZHVsZXMvdGVyc2VyL2Rpc3QvYnVuZGxlLm1pbi5qcz85ZmRhIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG50eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3NvdXJjZS1tYXAnKSkgOlxudHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdzb3VyY2UtbWFwJ10sIGZhY3RvcnkpIDpcbihnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLlRlcnNlciA9IHt9LCBnbG9iYWwuc291cmNlTWFwKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cywgTU9aX1NvdXJjZU1hcCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG52YXIgTU9aX1NvdXJjZU1hcF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koTU9aX1NvdXJjZU1hcCk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZnVuY3Rpb24gY2hhcmFjdGVycyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KFwiXCIpO1xufVxuXG5mdW5jdGlvbiBtZW1iZXIobmFtZSwgYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkuaW5jbHVkZXMobmFtZSk7XG59XG5cbmNsYXNzIERlZmF1bHRzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnLCBkZWZzKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5uYW1lID0gXCJEZWZhdWx0c0Vycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgICAgICAgdGhpcy5kZWZzID0gZGVmcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRzKGFyZ3MsIGRlZnMsIGNyb2FrKSB7XG4gICAgaWYgKGFyZ3MgPT09IHRydWUpIHtcbiAgICAgICAgYXJncyA9IHt9O1xuICAgIH0gZWxzZSBpZiAoYXJncyAhPSBudWxsICYmIHR5cGVvZiBhcmdzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGFyZ3MgPSB7Li4uYXJnc307XG4gICAgfVxuXG4gICAgY29uc3QgcmV0ID0gYXJncyB8fCB7fTtcblxuICAgIGlmIChjcm9haykgZm9yIChjb25zdCBpIGluIHJldCkgaWYgKEhPUChyZXQsIGkpICYmICFIT1AoZGVmcywgaSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IERlZmF1bHRzRXJyb3IoXCJgXCIgKyBpICsgXCJgIGlzIG5vdCBhIHN1cHBvcnRlZCBvcHRpb25cIiwgZGVmcyk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBpIGluIGRlZnMpIGlmIChIT1AoZGVmcywgaSkpIHtcbiAgICAgICAgaWYgKCFhcmdzIHx8ICFIT1AoYXJncywgaSkpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IGRlZnNbaV07XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gXCJlY21hXCIpIHtcbiAgICAgICAgICAgIGxldCBlY21hID0gYXJnc1tpXSB8IDA7XG4gICAgICAgICAgICBpZiAoZWNtYSA+IDUgJiYgZWNtYSA8IDIwMTUpIGVjbWEgKz0gMjAwOTtcbiAgICAgICAgICAgIHJldFtpXSA9IGVjbWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXRbaV0gPSAoYXJncyAmJiBIT1AoYXJncywgaSkpID8gYXJnc1tpXSA6IGRlZnNbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cbmZ1bmN0aW9uIHJldHVybl9mYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5mdW5jdGlvbiByZXR1cm5fdHJ1ZSgpIHsgcmV0dXJuIHRydWU7IH1cbmZ1bmN0aW9uIHJldHVybl90aGlzKCkgeyByZXR1cm4gdGhpczsgfVxuZnVuY3Rpb24gcmV0dXJuX251bGwoKSB7IHJldHVybiBudWxsOyB9XG5cbnZhciBNQVAgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTUFQKGEsIGYsIGJhY2t3YXJkcykge1xuICAgICAgICB2YXIgcmV0ID0gW10sIHRvcCA9IFtdLCBpO1xuICAgICAgICBmdW5jdGlvbiBkb2l0KCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGYoYVtpXSwgaSk7XG4gICAgICAgICAgICB2YXIgaXNfbGFzdCA9IHZhbCBpbnN0YW5jZW9mIExhc3Q7XG4gICAgICAgICAgICBpZiAoaXNfbGFzdCkgdmFsID0gdmFsLnY7XG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXRUb3ApIHtcbiAgICAgICAgICAgICAgICB2YWwgPSB2YWwudjtcbiAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgU3BsaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcC5wdXNoLmFwcGx5KHRvcCwgYmFja3dhcmRzID8gdmFsLnYuc2xpY2UoKS5yZXZlcnNlKCkgOiB2YWwudik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCAhPT0gc2tpcCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBTcGxpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LnB1c2guYXBwbHkocmV0LCBiYWNrd2FyZHMgPyB2YWwudi5zbGljZSgpLnJldmVyc2UoKSA6IHZhbC52KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc19sYXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgICAgICBpZiAoYmFja3dhcmRzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gYS5sZW5ndGg7IC0taSA+PSAwOykgaWYgKGRvaXQoKSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgcmV0LnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICB0b3AucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkgaWYgKGRvaXQoKSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gYSkgaWYgKEhPUChhLCBpKSkgaWYgKGRvaXQoKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcC5jb25jYXQocmV0KTtcbiAgICB9XG4gICAgTUFQLmF0X3RvcCA9IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gbmV3IEF0VG9wKHZhbCk7IH07XG4gICAgTUFQLnNwbGljZSA9IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gbmV3IFNwbGljZSh2YWwpOyB9O1xuICAgIE1BUC5sYXN0ID0gZnVuY3Rpb24odmFsKSB7IHJldHVybiBuZXcgTGFzdCh2YWwpOyB9O1xuICAgIHZhciBza2lwID0gTUFQLnNraXAgPSB7fTtcbiAgICBmdW5jdGlvbiBBdFRvcCh2YWwpIHsgdGhpcy52ID0gdmFsOyB9XG4gICAgZnVuY3Rpb24gU3BsaWNlKHZhbCkgeyB0aGlzLnYgPSB2YWw7IH1cbiAgICBmdW5jdGlvbiBMYXN0KHZhbCkgeyB0aGlzLnYgPSB2YWw7IH1cbiAgICByZXR1cm4gTUFQO1xufSkoKTtcblxuZnVuY3Rpb24gbWFrZV9ub2RlKGN0b3IsIG9yaWcsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykgcHJvcHMgPSB7fTtcbiAgICBpZiAob3JpZykge1xuICAgICAgICBpZiAoIXByb3BzLnN0YXJ0KSBwcm9wcy5zdGFydCA9IG9yaWcuc3RhcnQ7XG4gICAgICAgIGlmICghcHJvcHMuZW5kKSBwcm9wcy5lbmQgPSBvcmlnLmVuZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBjdG9yKHByb3BzKTtcbn1cblxuZnVuY3Rpb24gcHVzaF91bmlxKGFycmF5LCBlbCkge1xuICAgIGlmICghYXJyYXkuaW5jbHVkZXMoZWwpKVxuICAgICAgICBhcnJheS5wdXNoKGVsKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nX3RlbXBsYXRlKHRleHQsIHByb3BzKSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgveyguKz8pfS9nLCBmdW5jdGlvbihzdHIsIHApIHtcbiAgICAgICAgcmV0dXJuIHByb3BzICYmIHByb3BzW3BdO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIGVsKSB7XG4gICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZWwpIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlU29ydChhcnJheSwgY21wKSB7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA8IDIpIHJldHVybiBhcnJheS5zbGljZSgpO1xuICAgIGZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcbiAgICAgICAgdmFyIHIgPSBbXSwgYWkgPSAwLCBiaSA9IDAsIGkgPSAwO1xuICAgICAgICB3aGlsZSAoYWkgPCBhLmxlbmd0aCAmJiBiaSA8IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjbXAoYVthaV0sIGJbYmldKSA8PSAwXG4gICAgICAgICAgICAgICAgPyByW2krK10gPSBhW2FpKytdXG4gICAgICAgICAgICAgICAgOiByW2krK10gPSBiW2JpKytdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhaSA8IGEubGVuZ3RoKSByLnB1c2guYXBwbHkociwgYS5zbGljZShhaSkpO1xuICAgICAgICBpZiAoYmkgPCBiLmxlbmd0aCkgci5wdXNoLmFwcGx5KHIsIGIuc2xpY2UoYmkpKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9tcyhhKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCA8PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIHZhciBtID0gTWF0aC5mbG9vcihhLmxlbmd0aCAvIDIpLCBsZWZ0ID0gYS5zbGljZSgwLCBtKSwgcmlnaHQgPSBhLnNsaWNlKG0pO1xuICAgICAgICBsZWZ0ID0gX21zKGxlZnQpO1xuICAgICAgICByaWdodCA9IF9tcyhyaWdodCk7XG4gICAgICAgIHJldHVybiBtZXJnZShsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBfbXMoYXJyYXkpO1xufVxuXG5mdW5jdGlvbiBtYWtlUHJlZGljYXRlKHdvcmRzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRzKSkgd29yZHMgPSB3b3Jkcy5zcGxpdChcIiBcIik7XG5cbiAgICByZXR1cm4gbmV3IFNldCh3b3Jkcy5zb3J0KCkpO1xufVxuXG5mdW5jdGlvbiBtYXBfYWRkKG1hcCwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChtYXAuaGFzKGtleSkpIHtcbiAgICAgICAgbWFwLmdldChrZXkpLnB1c2godmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBbIHZhbHVlIF0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFwX2Zyb21fb2JqZWN0KG9iaikge1xuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoSE9QKG9iaiwga2V5KSAmJiBrZXkuY2hhckF0KDApID09PSBcIiRcIikge1xuICAgICAgICAgICAgbWFwLnNldChrZXkuc3Vic3RyKDEpLCBvYmpba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cblxuZnVuY3Rpb24gbWFwX3RvX29iamVjdChtYXApIHtcbiAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBvYmpbXCIkXCIgKyBrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gSE9QKG9iaiwgcHJvcCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuZnVuY3Rpb24ga2VlcF9uYW1lKGtlZXBfc2V0dGluZywgbmFtZSkge1xuICAgIHJldHVybiBrZWVwX3NldHRpbmcgPT09IHRydWVcbiAgICAgICAgfHwgKGtlZXBfc2V0dGluZyBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBrZWVwX3NldHRpbmcudGVzdChuYW1lKSk7XG59XG5cbnZhciBsaW5lVGVybWluYXRvckVzY2FwZSA9IHtcbiAgICBcIlxcMFwiOiBcIjBcIixcbiAgICBcIlxcblwiOiBcIm5cIixcbiAgICBcIlxcclwiOiBcInJcIixcbiAgICBcIlxcdTIwMjhcIjogXCJ1MjAyOFwiLFxuICAgIFwiXFx1MjAyOVwiOiBcInUyMDI5XCIsXG59O1xuZnVuY3Rpb24gcmVnZXhwX3NvdXJjZV9maXgoc291cmNlKSB7XG4gICAgLy8gVjggZG9lcyBub3QgZXNjYXBlIGxpbmUgdGVybWluYXRvcnMgaW4gcmVnZXhwIHBhdHRlcm5zIGluIG5vZGUgMTJcbiAgICAvLyBXZSdsbCBhbHNvIHJlbW92ZSBsaXRlcmFsIFxcMFxuICAgIHJldHVybiBzb3VyY2UucmVwbGFjZSgvW1xcMFxcblxcclxcdTIwMjhcXHUyMDI5XS9nLCBmdW5jdGlvbiAobWF0Y2gsIG9mZnNldCkge1xuICAgICAgICB2YXIgZXNjYXBlZCA9IHNvdXJjZVtvZmZzZXQgLSAxXSA9PSBcIlxcXFxcIlxuICAgICAgICAgICAgJiYgKHNvdXJjZVtvZmZzZXQgLSAyXSAhPSBcIlxcXFxcIlxuICAgICAgICAgICAgfHwgLyg/Ol58W15cXFxcXSkoPzpcXFxcezJ9KSokLy50ZXN0KHNvdXJjZS5zbGljZSgwLCBvZmZzZXQgLSAxKSkpO1xuICAgICAgICByZXR1cm4gKGVzY2FwZWQgPyBcIlwiIDogXCJcXFxcXCIpICsgbGluZVRlcm1pbmF0b3JFc2NhcGVbbWF0Y2hdO1xuICAgIH0pO1xufVxuY29uc3QgYWxsX2ZsYWdzID0gXCJnaW11eVwiO1xuZnVuY3Rpb24gc29ydF9yZWdleHBfZmxhZ3MoZmxhZ3MpIHtcbiAgICBjb25zdCBleGlzdGluZ19mbGFncyA9IG5ldyBTZXQoZmxhZ3Muc3BsaXQoXCJcIikpO1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGZvciAoY29uc3QgZmxhZyBvZiBhbGxfZmxhZ3MpIHtcbiAgICAgICAgaWYgKGV4aXN0aW5nX2ZsYWdzLmhhcyhmbGFnKSkge1xuICAgICAgICAgICAgb3V0ICs9IGZsYWc7XG4gICAgICAgICAgICBleGlzdGluZ19mbGFncy5kZWxldGUoZmxhZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4aXN0aW5nX2ZsYWdzLnNpemUpIHtcbiAgICAgICAgLy8gRmxhZ3MgVGVyc2VyIGRvZXNuJ3Qga25vdyBhYm91dFxuICAgICAgICBleGlzdGluZ19mbGFncy5mb3JFYWNoKGZsYWcgPT4geyBvdXQgKz0gZmxhZzsgfSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGhhc19hbm5vdGF0aW9uKG5vZGUsIGFubm90YXRpb24pIHtcbiAgICByZXR1cm4gbm9kZS5fYW5ub3RhdGlvbnMgJiBhbm5vdGF0aW9uO1xufVxuXG5mdW5jdGlvbiBzZXRfYW5ub3RhdGlvbihub2RlLCBhbm5vdGF0aW9uKSB7XG4gICAgbm9kZS5fYW5ub3RhdGlvbnMgfD0gYW5ub3RhdGlvbjtcbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgQSBKYXZhU2NyaXB0IHRva2VuaXplciAvIHBhcnNlciAvIGJlYXV0aWZpZXIgLyBjb21wcmVzc29yLlxuICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMlxuXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIChDKSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yOiBNaWhhaSBCYXpvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG4gICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9taWhhaS5iYXpvbi5uZXQvYmxvZ1xuXG4gIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgbGljZW5zZTpcblxuICAgIENvcHlyaWdodCAyMDEyIChjKSBNaWhhaSBCYXpvbiA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgIFBhcnNlciBiYXNlZCBvbiBwYXJzZS1qcyAoaHR0cDovL21hcmlqbi5oYXZlcmJla2UubmwvcGFyc2UtanMvKS5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIExBVEVTVF9SQVcgPSBcIlwiOyAgLy8gT25seSB1c2VkIGZvciBudW1iZXJzIGFuZCB0ZW1wbGF0ZSBzdHJpbmdzXG52YXIgTEFURVNUX1RFTVBMQVRFX0VORCA9IHRydWU7XG5cbnZhciBLRVlXT1JEUyA9IFwiYnJlYWsgY2FzZSBjYXRjaCBjbGFzcyBjb25zdCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRlbGV0ZSBkbyBlbHNlIGV4cG9ydCBleHRlbmRzIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIGluIGluc3RhbmNlb2YgbGV0IG5ldyByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB0eXBlb2YgdmFyIHZvaWQgd2hpbGUgd2l0aFwiO1xudmFyIEtFWVdPUkRTX0FUT00gPSBcImZhbHNlIG51bGwgdHJ1ZVwiO1xudmFyIFJFU0VSVkVEX1dPUkRTID0gXCJlbnVtIGltcGxlbWVudHMgaW1wb3J0IGludGVyZmFjZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzdGF0aWMgc3VwZXIgdGhpcyBcIiArIEtFWVdPUkRTX0FUT00gKyBcIiBcIiArIEtFWVdPUkRTO1xudmFyIEtFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OID0gXCJyZXR1cm4gbmV3IGRlbGV0ZSB0aHJvdyBlbHNlIGNhc2UgeWllbGQgYXdhaXRcIjtcblxuS0VZV09SRFMgPSBtYWtlUHJlZGljYXRlKEtFWVdPUkRTKTtcblJFU0VSVkVEX1dPUkRTID0gbWFrZVByZWRpY2F0ZShSRVNFUlZFRF9XT1JEUyk7XG5LRVlXT1JEU19CRUZPUkVfRVhQUkVTU0lPTiA9IG1ha2VQcmVkaWNhdGUoS0VZV09SRFNfQkVGT1JFX0VYUFJFU1NJT04pO1xuS0VZV09SRFNfQVRPTSA9IG1ha2VQcmVkaWNhdGUoS0VZV09SRFNfQVRPTSk7XG5cbnZhciBPUEVSQVRPUl9DSEFSUyA9IG1ha2VQcmVkaWNhdGUoY2hhcmFjdGVycyhcIistKiYlPTw+IT98fl5cIikpO1xuXG52YXIgUkVfTlVNX0xJVEVSQUwgPSAvWzAtOWEtZl0vaTtcbnZhciBSRV9IRVhfTlVNQkVSID0gL14weFswLTlhLWZdKyQvaTtcbnZhciBSRV9PQ1RfTlVNQkVSID0gL14wWzAtN10rJC87XG52YXIgUkVfRVM2X09DVF9OVU1CRVIgPSAvXjBvWzAtN10rJC9pO1xudmFyIFJFX0JJTl9OVU1CRVIgPSAvXjBiWzAxXSskL2k7XG52YXIgUkVfREVDX05VTUJFUiA9IC9eXFxkKlxcLj9cXGQqKD86ZVsrLV0/XFxkKig/OlxcZFxcLj98XFwuP1xcZClcXGQqKT8kL2k7XG52YXIgUkVfQklHX0lOVCA9IC9eKDBbeG9iXSk/WzAtOWEtZl0rbiQvaTtcblxudmFyIE9QRVJBVE9SUyA9IG1ha2VQcmVkaWNhdGUoW1xuICAgIFwiaW5cIixcbiAgICBcImluc3RhbmNlb2ZcIixcbiAgICBcInR5cGVvZlwiLFxuICAgIFwibmV3XCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJkZWxldGVcIixcbiAgICBcIisrXCIsXG4gICAgXCItLVwiLFxuICAgIFwiK1wiLFxuICAgIFwiLVwiLFxuICAgIFwiIVwiLFxuICAgIFwiflwiLFxuICAgIFwiJlwiLFxuICAgIFwifFwiLFxuICAgIFwiXlwiLFxuICAgIFwiKlwiLFxuICAgIFwiKipcIixcbiAgICBcIi9cIixcbiAgICBcIiVcIixcbiAgICBcIj4+XCIsXG4gICAgXCI8PFwiLFxuICAgIFwiPj4+XCIsXG4gICAgXCI8XCIsXG4gICAgXCI+XCIsXG4gICAgXCI8PVwiLFxuICAgIFwiPj1cIixcbiAgICBcIj09XCIsXG4gICAgXCI9PT1cIixcbiAgICBcIiE9XCIsXG4gICAgXCIhPT1cIixcbiAgICBcIj9cIixcbiAgICBcIj1cIixcbiAgICBcIis9XCIsXG4gICAgXCItPVwiLFxuICAgIFwifHw9XCIsXG4gICAgXCImJj1cIixcbiAgICBcIj8/PVwiLFxuICAgIFwiLz1cIixcbiAgICBcIio9XCIsXG4gICAgXCIqKj1cIixcbiAgICBcIiU9XCIsXG4gICAgXCI+Pj1cIixcbiAgICBcIjw8PVwiLFxuICAgIFwiPj4+PVwiLFxuICAgIFwifD1cIixcbiAgICBcIl49XCIsXG4gICAgXCImPVwiLFxuICAgIFwiJiZcIixcbiAgICBcIj8/XCIsXG4gICAgXCJ8fFwiLFxuXSk7XG5cbnZhciBXSElURVNQQUNFX0NIQVJTID0gbWFrZVByZWRpY2F0ZShjaGFyYWN0ZXJzKFwiIFxcdTAwYTBcXG5cXHJcXHRcXGZcXHUwMDBiXFx1MjAwYlxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyOFxcdTIwMjlcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVGRUZGXCIpKTtcblxudmFyIE5FV0xJTkVfQ0hBUlMgPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXCJcXG5cXHJcXHUyMDI4XFx1MjAyOVwiKSk7XG5cbnZhciBQVU5DX0FGVEVSX0VYUFJFU1NJT04gPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXCI7XSksOlwiKSk7XG5cbnZhciBQVU5DX0JFRk9SRV9FWFBSRVNTSU9OID0gbWFrZVByZWRpY2F0ZShjaGFyYWN0ZXJzKFwiW3soLDs6XCIpKTtcblxudmFyIFBVTkNfQ0hBUlMgPSBtYWtlUHJlZGljYXRlKGNoYXJhY3RlcnMoXCJbXXt9KCksOzpcIikpO1xuXG4vKiAtLS0tLVsgVG9rZW5pemVyIF0tLS0tLSAqL1xuXG4vLyBzdXJyb2dhdGUgc2FmZSByZWdleHBzIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy91bmljb2RlLTguMC4wL3RyZWUvODliNDEyZDhhNzFlY2NhOWVkNTkzZDllOWZhMDczYWI2NGFjZmViZS9CaW5hcnlfUHJvcGVydHlcbnZhciBVTklDT0RFID0ge1xuICAgIElEX1N0YXJ0OiAvWyRBLVpfYS16XFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5Qi1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QURcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdfFxcdUQ4MDBbXFx1REMwMC1cXHVEQzBCXFx1REMwRC1cXHVEQzI2XFx1REMyOC1cXHVEQzNBXFx1REMzQ1xcdURDM0RcXHVEQzNGLVxcdURDNERcXHVEQzUwLVxcdURDNURcXHVEQzgwLVxcdURDRkFcXHVERDQwLVxcdURENzRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGNzVcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMFxcdURFMTAtXFx1REUxM1xcdURFMTUtXFx1REUxN1xcdURFMTktXFx1REUzM1xcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNFxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMy1cXHVEQzM3XFx1REM4My1cXHVEQ0FGXFx1RENEMC1cXHVEQ0U4XFx1REQwMy1cXHVERDI2XFx1REQ1MC1cXHVERDcyXFx1REQ3NlxcdUREODMtXFx1RERCMlxcdUREQzEtXFx1RERDNFxcdUREREFcXHVERERDXFx1REUwMC1cXHVERTExXFx1REUxMy1cXHVERTJCXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVERVxcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNEXFx1REY1MFxcdURGNUQtXFx1REY2MV18XFx1RDgwNVtcXHVEQzgwLVxcdURDQUZcXHVEQ0M0XFx1RENDNVxcdURDQzdcXHVERDgwLVxcdUREQUVcXHVEREQ4LVxcdUREREJcXHVERTAwLVxcdURFMkZcXHVERTQ0XFx1REU4MC1cXHVERUFBXFx1REYwMC1cXHVERjE5XXxcXHVEODA2W1xcdURDQTAtXFx1RENERlxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXFx1REY5My1cXHVERjlGXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNF18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdLyxcbiAgICBJRF9Db250aW51ZTogLyg/OlskMC05QS1aX2EtelxceEFBXFx4QjVcXHhCN1xceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODYtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjRcXHUwOEUzLVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQUY5XFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OC1cXHUwQzVBXFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ1Ri1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM2OS1cXHUxMzcxXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5REFcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZDLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE4LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OS1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FEXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1RERGRFxcdURFODAtXFx1REU5Q1xcdURFQTAtXFx1REVEMFxcdURFRTBcXHVERjAwLVxcdURGMUZcXHVERjMwLVxcdURGNEFcXHVERjUwLVxcdURGN0FcXHVERjgwLVxcdURGOURcXHVERkEwLVxcdURGQzNcXHVERkM4LVxcdURGQ0ZcXHVERkQxLVxcdURGRDVdfFxcdUQ4MDFbXFx1REMwMC1cXHVEQzlEXFx1RENBMC1cXHVEQ0E5XFx1REQwMC1cXHVERDI3XFx1REQzMC1cXHVERDYzXFx1REUwMC1cXHVERjM2XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjY3XXxcXHVEODAyW1xcdURDMDAtXFx1REMwNVxcdURDMDhcXHVEQzBBLVxcdURDMzVcXHVEQzM3XFx1REMzOFxcdURDM0NcXHVEQzNGLVxcdURDNTVcXHVEQzYwLVxcdURDNzZcXHVEQzgwLVxcdURDOUVcXHVEQ0UwLVxcdURDRjJcXHVEQ0Y0XFx1RENGNVxcdUREMDAtXFx1REQxNVxcdUREMjAtXFx1REQzOVxcdUREODAtXFx1RERCN1xcdUREQkVcXHVEREJGXFx1REUwMC1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REU2MC1cXHVERTdDXFx1REU4MC1cXHVERTlDXFx1REVDMC1cXHVERUM3XFx1REVDOS1cXHVERUU2XFx1REYwMC1cXHVERjM1XFx1REY0MC1cXHVERjU1XFx1REY2MC1cXHVERjcyXFx1REY4MC1cXHVERjkxXXxcXHVEODAzW1xcdURDMDAtXFx1REM0OFxcdURDODAtXFx1RENCMlxcdURDQzAtXFx1RENGMl18XFx1RDgwNFtcXHVEQzAwLVxcdURDNDZcXHVEQzY2LVxcdURDNkZcXHVEQzdGLVxcdURDQkFcXHVEQ0QwLVxcdURDRThcXHVEQ0YwLVxcdURDRjlcXHVERDAwLVxcdUREMzRcXHVERDM2LVxcdUREM0ZcXHVERDUwLVxcdURENzNcXHVERDc2XFx1REQ4MC1cXHVEREM0XFx1RERDQS1cXHVERENDXFx1REREMC1cXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUzN1xcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFRUFcXHVERUYwLVxcdURFRjlcXHVERjAwLVxcdURGMDNcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzQy1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjUwXFx1REY1N1xcdURGNUQtXFx1REY2M1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzgwLVxcdURDQzVcXHVEQ0M3XFx1RENEMC1cXHVEQ0Q5XFx1REQ4MC1cXHVEREI1XFx1RERCOC1cXHVEREMwXFx1REREOC1cXHVEREREXFx1REUwMC1cXHVERTQwXFx1REU0NFxcdURFNTAtXFx1REU1OVxcdURFODAtXFx1REVCN1xcdURFQzAtXFx1REVDOVxcdURGMDAtXFx1REYxOVxcdURGMUQtXFx1REYyQlxcdURGMzAtXFx1REYzOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDRTlcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERTYwLVxcdURFNjlcXHVERUQwLVxcdURFRURcXHVERUYwLVxcdURFRjRcXHVERjAwLVxcdURGMzZcXHVERjQwLVxcdURGNDNcXHVERjUwLVxcdURGNTlcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MC1cXHVERjdFXFx1REY4Ri1cXHVERjlGXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OVxcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjUtXFx1REQ2OVxcdURENkQtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXFx1REZDRS1cXHVERkZGXXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDRDAtXFx1RENENl18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXSkrLyxcbn07XG5cbmZ1bmN0aW9uIGdldF9mdWxsX2NoYXIoc3RyLCBwb3MpIHtcbiAgICBpZiAoaXNfc3Vycm9nYXRlX3BhaXJfaGVhZChzdHIuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICBpZiAoaXNfc3Vycm9nYXRlX3BhaXJfdGFpbChzdHIuY2hhckNvZGVBdChwb3MgKyAxKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIuY2hhckF0KHBvcykgKyBzdHIuY2hhckF0KHBvcyArIDEpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpc19zdXJyb2dhdGVfcGFpcl90YWlsKHN0ci5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgICAgIGlmIChpc19zdXJyb2dhdGVfcGFpcl9oZWFkKHN0ci5jaGFyQ29kZUF0KHBvcyAtIDEpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5jaGFyQXQocG9zIC0gMSkgKyBzdHIuY2hhckF0KHBvcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQocG9zKTtcbn1cblxuZnVuY3Rpb24gZ2V0X2Z1bGxfY2hhcl9jb2RlKHN0ciwgcG9zKSB7XG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsX0NoYXJhY3Rlcl9TZXRfY2hhcmFjdGVycyNTdXJyb2dhdGVzXG4gICAgaWYgKGlzX3N1cnJvZ2F0ZV9wYWlyX2hlYWQoc3RyLmNoYXJDb2RlQXQocG9zKSkpIHtcbiAgICAgICAgcmV0dXJuIDB4MTAwMDAgKyAoc3RyLmNoYXJDb2RlQXQocG9zKSAtIDB4ZDgwMCA8PCAxMCkgKyBzdHIuY2hhckNvZGVBdChwb3MgKyAxKSAtIDB4ZGMwMDtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KHBvcyk7XG59XG5cbmZ1bmN0aW9uIGdldF9mdWxsX2NoYXJfbGVuZ3RoKHN0cikge1xuICAgIHZhciBzdXJyb2dhdGVzID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc19zdXJyb2dhdGVfcGFpcl9oZWFkKHN0ci5jaGFyQ29kZUF0KGkpKSAmJiBpc19zdXJyb2dhdGVfcGFpcl90YWlsKHN0ci5jaGFyQ29kZUF0KGkgKyAxKSkpIHtcbiAgICAgICAgICAgIHN1cnJvZ2F0ZXMrKztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHIubGVuZ3RoIC0gc3Vycm9nYXRlcztcbn1cblxuZnVuY3Rpb24gZnJvbV9jaGFyX2NvZGUoY29kZSkge1xuICAgIC8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5mcm9tQ29kZVBvaW50L2Jsb2IvbWFzdGVyL2Zyb21jb2RlcG9pbnQuanNcbiAgICBpZiAoY29kZSA+IDB4RkZGRikge1xuICAgICAgICBjb2RlIC09IDB4MTAwMDA7XG4gICAgICAgIHJldHVybiAoU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyAweEQ4MDApICtcbiAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgJSAweDQwMCkgKyAweERDMDApKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59XG5cbmZ1bmN0aW9uIGlzX3N1cnJvZ2F0ZV9wYWlyX2hlYWQoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IDB4ZDgwMCAmJiBjb2RlIDw9IDB4ZGJmZjtcbn1cblxuZnVuY3Rpb24gaXNfc3Vycm9nYXRlX3BhaXJfdGFpbChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhkYzAwICYmIGNvZGUgPD0gMHhkZmZmO1xufVxuXG5mdW5jdGlvbiBpc19kaWdpdChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gNDggJiYgY29kZSA8PSA1Nztcbn1cblxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcl9zdGFydChjaCkge1xuICAgIHJldHVybiBVTklDT0RFLklEX1N0YXJ0LnRlc3QoY2gpO1xufVxuXG5mdW5jdGlvbiBpc19pZGVudGlmaWVyX2NoYXIoY2gpIHtcbiAgICByZXR1cm4gVU5JQ09ERS5JRF9Db250aW51ZS50ZXN0KGNoKTtcbn1cblxuY29uc3QgQkFTSUNfSURFTlQgPSAvXlthLXpfJF1bYS16MC05XyRdKiQvaTtcblxuZnVuY3Rpb24gaXNfYmFzaWNfaWRlbnRpZmllcl9zdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIEJBU0lDX0lERU5ULnRlc3Qoc3RyKTtcbn1cblxuZnVuY3Rpb24gaXNfaWRlbnRpZmllcl9zdHJpbmcoc3RyLCBhbGxvd19zdXJyb2dhdGVzKSB7XG4gICAgaWYgKEJBU0lDX0lERU5ULnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhbGxvd19zdXJyb2dhdGVzICYmIC9bXFx1ZDgwMC1cXHVkZmZmXS8udGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gVU5JQ09ERS5JRF9TdGFydC5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgc3RyID0gc3RyLnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgaWYgKCFzdHIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbWF0Y2ggPSBVTklDT0RFLklEX0NvbnRpbnVlLmV4ZWMoc3RyKTtcbiAgICByZXR1cm4gISFtYXRjaCAmJiBtYXRjaFswXS5sZW5ndGggPT09IHN0ci5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2pzX251bWJlcihudW0sIGFsbG93X2UgPSB0cnVlKSB7XG4gICAgaWYgKCFhbGxvd19lICYmIG51bS5pbmNsdWRlcyhcImVcIikpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgaWYgKFJFX0hFWF9OVU1CRVIudGVzdChudW0pKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChudW0uc3Vic3RyKDIpLCAxNik7XG4gICAgfSBlbHNlIGlmIChSRV9PQ1RfTlVNQkVSLnRlc3QobnVtKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLnN1YnN0cigxKSwgOCk7XG4gICAgfSBlbHNlIGlmIChSRV9FUzZfT0NUX05VTUJFUi50ZXN0KG51bSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bS5zdWJzdHIoMiksIDgpO1xuICAgIH0gZWxzZSBpZiAoUkVfQklOX05VTUJFUi50ZXN0KG51bSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bS5zdWJzdHIoMiksIDIpO1xuICAgIH0gZWxzZSBpZiAoUkVfREVDX05VTUJFUi50ZXN0KG51bSkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobnVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsID0gcGFyc2VGbG9hdChudW0pO1xuICAgICAgICBpZiAodmFsID09IG51bSkgcmV0dXJuIHZhbDtcbiAgICB9XG59XG5cbmNsYXNzIEpTX1BhcnNlX0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGZpbGVuYW1lLCBsaW5lLCBjb2wsIHBvcykge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU3ludGF4RXJyb3JcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLmNvbCA9IGNvbDtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBqc19lcnJvcihtZXNzYWdlLCBmaWxlbmFtZSwgbGluZSwgY29sLCBwb3MpIHtcbiAgICB0aHJvdyBuZXcgSlNfUGFyc2VfRXJyb3IobWVzc2FnZSwgZmlsZW5hbWUsIGxpbmUsIGNvbCwgcG9zKTtcbn1cblxuZnVuY3Rpb24gaXNfdG9rZW4odG9rZW4sIHR5cGUsIHZhbCkge1xuICAgIHJldHVybiB0b2tlbi50eXBlID09IHR5cGUgJiYgKHZhbCA9PSBudWxsIHx8IHRva2VuLnZhbHVlID09IHZhbCk7XG59XG5cbnZhciBFWF9FT0YgPSB7fTtcblxuZnVuY3Rpb24gdG9rZW5pemVyKCRURVhULCBmaWxlbmFtZSwgaHRtbDVfY29tbWVudHMsIHNoZWJhbmcpIHtcbiAgICB2YXIgUyA9IHtcbiAgICAgICAgdGV4dCAgICAgICAgICAgIDogJFRFWFQsXG4gICAgICAgIGZpbGVuYW1lICAgICAgICA6IGZpbGVuYW1lLFxuICAgICAgICBwb3MgICAgICAgICAgICAgOiAwLFxuICAgICAgICB0b2twb3MgICAgICAgICAgOiAwLFxuICAgICAgICBsaW5lICAgICAgICAgICAgOiAxLFxuICAgICAgICB0b2tsaW5lICAgICAgICAgOiAwLFxuICAgICAgICBjb2wgICAgICAgICAgICAgOiAwLFxuICAgICAgICB0b2tjb2wgICAgICAgICAgOiAwLFxuICAgICAgICBuZXdsaW5lX2JlZm9yZSAgOiBmYWxzZSxcbiAgICAgICAgcmVnZXhfYWxsb3dlZCAgIDogZmFsc2UsXG4gICAgICAgIGJyYWNlX2NvdW50ZXIgICA6IDAsXG4gICAgICAgIHRlbXBsYXRlX2JyYWNlcyA6IFtdLFxuICAgICAgICBjb21tZW50c19iZWZvcmUgOiBbXSxcbiAgICAgICAgZGlyZWN0aXZlcyAgICAgIDoge30sXG4gICAgICAgIGRpcmVjdGl2ZV9zdGFjayA6IFtdXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBlZWsoKSB7IHJldHVybiBnZXRfZnVsbF9jaGFyKFMudGV4dCwgUy5wb3MpOyB9XG5cbiAgICAvLyBVc2VkIGJlY2F1c2UgcGFyc2luZyA/LiBpbnZvbHZlcyBhIGxvb2thaGVhZCBmb3IgYSBkaWdpdFxuICAgIGZ1bmN0aW9uIGlzX29wdGlvbl9jaGFpbl9vcCgpIHtcbiAgICAgICAgY29uc3QgbXVzdF9iZV9kb3QgPSBTLnRleHQuY2hhckNvZGVBdChTLnBvcyArIDEpID09PSA0NjtcbiAgICAgICAgaWYgKCFtdXN0X2JlX2RvdCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IGNhbm5vdF9iZV9kaWdpdCA9IFMudGV4dC5jaGFyQ29kZUF0KFMucG9zICsgMik7XG4gICAgICAgIHJldHVybiBjYW5ub3RfYmVfZGlnaXQgPCA0OCB8fCBjYW5ub3RfYmVfZGlnaXQgPiA1NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0KHNpZ25hbF9lb2YsIGluX3N0cmluZykge1xuICAgICAgICB2YXIgY2ggPSBnZXRfZnVsbF9jaGFyKFMudGV4dCwgUy5wb3MrKyk7XG4gICAgICAgIGlmIChzaWduYWxfZW9mICYmICFjaClcbiAgICAgICAgICAgIHRocm93IEVYX0VPRjtcbiAgICAgICAgaWYgKE5FV0xJTkVfQ0hBUlMuaGFzKGNoKSkge1xuICAgICAgICAgICAgUy5uZXdsaW5lX2JlZm9yZSA9IFMubmV3bGluZV9iZWZvcmUgfHwgIWluX3N0cmluZztcbiAgICAgICAgICAgICsrUy5saW5lO1xuICAgICAgICAgICAgUy5jb2wgPSAwO1xuICAgICAgICAgICAgaWYgKGNoID09IFwiXFxyXCIgJiYgcGVlaygpID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAvLyB0cmVhdCBhIFxcclxcbiBzZXF1ZW5jZSBhcyBhIHNpbmdsZSBcXG5cbiAgICAgICAgICAgICAgICArK1MucG9zO1xuICAgICAgICAgICAgICAgIGNoID0gXCJcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgKytTLnBvcztcbiAgICAgICAgICAgICAgICArK1MuY29sO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytTLmNvbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9yd2FyZChpKSB7XG4gICAgICAgIHdoaWxlIChpLS0pIG5leHQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29raW5nX2F0KHN0cikge1xuICAgICAgICByZXR1cm4gUy50ZXh0LnN1YnN0cihTLnBvcywgc3RyLmxlbmd0aCkgPT0gc3RyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRfZW9sKCkge1xuICAgICAgICB2YXIgdGV4dCA9IFMudGV4dDtcbiAgICAgICAgZm9yICh2YXIgaSA9IFMucG9zLCBuID0gUy50ZXh0Lmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgdmFyIGNoID0gdGV4dFtpXTtcbiAgICAgICAgICAgIGlmIChORVdMSU5FX0NIQVJTLmhhcyhjaCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmQod2hhdCwgc2lnbmFsX2VvZikge1xuICAgICAgICB2YXIgcG9zID0gUy50ZXh0LmluZGV4T2Yod2hhdCwgUy5wb3MpO1xuICAgICAgICBpZiAoc2lnbmFsX2VvZiAmJiBwb3MgPT0gLTEpIHRocm93IEVYX0VPRjtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydF90b2tlbigpIHtcbiAgICAgICAgUy50b2tsaW5lID0gUy5saW5lO1xuICAgICAgICBTLnRva2NvbCA9IFMuY29sO1xuICAgICAgICBTLnRva3BvcyA9IFMucG9zO1xuICAgIH1cblxuICAgIHZhciBwcmV2X3dhc19kb3QgPSBmYWxzZTtcbiAgICB2YXIgcHJldmlvdXNfdG9rZW4gPSBudWxsO1xuICAgIGZ1bmN0aW9uIHRva2VuKHR5cGUsIHZhbHVlLCBpc19jb21tZW50KSB7XG4gICAgICAgIFMucmVnZXhfYWxsb3dlZCA9ICgodHlwZSA9PSBcIm9wZXJhdG9yXCIgJiYgIVVOQVJZX1BPU1RGSVguaGFzKHZhbHVlKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlID09IFwia2V5d29yZFwiICYmIEtFWVdPUkRTX0JFRk9SRV9FWFBSRVNTSU9OLmhhcyh2YWx1ZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZSA9PSBcInB1bmNcIiAmJiBQVU5DX0JFRk9SRV9FWFBSRVNTSU9OLmhhcyh2YWx1ZSkpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGUgPT0gXCJhcnJvd1wiKTtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJwdW5jXCIgJiYgKHZhbHVlID09IFwiLlwiIHx8IHZhbHVlID09IFwiPy5cIikpIHtcbiAgICAgICAgICAgIHByZXZfd2FzX2RvdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzX2NvbW1lbnQpIHtcbiAgICAgICAgICAgIHByZXZfd2FzX2RvdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmUgICAgID0gUy50b2tsaW5lO1xuICAgICAgICBjb25zdCBjb2wgICAgICA9IFMudG9rY29sO1xuICAgICAgICBjb25zdCBwb3MgICAgICA9IFMudG9rcG9zO1xuICAgICAgICBjb25zdCBubGIgICAgICA9IFMubmV3bGluZV9iZWZvcmU7XG4gICAgICAgIGNvbnN0IGZpbGUgICAgID0gZmlsZW5hbWU7XG4gICAgICAgIGxldCBjb21tZW50c19iZWZvcmUgPSBbXTtcbiAgICAgICAgbGV0IGNvbW1lbnRzX2FmdGVyICA9IFtdO1xuXG4gICAgICAgIGlmICghaXNfY29tbWVudCkge1xuICAgICAgICAgICAgY29tbWVudHNfYmVmb3JlID0gUy5jb21tZW50c19iZWZvcmU7XG4gICAgICAgICAgICBjb21tZW50c19hZnRlciA9IFMuY29tbWVudHNfYmVmb3JlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgUy5uZXdsaW5lX2JlZm9yZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0b2sgPSBuZXcgQVNUX1Rva2VuKHR5cGUsIHZhbHVlLCBsaW5lLCBjb2wsIHBvcywgbmxiLCBjb21tZW50c19iZWZvcmUsIGNvbW1lbnRzX2FmdGVyLCBmaWxlKTtcblxuICAgICAgICBpZiAoIWlzX2NvbW1lbnQpIHByZXZpb3VzX3Rva2VuID0gdG9rO1xuICAgICAgICByZXR1cm4gdG9rO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNraXBfd2hpdGVzcGFjZSgpIHtcbiAgICAgICAgd2hpbGUgKFdISVRFU1BBQ0VfQ0hBUlMuaGFzKHBlZWsoKSkpXG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZF93aGlsZShwcmVkKSB7XG4gICAgICAgIHZhciByZXQgPSBcIlwiLCBjaCwgaSA9IDA7XG4gICAgICAgIHdoaWxlICgoY2ggPSBwZWVrKCkpICYmIHByZWQoY2gsIGkrKykpXG4gICAgICAgICAgICByZXQgKz0gbmV4dCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlX2Vycm9yKGVycikge1xuICAgICAgICBqc19lcnJvcihlcnIsIGZpbGVuYW1lLCBTLnRva2xpbmUsIFMudG9rY29sLCBTLnRva3Bvcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZF9udW0ocHJlZml4KSB7XG4gICAgICAgIHZhciBoYXNfZSA9IGZhbHNlLCBhZnRlcl9lID0gZmFsc2UsIGhhc194ID0gZmFsc2UsIGhhc19kb3QgPSBwcmVmaXggPT0gXCIuXCIsIGlzX2JpZ19pbnQgPSBmYWxzZSwgbnVtZXJpY19zZXBhcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIG51bSA9IHJlYWRfd2hpbGUoZnVuY3Rpb24oY2gsIGkpIHtcbiAgICAgICAgICAgIGlmIChpc19iaWdfaW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBjb2RlID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk1OiAvLyBfXG4gICAgICAgICAgICAgICAgcmV0dXJuIChudW1lcmljX3NlcGFyYXRvciA9IHRydWUpO1xuICAgICAgICAgICAgICBjYXNlIDk4OiBjYXNlIDY2OiAvLyBiQlxuICAgICAgICAgICAgICAgIHJldHVybiAoaGFzX3ggPSB0cnVlKTsgLy8gQ2FuIG9jY3VyIGluIGhleCBzZXF1ZW5jZSwgZG9uJ3QgcmV0dXJuIGZhbHNlIHlldFxuICAgICAgICAgICAgICBjYXNlIDExMTogY2FzZSA3OTogLy8gb09cbiAgICAgICAgICAgICAgY2FzZSAxMjA6IGNhc2UgODg6IC8vIHhYXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc194ID8gZmFsc2UgOiAoaGFzX3ggPSB0cnVlKTtcbiAgICAgICAgICAgICAgY2FzZSAxMDE6IGNhc2UgNjk6IC8vIGVFXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc194ID8gdHJ1ZSA6IGhhc19lID8gZmFsc2UgOiAoaGFzX2UgPSBhZnRlcl9lID0gdHJ1ZSk7XG4gICAgICAgICAgICAgIGNhc2UgNDU6IC8vIC1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXJfZSB8fCAoaSA9PSAwICYmICFwcmVmaXgpO1xuICAgICAgICAgICAgICBjYXNlIDQzOiAvLyArXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyX2U7XG4gICAgICAgICAgICAgIGNhc2UgKGFmdGVyX2UgPSBmYWxzZSwgNDYpOiAvLyAuXG4gICAgICAgICAgICAgICAgcmV0dXJuICghaGFzX2RvdCAmJiAhaGFzX3ggJiYgIWhhc19lKSA/IChoYXNfZG90ID0gdHJ1ZSkgOiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoID09PSBcIm5cIikge1xuICAgICAgICAgICAgICAgIGlzX2JpZ19pbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBSRV9OVU1fTElURVJBTC50ZXN0KGNoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwcmVmaXgpIG51bSA9IHByZWZpeCArIG51bTtcblxuICAgICAgICBMQVRFU1RfUkFXID0gbnVtO1xuXG4gICAgICAgIGlmIChSRV9PQ1RfTlVNQkVSLnRlc3QobnVtKSAmJiBuZXh0X3Rva2VuLmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpKSB7XG4gICAgICAgICAgICBwYXJzZV9lcnJvcihcIkxlZ2FjeSBvY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bWVyaWNfc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBpZiAobnVtLmVuZHNXaXRoKFwiX1wiKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiTnVtZXJpYyBzZXBhcmF0b3JzIGFyZSBub3QgYWxsb3dlZCBhdCB0aGUgZW5kIG9mIG51bWVyaWMgbGl0ZXJhbHNcIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bS5pbmNsdWRlcyhcIl9fXCIpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJPbmx5IG9uZSB1bmRlcnNjb3JlIGlzIGFsbG93ZWQgYXMgbnVtZXJpYyBzZXBhcmF0b3JcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW0gPSBudW0ucmVwbGFjZSgvXy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtLmVuZHNXaXRoKFwiblwiKSkge1xuICAgICAgICAgICAgY29uc3Qgd2l0aG91dF9uID0gbnVtLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93X2UgPSBSRV9IRVhfTlVNQkVSLnRlc3Qod2l0aG91dF9uKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gcGFyc2VfanNfbnVtYmVyKHdpdGhvdXRfbiwgYWxsb3dfZSk7XG4gICAgICAgICAgICBpZiAoIWhhc19kb3QgJiYgUkVfQklHX0lOVC50ZXN0KG51bSkgJiYgIWlzTmFOKHZhbGlkKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW4oXCJiaWdfaW50XCIsIHdpdGhvdXRfbik7XG4gICAgICAgICAgICBwYXJzZV9lcnJvcihcIkludmFsaWQgb3IgdW5leHBlY3RlZCB0b2tlblwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsaWQgPSBwYXJzZV9qc19udW1iZXIobnVtKTtcbiAgICAgICAgaWYgKCFpc05hTih2YWxpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbihcIm51bVwiLCB2YWxpZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJzZV9lcnJvcihcIkludmFsaWQgc3ludGF4OiBcIiArIG51bSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc19vY3RhbChjaCkge1xuICAgICAgICByZXR1cm4gY2ggPj0gXCIwXCIgJiYgY2ggPD0gXCI3XCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZF9lc2NhcGVkX2NoYXIoaW5fc3RyaW5nLCBzdHJpY3RfaGV4LCB0ZW1wbGF0ZV9zdHJpbmcpIHtcbiAgICAgICAgdmFyIGNoID0gbmV4dCh0cnVlLCBpbl9zdHJpbmcpO1xuICAgICAgICBzd2l0Y2ggKGNoLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICBjYXNlIDExMCA6IHJldHVybiBcIlxcblwiO1xuICAgICAgICAgIGNhc2UgMTE0IDogcmV0dXJuIFwiXFxyXCI7XG4gICAgICAgICAgY2FzZSAxMTYgOiByZXR1cm4gXCJcXHRcIjtcbiAgICAgICAgICBjYXNlIDk4ICA6IHJldHVybiBcIlxcYlwiO1xuICAgICAgICAgIGNhc2UgMTE4IDogcmV0dXJuIFwiXFx1MDAwYlwiOyAvLyBcXHZcbiAgICAgICAgICBjYXNlIDEwMiA6IHJldHVybiBcIlxcZlwiO1xuICAgICAgICAgIGNhc2UgMTIwIDogcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaGV4X2J5dGVzKDIsIHN0cmljdF9oZXgpKTsgLy8gXFx4XG4gICAgICAgICAgY2FzZSAxMTcgOiAvLyBcXHVcbiAgICAgICAgICAgIGlmIChwZWVrKCkgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICBuZXh0KHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgPT09IFwifVwiKVxuICAgICAgICAgICAgICAgICAgICBwYXJzZV9lcnJvcihcIkV4cGVjdGluZyBoZXgtY2hhcmFjdGVyIGJldHdlZW4ge31cIik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBlZWsoKSA9PSBcIjBcIikgbmV4dCh0cnVlKTsgLy8gTm8gc2lnbmlmaWNhbmNlXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCwgbGVuZ3RoID0gZmluZChcIn1cIiwgdHJ1ZSkgLSBTLnBvcztcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCAzMiBiaXQgaW50ZWdlciBvdmVyZmxvdyAoMSA8PCAzMiA9PT0gMSlcbiAgICAgICAgICAgICAgICAvLyBXZSBrbm93IGZpcnN0IGNoYXJhY3RlciBpc24ndCAwIGFuZCB0aHVzIG91dCBvZiByYW5nZSBhbnl3YXlcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gNiB8fCAocmVzdWx0ID0gaGV4X2J5dGVzKGxlbmd0aCwgc3RyaWN0X2hleCkpID4gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJVbmljb2RlIHJlZmVyZW5jZSBvdXQgb2YgYm91bmRzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tX2NoYXJfY29kZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoaGV4X2J5dGVzKDQsIHN0cmljdF9oZXgpKTtcbiAgICAgICAgICBjYXNlIDEwICA6IHJldHVybiBcIlwiOyAvLyBuZXdsaW5lXG4gICAgICAgICAgY2FzZSAxMyAgOiAgICAgICAgICAgIC8vIFxcclxuICAgICAgICAgICAgaWYgKHBlZWsoKSA9PSBcIlxcblwiKSB7IC8vIERPUyBuZXdsaW5lXG4gICAgICAgICAgICAgICAgbmV4dCh0cnVlLCBpbl9zdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc19vY3RhbChjaCkpIHtcbiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZV9zdHJpbmcgJiYgc3RyaWN0X2hleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcHJlc2VudHNfbnVsbF9jaGFyYWN0ZXIgPSBjaCA9PT0gXCIwXCIgJiYgIWlzX29jdGFsKHBlZWsoKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXByZXNlbnRzX251bGxfY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiT2N0YWwgZXNjYXBlIHNlcXVlbmNlcyBhcmUgbm90IGFsbG93ZWQgaW4gdGVtcGxhdGUgc3RyaW5nc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVhZF9vY3RhbF9lc2NhcGVfc2VxdWVuY2UoY2gsIHN0cmljdF9oZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkX29jdGFsX2VzY2FwZV9zZXF1ZW5jZShjaCwgc3RyaWN0X29jdGFsKSB7XG4gICAgICAgIC8vIFJlYWRcbiAgICAgICAgdmFyIHAgPSBwZWVrKCk7XG4gICAgICAgIGlmIChwID49IFwiMFwiICYmIHAgPD0gXCI3XCIpIHtcbiAgICAgICAgICAgIGNoICs9IG5leHQodHJ1ZSk7XG4gICAgICAgICAgICBpZiAoY2hbMF0gPD0gXCIzXCIgJiYgKHAgPSBwZWVrKCkpID49IFwiMFwiICYmIHAgPD0gXCI3XCIpXG4gICAgICAgICAgICAgICAgY2ggKz0gbmV4dCh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcnNlXG4gICAgICAgIGlmIChjaCA9PT0gXCIwXCIpIHJldHVybiBcIlxcMFwiO1xuICAgICAgICBpZiAoY2gubGVuZ3RoID4gMCAmJiBuZXh0X3Rva2VuLmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpICYmIHN0cmljdF9vY3RhbClcbiAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiTGVnYWN5IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZXMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlXCIpO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjaCwgOCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhleF9ieXRlcyhuLCBzdHJpY3RfaGV4KSB7XG4gICAgICAgIHZhciBudW0gPSAwO1xuICAgICAgICBmb3IgKDsgbiA+IDA7IC0tbikge1xuICAgICAgICAgICAgaWYgKCFzdHJpY3RfaGV4ICYmIGlzTmFOKHBhcnNlSW50KHBlZWsoKSwgMTYpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChudW0sIDE2KSB8fCBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRpZ2l0ID0gbmV4dCh0cnVlKTtcbiAgICAgICAgICAgIGlmIChpc05hTihwYXJzZUludChkaWdpdCwgMTYpKSlcbiAgICAgICAgICAgICAgICBwYXJzZV9lcnJvcihcIkludmFsaWQgaGV4LWNoYXJhY3RlciBwYXR0ZXJuIGluIHN0cmluZ1wiKTtcbiAgICAgICAgICAgIG51bSArPSBkaWdpdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtLCAxNik7XG4gICAgfVxuXG4gICAgdmFyIHJlYWRfc3RyaW5nID0gd2l0aF9lb2ZfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBzdGFydF9wb3MgPSBTLnBvcztcbiAgICAgICAgdmFyIHF1b3RlID0gbmV4dCgpLCByZXQgPSBbXTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgdmFyIGNoID0gbmV4dCh0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChjaCA9PSBcIlxcXFxcIikgY2ggPSByZWFkX2VzY2FwZWRfY2hhcih0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09IFwiXFxyXCIgfHwgY2ggPT0gXCJcXG5cIikgcGFyc2VfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gcXVvdGUpIGJyZWFrO1xuICAgICAgICAgICAgcmV0LnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b2sgPSB0b2tlbihcInN0cmluZ1wiLCByZXQuam9pbihcIlwiKSk7XG4gICAgICAgIExBVEVTVF9SQVcgPSBTLnRleHQuc2xpY2Uoc3RhcnRfcG9zLCBTLnBvcyk7XG4gICAgICAgIHRvay5xdW90ZSA9IHF1b3RlO1xuICAgICAgICByZXR1cm4gdG9rO1xuICAgIH0pO1xuXG4gICAgdmFyIHJlYWRfdGVtcGxhdGVfY2hhcmFjdGVycyA9IHdpdGhfZW9mX2Vycm9yKFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIsIGZ1bmN0aW9uKGJlZ2luKSB7XG4gICAgICAgIGlmIChiZWdpbikge1xuICAgICAgICAgICAgUy50ZW1wbGF0ZV9icmFjZXMucHVzaChTLmJyYWNlX2NvdW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb250ZW50ID0gXCJcIiwgcmF3ID0gXCJcIiwgY2gsIHRvaztcbiAgICAgICAgbmV4dCh0cnVlLCB0cnVlKTtcbiAgICAgICAgd2hpbGUgKChjaCA9IG5leHQodHJ1ZSwgdHJ1ZSkpICE9IFwiYFwiKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT0gXCJcXHJcIikge1xuICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgPT0gXCJcXG5cIikgKytTLnBvcztcbiAgICAgICAgICAgICAgICBjaCA9IFwiXFxuXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiJFwiICYmIHBlZWsoKSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAgIG5leHQodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgUy5icmFjZV9jb3VudGVyKys7XG4gICAgICAgICAgICAgICAgdG9rID0gdG9rZW4oYmVnaW4gPyBcInRlbXBsYXRlX2hlYWRcIiA6IFwidGVtcGxhdGVfc3Vic3RpdHV0aW9uXCIsIGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIExBVEVTVF9SQVcgPSByYXc7XG4gICAgICAgICAgICAgICAgTEFURVNUX1RFTVBMQVRFX0VORCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2s7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJhdyArPSBjaDtcbiAgICAgICAgICAgIGlmIChjaCA9PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBTLnBvcztcbiAgICAgICAgICAgICAgICB2YXIgcHJldl9pc190YWcgPSBwcmV2aW91c190b2tlbiAmJiAocHJldmlvdXNfdG9rZW4udHlwZSA9PT0gXCJuYW1lXCIgfHwgcHJldmlvdXNfdG9rZW4udHlwZSA9PT0gXCJwdW5jXCIgJiYgKHByZXZpb3VzX3Rva2VuLnZhbHVlID09PSBcIilcIiB8fCBwcmV2aW91c190b2tlbi52YWx1ZSA9PT0gXCJdXCIpKTtcbiAgICAgICAgICAgICAgICBjaCA9IHJlYWRfZXNjYXBlZF9jaGFyKHRydWUsICFwcmV2X2lzX3RhZywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmF3ICs9IFMudGV4dC5zdWJzdHIodG1wLCBTLnBvcyAtIHRtcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRlbnQgKz0gY2g7XG4gICAgICAgIH1cbiAgICAgICAgUy50ZW1wbGF0ZV9icmFjZXMucG9wKCk7XG4gICAgICAgIHRvayA9IHRva2VuKGJlZ2luID8gXCJ0ZW1wbGF0ZV9oZWFkXCIgOiBcInRlbXBsYXRlX3N1YnN0aXR1dGlvblwiLCBjb250ZW50KTtcbiAgICAgICAgTEFURVNUX1JBVyA9IHJhdztcbiAgICAgICAgTEFURVNUX1RFTVBMQVRFX0VORCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2s7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBza2lwX2xpbmVfY29tbWVudCh0eXBlKSB7XG4gICAgICAgIHZhciByZWdleF9hbGxvd2VkID0gUy5yZWdleF9hbGxvd2VkO1xuICAgICAgICB2YXIgaSA9IGZpbmRfZW9sKCksIHJldDtcbiAgICAgICAgaWYgKGkgPT0gLTEpIHtcbiAgICAgICAgICAgIHJldCA9IFMudGV4dC5zdWJzdHIoUy5wb3MpO1xuICAgICAgICAgICAgUy5wb3MgPSBTLnRleHQubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gUy50ZXh0LnN1YnN0cmluZyhTLnBvcywgaSk7XG4gICAgICAgICAgICBTLnBvcyA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgUy5jb2wgPSBTLnRva2NvbCArIChTLnBvcyAtIFMudG9rcG9zKTtcbiAgICAgICAgUy5jb21tZW50c19iZWZvcmUucHVzaCh0b2tlbih0eXBlLCByZXQsIHRydWUpKTtcbiAgICAgICAgUy5yZWdleF9hbGxvd2VkID0gcmVnZXhfYWxsb3dlZDtcbiAgICAgICAgcmV0dXJuIG5leHRfdG9rZW47XG4gICAgfVxuXG4gICAgdmFyIHNraXBfbXVsdGlsaW5lX2NvbW1lbnQgPSB3aXRoX2VvZl9lcnJvcihcIlVudGVybWluYXRlZCBtdWx0aWxpbmUgY29tbWVudFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlZ2V4X2FsbG93ZWQgPSBTLnJlZ2V4X2FsbG93ZWQ7XG4gICAgICAgIHZhciBpID0gZmluZChcIiovXCIsIHRydWUpO1xuICAgICAgICB2YXIgdGV4dCA9IFMudGV4dC5zdWJzdHJpbmcoUy5wb3MsIGkpLnJlcGxhY2UoL1xcclxcbnxcXHJ8XFx1MjAyOHxcXHUyMDI5L2csIFwiXFxuXCIpO1xuICAgICAgICAvLyB1cGRhdGUgc3RyZWFtIHBvc2l0aW9uXG4gICAgICAgIGZvcndhcmQoZ2V0X2Z1bGxfY2hhcl9sZW5ndGgodGV4dCkgLyogdGV4dCBsZW5ndGggZG9lc24ndCBjb3VudCBcXHJcXG4gYXMgMiBjaGFyIHdoaWxlIFMucG9zIC0gaSBkb2VzICovICsgMik7XG4gICAgICAgIFMuY29tbWVudHNfYmVmb3JlLnB1c2godG9rZW4oXCJjb21tZW50MlwiLCB0ZXh0LCB0cnVlKSk7XG4gICAgICAgIFMubmV3bGluZV9iZWZvcmUgPSBTLm5ld2xpbmVfYmVmb3JlIHx8IHRleHQuaW5jbHVkZXMoXCJcXG5cIik7XG4gICAgICAgIFMucmVnZXhfYWxsb3dlZCA9IHJlZ2V4X2FsbG93ZWQ7XG4gICAgICAgIHJldHVybiBuZXh0X3Rva2VuO1xuICAgIH0pO1xuXG4gICAgdmFyIHJlYWRfbmFtZSA9IHdpdGhfZW9mX2Vycm9yKFwiVW50ZXJtaW5hdGVkIGlkZW50aWZpZXIgbmFtZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBbXSwgY2gsIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJlYWRfZXNjYXBlZF9pZGVudGlmaWVyX2NoYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgaWYgKHBlZWsoKSAhPT0gXCJ1XCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZV9lcnJvcihcIkV4cGVjdGluZyBVbmljb2RlRXNjYXBlU2VxdWVuY2UgLS0gdVhYWFggb3IgdXtYWFhYfVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWFkX2VzY2FwZWRfY2hhcihmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVhZCBmaXJzdCBjaGFyYWN0ZXIgKElEX1N0YXJ0KVxuICAgICAgICBpZiAoKGNoID0gcGVlaygpKSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIGNoID0gcmVhZF9lc2NhcGVkX2lkZW50aWZpZXJfY2hhcigpO1xuICAgICAgICAgICAgaWYgKCFpc19pZGVudGlmaWVyX3N0YXJ0KGNoKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlX2Vycm9yKFwiRmlyc3QgaWRlbnRpZmllciBjaGFyIGlzIGFuIGludmFsaWQgaWRlbnRpZmllciBjaGFyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzX2lkZW50aWZpZXJfc3RhcnQoY2gpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUucHVzaChjaCk7XG5cbiAgICAgICAgLy8gUmVhZCBJRF9Db250aW51ZVxuICAgICAgICB3aGlsZSAoKGNoID0gcGVlaygpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKGNoID0gcGVlaygpKSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICBjaCA9IHJlYWRfZXNjYXBlZF9pZGVudGlmaWVyX2NoYXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzX2lkZW50aWZpZXJfY2hhcihjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJJbnZhbGlkIGVzY2FwZWQgaWRlbnRpZmllciBjaGFyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc19pZGVudGlmaWVyX2NoYXIoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWVfc3RyID0gbmFtZS5qb2luKFwiXCIpO1xuICAgICAgICBpZiAoUkVTRVJWRURfV09SRFMuaGFzKG5hbWVfc3RyKSAmJiBlc2NhcGVkKSB7XG4gICAgICAgICAgICBwYXJzZV9lcnJvcihcIkVzY2FwZWQgY2hhcmFjdGVycyBhcmUgbm90IGFsbG93ZWQgaW4ga2V5d29yZHNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWVfc3RyO1xuICAgIH0pO1xuXG4gICAgdmFyIHJlYWRfcmVnZXhwID0gd2l0aF9lb2ZfZXJyb3IoXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIsIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICB2YXIgcHJldl9iYWNrc2xhc2ggPSBmYWxzZSwgY2gsIGluX2NsYXNzID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICgoY2ggPSBuZXh0KHRydWUpKSkgaWYgKE5FV0xJTkVfQ0hBUlMuaGFzKGNoKSkge1xuICAgICAgICAgICAgcGFyc2VfZXJyb3IoXCJVbmV4cGVjdGVkIGxpbmUgdGVybWluYXRvclwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2X2JhY2tzbGFzaCkge1xuICAgICAgICAgICAgc291cmNlICs9IFwiXFxcXFwiICsgY2g7XG4gICAgICAgICAgICBwcmV2X2JhY2tzbGFzaCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09IFwiW1wiKSB7XG4gICAgICAgICAgICBpbl9jbGFzcyA9IHRydWU7XG4gICAgICAgICAgICBzb3VyY2UgKz0gY2g7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJdXCIgJiYgaW5fY2xhc3MpIHtcbiAgICAgICAgICAgIGluX2NsYXNzID0gZmFsc2U7XG4gICAgICAgICAgICBzb3VyY2UgKz0gY2g7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIvXCIgJiYgIWluX2NsYXNzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgcHJldl9iYWNrc2xhc2ggPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlICs9IGNoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYWdzID0gcmVhZF9uYW1lKCk7XG4gICAgICAgIHJldHVybiB0b2tlbihcInJlZ2V4cFwiLCBcIi9cIiArIHNvdXJjZSArIFwiL1wiICsgZmxhZ3MpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcmVhZF9vcGVyYXRvcihwcmVmaXgpIHtcbiAgICAgICAgZnVuY3Rpb24gZ3JvdyhvcCkge1xuICAgICAgICAgICAgaWYgKCFwZWVrKCkpIHJldHVybiBvcDtcbiAgICAgICAgICAgIHZhciBiaWdnZXIgPSBvcCArIHBlZWsoKTtcbiAgICAgICAgICAgIGlmIChPUEVSQVRPUlMuaGFzKGJpZ2dlcikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3coYmlnZ2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbihcIm9wZXJhdG9yXCIsIGdyb3cocHJlZml4IHx8IG5leHQoKSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9zbGFzaCgpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBzd2l0Y2ggKHBlZWsoKSkge1xuICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gc2tpcF9saW5lX2NvbW1lbnQoXCJjb21tZW50MVwiKTtcbiAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNraXBfbXVsdGlsaW5lX2NvbW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUy5yZWdleF9hbGxvd2VkID8gcmVhZF9yZWdleHAoXCJcIikgOiByZWFkX29wZXJhdG9yKFwiL1wiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVfZXFfc2lnbigpIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICBpZiAocGVlaygpID09PSBcIj5cIikge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwiYXJyb3dcIiwgXCI9PlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkX29wZXJhdG9yKFwiPVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9kb3QoKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgaWYgKGlzX2RpZ2l0KHBlZWsoKS5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRfbnVtKFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVlaygpID09PSBcIi5cIikge1xuICAgICAgICAgICAgbmV4dCgpOyAgLy8gQ29uc3VtZSBzZWNvbmQgZG90XG4gICAgICAgICAgICBuZXh0KCk7ICAvLyBDb25zdW1lIHRoaXJkIGRvdFxuICAgICAgICAgICAgcmV0dXJuIHRva2VuKFwiZXhwYW5kXCIsIFwiLi4uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuKFwicHVuY1wiLCBcIi5cIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZF93b3JkKCkge1xuICAgICAgICB2YXIgd29yZCA9IHJlYWRfbmFtZSgpO1xuICAgICAgICBpZiAocHJldl93YXNfZG90KSByZXR1cm4gdG9rZW4oXCJuYW1lXCIsIHdvcmQpO1xuICAgICAgICByZXR1cm4gS0VZV09SRFNfQVRPTS5oYXMod29yZCkgPyB0b2tlbihcImF0b21cIiwgd29yZClcbiAgICAgICAgICAgIDogIUtFWVdPUkRTLmhhcyh3b3JkKSA/IHRva2VuKFwibmFtZVwiLCB3b3JkKVxuICAgICAgICAgICAgOiBPUEVSQVRPUlMuaGFzKHdvcmQpID8gdG9rZW4oXCJvcGVyYXRvclwiLCB3b3JkKVxuICAgICAgICAgICAgOiB0b2tlbihcImtleXdvcmRcIiwgd29yZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZF9wcml2YXRlX3dvcmQoKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuKFwicHJpdmF0ZW5hbWVcIiwgcmVhZF9uYW1lKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpdGhfZW9mX2Vycm9yKGVvZl9lcnJvciwgY29udCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udCh4KTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXggPT09IEVYX0VPRikgcGFyc2VfZXJyb3IoZW9mX2Vycm9yKTtcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHRfdG9rZW4oZm9yY2VfcmVnZXhwKSB7XG4gICAgICAgIGlmIChmb3JjZV9yZWdleHAgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiByZWFkX3JlZ2V4cChmb3JjZV9yZWdleHApO1xuICAgICAgICBpZiAoc2hlYmFuZyAmJiBTLnBvcyA9PSAwICYmIGxvb2tpbmdfYXQoXCIjIVwiKSkge1xuICAgICAgICAgICAgc3RhcnRfdG9rZW4oKTtcbiAgICAgICAgICAgIGZvcndhcmQoMik7XG4gICAgICAgICAgICBza2lwX2xpbmVfY29tbWVudChcImNvbW1lbnQ1XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHNraXBfd2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgc3RhcnRfdG9rZW4oKTtcbiAgICAgICAgICAgIGlmIChodG1sNV9jb21tZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChsb29raW5nX2F0KFwiPCEtLVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkKDQpO1xuICAgICAgICAgICAgICAgICAgICBza2lwX2xpbmVfY29tbWVudChcImNvbW1lbnQzXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxvb2tpbmdfYXQoXCItLT5cIikgJiYgUy5uZXdsaW5lX2JlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3J3YXJkKDMpO1xuICAgICAgICAgICAgICAgICAgICBza2lwX2xpbmVfY29tbWVudChcImNvbW1lbnQ0XCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2ggPSBwZWVrKCk7XG4gICAgICAgICAgICBpZiAoIWNoKSByZXR1cm4gdG9rZW4oXCJlb2ZcIik7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAzNDogY2FzZSAzOTogcmV0dXJuIHJlYWRfc3RyaW5nKCk7XG4gICAgICAgICAgICAgIGNhc2UgNDY6IHJldHVybiBoYW5kbGVfZG90KCk7XG4gICAgICAgICAgICAgIGNhc2UgNDc6IHtcbiAgICAgICAgICAgICAgICAgIHZhciB0b2sgPSBoYW5kbGVfc2xhc2goKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0b2sgPT09IG5leHRfdG9rZW4pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDYxOiByZXR1cm4gaGFuZGxlX2VxX3NpZ24oKTtcbiAgICAgICAgICAgICAgY2FzZSA2Mzoge1xuICAgICAgICAgICAgICAgICAgaWYgKCFpc19vcHRpb25fY2hhaW5fb3AoKSkgYnJlYWs7ICAvLyBIYW5kbGVkIGJlbG93XG5cbiAgICAgICAgICAgICAgICAgIG5leHQoKTsgLy8gP1xuICAgICAgICAgICAgICAgICAgbmV4dCgpOyAvLyAuXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbihcInB1bmNcIiwgXCI/LlwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDk2OiByZXR1cm4gcmVhZF90ZW1wbGF0ZV9jaGFyYWN0ZXJzKHRydWUpO1xuICAgICAgICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICAgICAgICBTLmJyYWNlX2NvdW50ZXIrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgICAgICAgUy5icmFjZV9jb3VudGVyLS07XG4gICAgICAgICAgICAgICAgaWYgKFMudGVtcGxhdGVfYnJhY2VzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICAgJiYgUy50ZW1wbGF0ZV9icmFjZXNbUy50ZW1wbGF0ZV9icmFjZXMubGVuZ3RoIC0gMV0gPT09IFMuYnJhY2VfY291bnRlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRfdGVtcGxhdGVfY2hhcmFjdGVycyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNfZGlnaXQoY29kZSkpIHJldHVybiByZWFkX251bSgpO1xuICAgICAgICAgICAgaWYgKFBVTkNfQ0hBUlMuaGFzKGNoKSkgcmV0dXJuIHRva2VuKFwicHVuY1wiLCBuZXh0KCkpO1xuICAgICAgICAgICAgaWYgKE9QRVJBVE9SX0NIQVJTLmhhcyhjaCkpIHJldHVybiByZWFkX29wZXJhdG9yKCk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PSA5MiB8fCBpc19pZGVudGlmaWVyX3N0YXJ0KGNoKSkgcmV0dXJuIHJlYWRfd29yZCgpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT0gMzUpIHJldHVybiByZWFkX3ByaXZhdGVfd29yZCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VfZXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICB9XG5cbiAgICBuZXh0X3Rva2VuLm5leHQgPSBuZXh0O1xuICAgIG5leHRfdG9rZW4ucGVlayA9IHBlZWs7XG5cbiAgICBuZXh0X3Rva2VuLmNvbnRleHQgPSBmdW5jdGlvbihuYykge1xuICAgICAgICBpZiAobmMpIFMgPSBuYztcbiAgICAgICAgcmV0dXJuIFM7XG4gICAgfTtcblxuICAgIG5leHRfdG9rZW4uYWRkX2RpcmVjdGl2ZSA9IGZ1bmN0aW9uKGRpcmVjdGl2ZSkge1xuICAgICAgICBTLmRpcmVjdGl2ZV9zdGFja1tTLmRpcmVjdGl2ZV9zdGFjay5sZW5ndGggLSAxXS5wdXNoKGRpcmVjdGl2ZSk7XG5cbiAgICAgICAgaWYgKFMuZGlyZWN0aXZlc1tkaXJlY3RpdmVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFMuZGlyZWN0aXZlc1tkaXJlY3RpdmVdID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFMuZGlyZWN0aXZlc1tkaXJlY3RpdmVdKys7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbmV4dF90b2tlbi5wdXNoX2RpcmVjdGl2ZXNfc3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgUy5kaXJlY3RpdmVfc3RhY2sucHVzaChbXSk7XG4gICAgfTtcblxuICAgIG5leHRfdG9rZW4ucG9wX2RpcmVjdGl2ZXNfc3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZXMgPSBTLmRpcmVjdGl2ZV9zdGFja1tTLmRpcmVjdGl2ZV9zdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcmVjdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIFMuZGlyZWN0aXZlc1tkaXJlY3RpdmVzW2ldXS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgUy5kaXJlY3RpdmVfc3RhY2sucG9wKCk7XG4gICAgfTtcblxuICAgIG5leHRfdG9rZW4uaGFzX2RpcmVjdGl2ZSA9IGZ1bmN0aW9uKGRpcmVjdGl2ZSkge1xuICAgICAgICByZXR1cm4gUy5kaXJlY3RpdmVzW2RpcmVjdGl2ZV0gPiAwO1xuICAgIH07XG5cbiAgICByZXR1cm4gbmV4dF90b2tlbjtcblxufVxuXG4vKiAtLS0tLVsgUGFyc2VyIChjb25zdGFudHMpIF0tLS0tLSAqL1xuXG52YXIgVU5BUllfUFJFRklYID0gbWFrZVByZWRpY2F0ZShbXG4gICAgXCJ0eXBlb2ZcIixcbiAgICBcInZvaWRcIixcbiAgICBcImRlbGV0ZVwiLFxuICAgIFwiLS1cIixcbiAgICBcIisrXCIsXG4gICAgXCIhXCIsXG4gICAgXCJ+XCIsXG4gICAgXCItXCIsXG4gICAgXCIrXCJcbl0pO1xuXG52YXIgVU5BUllfUE9TVEZJWCA9IG1ha2VQcmVkaWNhdGUoWyBcIi0tXCIsIFwiKytcIiBdKTtcblxudmFyIEFTU0lHTk1FTlQgPSBtYWtlUHJlZGljYXRlKFsgXCI9XCIsIFwiKz1cIiwgXCItPVwiLCBcIj8/PVwiLCBcIiYmPVwiLCBcInx8PVwiLCBcIi89XCIsIFwiKj1cIiwgXCIqKj1cIiwgXCIlPVwiLCBcIj4+PVwiLCBcIjw8PVwiLCBcIj4+Pj1cIiwgXCJ8PVwiLCBcIl49XCIsIFwiJj1cIiBdKTtcblxudmFyIExPR0lDQUxfQVNTSUdOTUVOVCA9IG1ha2VQcmVkaWNhdGUoWyBcIj8/PVwiLCBcIiYmPVwiLCBcInx8PVwiIF0pO1xuXG52YXIgUFJFQ0VERU5DRSA9IChmdW5jdGlvbihhLCByZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGIgPSBhW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHJldFtiW2pdXSA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59KShcbiAgICBbXG4gICAgICAgIFtcInx8XCJdLFxuICAgICAgICBbXCI/P1wiXSxcbiAgICAgICAgW1wiJiZcIl0sXG4gICAgICAgIFtcInxcIl0sXG4gICAgICAgIFtcIl5cIl0sXG4gICAgICAgIFtcIiZcIl0sXG4gICAgICAgIFtcIj09XCIsIFwiPT09XCIsIFwiIT1cIiwgXCIhPT1cIl0sXG4gICAgICAgIFtcIjxcIiwgXCI+XCIsIFwiPD1cIiwgXCI+PVwiLCBcImluXCIsIFwiaW5zdGFuY2VvZlwiXSxcbiAgICAgICAgW1wiPj5cIiwgXCI8PFwiLCBcIj4+PlwiXSxcbiAgICAgICAgW1wiK1wiLCBcIi1cIl0sXG4gICAgICAgIFtcIipcIiwgXCIvXCIsIFwiJVwiXSxcbiAgICAgICAgW1wiKipcIl1cbiAgICBdLFxuICAgIHt9XG4pO1xuXG52YXIgQVRPTUlDX1NUQVJUX1RPS0VOID0gbWFrZVByZWRpY2F0ZShbIFwiYXRvbVwiLCBcIm51bVwiLCBcImJpZ19pbnRcIiwgXCJzdHJpbmdcIiwgXCJyZWdleHBcIiwgXCJuYW1lXCIgXSk7XG5cbi8qIC0tLS0tWyBQYXJzZXIgXS0tLS0tICovXG5cbmZ1bmN0aW9uIHBhcnNlKCRURVhULCBvcHRpb25zKSB7XG4gICAgLy8gbWFwcyBzdGFydCB0b2tlbnMgdG8gY291bnQgb2YgY29tbWVudHMgZm91bmQgb3V0c2lkZSBvZiB0aGVpciBwYXJlbnNcbiAgICAvLyBFeGFtcGxlOiAvKiBJIGNvdW50ICovICggLyogSSBkb24ndCAqLyBmb28oKSApXG4gICAgLy8gVXNlZnVsIGJlY2F1c2UgY29tbWVudHNfYmVmb3JlIHByb3BlcnR5IG9mIGNhbGwgd2l0aCBwYXJlbnMgb3V0c2lkZVxuICAgIC8vIGNvbnRhaW5zIGJvdGggY29tbWVudHMgaW5zaWRlIGFuZCBvdXRzaWRlIHRoZXNlIHBhcmVucy4gVXNlZCB0byBmaW5kIHRoZVxuICAgIC8vIHJpZ2h0ICNfX1BVUkVfXyBjb21tZW50cyBmb3IgYW4gZXhwcmVzc2lvblxuICAgIGNvbnN0IG91dGVyX2NvbW1lbnRzX2JlZm9yZV9jb3VudHMgPSBuZXcgV2Vha01hcCgpO1xuXG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgYmFyZV9yZXR1cm5zICAgOiBmYWxzZSxcbiAgICAgICAgZWNtYSAgICAgICAgICAgOiBudWxsLCAgLy8gTGVnYWN5XG4gICAgICAgIGV4cHJlc3Npb24gICAgIDogZmFsc2UsXG4gICAgICAgIGZpbGVuYW1lICAgICAgIDogbnVsbCxcbiAgICAgICAgaHRtbDVfY29tbWVudHMgOiB0cnVlLFxuICAgICAgICBtb2R1bGUgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBzaGViYW5nICAgICAgICA6IHRydWUsXG4gICAgICAgIHN0cmljdCAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHRvcGxldmVsICAgICAgIDogbnVsbCxcbiAgICB9LCB0cnVlKTtcblxuICAgIHZhciBTID0ge1xuICAgICAgICBpbnB1dCAgICAgICAgIDogKHR5cGVvZiAkVEVYVCA9PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgPyB0b2tlbml6ZXIoJFRFWFQsIG9wdGlvbnMuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5odG1sNV9jb21tZW50cywgb3B0aW9ucy5zaGViYW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgIDogJFRFWFQpLFxuICAgICAgICB0b2tlbiAgICAgICAgIDogbnVsbCxcbiAgICAgICAgcHJldiAgICAgICAgICA6IG51bGwsXG4gICAgICAgIHBlZWtlZCAgICAgICAgOiBudWxsLFxuICAgICAgICBpbl9mdW5jdGlvbiAgIDogMCxcbiAgICAgICAgaW5fYXN5bmMgICAgICA6IC0xLFxuICAgICAgICBpbl9nZW5lcmF0b3IgIDogLTEsXG4gICAgICAgIGluX2RpcmVjdGl2ZXMgOiB0cnVlLFxuICAgICAgICBpbl9sb29wICAgICAgIDogMCxcbiAgICAgICAgbGFiZWxzICAgICAgICA6IFtdXG4gICAgfTtcblxuICAgIFMudG9rZW4gPSBuZXh0KCk7XG5cbiAgICBmdW5jdGlvbiBpcyh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNfdG9rZW4oUy50b2tlbiwgdHlwZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZWsoKSB7IHJldHVybiBTLnBlZWtlZCB8fCAoUy5wZWVrZWQgPSBTLmlucHV0KCkpOyB9XG5cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBTLnByZXYgPSBTLnRva2VuO1xuXG4gICAgICAgIGlmICghUy5wZWVrZWQpIHBlZWsoKTtcbiAgICAgICAgUy50b2tlbiA9IFMucGVla2VkO1xuICAgICAgICBTLnBlZWtlZCA9IG51bGw7XG4gICAgICAgIFMuaW5fZGlyZWN0aXZlcyA9IFMuaW5fZGlyZWN0aXZlcyAmJiAoXG4gICAgICAgICAgICBTLnRva2VuLnR5cGUgPT0gXCJzdHJpbmdcIiB8fCBpcyhcInB1bmNcIiwgXCI7XCIpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBTLnRva2VuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgIHJldHVybiBTLnByZXY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JvYWsobXNnLCBsaW5lLCBjb2wsIHBvcykge1xuICAgICAgICB2YXIgY3R4ID0gUy5pbnB1dC5jb250ZXh0KCk7XG4gICAgICAgIGpzX2Vycm9yKG1zZyxcbiAgICAgICAgICAgICAgICAgY3R4LmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICBsaW5lICE9IG51bGwgPyBsaW5lIDogY3R4LnRva2xpbmUsXG4gICAgICAgICAgICAgICAgIGNvbCAhPSBudWxsID8gY29sIDogY3R4LnRva2NvbCxcbiAgICAgICAgICAgICAgICAgcG9zICE9IG51bGwgPyBwb3MgOiBjdHgudG9rcG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b2tlbl9lcnJvcih0b2tlbiwgbXNnKSB7XG4gICAgICAgIGNyb2FrKG1zZywgdG9rZW4ubGluZSwgdG9rZW4uY29sKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmV4cGVjdGVkKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PSBudWxsKVxuICAgICAgICAgICAgdG9rZW4gPSBTLnRva2VuO1xuICAgICAgICB0b2tlbl9lcnJvcih0b2tlbiwgXCJVbmV4cGVjdGVkIHRva2VuOiBcIiArIHRva2VuLnR5cGUgKyBcIiAoXCIgKyB0b2tlbi52YWx1ZSArIFwiKVwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBlY3RfdG9rZW4odHlwZSwgdmFsKSB7XG4gICAgICAgIGlmIChpcyh0eXBlLCB2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHRva2VuX2Vycm9yKFMudG9rZW4sIFwiVW5leHBlY3RlZCB0b2tlbiBcIiArIFMudG9rZW4udHlwZSArIFwiIMKrXCIgKyBTLnRva2VuLnZhbHVlICsgXCLCu1wiICsgXCIsIGV4cGVjdGVkIFwiICsgdHlwZSArIFwiIMKrXCIgKyB2YWwgKyBcIsK7XCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGVjdChwdW5jKSB7IHJldHVybiBleHBlY3RfdG9rZW4oXCJwdW5jXCIsIHB1bmMpOyB9XG5cbiAgICBmdW5jdGlvbiBoYXNfbmV3bGluZV9iZWZvcmUodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLm5sYiB8fCAhdG9rZW4uY29tbWVudHNfYmVmb3JlLmV2ZXJ5KChjb21tZW50KSA9PiAhY29tbWVudC5ubGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbl9pbnNlcnRfc2VtaWNvbG9uKCkge1xuICAgICAgICByZXR1cm4gIW9wdGlvbnMuc3RyaWN0XG4gICAgICAgICAgICAmJiAoaXMoXCJlb2ZcIikgfHwgaXMoXCJwdW5jXCIsIFwifVwiKSB8fCBoYXNfbmV3bGluZV9iZWZvcmUoUy50b2tlbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX2luX2dlbmVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIFMuaW5fZ2VuZXJhdG9yID09PSBTLmluX2Z1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX2luX2FzeW5jKCkge1xuICAgICAgICByZXR1cm4gUy5pbl9hc3luYyA9PT0gUy5pbl9mdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5fYXdhaXQoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBTLmluX2FzeW5jID09PSBTLmluX2Z1bmN0aW9uXG4gICAgICAgICAgICB8fCBTLmluX2Z1bmN0aW9uID09PSAwICYmIFMuaW5wdXQuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIilcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZW1pY29sb24ob3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIjtcIikpIG5leHQoKTtcbiAgICAgICAgZWxzZSBpZiAoIW9wdGlvbmFsICYmICFjYW5faW5zZXJ0X3NlbWljb2xvbigpKSB1bmV4cGVjdGVkKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyZW50aGVzaXNlZCgpIHtcbiAgICAgICAgZXhwZWN0KFwiKFwiKTtcbiAgICAgICAgdmFyIGV4cCA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgIHJldHVybiBleHA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW1iZWRfdG9rZW5zKHBhcnNlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gX2VtYmVkX3Rva2Vuc193cmFwcGVyKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSBwYXJzZXIoLi4uYXJncyk7XG4gICAgICAgICAgICBleHByLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBleHByLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZV9yZWdleHAoKSB7XG4gICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiL1wiKSB8fCBpcyhcIm9wZXJhdG9yXCIsIFwiLz1cIikpIHtcbiAgICAgICAgICAgIFMucGVla2VkID0gbnVsbDtcbiAgICAgICAgICAgIFMudG9rZW4gPSBTLmlucHV0KFMudG9rZW4udmFsdWUuc3Vic3RyKDEpKTsgLy8gZm9yY2UgcmVnZXhwXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3RhdGVtZW50ID0gZW1iZWRfdG9rZW5zKGZ1bmN0aW9uIHN0YXRlbWVudChpc19leHBvcnRfZGVmYXVsdCwgaXNfZm9yX2JvZHksIGlzX2lmX2JvZHkpIHtcbiAgICAgICAgaGFuZGxlX3JlZ2V4cCgpO1xuICAgICAgICBzd2l0Y2ggKFMudG9rZW4udHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIGlmIChTLmluX2RpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBwZWVrKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFMQVRFU1RfUkFXLmluY2x1ZGVzKFwiXFxcXFwiKVxuICAgICAgICAgICAgICAgICAgICAmJiAoaXNfdG9rZW4odG9rZW4sIFwicHVuY1wiLCBcIjtcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGlzX3Rva2VuKHRva2VuLCBcInB1bmNcIiwgXCJ9XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBoYXNfbmV3bGluZV9iZWZvcmUodG9rZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBpc190b2tlbih0b2tlbiwgXCJlb2ZcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgIFMuaW5wdXQuYWRkX2RpcmVjdGl2ZShTLnRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBTLmluX2RpcmVjdGl2ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGlyID0gUy5pbl9kaXJlY3RpdmVzLCBzdGF0ID0gc2ltcGxlX3N0YXRlbWVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIGRpciAmJiBzdGF0LmJvZHkgaW5zdGFuY2VvZiBBU1RfU3RyaW5nID8gbmV3IEFTVF9EaXJlY3RpdmUoc3RhdC5ib2R5KSA6IHN0YXQ7XG4gICAgICAgICAgY2FzZSBcInRlbXBsYXRlX2hlYWRcIjpcbiAgICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgY2FzZSBcImJpZ19pbnRcIjpcbiAgICAgICAgICBjYXNlIFwicmVnZXhwXCI6XG4gICAgICAgICAgY2FzZSBcIm9wZXJhdG9yXCI6XG4gICAgICAgICAgY2FzZSBcImF0b21cIjpcbiAgICAgICAgICAgIHJldHVybiBzaW1wbGVfc3RhdGVtZW50KCk7XG5cbiAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgaWYgKFMudG9rZW4udmFsdWUgPT0gXCJhc3luY1wiICYmIGlzX3Rva2VuKHBlZWsoKSwgXCJrZXl3b3JkXCIsIFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChpc19mb3JfYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBjcm9hayhcImZ1bmN0aW9ucyBhcmUgbm90IGFsbG93ZWQgYXMgdGhlIGJvZHkgb2YgYSBsb29wXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25fKEFTVF9EZWZ1biwgZmFsc2UsIHRydWUsIGlzX2V4cG9ydF9kZWZhdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChTLnRva2VuLnZhbHVlID09IFwiaW1wb3J0XCIgJiYgIWlzX3Rva2VuKHBlZWsoKSwgXCJwdW5jXCIsIFwiKFwiKSAmJiAhaXNfdG9rZW4ocGVlaygpLCBcInB1bmNcIiwgXCIuXCIpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gaW1wb3J0XygpO1xuICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzX3Rva2VuKHBlZWsoKSwgXCJwdW5jXCIsIFwiOlwiKVxuICAgICAgICAgICAgICAgID8gbGFiZWxlZF9zdGF0ZW1lbnQoKVxuICAgICAgICAgICAgICAgIDogc2ltcGxlX3N0YXRlbWVudCgpO1xuXG4gICAgICAgICAgY2FzZSBcInB1bmNcIjpcbiAgICAgICAgICAgIHN3aXRjaCAoUy50b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0Jsb2NrU3RhdGVtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgOiBTLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICA6IGJsb2NrXygpLFxuICAgICAgICAgICAgICAgICAgICBlbmQgICA6IHByZXYoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGVfc3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgIGNhc2UgXCI7XCI6XG4gICAgICAgICAgICAgICAgUy5pbl9kaXJlY3RpdmVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0VtcHR5U3RhdGVtZW50KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICAgIHN3aXRjaCAoUy50b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiYnJlYWtcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyZWFrX2NvbnQoQVNUX0JyZWFrKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiY29udGludWVcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyZWFrX2NvbnQoQVNUX0NvbnRpbnVlKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZGVidWdnZXJcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVidWdnZXIoKTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZG9cIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBpbl9sb29wKHN0YXRlbWVudCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0X3Rva2VuKFwia2V5d29yZFwiLCBcIndoaWxlXCIpO1xuICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSBwYXJlbnRoZXNpc2VkKCk7XG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0RvKHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgICAgIDogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uIDogY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIndoaWxlXCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1doaWxlKHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uIDogcGFyZW50aGVzaXNlZCgpLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICAgICAgOiBpbl9sb29wKGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhdGVtZW50KGZhbHNlLCB0cnVlKTsgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZm9yXCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JfKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChpc19mb3JfYm9keSkge1xuICAgICAgICAgICAgICAgICAgICBjcm9hayhcImNsYXNzZXMgYXJlIG5vdCBhbGxvd2VkIGFzIHRoZSBib2R5IG9mIGEgbG9vcFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzX2lmX2JvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJjbGFzc2VzIGFyZSBub3QgYWxsb3dlZCBhcyB0aGUgYm9keSBvZiBhbiBpZlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsYXNzXyhBU1RfRGVmQ2xhc3MsIGlzX2V4cG9ydF9kZWZhdWx0KTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzX2Zvcl9ib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiZnVuY3Rpb25zIGFyZSBub3QgYWxsb3dlZCBhcyB0aGUgYm9keSBvZiBhIGxvb3BcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbl8oQVNUX0RlZnVuLCBmYWxzZSwgZmFsc2UsIGlzX2V4cG9ydF9kZWZhdWx0KTtcblxuICAgICAgICAgICAgICBjYXNlIFwiaWZcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlmXygpO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJyZXR1cm5cIjpcbiAgICAgICAgICAgICAgICBpZiAoUy5pbl9mdW5jdGlvbiA9PSAwICYmICFvcHRpb25zLmJhcmVfcmV0dXJucylcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCI7XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFjYW5faW5zZXJ0X3NlbWljb2xvbigpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1JldHVybih7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJzd2l0Y2hcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfU3dpdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IHBhcmVudGhlc2lzZWQoKSxcbiAgICAgICAgICAgICAgICAgICAgYm9keSAgICAgICA6IGluX2xvb3Aoc3dpdGNoX2JvZHlfKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJ0aHJvd1wiOlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzX25ld2xpbmVfYmVmb3JlKFMudG9rZW4pKVxuICAgICAgICAgICAgICAgICAgICBjcm9hayhcIklsbGVnYWwgbmV3bGluZSBhZnRlciAndGhyb3cnXCIpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfVGhyb3coe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIFwidHJ5XCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnlfKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSBcInZhclwiOlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHZhcl8oKTtcbiAgICAgICAgICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcblxuICAgICAgICAgICAgICBjYXNlIFwibGV0XCI6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gbGV0XygpO1xuICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJjb25zdFwiOlxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNvbnN0XygpO1xuICAgICAgICAgICAgICAgIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJ3aXRoXCI6XG4gICAgICAgICAgICAgICAgaWYgKFMuaW5wdXQuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJTdHJpY3QgbW9kZSBtYXkgbm90IGluY2x1ZGUgYSB3aXRoIHN0YXRlbWVudFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1dpdGgoe1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogcGFyZW50aGVzaXNlZCgpLFxuICAgICAgICAgICAgICAgICAgICBib2R5ICAgICAgIDogc3RhdGVtZW50KClcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIFwiZXhwb3J0XCI6XG4gICAgICAgICAgICAgICAgaWYgKCFpc190b2tlbihwZWVrKCksIFwicHVuY1wiLCBcIihcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGV4cG9ydF8oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIjtcIikpIHNlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbGFiZWxlZF9zdGF0ZW1lbnQoKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IGFzX3N5bWJvbChBU1RfTGFiZWwpO1xuICAgICAgICBpZiAobGFiZWwubmFtZSA9PT0gXCJhd2FpdFwiICYmIGlzX2luX2FzeW5jKCkpIHtcbiAgICAgICAgICAgIHRva2VuX2Vycm9yKFMucHJldiwgXCJhd2FpdCBjYW5ub3QgYmUgdXNlZCBhcyBsYWJlbCBpbnNpZGUgYXN5bmMgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFMubGFiZWxzLnNvbWUoKGwpID0+IGwubmFtZSA9PT0gbGFiZWwubmFtZSkpIHtcbiAgICAgICAgICAgIC8vIEVDTUEtMjYyLCAxMi4xMjogQW4gRUNNQVNjcmlwdCBwcm9ncmFtIGlzIGNvbnNpZGVyZWRcbiAgICAgICAgICAgIC8vIHN5bnRhY3RpY2FsbHkgaW5jb3JyZWN0IGlmIGl0IGNvbnRhaW5zIGFcbiAgICAgICAgICAgIC8vIExhYmVsbGVkU3RhdGVtZW50IHRoYXQgaXMgZW5jbG9zZWQgYnkgYVxuICAgICAgICAgICAgLy8gTGFiZWxsZWRTdGF0ZW1lbnQgd2l0aCB0aGUgc2FtZSBJZGVudGlmaWVyIGFzIGxhYmVsLlxuICAgICAgICAgICAgY3JvYWsoXCJMYWJlbCBcIiArIGxhYmVsLm5hbWUgKyBcIiBkZWZpbmVkIHR3aWNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdChcIjpcIik7XG4gICAgICAgIFMubGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICB2YXIgc3RhdCA9IHN0YXRlbWVudCgpO1xuICAgICAgICBTLmxhYmVscy5wb3AoKTtcbiAgICAgICAgaWYgKCEoc3RhdCBpbnN0YW5jZW9mIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQpKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgYGNvbnRpbnVlYCB0aGF0IHJlZmVycyB0byB0aGlzIGxhYmVsLlxuICAgICAgICAgICAgLy8gdGhvc2Ugc2hvdWxkIGJlIHJlcG9ydGVkIGFzIHN5bnRheCBlcnJvcnMuXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvMjg3XG4gICAgICAgICAgICBsYWJlbC5yZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24ocmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIEFTVF9Db250aW51ZSkge1xuICAgICAgICAgICAgICAgICAgICByZWYgPSByZWYubGFiZWwuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGNyb2FrKFwiQ29udGludWUgbGFiZWwgYFwiICsgbGFiZWwubmFtZSArIFwiYCByZWZlcnMgdG8gbm9uLUl0ZXJhdGlvblN0YXRlbWVudC5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLmxpbmUsIHJlZi5jb2wsIHJlZi5wb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0xhYmVsZWRTdGF0ZW1lbnQoeyBib2R5OiBzdGF0LCBsYWJlbDogbGFiZWwgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2ltcGxlX3N0YXRlbWVudCh0bXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfU2ltcGxlU3RhdGVtZW50KHsgYm9keTogKHRtcCA9IGV4cHJlc3Npb24odHJ1ZSksIHNlbWljb2xvbigpLCB0bXApIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJyZWFrX2NvbnQodHlwZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBudWxsLCBsZGVmO1xuICAgICAgICBpZiAoIWNhbl9pbnNlcnRfc2VtaWNvbG9uKCkpIHtcbiAgICAgICAgICAgIGxhYmVsID0gYXNfc3ltYm9sKEFTVF9MYWJlbFJlZiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhYmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxkZWYgPSBTLmxhYmVscy5maW5kKChsKSA9PiBsLm5hbWUgPT09IGxhYmVsLm5hbWUpO1xuICAgICAgICAgICAgaWYgKCFsZGVmKVxuICAgICAgICAgICAgICAgIGNyb2FrKFwiVW5kZWZpbmVkIGxhYmVsIFwiICsgbGFiZWwubmFtZSk7XG4gICAgICAgICAgICBsYWJlbC50aGVkZWYgPSBsZGVmO1xuICAgICAgICB9IGVsc2UgaWYgKFMuaW5fbG9vcCA9PSAwKVxuICAgICAgICAgICAgY3JvYWsodHlwZS5UWVBFICsgXCIgbm90IGluc2lkZSBhIGxvb3Agb3Igc3dpdGNoXCIpO1xuICAgICAgICBzZW1pY29sb24oKTtcbiAgICAgICAgdmFyIHN0YXQgPSBuZXcgdHlwZSh7IGxhYmVsOiBsYWJlbCB9KTtcbiAgICAgICAgaWYgKGxkZWYpIGxkZWYucmVmZXJlbmNlcy5wdXNoKHN0YXQpO1xuICAgICAgICByZXR1cm4gc3RhdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JfKCkge1xuICAgICAgICB2YXIgZm9yX2F3YWl0X2Vycm9yID0gXCJgZm9yIGF3YWl0YCBpbnZhbGlkIGluIHRoaXMgY29udGV4dFwiO1xuICAgICAgICB2YXIgYXdhaXRfdG9rID0gUy50b2tlbjtcbiAgICAgICAgaWYgKGF3YWl0X3Rvay50eXBlID09IFwibmFtZVwiICYmIGF3YWl0X3Rvay52YWx1ZSA9PSBcImF3YWl0XCIpIHtcbiAgICAgICAgICAgIGlmICghY2FuX2F3YWl0KCkpIHtcbiAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihhd2FpdF90b2ssIGZvcl9hd2FpdF9lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdF90b2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoXCIoXCIpO1xuICAgICAgICB2YXIgaW5pdCA9IG51bGw7XG4gICAgICAgIGlmICghaXMoXCJwdW5jXCIsIFwiO1wiKSkge1xuICAgICAgICAgICAgaW5pdCA9XG4gICAgICAgICAgICAgICAgaXMoXCJrZXl3b3JkXCIsIFwidmFyXCIpID8gKG5leHQoKSwgdmFyXyh0cnVlKSkgOlxuICAgICAgICAgICAgICAgIGlzKFwia2V5d29yZFwiLCBcImxldFwiKSA/IChuZXh0KCksIGxldF8odHJ1ZSkpIDpcbiAgICAgICAgICAgICAgICBpcyhcImtleXdvcmRcIiwgXCJjb25zdFwiKSA/IChuZXh0KCksIGNvbnN0Xyh0cnVlKSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbih0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBpc19pbiA9IGlzKFwib3BlcmF0b3JcIiwgXCJpblwiKTtcbiAgICAgICAgICAgIHZhciBpc19vZiA9IGlzKFwibmFtZVwiLCBcIm9mXCIpO1xuICAgICAgICAgICAgaWYgKGF3YWl0X3RvayAmJiAhaXNfb2YpIHtcbiAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihhd2FpdF90b2ssIGZvcl9hd2FpdF9lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNfaW4gfHwgaXNfb2YpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdCBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdC5kZWZpbml0aW9ucy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5fZXJyb3IoaW5pdC5zdGFydCwgXCJPbmx5IG9uZSB2YXJpYWJsZSBkZWNsYXJhdGlvbiBhbGxvd2VkIGluIGZvci4uaW4gbG9vcFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCEoaXNfYXNzaWduYWJsZShpbml0KSB8fCAoaW5pdCA9IHRvX2Rlc3RydWN0dXJpbmcoaW5pdCkpIGluc3RhbmNlb2YgQVNUX0Rlc3RydWN0dXJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKGluaXQuc3RhcnQsIFwiSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3IuLmluIGxvb3BcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNfaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcl9pbihpbml0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9yX29mKGluaXQsICEhYXdhaXRfdG9rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXdhaXRfdG9rKSB7XG4gICAgICAgICAgICB0b2tlbl9lcnJvcihhd2FpdF90b2ssIGZvcl9hd2FpdF9lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZ3VsYXJfZm9yKGluaXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ3VsYXJfZm9yKGluaXQpIHtcbiAgICAgICAgZXhwZWN0KFwiO1wiKTtcbiAgICAgICAgdmFyIHRlc3QgPSBpcyhcInB1bmNcIiwgXCI7XCIpID8gbnVsbCA6IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIGV4cGVjdChcIjtcIik7XG4gICAgICAgIHZhciBzdGVwID0gaXMoXCJwdW5jXCIsIFwiKVwiKSA/IG51bGwgOiBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Gb3Ioe1xuICAgICAgICAgICAgaW5pdCAgICAgIDogaW5pdCxcbiAgICAgICAgICAgIGNvbmRpdGlvbiA6IHRlc3QsXG4gICAgICAgICAgICBzdGVwICAgICAgOiBzdGVwLFxuICAgICAgICAgICAgYm9keSAgICAgIDogaW5fbG9vcChmdW5jdGlvbigpIHsgcmV0dXJuIHN0YXRlbWVudChmYWxzZSwgdHJ1ZSk7IH0pXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcl9vZihpbml0LCBpc19hd2FpdCkge1xuICAgICAgICB2YXIgbGhzID0gaW5pdCBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucyA/IGluaXQuZGVmaW5pdGlvbnNbMF0ubmFtZSA6IG51bGw7XG4gICAgICAgIHZhciBvYmogPSBleHByZXNzaW9uKHRydWUpO1xuICAgICAgICBleHBlY3QoXCIpXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9Gb3JPZih7XG4gICAgICAgICAgICBhd2FpdCAgOiBpc19hd2FpdCxcbiAgICAgICAgICAgIGluaXQgICA6IGluaXQsXG4gICAgICAgICAgICBuYW1lICAgOiBsaHMsXG4gICAgICAgICAgICBvYmplY3QgOiBvYmosXG4gICAgICAgICAgICBib2R5ICAgOiBpbl9sb29wKGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhdGVtZW50KGZhbHNlLCB0cnVlKTsgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9yX2luKGluaXQpIHtcbiAgICAgICAgdmFyIG9iaiA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0ZvckluKHtcbiAgICAgICAgICAgIGluaXQgICA6IGluaXQsXG4gICAgICAgICAgICBvYmplY3QgOiBvYmosXG4gICAgICAgICAgICBib2R5ICAgOiBpbl9sb29wKGZ1bmN0aW9uKCkgeyByZXR1cm4gc3RhdGVtZW50KGZhbHNlLCB0cnVlKTsgfSlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGFycm93X2Z1bmN0aW9uID0gZnVuY3Rpb24oc3RhcnQsIGFyZ25hbWVzLCBpc19hc3luYykge1xuICAgICAgICBpZiAoaGFzX25ld2xpbmVfYmVmb3JlKFMudG9rZW4pKSB7XG4gICAgICAgICAgICBjcm9hayhcIlVuZXhwZWN0ZWQgbmV3bGluZSBiZWZvcmUgYXJyb3cgKD0+KVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV4cGVjdF90b2tlbihcImFycm93XCIsIFwiPT5cIik7XG5cbiAgICAgICAgdmFyIGJvZHkgPSBfZnVuY3Rpb25fYm9keShpcyhcInB1bmNcIiwgXCJ7XCIpLCBmYWxzZSwgaXNfYXN5bmMpO1xuXG4gICAgICAgIHZhciBlbmQgPVxuICAgICAgICAgICAgYm9keSBpbnN0YW5jZW9mIEFycmF5ICYmIGJvZHkubGVuZ3RoID8gYm9keVtib2R5Lmxlbmd0aCAtIDFdLmVuZCA6XG4gICAgICAgICAgICBib2R5IGluc3RhbmNlb2YgQXJyYXkgPyBzdGFydCA6XG4gICAgICAgICAgICAgICAgYm9keS5lbmQ7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfQXJyb3coe1xuICAgICAgICAgICAgc3RhcnQgICAgOiBzdGFydCxcbiAgICAgICAgICAgIGVuZCAgICAgIDogZW5kLFxuICAgICAgICAgICAgYXN5bmMgICAgOiBpc19hc3luYyxcbiAgICAgICAgICAgIGFyZ25hbWVzIDogYXJnbmFtZXMsXG4gICAgICAgICAgICBib2R5ICAgICA6IGJvZHlcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBmdW5jdGlvbl8gPSBmdW5jdGlvbihjdG9yLCBpc19nZW5lcmF0b3JfcHJvcGVydHksIGlzX2FzeW5jLCBpc19leHBvcnRfZGVmYXVsdCkge1xuICAgICAgICB2YXIgaW5fc3RhdGVtZW50ID0gY3RvciA9PT0gQVNUX0RlZnVuO1xuICAgICAgICB2YXIgaXNfZ2VuZXJhdG9yID0gaXMoXCJvcGVyYXRvclwiLCBcIipcIik7XG4gICAgICAgIGlmIChpc19nZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lID0gaXMoXCJuYW1lXCIpID8gYXNfc3ltYm9sKGluX3N0YXRlbWVudCA/IEFTVF9TeW1ib2xEZWZ1biA6IEFTVF9TeW1ib2xMYW1iZGEpIDogbnVsbDtcbiAgICAgICAgaWYgKGluX3N0YXRlbWVudCAmJiAhbmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzX2V4cG9ydF9kZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgY3RvciA9IEFTVF9GdW5jdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWUgJiYgY3RvciAhPT0gQVNUX0FjY2Vzc29yICYmICEobmFtZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWNsYXJhdGlvbikpXG4gICAgICAgICAgICB1bmV4cGVjdGVkKHByZXYoKSk7XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgdmFyIGJvZHkgPSBfZnVuY3Rpb25fYm9keSh0cnVlLCBpc19nZW5lcmF0b3IgfHwgaXNfZ2VuZXJhdG9yX3Byb3BlcnR5LCBpc19hc3luYywgbmFtZSwgYXJncyk7XG4gICAgICAgIHJldHVybiBuZXcgY3Rvcih7XG4gICAgICAgICAgICBzdGFydCA6IGFyZ3Muc3RhcnQsXG4gICAgICAgICAgICBlbmQgICA6IGJvZHkuZW5kLFxuICAgICAgICAgICAgaXNfZ2VuZXJhdG9yOiBpc19nZW5lcmF0b3IsXG4gICAgICAgICAgICBhc3luYyA6IGlzX2FzeW5jLFxuICAgICAgICAgICAgbmFtZSAgOiBuYW1lLFxuICAgICAgICAgICAgYXJnbmFtZXM6IGFyZ3MsXG4gICAgICAgICAgICBib2R5ICA6IGJvZHlcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHRyYWNrX3VzZWRfYmluZGluZ19pZGVudGlmaWVycyhpc19wYXJhbWV0ZXIsIHN0cmljdCkge1xuICAgICAgICB2YXIgcGFyYW1ldGVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIGR1cGxpY2F0ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgZGVmYXVsdF9hc3NpZ25tZW50ID0gZmFsc2U7XG4gICAgICAgIHZhciBzcHJlYWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHN0cmljdF9tb2RlID0gISFzdHJpY3Q7XG4gICAgICAgIHZhciB0cmFja2VyID0ge1xuICAgICAgICAgICAgYWRkX3BhcmFtZXRlcjogZnVuY3Rpb24odG9rZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1ldGVycy5oYXModG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkdXBsaWNhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXBsaWNhdGUgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cmFja2VyLmNoZWNrX3N0cmljdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuYWRkKHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzX3BhcmFtZXRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXJndW1lbnRzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJldmFsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ5aWVsZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHJpY3RfbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcih0b2tlbiwgXCJVbmV4cGVjdGVkIFwiICsgdG9rZW4udmFsdWUgKyBcIiBpZGVudGlmaWVyIGFzIHBhcmFtZXRlciBpbnNpZGUgc3RyaWN0IG1vZGVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSRVNFUlZFRF9XT1JEUy5oYXModG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFya19kZWZhdWx0X2Fzc2lnbm1lbnQ6IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRfYXNzaWdubWVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdF9hc3NpZ25tZW50ID0gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcmtfc3ByZWFkOiBmdW5jdGlvbih0b2tlbikge1xuICAgICAgICAgICAgICAgIGlmIChzcHJlYWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwcmVhZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXJrX3N0cmljdF9tb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzdHJpY3RfbW9kZSA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNfc3RyaWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdF9hc3NpZ25tZW50ICE9PSBmYWxzZSB8fCBzcHJlYWQgIT09IGZhbHNlIHx8IHN0cmljdF9tb2RlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoZWNrX3N0cmljdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZXIuaXNfc3RyaWN0KCkgJiYgZHVwbGljYXRlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihkdXBsaWNhdGUsIFwiUGFyYW1ldGVyIFwiICsgZHVwbGljYXRlLnZhbHVlICsgXCIgd2FzIHVzZWQgYWxyZWFkeVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRyYWNrZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIHVzZWRfcGFyYW1ldGVycyA9IHRyYWNrX3VzZWRfYmluZGluZ19pZGVudGlmaWVycyh0cnVlLCBTLmlucHV0Lmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpKTtcblxuICAgICAgICBleHBlY3QoXCIoXCIpO1xuXG4gICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwiKVwiKSkge1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1ldGVyKHVzZWRfcGFyYW1ldGVycyk7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG5cbiAgICAgICAgICAgIGlmICghaXMoXCJwdW5jXCIsIFwiKVwiKSkge1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIixcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJhbSBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJhbWV0ZXIodXNlZF9wYXJhbWV0ZXJzLCBzeW1ib2xfdHlwZSkge1xuICAgICAgICB2YXIgcGFyYW07XG4gICAgICAgIHZhciBleHBhbmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHVzZWRfcGFyYW1ldGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1c2VkX3BhcmFtZXRlcnMgPSB0cmFja191c2VkX2JpbmRpbmdfaWRlbnRpZmllcnModHJ1ZSwgUy5pbnB1dC5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKFwiZXhwYW5kXCIsIFwiLi4uXCIpKSB7XG4gICAgICAgICAgICBleHBhbmQgPSBTLnRva2VuO1xuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLm1hcmtfc3ByZWFkKFMudG9rZW4pO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtID0gYmluZGluZ19lbGVtZW50KHVzZWRfcGFyYW1ldGVycywgc3ltYm9sX3R5cGUpO1xuXG4gICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiPVwiKSAmJiBleHBhbmQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1c2VkX3BhcmFtZXRlcnMubWFya19kZWZhdWx0X2Fzc2lnbm1lbnQoUy50b2tlbik7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBwYXJhbSA9IG5ldyBBU1RfRGVmYXVsdEFzc2lnbih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHBhcmFtLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGxlZnQ6IHBhcmFtLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgICAgICByaWdodDogZXhwcmVzc2lvbihmYWxzZSksXG4gICAgICAgICAgICAgICAgZW5kOiBTLnRva2VuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHBhbmQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoIWlzKFwicHVuY1wiLCBcIilcIikpIHtcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbSA9IG5ldyBBU1RfRXhwYW5zaW9uKHtcbiAgICAgICAgICAgICAgICBzdGFydDogZXhwYW5kLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHBhcmFtLFxuICAgICAgICAgICAgICAgIGVuZDogZXhwYW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB1c2VkX3BhcmFtZXRlcnMuY2hlY2tfc3RyaWN0KCk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmRpbmdfZWxlbWVudCh1c2VkX3BhcmFtZXRlcnMsIHN5bWJvbF90eXBlKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xuICAgICAgICB2YXIgaXNfZXhwYW5kID0gZmFsc2U7XG4gICAgICAgIHZhciBleHBhbmRfdG9rZW47XG4gICAgICAgIHZhciBmaXJzdF90b2tlbiA9IFMudG9rZW47XG4gICAgICAgIGlmICh1c2VkX3BhcmFtZXRlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzID0gdHJhY2tfdXNlZF9iaW5kaW5nX2lkZW50aWZpZXJzKGZhbHNlLCBTLmlucHV0Lmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2xfdHlwZSA9IHN5bWJvbF90eXBlID09PSB1bmRlZmluZWQgPyBBU1RfU3ltYm9sRnVuYXJnIDogc3ltYm9sX3R5cGU7XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCJbXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBcIl1cIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCIsXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpcyhcImV4cGFuZFwiLCBcIi4uLlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpc19leHBhbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRfdG9rZW4gPSBTLnRva2VuO1xuICAgICAgICAgICAgICAgICAgICB1c2VkX3BhcmFtZXRlcnMubWFya19zcHJlYWQoUy50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwicHVuY1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKFMudG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChuZXcgQVNUX0hvbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBTLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogUy50b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIl1cIjogLy8gVHJhaWxpbmcgY29tbWEgYWZ0ZXIgbGFzdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGJpbmRpbmdfZWxlbWVudCh1c2VkX3BhcmFtZXRlcnMsIHN5bWJvbF90eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhcIm5hbWVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmFkZF9wYXJhbWV0ZXIoUy50b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goYXNfc3ltYm9sKHN5bWJvbF90eXBlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJJbnZhbGlkIGZ1bmN0aW9uIHBhcmFtZXRlclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCI9XCIpICYmIGlzX2V4cGFuZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLm1hcmtfZGVmYXVsdF9hc3NpZ25tZW50KFMudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdID0gbmV3IEFTVF9EZWZhdWx0QXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiPVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGV4cHJlc3Npb24oZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBTLnRva2VuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNfZXhwYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXMoXCJwdW5jXCIsIFwiXVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJSZXN0IGVsZW1lbnQgbXVzdCBiZSBsYXN0IGVsZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0gPSBuZXcgQVNUX0V4cGFuc2lvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZXhwYW5kX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGV4cGFuZF90b2tlblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBlY3QoXCJdXCIpO1xuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmNoZWNrX3N0cmljdCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVzdHJ1Y3R1cmluZyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZpcnN0X3Rva2VuLFxuICAgICAgICAgICAgICAgIG5hbWVzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICBpc19hcnJheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMoXCJwdW5jXCIsIFwie1wiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwiZXhwYW5kXCIsIFwiLi4uXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzX2V4cGFuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZF90b2tlbiA9IFMudG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHVzZWRfcGFyYW1ldGVycy5tYXJrX3NwcmVhZChTLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJuYW1lXCIpICYmIChpc190b2tlbihwZWVrKCksIFwicHVuY1wiKSB8fCBpc190b2tlbihwZWVrKCksIFwib3BlcmF0b3JcIikpICYmIFtcIixcIiwgXCJ9XCIsIFwiPVwiXS5pbmNsdWRlcyhwZWVrKCkudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZWRfcGFyYW1ldGVycy5hZGRfcGFyYW1ldGVyKFMudG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBwcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFzX3N5bWJvbChzeW1ib2xfdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc19leHBhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobmV3IEFTVF9FeHBhbnNpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBleHBhbmRfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiB2YWx1ZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG5ldyBBU1RfT2JqZWN0S2V5VmFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB2YWx1ZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHZhbHVlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gQWxsb3cgdHJhaWxpbmcgaG9sZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eV90b2tlbiA9IFMudG9rZW47XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IGFzX3Byb3BlcnR5X25hbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKHByZXYoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldigpLnR5cGUgPT09IFwibmFtZVwiICYmICFpcyhcInB1bmNcIiwgXCI6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG5ldyBBU1RfT2JqZWN0S2V5VmFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJldigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBzeW1ib2xfdHlwZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcmV2KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChuZXcgQVNUX09iamVjdEtleVZhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHByb3BlcnR5X3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlOiBwcm9wZXJ0eV90b2tlbi5xdW90ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBiaW5kaW5nX2VsZW1lbnQodXNlZF9wYXJhbWV0ZXJzLCBzeW1ib2xfdHlwZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNfZXhwYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JvYWsoXCJSZXN0IGVsZW1lbnQgbXVzdCBiZSBsYXN0IGVsZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCI9XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZWRfcGFyYW1ldGVycy5tYXJrX2RlZmF1bHRfYXNzaWdubWVudChTLnRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS52YWx1ZSA9IG5ldyBBU1RfRGVmYXVsdEFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0udmFsdWUuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBleHByZXNzaW9uKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogUy50b2tlblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBlY3QoXCJ9XCIpO1xuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmNoZWNrX3N0cmljdCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVzdHJ1Y3R1cmluZyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGZpcnN0X3Rva2VuLFxuICAgICAgICAgICAgICAgIG5hbWVzOiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICBpc19hcnJheTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGlzKFwibmFtZVwiKSkge1xuICAgICAgICAgICAgdXNlZF9wYXJhbWV0ZXJzLmFkZF9wYXJhbWV0ZXIoUy50b2tlbik7XG4gICAgICAgICAgICByZXR1cm4gYXNfc3ltYm9sKHN5bWJvbF90eXBlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNyb2FrKFwiSW52YWxpZCBmdW5jdGlvbiBwYXJhbWV0ZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJhbXNfb3Jfc2VxXyhhbGxvd19hcnJvd3MsIG1heWJlX3NlcXVlbmNlKSB7XG4gICAgICAgIHZhciBzcHJlYWRfdG9rZW47XG4gICAgICAgIHZhciBpbnZhbGlkX3NlcXVlbmNlO1xuICAgICAgICB2YXIgdHJhaWxpbmdfY29tbWE7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIGV4cGVjdChcIihcIik7XG4gICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwiKVwiKSkge1xuICAgICAgICAgICAgaWYgKHNwcmVhZF90b2tlbikgdW5leHBlY3RlZChzcHJlYWRfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGlzKFwiZXhwYW5kXCIsIFwiLi4uXCIpKSB7XG4gICAgICAgICAgICAgICAgc3ByZWFkX3Rva2VuID0gUy50b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAobWF5YmVfc2VxdWVuY2UpIGludmFsaWRfc2VxdWVuY2UgPSBTLnRva2VuO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBhLnB1c2gobmV3IEFTVF9FeHBhbnNpb24oe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJldigpLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uKCksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogUy50b2tlbixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGEucHVzaChleHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpcyhcInB1bmNcIiwgXCIpXCIpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwiKVwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFpbGluZ19jb21tYSA9IHByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlX3NlcXVlbmNlKSBpbnZhbGlkX3NlcXVlbmNlID0gdHJhaWxpbmdfY29tbWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV4cGVjdChcIilcIik7XG4gICAgICAgIGlmIChhbGxvd19hcnJvd3MgJiYgaXMoXCJhcnJvd1wiLCBcIj0+XCIpKSB7XG4gICAgICAgICAgICBpZiAoc3ByZWFkX3Rva2VuICYmIHRyYWlsaW5nX2NvbW1hKSB1bmV4cGVjdGVkKHRyYWlsaW5nX2NvbW1hKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnZhbGlkX3NlcXVlbmNlKSB7XG4gICAgICAgICAgICB1bmV4cGVjdGVkKGludmFsaWRfc2VxdWVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9mdW5jdGlvbl9ib2R5KGJsb2NrLCBnZW5lcmF0b3IsIGlzX2FzeW5jLCBuYW1lLCBhcmdzKSB7XG4gICAgICAgIHZhciBsb29wID0gUy5pbl9sb29wO1xuICAgICAgICB2YXIgbGFiZWxzID0gUy5sYWJlbHM7XG4gICAgICAgIHZhciBjdXJyZW50X2dlbmVyYXRvciA9IFMuaW5fZ2VuZXJhdG9yO1xuICAgICAgICB2YXIgY3VycmVudF9hc3luYyA9IFMuaW5fYXN5bmM7XG4gICAgICAgICsrUy5pbl9mdW5jdGlvbjtcbiAgICAgICAgaWYgKGdlbmVyYXRvcilcbiAgICAgICAgICAgIFMuaW5fZ2VuZXJhdG9yID0gUy5pbl9mdW5jdGlvbjtcbiAgICAgICAgaWYgKGlzX2FzeW5jKVxuICAgICAgICAgICAgUy5pbl9hc3luYyA9IFMuaW5fZnVuY3Rpb247XG4gICAgICAgIGlmIChhcmdzKSBwYXJhbWV0ZXJzKGFyZ3MpO1xuICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgICBTLmluX2RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICBTLmluX2xvb3AgPSAwO1xuICAgICAgICBTLmxhYmVscyA9IFtdO1xuICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgIFMuaW5wdXQucHVzaF9kaXJlY3RpdmVzX3N0YWNrKCk7XG4gICAgICAgICAgICB2YXIgYSA9IGJsb2NrXygpO1xuICAgICAgICAgICAgaWYgKG5hbWUpIF92ZXJpZnlfc3ltYm9sKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGFyZ3MpIGFyZ3MuZm9yRWFjaChfdmVyaWZ5X3N5bWJvbCk7XG4gICAgICAgICAgICBTLmlucHV0LnBvcF9kaXJlY3RpdmVzX3N0YWNrKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYSA9IFtuZXcgQVNUX1JldHVybih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IFMudG9rZW4sXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4cHJlc3Npb24oZmFsc2UpLFxuICAgICAgICAgICAgICAgIGVuZDogUy50b2tlblxuICAgICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICAgIC0tUy5pbl9mdW5jdGlvbjtcbiAgICAgICAgUy5pbl9sb29wID0gbG9vcDtcbiAgICAgICAgUy5sYWJlbHMgPSBsYWJlbHM7XG4gICAgICAgIFMuaW5fZ2VuZXJhdG9yID0gY3VycmVudF9nZW5lcmF0b3I7XG4gICAgICAgIFMuaW5fYXN5bmMgPSBjdXJyZW50X2FzeW5jO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYXdhaXRfZXhwcmVzc2lvbigpIHtcbiAgICAgICAgLy8gUHJldmlvdXMgdG9rZW4gbXVzdCBiZSBcImF3YWl0XCIgYW5kIG5vdCBiZSBpbnRlcnByZXRlZCBhcyBhbiBpZGVudGlmaWVyXG4gICAgICAgIGlmICghY2FuX2F3YWl0KCkpIHtcbiAgICAgICAgICAgIGNyb2FrKFwiVW5leHBlY3RlZCBhd2FpdCBleHByZXNzaW9uIG91dHNpZGUgYXN5bmMgZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBTLnByZXYubGluZSwgUy5wcmV2LmNvbCwgUy5wcmV2LnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGF3YWl0IGV4cHJlc3Npb24gaXMgcGFyc2VkIGFzIGEgdW5hcnkgZXhwcmVzc2lvbiBpbiBCYWJlbFxuICAgICAgICByZXR1cm4gbmV3IEFTVF9Bd2FpdCh7XG4gICAgICAgICAgICBzdGFydDogcHJldigpLFxuICAgICAgICAgICAgZW5kOiBTLnRva2VuLFxuICAgICAgICAgICAgZXhwcmVzc2lvbiA6IG1heWJlX3VuYXJ5KHRydWUpLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfeWllbGRfZXhwcmVzc2lvbigpIHtcbiAgICAgICAgLy8gUHJldmlvdXMgdG9rZW4gbXVzdCBiZSBrZXl3b3JkIHlpZWxkIGFuZCBub3QgYmUgaW50ZXJwcmV0IGFzIGFuIGlkZW50aWZpZXJcbiAgICAgICAgaWYgKCFpc19pbl9nZW5lcmF0b3IoKSkge1xuICAgICAgICAgICAgY3JvYWsoXCJVbmV4cGVjdGVkIHlpZWxkIGV4cHJlc3Npb24gb3V0c2lkZSBnZW5lcmF0b3IgZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBTLnByZXYubGluZSwgUy5wcmV2LmNvbCwgUy5wcmV2LnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgdmFyIHN0YXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhc19leHByZXNzaW9uID0gdHJ1ZTtcblxuICAgICAgICAvLyBBdHRlbXB0IHRvIGdldCBleHByZXNzaW9uIG9yIHN0YXIgKGFuZCB0aGVuIHRoZSBtYW5kYXRvcnkgZXhwcmVzc2lvbilcbiAgICAgICAgLy8gYmVoaW5kIHlpZWxkIG9uIHRoZSBzYW1lIGxpbmUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIG5vdGhpbmcgZm9sbG93cyBvbiB0aGUgc2FtZSBsaW5lIG9mIHRoZSB5aWVsZEV4cHJlc3Npb24sXG4gICAgICAgIC8vIGl0IHNob3VsZCBkZWZhdWx0IHRvIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBmb3IgeWllbGQgdG8gcmV0dXJuLlxuICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHRoZSBgdW5kZWZpbmVkYCBzdG9yZWQgYXMgYG51bGxgIGluIGFzdC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZSAxOiBJdCBpc24ndCBhbGxvd2VkIGZvciB5aWVsZCogdG8gY2xvc2Ugd2l0aG91dCBhbiBleHByZXNzaW9uXG4gICAgICAgIC8vIE5vdGUgMjogSWYgdGhlcmUgaXMgYSBubGIgYmV0d2VlbiB5aWVsZCBhbmQgc3RhciwgaXQgaXMgaW50ZXJwcmV0IGFzXG4gICAgICAgIC8vICAgICAgICAgeWllbGQgPGV4cGxpY2l0IHVuZGVmaW5lZD4gPGluc2VydGVkIGF1dG9tYXRpYyBzZW1pY29sb24+ICpcbiAgICAgICAgaWYgKGNhbl9pbnNlcnRfc2VtaWNvbG9uKCkgfHxcbiAgICAgICAgICAgIChpcyhcInB1bmNcIikgJiYgUFVOQ19BRlRFUl9FWFBSRVNTSU9OLmhhcyhTLnRva2VuLnZhbHVlKSkpIHtcbiAgICAgICAgICAgIGhhc19leHByZXNzaW9uID0gZmFsc2U7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiKlwiKSkge1xuICAgICAgICAgICAgc3RhciA9IHRydWU7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEFTVF9ZaWVsZCh7XG4gICAgICAgICAgICBzdGFydCAgICAgIDogc3RhcnQsXG4gICAgICAgICAgICBpc19zdGFyICAgIDogc3RhcixcbiAgICAgICAgICAgIGV4cHJlc3Npb24gOiBoYXNfZXhwcmVzc2lvbiA/IGV4cHJlc3Npb24oKSA6IG51bGwsXG4gICAgICAgICAgICBlbmQgICAgICAgIDogcHJldigpXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlmXygpIHtcbiAgICAgICAgdmFyIGNvbmQgPSBwYXJlbnRoZXNpc2VkKCksIGJvZHkgPSBzdGF0ZW1lbnQoZmFsc2UsIGZhbHNlLCB0cnVlKSwgYmVsc2UgPSBudWxsO1xuICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZWxzZVwiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgYmVsc2UgPSBzdGF0ZW1lbnQoZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFTVF9JZih7XG4gICAgICAgICAgICBjb25kaXRpb24gICA6IGNvbmQsXG4gICAgICAgICAgICBib2R5ICAgICAgICA6IGJvZHksXG4gICAgICAgICAgICBhbHRlcm5hdGl2ZSA6IGJlbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJsb2NrXygpIHtcbiAgICAgICAgZXhwZWN0KFwie1wiKTtcbiAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICBpZiAoaXMoXCJlb2ZcIikpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIGEucHVzaChzdGF0ZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzd2l0Y2hfYm9keV8oKSB7XG4gICAgICAgIGV4cGVjdChcIntcIik7XG4gICAgICAgIHZhciBhID0gW10sIGN1ciA9IG51bGwsIGJyYW5jaCA9IG51bGwsIHRtcDtcbiAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICBpZiAoaXMoXCJlb2ZcIikpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIGlmIChpcyhcImtleXdvcmRcIiwgXCJjYXNlXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyYW5jaCkgYnJhbmNoLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgICAgICBjdXIgPSBbXTtcbiAgICAgICAgICAgICAgICBicmFuY2ggPSBuZXcgQVNUX0Nhc2Uoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogKHRtcCA9IFMudG9rZW4sIG5leHQoKSwgdG1wKSxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGV4cHJlc3Npb24odHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgICAgICAgOiBjdXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhLnB1c2goYnJhbmNoKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCI6XCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhcImtleXdvcmRcIiwgXCJkZWZhdWx0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJyYW5jaCkgYnJhbmNoLmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgICAgICBjdXIgPSBbXTtcbiAgICAgICAgICAgICAgICBicmFuY2ggPSBuZXcgQVNUX0RlZmF1bHQoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA6ICh0bXAgPSBTLnRva2VuLCBuZXh0KCksIGV4cGVjdChcIjpcIiksIHRtcCksXG4gICAgICAgICAgICAgICAgICAgIGJvZHkgIDogY3VyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYS5wdXNoKGJyYW5jaCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghY3VyKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgY3VyLnB1c2goc3RhdGVtZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChicmFuY2gpIGJyYW5jaC5lbmQgPSBwcmV2KCk7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJ5XygpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBibG9ja18oKSwgYmNhdGNoID0gbnVsbCwgYmZpbmFsbHkgPSBudWxsO1xuICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiY2F0Y2hcIikpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwie1wiKSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiKFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHBhcmFtZXRlcih1bmRlZmluZWQsIEFTVF9TeW1ib2xDYXRjaCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJjYXRjaCA9IG5ldyBBU1RfQ2F0Y2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBhcmduYW1lIDogbmFtZSxcbiAgICAgICAgICAgICAgICBib2R5ICAgIDogYmxvY2tfKCksXG4gICAgICAgICAgICAgICAgZW5kICAgICA6IHByZXYoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKFwia2V5d29yZFwiLCBcImZpbmFsbHlcIikpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBiZmluYWxseSA9IG5ldyBBU1RfRmluYWxseSh7XG4gICAgICAgICAgICAgICAgc3RhcnQgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBib2R5ICA6IGJsb2NrXygpLFxuICAgICAgICAgICAgICAgIGVuZCAgIDogcHJldigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJjYXRjaCAmJiAhYmZpbmFsbHkpXG4gICAgICAgICAgICBjcm9hayhcIk1pc3NpbmcgY2F0Y2gvZmluYWxseSBibG9ja3NcIik7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX1RyeSh7XG4gICAgICAgICAgICBib2R5ICAgICA6IGJvZHksXG4gICAgICAgICAgICBiY2F0Y2ggICA6IGJjYXRjaCxcbiAgICAgICAgICAgIGJmaW5hbGx5IDogYmZpbmFsbHlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFyZGVmcyhub19pbiwga2luZCkge1xuICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICB2YXIgZGVmO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICB2YXIgc3ltX3R5cGUgPVxuICAgICAgICAgICAgICAgIGtpbmQgPT09IFwidmFyXCIgPyBBU1RfU3ltYm9sVmFyIDpcbiAgICAgICAgICAgICAgICBraW5kID09PSBcImNvbnN0XCIgPyBBU1RfU3ltYm9sQ29uc3QgOlxuICAgICAgICAgICAgICAgIGtpbmQgPT09IFwibGV0XCIgPyBBU1RfU3ltYm9sTGV0IDogbnVsbDtcbiAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCJ7XCIpIHx8IGlzKFwicHVuY1wiLCBcIltcIikpIHtcbiAgICAgICAgICAgICAgICBkZWYgPSBuZXcgQVNUX1ZhckRlZih7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBTLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBiaW5kaW5nX2VsZW1lbnQodW5kZWZpbmVkICxzeW1fdHlwZSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpcyhcIm9wZXJhdG9yXCIsIFwiPVwiKSA/IChleHBlY3RfdG9rZW4oXCJvcGVyYXRvclwiLCBcIj1cIiksIGV4cHJlc3Npb24oZmFsc2UsIG5vX2luKSkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWYgPSBuZXcgQVNUX1ZhckRlZih7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0IDogUy50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgbmFtZSAgOiBhc19zeW1ib2woc3ltX3R5cGUpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6IGlzKFwib3BlcmF0b3JcIiwgXCI9XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChuZXh0KCksIGV4cHJlc3Npb24oZmFsc2UsIG5vX2luKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogIW5vX2luICYmIGtpbmQgPT09IFwiY29uc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY3JvYWsoXCJNaXNzaW5nIGluaXRpYWxpemVyIGluIGNvbnN0IGRlY2xhcmF0aW9uXCIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZW5kICAgOiBwcmV2KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmLm5hbWUubmFtZSA9PSBcImltcG9ydFwiKSBjcm9hayhcIlVuZXhwZWN0ZWQgdG9rZW46IGltcG9ydFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEucHVzaChkZWYpO1xuICAgICAgICAgICAgaWYgKCFpcyhcInB1bmNcIiwgXCIsXCIpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHZhciB2YXJfID0gZnVuY3Rpb24obm9faW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVmFyKHtcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogcHJldigpLFxuICAgICAgICAgICAgZGVmaW5pdGlvbnMgOiB2YXJkZWZzKG5vX2luLCBcInZhclwiKSxcbiAgICAgICAgICAgIGVuZCAgICAgICAgIDogcHJldigpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgbGV0XyA9IGZ1bmN0aW9uKG5vX2luKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0xldCh7XG4gICAgICAgICAgICBzdGFydCAgICAgICA6IHByZXYoKSxcbiAgICAgICAgICAgIGRlZmluaXRpb25zIDogdmFyZGVmcyhub19pbiwgXCJsZXRcIiksXG4gICAgICAgICAgICBlbmQgICAgICAgICA6IHByZXYoKVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIGNvbnN0XyA9IGZ1bmN0aW9uKG5vX2luKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0NvbnN0KHtcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogcHJldigpLFxuICAgICAgICAgICAgZGVmaW5pdGlvbnMgOiB2YXJkZWZzKG5vX2luLCBcImNvbnN0XCIpLFxuICAgICAgICAgICAgZW5kICAgICAgICAgOiBwcmV2KClcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBuZXdfID0gZnVuY3Rpb24oYWxsb3dfY2FsbHMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgZXhwZWN0X3Rva2VuKFwib3BlcmF0b3JcIiwgXCJuZXdcIik7XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIuXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBleHBlY3RfdG9rZW4oXCJuYW1lXCIsIFwidGFyZ2V0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9OZXdUYXJnZXQoe1xuICAgICAgICAgICAgICAgIHN0YXJ0IDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kICAgOiBwcmV2KClcbiAgICAgICAgICAgIH0pLCBhbGxvd19jYWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld2V4cCA9IGV4cHJfYXRvbShmYWxzZSksIGFyZ3M7XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIoXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBhcmdzID0gZXhwcl9saXN0KFwiKVwiLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbCA9IG5ldyBBU1RfTmV3KHtcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBzdGFydCxcbiAgICAgICAgICAgIGV4cHJlc3Npb24gOiBuZXdleHAsXG4gICAgICAgICAgICBhcmdzICAgICAgIDogYXJncyxcbiAgICAgICAgICAgIGVuZCAgICAgICAgOiBwcmV2KClcbiAgICAgICAgfSk7XG4gICAgICAgIGFubm90YXRlKGNhbGwpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhjYWxsLCBhbGxvd19jYWxscyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGFzX2F0b21fbm9kZSgpIHtcbiAgICAgICAgdmFyIHRvayA9IFMudG9rZW4sIHJldDtcbiAgICAgICAgc3dpdGNoICh0b2sudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICByZXQgPSBfbWFrZV9zeW1ib2woQVNUX1N5bWJvbFJlZik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibnVtXCI6XG4gICAgICAgICAgICByZXQgPSBuZXcgQVNUX051bWJlcih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRvayxcbiAgICAgICAgICAgICAgICBlbmQ6IHRvayxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdG9rLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJhdzogTEFURVNUX1JBV1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYmlnX2ludFwiOlxuICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9CaWdJbnQoeyBzdGFydDogdG9rLCBlbmQ6IHRvaywgdmFsdWU6IHRvay52YWx1ZSB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfU3RyaW5nKHtcbiAgICAgICAgICAgICAgICBzdGFydCA6IHRvayxcbiAgICAgICAgICAgICAgICBlbmQgICA6IHRvayxcbiAgICAgICAgICAgICAgICB2YWx1ZSA6IHRvay52YWx1ZSxcbiAgICAgICAgICAgICAgICBxdW90ZSA6IHRvay5xdW90ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicmVnZXhwXCI6XG4gICAgICAgICAgICBjb25zdCBbXywgc291cmNlLCBmbGFnc10gPSB0b2sudmFsdWUubWF0Y2goL15cXC8oLiopXFwvKFxcdyopJC8pO1xuXG4gICAgICAgICAgICByZXQgPSBuZXcgQVNUX1JlZ0V4cCh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rLCB2YWx1ZTogeyBzb3VyY2UsIGZsYWdzIH0gfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYXRvbVwiOlxuICAgICAgICAgICAgc3dpdGNoICh0b2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICAgICAgICAgICAgcmV0ID0gbmV3IEFTVF9GYWxzZSh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidHJ1ZVwiOlxuICAgICAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfVHJ1ZSh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgICAgIHJldCA9IG5ldyBBU1RfTnVsbCh7IHN0YXJ0OiB0b2ssIGVuZDogdG9rIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvX2Z1bl9hcmdzKGV4LCBkZWZhdWx0X3NlZW5fYWJvdmUpIHtcbiAgICAgICAgdmFyIGluc2VydF9kZWZhdWx0ID0gZnVuY3Rpb24oZXgsIGRlZmF1bHRfdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0X3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRGVmYXVsdEFzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBleC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZXgsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGRlZmF1bHRfdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZGVmYXVsdF92YWx1ZS5lbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgQVNUX09iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydF9kZWZhdWx0KG5ldyBBU1RfRGVzdHJ1Y3R1cmluZyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGV4LnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogZXguZW5kLFxuICAgICAgICAgICAgICAgIGlzX2FycmF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBuYW1lczogZXgucHJvcGVydGllcy5tYXAocHJvcCA9PiB0b19mdW5fYXJncyhwcm9wKSlcbiAgICAgICAgICAgIH0pLCBkZWZhdWx0X3NlZW5fYWJvdmUpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgQVNUX09iamVjdEtleVZhbCkge1xuICAgICAgICAgICAgZXgudmFsdWUgPSB0b19mdW5fYXJncyhleC52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0X2RlZmF1bHQoZXgsIGRlZmF1bHRfc2Vlbl9hYm92ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXggaW5zdGFuY2VvZiBBU1RfSG9sZSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4O1xuICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgQVNUX0Rlc3RydWN0dXJpbmcpIHtcbiAgICAgICAgICAgIGV4Lm5hbWVzID0gZXgubmFtZXMubWFwKG5hbWUgPT4gdG9fZnVuX2FyZ3MobmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydF9kZWZhdWx0KGV4LCBkZWZhdWx0X3NlZW5fYWJvdmUpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikge1xuICAgICAgICAgICAgcmV0dXJuIGluc2VydF9kZWZhdWx0KG5ldyBBU1RfU3ltYm9sRnVuYXJnKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBleC5uYW1lLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBleC5zdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGV4LmVuZFxuICAgICAgICAgICAgfSksIGRlZmF1bHRfc2Vlbl9hYm92ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXggaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKSB7XG4gICAgICAgICAgICBleC5leHByZXNzaW9uID0gdG9fZnVuX2FyZ3MoZXguZXhwcmVzc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0X2RlZmF1bHQoZXgsIGRlZmF1bHRfc2Vlbl9hYm92ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXggaW5zdGFuY2VvZiBBU1RfQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnRfZGVmYXVsdChuZXcgQVNUX0Rlc3RydWN0dXJpbmcoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBleC5zdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGV4LmVuZCxcbiAgICAgICAgICAgICAgICBpc19hcnJheTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBuYW1lczogZXguZWxlbWVudHMubWFwKGVsbSA9PiB0b19mdW5fYXJncyhlbG0pKVxuICAgICAgICAgICAgfSksIGRlZmF1bHRfc2Vlbl9hYm92ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXggaW5zdGFuY2VvZiBBU1RfQXNzaWduKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0X2RlZmF1bHQodG9fZnVuX2FyZ3MoZXgubGVmdCwgZXgucmlnaHQpLCBkZWZhdWx0X3NlZW5fYWJvdmUpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4IGluc3RhbmNlb2YgQVNUX0RlZmF1bHRBc3NpZ24pIHtcbiAgICAgICAgICAgIGV4LmxlZnQgPSB0b19mdW5fYXJncyhleC5sZWZ0KTtcbiAgICAgICAgICAgIHJldHVybiBleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNyb2FrKFwiSW52YWxpZCBmdW5jdGlvbiBwYXJhbWV0ZXJcIiwgZXguc3RhcnQubGluZSwgZXguc3RhcnQuY29sKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBleHByX2F0b20gPSBmdW5jdGlvbihhbGxvd19jYWxscywgYWxsb3dfYXJyb3dzKSB7XG4gICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwibmV3XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3XyhhbGxvd19jYWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCJpbXBvcnRcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnRfbWV0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIHZhciBwZWVrZWQ7XG4gICAgICAgIHZhciBhc3luYyA9IGlzKFwibmFtZVwiLCBcImFzeW5jXCIpXG4gICAgICAgICAgICAmJiAocGVla2VkID0gcGVlaygpKS52YWx1ZSAhPSBcIltcIlxuICAgICAgICAgICAgJiYgcGVla2VkLnR5cGUgIT0gXCJhcnJvd1wiXG4gICAgICAgICAgICAmJiBhc19hdG9tX25vZGUoKTtcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiKSkge1xuICAgICAgICAgICAgc3dpdGNoIChTLnRva2VuLnZhbHVlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgaWYgKGFzeW5jICYmICFhbGxvd19jYWxscykgYnJlYWs7XG4gICAgICAgICAgICAgICAgdmFyIGV4cHJzID0gcGFyYW1zX29yX3NlcV8oYWxsb3dfYXJyb3dzLCAhYXN5bmMpO1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd19hcnJvd3MgJiYgaXMoXCJhcnJvd1wiLCBcIj0+XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJvd19mdW5jdGlvbihzdGFydCwgZXhwcnMubWFwKGUgPT4gdG9fZnVuX2FyZ3MoZSkpLCAhIWFzeW5jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGV4ID0gYXN5bmMgPyBuZXcgQVNUX0NhbGwoe1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBhc3luYyxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogZXhwcnNcbiAgICAgICAgICAgICAgICB9KSA6IGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiBuZXcgQVNUX1NlcXVlbmNlKHtcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IGV4cHJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4LnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dGVyX2NvbW1lbnRzX2JlZm9yZSA9IHN0YXJ0LmNvbW1lbnRzX2JlZm9yZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIG91dGVyX2NvbW1lbnRzX2JlZm9yZV9jb3VudHMuc2V0KHN0YXJ0LCBvdXRlcl9jb21tZW50c19iZWZvcmUpO1xuICAgICAgICAgICAgICAgICAgICBleC5zdGFydC5jb21tZW50c19iZWZvcmUudW5zaGlmdCguLi5zdGFydC5jb21tZW50c19iZWZvcmUpO1xuICAgICAgICAgICAgICAgICAgICBzdGFydC5jb21tZW50c19iZWZvcmUgPSBleC5zdGFydC5jb21tZW50c19iZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRlcl9jb21tZW50c19iZWZvcmUgPT0gMCAmJiBzdGFydC5jb21tZW50c19iZWZvcmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBzdGFydC5jb21tZW50c19iZWZvcmVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbW1lbnQubmxiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5ubGIgPSBzdGFydC5ubGI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQubmxiID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnQuY29tbWVudHNfYWZ0ZXIgPSBleC5zdGFydC5jb21tZW50c19hZnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXguc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gcHJldigpO1xuICAgICAgICAgICAgICAgIGlmIChleC5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kLmNvbW1lbnRzX2JlZm9yZSA9IGV4LmVuZC5jb21tZW50c19iZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIGV4LmVuZC5jb21tZW50c19hZnRlci5wdXNoKC4uLmVuZC5jb21tZW50c19hZnRlcik7XG4gICAgICAgICAgICAgICAgICAgIGVuZC5jb21tZW50c19hZnRlciA9IGV4LmVuZC5jb21tZW50c19hZnRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXguZW5kID0gZW5kO1xuICAgICAgICAgICAgICAgIGlmIChleCBpbnN0YW5jZW9mIEFTVF9DYWxsKSBhbm5vdGF0ZShleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoZXgsIGFsbG93X2NhbGxzKTtcbiAgICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhhcnJheV8oKSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG9iamVjdF9vcl9kZXN0cnVjdHVyaW5nXygpLCBhbGxvd19jYWxscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFzeW5jKSB1bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93X2Fycm93cyAmJiBpcyhcIm5hbWVcIikgJiYgaXNfdG9rZW4ocGVlaygpLCBcImFycm93XCIpKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSBuZXcgQVNUX1N5bWJvbEZ1bmFyZyh7XG4gICAgICAgICAgICAgICAgbmFtZTogUy50b2tlbi52YWx1ZSxcbiAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBzdGFydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIGFycm93X2Z1bmN0aW9uKHN0YXJ0LCBbcGFyYW1dLCAhIWFzeW5jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZnVuY3Rpb25cIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHZhciBmdW5jID0gZnVuY3Rpb25fKEFTVF9GdW5jdGlvbiwgZmFsc2UsICEhYXN5bmMpO1xuICAgICAgICAgICAgZnVuYy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgZnVuYy5lbmQgPSBwcmV2KCk7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhmdW5jLCBhbGxvd19jYWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzeW5jKSByZXR1cm4gc3Vic2NyaXB0cyhhc3luYywgYWxsb3dfY2FsbHMpO1xuICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiY2xhc3NcIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHZhciBjbHMgPSBjbGFzc18oQVNUX0NsYXNzRXhwcmVzc2lvbik7XG4gICAgICAgICAgICBjbHMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGNscy5lbmQgPSBwcmV2KCk7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyhjbHMsIGFsbG93X2NhbGxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoXCJ0ZW1wbGF0ZV9oZWFkXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0cyh0ZW1wbGF0ZV9zdHJpbmcoKSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBVE9NSUNfU1RBUlRfVE9LRU4uaGFzKFMudG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKGFzX2F0b21fbm9kZSgpLCBhbGxvd19jYWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgdW5leHBlY3RlZCgpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZV9zdHJpbmcoKSB7XG4gICAgICAgIHZhciBzZWdtZW50cyA9IFtdLCBzdGFydCA9IFMudG9rZW47XG5cbiAgICAgICAgc2VnbWVudHMucHVzaChuZXcgQVNUX1RlbXBsYXRlU2VnbWVudCh7XG4gICAgICAgICAgICBzdGFydDogUy50b2tlbixcbiAgICAgICAgICAgIHJhdzogTEFURVNUX1JBVyxcbiAgICAgICAgICAgIHZhbHVlOiBTLnRva2VuLnZhbHVlLFxuICAgICAgICAgICAgZW5kOiBTLnRva2VuXG4gICAgICAgIH0pKTtcblxuICAgICAgICB3aGlsZSAoIUxBVEVTVF9URU1QTEFURV9FTkQpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGhhbmRsZV9yZWdleHAoKTtcbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goZXhwcmVzc2lvbih0cnVlKSk7XG5cbiAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gobmV3IEFTVF9UZW1wbGF0ZVNlZ21lbnQoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBTLnRva2VuLFxuICAgICAgICAgICAgICAgIHJhdzogTEFURVNUX1JBVyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogUy50b2tlbi52YWx1ZSxcbiAgICAgICAgICAgICAgICBlbmQ6IFMudG9rZW5cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVGVtcGxhdGVTdHJpbmcoe1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgc2VnbWVudHM6IHNlZ21lbnRzLFxuICAgICAgICAgICAgZW5kOiBTLnRva2VuXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cHJfbGlzdChjbG9zaW5nLCBhbGxvd190cmFpbGluZ19jb21tYSwgYWxsb3dfZW1wdHkpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZSwgYSA9IFtdO1xuICAgICAgICB3aGlsZSAoIWlzKFwicHVuY1wiLCBjbG9zaW5nKSkge1xuICAgICAgICAgICAgaWYgKGZpcnN0KSBmaXJzdCA9IGZhbHNlOyBlbHNlIGV4cGVjdChcIixcIik7XG4gICAgICAgICAgICBpZiAoYWxsb3dfdHJhaWxpbmdfY29tbWEgJiYgaXMoXCJwdW5jXCIsIGNsb3NpbmcpKSBicmVhaztcbiAgICAgICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIsXCIpICYmIGFsbG93X2VtcHR5KSB7XG4gICAgICAgICAgICAgICAgYS5wdXNoKG5ldyBBU1RfSG9sZSh7IHN0YXJ0OiBTLnRva2VuLCBlbmQ6IFMudG9rZW4gfSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhcImV4cGFuZFwiLCBcIi4uLlwiKSkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBhLnB1c2gobmV3IEFTVF9FeHBhbnNpb24oe3N0YXJ0OiBwcmV2KCksIGV4cHJlc3Npb246IGV4cHJlc3Npb24oKSxlbmQ6IFMudG9rZW59KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGEucHVzaChleHByZXNzaW9uKGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB2YXIgYXJyYXlfID0gZW1iZWRfdG9rZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICBleHBlY3QoXCJbXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9BcnJheSh7XG4gICAgICAgICAgICBlbGVtZW50czogZXhwcl9saXN0KFwiXVwiLCAhb3B0aW9ucy5zdHJpY3QsIHRydWUpXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGNyZWF0ZV9hY2Nlc3NvciA9IGVtYmVkX3Rva2VucygoaXNfZ2VuZXJhdG9yLCBpc19hc3luYykgPT4ge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25fKEFTVF9BY2Nlc3NvciwgaXNfZ2VuZXJhdG9yLCBpc19hc3luYyk7XG4gICAgfSk7XG5cbiAgICB2YXIgb2JqZWN0X29yX2Rlc3RydWN0dXJpbmdfID0gZW1iZWRfdG9rZW5zKGZ1bmN0aW9uIG9iamVjdF9vcl9kZXN0cnVjdHVyaW5nXygpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbiwgZmlyc3QgPSB0cnVlLCBhID0gW107XG4gICAgICAgIGV4cGVjdChcIntcIik7XG4gICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgaWYgKGZpcnN0KSBmaXJzdCA9IGZhbHNlOyBlbHNlIGV4cGVjdChcIixcIik7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0ICYmIGlzKFwicHVuY1wiLCBcIn1cIikpXG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgdHJhaWxpbmcgY29tbWFcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICAgICAgaWYgKHN0YXJ0LnR5cGUgPT0gXCJleHBhbmRcIikge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBhLnB1c2gobmV3IEFTVF9FeHBhbnNpb24oe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24oZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuYW1lID0gYXNfcHJvcGVydHlfbmFtZSgpO1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBwcm9wZXJ0eSBhbmQgZmV0Y2ggdmFsdWVcbiAgICAgICAgICAgIGlmICghaXMoXCJwdW5jXCIsIFwiOlwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBjb25jaXNlID0gY29uY2lzZV9tZXRob2Rfb3JfZ2V0c2V0KG5hbWUsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29uY2lzZSkge1xuICAgICAgICAgICAgICAgICAgICBhLnB1c2goY29uY2lzZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEFTVF9TeW1ib2xSZWYoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJldigpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdW5leHBlY3RlZChwcmV2KCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7IC8vIGA6YCAtIHNlZSBmaXJzdCBjb25kaXRpb25cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGV4cHJlc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgZGVmYXVsdCB2YWx1ZSBhbmQgYWx0ZXIgdmFsdWUgYWNjb3JkaW5nbHkgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiLCBcIj1cIikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQVNUX0Fzc2lnbih7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGV4cHJlc3Npb24oZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICBsb2dpY2FsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHByb3BlcnR5XG4gICAgICAgICAgICBhLnB1c2gobmV3IEFTVF9PYmplY3RLZXlWYWwoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBxdW90ZTogc3RhcnQucXVvdGUsXG4gICAgICAgICAgICAgICAga2V5OiBuYW1lIGluc3RhbmNlb2YgQVNUX05vZGUgPyBuYW1lIDogXCJcIiArIG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gbmV3IEFTVF9PYmplY3QoeyBwcm9wZXJ0aWVzOiBhIH0pO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gY2xhc3NfKEtpbmRPZkNsYXNzLCBpc19leHBvcnRfZGVmYXVsdCkge1xuICAgICAgICB2YXIgc3RhcnQsIG1ldGhvZCwgY2xhc3NfbmFtZSwgZXh0ZW5kc18sIGEgPSBbXTtcblxuICAgICAgICBTLmlucHV0LnB1c2hfZGlyZWN0aXZlc19zdGFjaygpOyAvLyBQdXNoIGRpcmVjdGl2ZSBzdGFjaywgYnV0IG5vdCBzY29wZSBzdGFja1xuICAgICAgICBTLmlucHV0LmFkZF9kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpO1xuXG4gICAgICAgIGlmIChTLnRva2VuLnR5cGUgPT0gXCJuYW1lXCIgJiYgUy50b2tlbi52YWx1ZSAhPSBcImV4dGVuZHNcIikge1xuICAgICAgICAgICAgY2xhc3NfbmFtZSA9IGFzX3N5bWJvbChLaW5kT2ZDbGFzcyA9PT0gQVNUX0RlZkNsYXNzID8gQVNUX1N5bWJvbERlZkNsYXNzIDogQVNUX1N5bWJvbENsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChLaW5kT2ZDbGFzcyA9PT0gQVNUX0RlZkNsYXNzICYmICFjbGFzc19uYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNfZXhwb3J0X2RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBLaW5kT2ZDbGFzcyA9IEFTVF9DbGFzc0V4cHJlc3Npb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChTLnRva2VuLnZhbHVlID09IFwiZXh0ZW5kc1wiKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBleHRlbmRzXyA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHBlY3QoXCJ7XCIpO1xuXG4gICAgICAgIHdoaWxlIChpcyhcInB1bmNcIiwgXCI7XCIpKSB7IG5leHQoKTsgfSAgLy8gTGVhZGluZyBzZW1pY29sb25zIGFyZSBva2F5IGluIGNsYXNzIGJvZGllcy5cbiAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCJ9XCIpKSB7XG4gICAgICAgICAgICBzdGFydCA9IFMudG9rZW47XG4gICAgICAgICAgICBtZXRob2QgPSBjb25jaXNlX21ldGhvZF9vcl9nZXRzZXQoYXNfcHJvcGVydHlfbmFtZSgpLCBzdGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIW1ldGhvZCkgeyB1bmV4cGVjdGVkKCk7IH1cbiAgICAgICAgICAgIGEucHVzaChtZXRob2QpO1xuICAgICAgICAgICAgd2hpbGUgKGlzKFwicHVuY1wiLCBcIjtcIikpIHsgbmV4dCgpOyB9XG4gICAgICAgIH1cblxuICAgICAgICBTLmlucHV0LnBvcF9kaXJlY3RpdmVzX3N0YWNrKCk7XG5cbiAgICAgICAgbmV4dCgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgS2luZE9mQ2xhc3Moe1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgbmFtZTogY2xhc3NfbmFtZSxcbiAgICAgICAgICAgIGV4dGVuZHM6IGV4dGVuZHNfLFxuICAgICAgICAgICAgcHJvcGVydGllczogYSxcbiAgICAgICAgICAgIGVuZDogcHJldigpLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25jaXNlX21ldGhvZF9vcl9nZXRzZXQobmFtZSwgc3RhcnQsIGlzX2NsYXNzKSB7XG4gICAgICAgIGNvbnN0IGdldF9zeW1ib2xfYXN0ID0gKG5hbWUsIFN5bWJvbENsYXNzID0gQVNUX1N5bWJvbE1ldGhvZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBuYW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTeW1ib2xDbGFzcyh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlwiICsgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGlzX25vdF9tZXRob2Rfc3RhcnQgPSAoKSA9PlxuICAgICAgICAgICAgIWlzKFwicHVuY1wiLCBcIihcIikgJiYgIWlzKFwicHVuY1wiLCBcIixcIikgJiYgIWlzKFwicHVuY1wiLCBcIn1cIikgJiYgIWlzKFwib3BlcmF0b3JcIiwgXCI9XCIpO1xuXG4gICAgICAgIHZhciBpc19hc3luYyA9IGZhbHNlO1xuICAgICAgICB2YXIgaXNfc3RhdGljID0gZmFsc2U7XG4gICAgICAgIHZhciBpc19nZW5lcmF0b3IgPSBmYWxzZTtcbiAgICAgICAgdmFyIGlzX3ByaXZhdGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFjY2Vzc29yX3R5cGUgPSBudWxsO1xuXG4gICAgICAgIGlmIChpc19jbGFzcyAmJiBuYW1lID09PSBcInN0YXRpY1wiICYmIGlzX25vdF9tZXRob2Rfc3RhcnQoKSkge1xuICAgICAgICAgICAgaXNfc3RhdGljID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBhc19wcm9wZXJ0eV9uYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09IFwiYXN5bmNcIiAmJiBpc19ub3RfbWV0aG9kX3N0YXJ0KCkpIHtcbiAgICAgICAgICAgIGlzX2FzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBhc19wcm9wZXJ0eV9uYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXYoKS50eXBlID09PSBcIm9wZXJhdG9yXCIgJiYgcHJldigpLnZhbHVlID09PSBcIipcIikge1xuICAgICAgICAgICAgaXNfZ2VuZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBhc19wcm9wZXJ0eV9uYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChuYW1lID09PSBcImdldFwiIHx8IG5hbWUgPT09IFwic2V0XCIpICYmIGlzX25vdF9tZXRob2Rfc3RhcnQoKSkge1xuICAgICAgICAgICAgYWNjZXNzb3JfdHlwZSA9IG5hbWU7XG4gICAgICAgICAgICBuYW1lID0gYXNfcHJvcGVydHlfbmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2KCkudHlwZSA9PT0gXCJwcml2YXRlbmFtZVwiKSB7XG4gICAgICAgICAgICBpc19wcml2YXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb3BlcnR5X3Rva2VuID0gcHJldigpO1xuXG4gICAgICAgIGlmIChhY2Nlc3Nvcl90eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghaXNfcHJpdmF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IEFjY2Vzc29yQ2xhc3MgPSBhY2Nlc3Nvcl90eXBlID09PSBcImdldFwiXG4gICAgICAgICAgICAgICAgICAgID8gQVNUX09iamVjdEdldHRlclxuICAgICAgICAgICAgICAgICAgICA6IEFTVF9PYmplY3RTZXR0ZXI7XG5cbiAgICAgICAgICAgICAgICBuYW1lID0gZ2V0X3N5bWJvbF9hc3QobmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBY2Nlc3NvckNsYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpYzogaXNfc3RhdGljLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1b3RlOiBuYW1lIGluc3RhbmNlb2YgQVNUX1N5bWJvbE1ldGhvZCA/IHByb3BlcnR5X3Rva2VuLnF1b3RlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY3JlYXRlX2FjY2Vzc29yKCksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IEFjY2Vzc29yQ2xhc3MgPSBhY2Nlc3Nvcl90eXBlID09PSBcImdldFwiXG4gICAgICAgICAgICAgICAgICAgID8gQVNUX1ByaXZhdGVHZXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgOiBBU1RfUHJpdmF0ZVNldHRlcjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWNjZXNzb3JDbGFzcyh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBzdGF0aWM6IGlzX3N0YXRpYyxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBnZXRfc3ltYm9sX2FzdChuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNyZWF0ZV9hY2Nlc3NvcigpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCIoXCIpKSB7XG4gICAgICAgICAgICBuYW1lID0gZ2V0X3N5bWJvbF9hc3QobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBBU1RfTWV0aG9kVmFyaWFudCA9IGlzX3ByaXZhdGVcbiAgICAgICAgICAgICAgICA/IEFTVF9Qcml2YXRlTWV0aG9kXG4gICAgICAgICAgICAgICAgOiBBU1RfQ29uY2lzZU1ldGhvZDtcbiAgICAgICAgICAgIHZhciBub2RlID0gbmV3IEFTVF9NZXRob2RWYXJpYW50KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgICA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIHN0YXRpYyAgICAgIDogaXNfc3RhdGljLFxuICAgICAgICAgICAgICAgIGlzX2dlbmVyYXRvcjogaXNfZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIGFzeW5jICAgICAgIDogaXNfYXN5bmMsXG4gICAgICAgICAgICAgICAga2V5ICAgICAgICAgOiBuYW1lLFxuICAgICAgICAgICAgICAgIHF1b3RlICAgICAgIDogbmFtZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xNZXRob2QgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlfdG9rZW4ucXVvdGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgICAgOiBjcmVhdGVfYWNjZXNzb3IoaXNfZ2VuZXJhdG9yLCBpc19hc3luYyksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICAgOiBwcmV2KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNfY2xhc3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldF9zeW1ib2xfYXN0KG5hbWUsIEFTVF9TeW1ib2xDbGFzc1Byb3BlcnR5KTtcbiAgICAgICAgICAgIGNvbnN0IHF1b3RlID0ga2V5IGluc3RhbmNlb2YgQVNUX1N5bWJvbENsYXNzUHJvcGVydHlcbiAgICAgICAgICAgICAgICA/IHByb3BlcnR5X3Rva2VuLnF1b3RlXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBBU1RfQ2xhc3NQcm9wZXJ0eVZhcmlhbnQgPSBpc19wcml2YXRlXG4gICAgICAgICAgICAgICAgPyBBU1RfQ2xhc3NQcml2YXRlUHJvcGVydHlcbiAgICAgICAgICAgICAgICA6IEFTVF9DbGFzc1Byb3BlcnR5O1xuICAgICAgICAgICAgaWYgKGlzKFwib3BlcmF0b3JcIiwgXCI9XCIpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0NsYXNzUHJvcGVydHlWYXJpYW50KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRpYzogaXNfc3RhdGljLFxuICAgICAgICAgICAgICAgICAgICBxdW90ZSxcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXhwcmVzc2lvbihmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIGlzKFwibmFtZVwiKVxuICAgICAgICAgICAgICAgIHx8IGlzKFwicHJpdmF0ZW5hbWVcIilcbiAgICAgICAgICAgICAgICB8fCBpcyhcIm9wZXJhdG9yXCIsIFwiKlwiKVxuICAgICAgICAgICAgICAgIHx8IGlzKFwicHVuY1wiLCBcIjtcIilcbiAgICAgICAgICAgICAgICB8fCBpcyhcInB1bmNcIiwgXCJ9XCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9DbGFzc1Byb3BlcnR5VmFyaWFudCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBzdGF0aWM6IGlzX3N0YXRpYyxcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUsXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGltcG9ydF8oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHByZXYoKTtcblxuICAgICAgICB2YXIgaW1wb3J0ZWRfbmFtZTtcbiAgICAgICAgdmFyIGltcG9ydGVkX25hbWVzO1xuICAgICAgICBpZiAoaXMoXCJuYW1lXCIpKSB7XG4gICAgICAgICAgICBpbXBvcnRlZF9uYW1lID0gYXNfc3ltYm9sKEFTVF9TeW1ib2xJbXBvcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIixcIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGltcG9ydGVkX25hbWVzID0gbWFwX25hbWVzKHRydWUpO1xuXG4gICAgICAgIGlmIChpbXBvcnRlZF9uYW1lcyB8fCBpbXBvcnRlZF9uYW1lKSB7XG4gICAgICAgICAgICBleHBlY3RfdG9rZW4oXCJuYW1lXCIsIFwiZnJvbVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kX3N0ciA9IFMudG9rZW47XG4gICAgICAgIGlmIChtb2Rfc3RyLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBuZXcgQVNUX0ltcG9ydCh7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBpbXBvcnRlZF9uYW1lOiBpbXBvcnRlZF9uYW1lLFxuICAgICAgICAgICAgaW1wb3J0ZWRfbmFtZXM6IGltcG9ydGVkX25hbWVzLFxuICAgICAgICAgICAgbW9kdWxlX25hbWU6IG5ldyBBU1RfU3RyaW5nKHtcbiAgICAgICAgICAgICAgICBzdGFydDogbW9kX3N0cixcbiAgICAgICAgICAgICAgICB2YWx1ZTogbW9kX3N0ci52YWx1ZSxcbiAgICAgICAgICAgICAgICBxdW90ZTogbW9kX3N0ci5xdW90ZSxcbiAgICAgICAgICAgICAgICBlbmQ6IG1vZF9zdHIsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVuZDogUy50b2tlbixcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW1wb3J0X21ldGEoKSB7XG4gICAgICAgIHZhciBzdGFydCA9IFMudG9rZW47XG4gICAgICAgIGV4cGVjdF90b2tlbihcIm9wZXJhdG9yXCIsIFwiaW1wb3J0XCIpO1xuICAgICAgICBleHBlY3RfdG9rZW4oXCJwdW5jXCIsIFwiLlwiKTtcbiAgICAgICAgZXhwZWN0X3Rva2VuKFwibmFtZVwiLCBcIm1ldGFcIik7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG5ldyBBU1RfSW1wb3J0TWV0YSh7XG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IHByZXYoKVxuICAgICAgICB9KSwgZmFsc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcF9uYW1lKGlzX2ltcG9ydCkge1xuICAgICAgICBmdW5jdGlvbiBtYWtlX3N5bWJvbCh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHR5cGUoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGFzX3Byb3BlcnR5X25hbWUoKSxcbiAgICAgICAgICAgICAgICBzdGFydDogcHJldigpLFxuICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmb3JlaWduX3R5cGUgPSBpc19pbXBvcnQgPyBBU1RfU3ltYm9sSW1wb3J0Rm9yZWlnbiA6IEFTVF9TeW1ib2xFeHBvcnRGb3JlaWduO1xuICAgICAgICB2YXIgdHlwZSA9IGlzX2ltcG9ydCA/IEFTVF9TeW1ib2xJbXBvcnQgOiBBU1RfU3ltYm9sRXhwb3J0O1xuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICB2YXIgZm9yZWlnbl9uYW1lO1xuICAgICAgICB2YXIgbmFtZTtcblxuICAgICAgICBpZiAoaXNfaW1wb3J0KSB7XG4gICAgICAgICAgICBmb3JlaWduX25hbWUgPSBtYWtlX3N5bWJvbChmb3JlaWduX3R5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IG1ha2Vfc3ltYm9sKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhcIm5hbWVcIiwgXCJhc1wiKSkge1xuICAgICAgICAgICAgbmV4dCgpOyAgLy8gVGhlIFwiYXNcIiB3b3JkXG4gICAgICAgICAgICBpZiAoaXNfaW1wb3J0KSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG1ha2Vfc3ltYm9sKHR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JlaWduX25hbWUgPSBtYWtlX3N5bWJvbChmb3JlaWduX3R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzX2ltcG9ydCkge1xuICAgICAgICAgICAgbmFtZSA9IG5ldyB0eXBlKGZvcmVpZ25fbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JlaWduX25hbWUgPSBuZXcgZm9yZWlnbl90eXBlKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfTmFtZU1hcHBpbmcoe1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZm9yZWlnbl9uYW1lOiBmb3JlaWduX25hbWUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgZW5kOiBwcmV2KCksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcF9uYW1lQXN0ZXJpc2soaXNfaW1wb3J0LCBuYW1lKSB7XG4gICAgICAgIHZhciBmb3JlaWduX3R5cGUgPSBpc19pbXBvcnQgPyBBU1RfU3ltYm9sSW1wb3J0Rm9yZWlnbiA6IEFTVF9TeW1ib2xFeHBvcnRGb3JlaWduO1xuICAgICAgICB2YXIgdHlwZSA9IGlzX2ltcG9ydCA/IEFTVF9TeW1ib2xJbXBvcnQgOiBBU1RfU3ltYm9sRXhwb3J0O1xuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICB2YXIgZm9yZWlnbl9uYW1lO1xuICAgICAgICB2YXIgZW5kID0gcHJldigpO1xuXG4gICAgICAgIG5hbWUgPSBuYW1lIHx8IG5ldyB0eXBlKHtcbiAgICAgICAgICAgIG5hbWU6IFwiKlwiLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvcmVpZ25fbmFtZSA9IG5ldyBmb3JlaWduX3R5cGUoe1xuICAgICAgICAgICAgbmFtZTogXCIqXCIsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfTmFtZU1hcHBpbmcoe1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZm9yZWlnbl9uYW1lOiBmb3JlaWduX25hbWUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcF9uYW1lcyhpc19pbXBvcnQpIHtcbiAgICAgICAgdmFyIG5hbWVzO1xuICAgICAgICBpZiAoaXMoXCJwdW5jXCIsIFwie1wiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgbmFtZXMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICghaXMoXCJwdW5jXCIsIFwifVwiKSkge1xuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2gobWFwX25hbWUoaXNfaW1wb3J0KSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIixcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiKlwiKSkge1xuICAgICAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBpZiAoaXNfaW1wb3J0ICYmIGlzKFwibmFtZVwiLCBcImFzXCIpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpOyAgLy8gVGhlIFwiYXNcIiB3b3JkXG4gICAgICAgICAgICAgICAgbmFtZSA9IGFzX3N5bWJvbChpc19pbXBvcnQgPyBBU1RfU3ltYm9sSW1wb3J0IDogQVNUX1N5bWJvbEV4cG9ydEZvcmVpZ24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZXMgPSBbbWFwX25hbWVBc3Rlcmlzayhpc19pbXBvcnQsIG5hbWUpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwb3J0XygpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgdmFyIGlzX2RlZmF1bHQ7XG4gICAgICAgIHZhciBleHBvcnRlZF9uYW1lcztcblxuICAgICAgICBpZiAoaXMoXCJrZXl3b3JkXCIsIFwiZGVmYXVsdFwiKSkge1xuICAgICAgICAgICAgaXNfZGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwb3J0ZWRfbmFtZXMgPSBtYXBfbmFtZXMoZmFsc2UpKSB7XG4gICAgICAgICAgICBpZiAoaXMoXCJuYW1lXCIsIFwiZnJvbVwiKSkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcblxuICAgICAgICAgICAgICAgIHZhciBtb2Rfc3RyID0gUy50b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAobW9kX3N0ci50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRXhwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpc19kZWZhdWx0OiBpc19kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZF9uYW1lczogZXhwb3J0ZWRfbmFtZXMsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZV9uYW1lOiBuZXcgQVNUX1N0cmluZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbW9kX3N0cixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtb2Rfc3RyLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGU6IG1vZF9zdHIucXVvdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG1vZF9zdHIsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHByZXYoKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRXhwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpc19kZWZhdWx0OiBpc19kZWZhdWx0LFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZF9uYW1lczogZXhwb3J0ZWRfbmFtZXMsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBleHBvcnRlZF92YWx1ZTtcbiAgICAgICAgdmFyIGV4cG9ydGVkX2RlZmluaXRpb247XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCJ7XCIpXG4gICAgICAgICAgICB8fCBpc19kZWZhdWx0XG4gICAgICAgICAgICAgICAgJiYgKGlzKFwia2V5d29yZFwiLCBcImNsYXNzXCIpIHx8IGlzKFwia2V5d29yZFwiLCBcImZ1bmN0aW9uXCIpKVxuICAgICAgICAgICAgICAgICYmIGlzX3Rva2VuKHBlZWsoKSwgXCJwdW5jXCIpKSB7XG4gICAgICAgICAgICBleHBvcnRlZF92YWx1ZSA9IGV4cHJlc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgc2VtaWNvbG9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKG5vZGUgPSBzdGF0ZW1lbnQoaXNfZGVmYXVsdCkpIGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zICYmIGlzX2RlZmF1bHQpIHtcbiAgICAgICAgICAgIHVuZXhwZWN0ZWQobm9kZS5zdGFydCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zXG4gICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0RlZnVuXG4gICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0RlZkNsYXNzXG4gICAgICAgICkge1xuICAgICAgICAgICAgZXhwb3J0ZWRfZGVmaW5pdGlvbiA9IG5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX0NsYXNzRXhwcmVzc2lvblxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICAgIGV4cG9ydGVkX3ZhbHVlID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgZXhwb3J0ZWRfdmFsdWUgPSBub2RlLmJvZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmV4cGVjdGVkKG5vZGUuc3RhcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfRXhwb3J0KHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGlzX2RlZmF1bHQ6IGlzX2RlZmF1bHQsXG4gICAgICAgICAgICBleHBvcnRlZF92YWx1ZTogZXhwb3J0ZWRfdmFsdWUsXG4gICAgICAgICAgICBleHBvcnRlZF9kZWZpbml0aW9uOiBleHBvcnRlZF9kZWZpbml0aW9uLFxuICAgICAgICAgICAgZW5kOiBwcmV2KCksXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzX3Byb3BlcnR5X25hbWUoKSB7XG4gICAgICAgIHZhciB0bXAgPSBTLnRva2VuO1xuICAgICAgICBzd2l0Y2ggKHRtcC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInB1bmNcIjpcbiAgICAgICAgICAgIGlmICh0bXAudmFsdWUgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciBleCA9IGV4cHJlc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChcIl1cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4O1xuICAgICAgICAgICAgfSBlbHNlIHVuZXhwZWN0ZWQodG1wKTtcbiAgICAgICAgICBjYXNlIFwib3BlcmF0b3JcIjpcbiAgICAgICAgICAgIGlmICh0bXAudmFsdWUgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFbXCJkZWxldGVcIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIiwgXCJuZXdcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCJdLmluY2x1ZGVzKHRtcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKHRtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICBjYXNlIFwicHJpdmF0ZW5hbWVcIjpcbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgY2FzZSBcIm51bVwiOlxuICAgICAgICAgIGNhc2UgXCJiaWdfaW50XCI6XG4gICAgICAgICAgY2FzZSBcImtleXdvcmRcIjpcbiAgICAgICAgICBjYXNlIFwiYXRvbVwiOlxuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRtcC52YWx1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdW5leHBlY3RlZCh0bXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXNfbmFtZSgpIHtcbiAgICAgICAgdmFyIHRtcCA9IFMudG9rZW47XG4gICAgICAgIGlmICh0bXAudHlwZSAhPSBcIm5hbWVcIiAmJiB0bXAudHlwZSAhPSBcInByaXZhdGVuYW1lXCIpIHVuZXhwZWN0ZWQoKTtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgICByZXR1cm4gdG1wLnZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9tYWtlX3N5bWJvbCh0eXBlKSB7XG4gICAgICAgIHZhciBuYW1lID0gUy50b2tlbi52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyAobmFtZSA9PSBcInRoaXNcIiA/IEFTVF9UaGlzIDpcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9PSBcInN1cGVyXCIgPyBBU1RfU3VwZXIgOlxuICAgICAgICAgICAgICAgICAgICB0eXBlKSh7XG4gICAgICAgICAgICBuYW1lICA6IFN0cmluZyhuYW1lKSxcbiAgICAgICAgICAgIHN0YXJ0IDogUy50b2tlbixcbiAgICAgICAgICAgIGVuZCAgIDogUy50b2tlblxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfdmVyaWZ5X3N5bWJvbChzeW0pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBzeW0ubmFtZTtcbiAgICAgICAgaWYgKGlzX2luX2dlbmVyYXRvcigpICYmIG5hbWUgPT0gXCJ5aWVsZFwiKSB7XG4gICAgICAgICAgICB0b2tlbl9lcnJvcihzeW0uc3RhcnQsIFwiWWllbGQgY2Fubm90IGJlIHVzZWQgYXMgaWRlbnRpZmllciBpbnNpZGUgZ2VuZXJhdG9yc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoUy5pbnB1dC5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJ5aWVsZFwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5fZXJyb3Ioc3ltLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgeWllbGQgaWRlbnRpZmllciBpbnNpZGUgc3RyaWN0IG1vZGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3ltIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlY2xhcmF0aW9uICYmIChuYW1lID09IFwiYXJndW1lbnRzXCIgfHwgbmFtZSA9PSBcImV2YWxcIikpIHtcbiAgICAgICAgICAgICAgICB0b2tlbl9lcnJvcihzeW0uc3RhcnQsIFwiVW5leHBlY3RlZCBcIiArIG5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzX3N5bWJvbCh0eXBlLCBub2Vycm9yKSB7XG4gICAgICAgIGlmICghaXMoXCJuYW1lXCIpKSB7XG4gICAgICAgICAgICBpZiAoIW5vZXJyb3IpIGNyb2FrKFwiTmFtZSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzeW0gPSBfbWFrZV9zeW1ib2wodHlwZSk7XG4gICAgICAgIF92ZXJpZnlfc3ltYm9sKHN5bSk7XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuIHN5bTtcbiAgICB9XG5cbiAgICAvLyBBbm5vdGF0ZSBBU1RfQ2FsbCwgQVNUX0xhbWJkYSBvciBBU1RfTmV3IHdpdGggdGhlIHNwZWNpYWwgY29tbWVudHNcbiAgICBmdW5jdGlvbiBhbm5vdGF0ZShub2RlKSB7XG4gICAgICAgIHZhciBzdGFydCA9IG5vZGUuc3RhcnQ7XG4gICAgICAgIHZhciBjb21tZW50cyA9IHN0YXJ0LmNvbW1lbnRzX2JlZm9yZTtcbiAgICAgICAgY29uc3QgY29tbWVudHNfb3V0c2lkZV9wYXJlbnMgPSBvdXRlcl9jb21tZW50c19iZWZvcmVfY291bnRzLmdldChzdGFydCk7XG4gICAgICAgIHZhciBpID0gY29tbWVudHNfb3V0c2lkZV9wYXJlbnMgIT0gbnVsbCA/IGNvbW1lbnRzX291dHNpZGVfcGFyZW5zIDogY29tbWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgIHZhciBjb21tZW50ID0gY29tbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoL1tAI11fXy8udGVzdChjb21tZW50LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICgvW0AjXV9fUFVSRV9fLy50ZXN0KGNvbW1lbnQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldF9hbm5vdGF0aW9uKG5vZGUsIF9QVVJFKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvW0AjXV9fSU5MSU5FX18vLnRlc3QoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0X2Fubm90YXRpb24obm9kZSwgX0lOTElORSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoL1tAI11fX05PSU5MSU5FX18vLnRlc3QoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0X2Fubm90YXRpb24obm9kZSwgX05PSU5MSU5FKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN1YnNjcmlwdHMgPSBmdW5jdGlvbihleHByLCBhbGxvd19jYWxscywgaXNfY2hhaW4pIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZXhwci5zdGFydDtcbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIi5cIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGNvbnN0IEFTVF9Eb3RWYXJpYW50ID0gaXMoXCJwcml2YXRlbmFtZVwiKSA/IEFTVF9Eb3RIYXNoIDogQVNUX0RvdDtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG5ldyBBU1RfRG90VmFyaWFudCh7XG4gICAgICAgICAgICAgICAgc3RhcnQgICAgICA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBleHByLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSAgIDogYXNfbmFtZSgpLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgOiBwcmV2KClcbiAgICAgICAgICAgIH0pLCBhbGxvd19jYWxscywgaXNfY2hhaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcyhcInB1bmNcIiwgXCJbXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB2YXIgcHJvcCA9IGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QoXCJdXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMobmV3IEFTVF9TdWIoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBzdGFydCxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZXhwcixcbiAgICAgICAgICAgICAgICBvcHRpb25hbCAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgICA6IHByb3AsXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IHByZXYoKVxuICAgICAgICAgICAgfSksIGFsbG93X2NhbGxzLCBpc19jaGFpbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93X2NhbGxzICYmIGlzKFwicHVuY1wiLCBcIihcIikpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHZhciBjYWxsID0gbmV3IEFTVF9DYWxsKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogc3RhcnQsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA6IGV4cHIsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWwgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFyZ3MgICAgICAgOiBjYWxsX2FyZ3MoKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogcHJldigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFubm90YXRlKGNhbGwpO1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdHMoY2FsbCwgdHJ1ZSwgaXNfY2hhaW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzKFwicHVuY1wiLCBcIj8uXCIpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG5cbiAgICAgICAgICAgIGxldCBjaGFpbl9jb250ZW50cztcblxuICAgICAgICAgICAgaWYgKGFsbG93X2NhbGxzICYmIGlzKFwicHVuY1wiLCBcIihcIikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsID0gbmV3IEFTVF9DYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBjYWxsX2FyZ3MoKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhbm5vdGF0ZShjYWxsKTtcblxuICAgICAgICAgICAgICAgIGNoYWluX2NvbnRlbnRzID0gc3Vic2NyaXB0cyhjYWxsLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXMoXCJuYW1lXCIpIHx8IGlzKFwicHJpdmF0ZW5hbWVcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBBU1RfRG90VmFyaWFudCA9IGlzKFwicHJpdmF0ZW5hbWVcIikgPyBBU1RfRG90SGFzaCA6IEFTVF9Eb3Q7XG4gICAgICAgICAgICAgICAgY2hhaW5fY29udGVudHMgPSBzdWJzY3JpcHRzKG5ldyBBU1RfRG90VmFyaWFudCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGFzX25hbWUoKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBwcmV2KClcbiAgICAgICAgICAgICAgICB9KSwgYWxsb3dfY2FsbHMsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpcyhcInB1bmNcIiwgXCJbXCIpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgICAgICAgICBleHBlY3QoXCJdXCIpO1xuICAgICAgICAgICAgICAgIGNoYWluX2NvbnRlbnRzID0gc3Vic2NyaXB0cyhuZXcgQVNUX1N1Yih7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgfSksIGFsbG93X2NhbGxzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjaGFpbl9jb250ZW50cykgdW5leHBlY3RlZCgpO1xuXG4gICAgICAgICAgICBpZiAoY2hhaW5fY29udGVudHMgaW5zdGFuY2VvZiBBU1RfQ2hhaW4pIHJldHVybiBjaGFpbl9jb250ZW50cztcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ2hhaW4oe1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGNoYWluX2NvbnRlbnRzLFxuICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpcyhcInRlbXBsYXRlX2hlYWRcIikpIHtcbiAgICAgICAgICAgIGlmIChpc19jaGFpbikge1xuICAgICAgICAgICAgICAgIC8vIGE/LmJgY2AgaXMgYSBzeW50YXggZXJyb3JcbiAgICAgICAgICAgICAgICB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRzKG5ldyBBU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIHByZWZpeDogZXhwcixcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZV9zdHJpbmc6IHRlbXBsYXRlX3N0cmluZygpLFxuICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICB9KSwgYWxsb3dfY2FsbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGxfYXJncygpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFpcyhcInB1bmNcIiwgXCIpXCIpKSB7XG4gICAgICAgICAgICBpZiAoaXMoXCJleHBhbmRcIiwgXCIuLi5cIikpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKG5ldyBBU1RfRXhwYW5zaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHByZXYoKSxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbihmYWxzZSksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcHJldigpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goZXhwcmVzc2lvbihmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpcyhcInB1bmNcIiwgXCIpXCIpKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0KFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cblxuICAgIHZhciBtYXliZV91bmFyeSA9IGZ1bmN0aW9uKGFsbG93X2NhbGxzLCBhbGxvd19hcnJvd3MpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgaWYgKHN0YXJ0LnR5cGUgPT0gXCJuYW1lXCIgJiYgc3RhcnQudmFsdWUgPT0gXCJhd2FpdFwiICYmIGNhbl9hd2FpdCgpKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gX2F3YWl0X2V4cHJlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiKSAmJiBVTkFSWV9QUkVGSVguaGFzKHN0YXJ0LnZhbHVlKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgaGFuZGxlX3JlZ2V4cCgpO1xuICAgICAgICAgICAgdmFyIGV4ID0gbWFrZV91bmFyeShBU1RfVW5hcnlQcmVmaXgsIHN0YXJ0LCBtYXliZV91bmFyeShhbGxvd19jYWxscykpO1xuICAgICAgICAgICAgZXguc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIGV4LmVuZCA9IHByZXYoKTtcbiAgICAgICAgICAgIHJldHVybiBleDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsID0gZXhwcl9hdG9tKGFsbG93X2NhbGxzLCBhbGxvd19hcnJvd3MpO1xuICAgICAgICB3aGlsZSAoaXMoXCJvcGVyYXRvclwiKSAmJiBVTkFSWV9QT1NURklYLmhhcyhTLnRva2VuLnZhbHVlKSAmJiAhaGFzX25ld2xpbmVfYmVmb3JlKFMudG9rZW4pKSB7XG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgQVNUX0Fycm93KSB1bmV4cGVjdGVkKCk7XG4gICAgICAgICAgICB2YWwgPSBtYWtlX3VuYXJ5KEFTVF9VbmFyeVBvc3RmaXgsIFMudG9rZW4sIHZhbCk7XG4gICAgICAgICAgICB2YWwuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHZhbC5lbmQgPSBTLnRva2VuO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VfdW5hcnkoY3RvciwgdG9rZW4sIGV4cHIpIHtcbiAgICAgICAgdmFyIG9wID0gdG9rZW4udmFsdWU7XG4gICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICBjYXNlIFwiKytcIjpcbiAgICAgICAgICBjYXNlIFwiLS1cIjpcbiAgICAgICAgICAgIGlmICghaXNfYXNzaWduYWJsZShleHByKSlcbiAgICAgICAgICAgICAgICBjcm9hayhcIkludmFsaWQgdXNlIG9mIFwiICsgb3AgKyBcIiBvcGVyYXRvclwiLCB0b2tlbi5saW5lLCB0b2tlbi5jb2wsIHRva2VuLnBvcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgUy5pbnB1dC5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKSlcbiAgICAgICAgICAgICAgICBjcm9hayhcIkNhbGxpbmcgZGVsZXRlIG9uIGV4cHJlc3Npb24gbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGVcIiwgZXhwci5zdGFydC5saW5lLCBleHByLnN0YXJ0LmNvbCwgZXhwci5zdGFydC5wb3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHsgb3BlcmF0b3I6IG9wLCBleHByZXNzaW9uOiBleHByIH0pO1xuICAgIH1cblxuICAgIHZhciBleHByX29wID0gZnVuY3Rpb24obGVmdCwgbWluX3ByZWMsIG5vX2luKSB7XG4gICAgICAgIHZhciBvcCA9IGlzKFwib3BlcmF0b3JcIikgPyBTLnRva2VuLnZhbHVlIDogbnVsbDtcbiAgICAgICAgaWYgKG9wID09IFwiaW5cIiAmJiBub19pbikgb3AgPSBudWxsO1xuICAgICAgICBpZiAob3AgPT0gXCIqKlwiICYmIGxlZnQgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgIC8qIHVuYXJ5IHRva2VuIGluIGZyb250IG5vdCBhbGxvd2VkIC0gcGFyZW50aGVzaXMgcmVxdWlyZWQgKi9cbiAgICAgICAgICAgICYmICFpc190b2tlbihsZWZ0LnN0YXJ0LCBcInB1bmNcIiwgXCIoXCIpXG4gICAgICAgICAgICAmJiBsZWZ0Lm9wZXJhdG9yICE9PSBcIi0tXCIgJiYgbGVmdC5vcGVyYXRvciAhPT0gXCIrK1wiKVxuICAgICAgICAgICAgICAgIHVuZXhwZWN0ZWQobGVmdC5zdGFydCk7XG4gICAgICAgIHZhciBwcmVjID0gb3AgIT0gbnVsbCA/IFBSRUNFREVOQ0Vbb3BdIDogbnVsbDtcbiAgICAgICAgaWYgKHByZWMgIT0gbnVsbCAmJiAocHJlYyA+IG1pbl9wcmVjIHx8IChvcCA9PT0gXCIqKlwiICYmIG1pbl9wcmVjID09PSBwcmVjKSkpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IGV4cHJfb3AobWF5YmVfdW5hcnkodHJ1ZSksIHByZWMsIG5vX2luKTtcbiAgICAgICAgICAgIHJldHVybiBleHByX29wKG5ldyBBU1RfQmluYXJ5KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICA6IGxlZnQuc3RhcnQsXG4gICAgICAgICAgICAgICAgbGVmdCAgICAgOiBsZWZ0LFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogb3AsXG4gICAgICAgICAgICAgICAgcmlnaHQgICAgOiByaWdodCxcbiAgICAgICAgICAgICAgICBlbmQgICAgICA6IHJpZ2h0LmVuZFxuICAgICAgICAgICAgfSksIG1pbl9wcmVjLCBub19pbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGV4cHJfb3BzKG5vX2luKSB7XG4gICAgICAgIHJldHVybiBleHByX29wKG1heWJlX3VuYXJ5KHRydWUsIHRydWUpLCAwLCBub19pbik7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlX2NvbmRpdGlvbmFsID0gZnVuY3Rpb24obm9faW4pIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgdmFyIGV4cHIgPSBleHByX29wcyhub19pbik7XG4gICAgICAgIGlmIChpcyhcIm9wZXJhdG9yXCIsIFwiP1wiKSkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgdmFyIHllcyA9IGV4cHJlc3Npb24oZmFsc2UpO1xuICAgICAgICAgICAgZXhwZWN0KFwiOlwiKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0NvbmRpdGlvbmFsKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgICA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvbiAgIDogZXhwcixcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW50ICA6IHllcyxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZSA6IGV4cHJlc3Npb24oZmFsc2UsIG5vX2luKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgICA6IHByZXYoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzX2Fzc2lnbmFibGUoZXhwcikge1xuICAgICAgICByZXR1cm4gZXhwciBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzIHx8IGV4cHIgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvX2Rlc3RydWN0dXJpbmcobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9PYmplY3QpIHtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgQVNUX0Rlc3RydWN0dXJpbmcoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIG5hbWVzOiBub2RlLnByb3BlcnRpZXMubWFwKHRvX2Rlc3RydWN0dXJpbmcpLFxuICAgICAgICAgICAgICAgIGlzX2FycmF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbmQ6IG5vZGUuZW5kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0FycmF5KSB7XG4gICAgICAgICAgICB2YXIgbmFtZXMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhbGxvdyBleHBhbnNpb24gYXMgbGFzdCBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZWxlbWVudHNbaV0gaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSAhPT0gbm9kZS5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKG5vZGUuZWxlbWVudHNbaV0uc3RhcnQsIFwiU3ByZWFkIG11c3QgdGhlIGJlIGxhc3QgZWxlbWVudCBpbiBkZXN0cnVjdHVyaW5nIGFycmF5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZWxlbWVudHNbaV0uZXhwcmVzc2lvbiA9IHRvX2Rlc3RydWN0dXJpbmcobm9kZS5lbGVtZW50c1tpXS5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKHRvX2Rlc3RydWN0dXJpbmcobm9kZS5lbGVtZW50c1tpXSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gbmV3IEFTVF9EZXN0cnVjdHVyaW5nKHtcbiAgICAgICAgICAgICAgICBzdGFydDogbm9kZS5zdGFydCxcbiAgICAgICAgICAgICAgICBuYW1lczogbmFtZXMsXG4gICAgICAgICAgICAgICAgaXNfYXJyYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgZW5kOiBub2RlLmVuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9PYmplY3RQcm9wZXJ0eSkge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHRvX2Rlc3RydWN0dXJpbmcobm9kZS52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24pIHtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgQVNUX0RlZmF1bHRBc3NpZ24oe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBub2RlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGxlZnQ6IG5vZGUubGVmdCxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCI9XCIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IG5vZGUucmlnaHQsXG4gICAgICAgICAgICAgICAgZW5kOiBub2RlLmVuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgLy8gSW4gRVM2LCBBc3NpZ25tZW50RXhwcmVzc2lvbiBjYW4gYWxzbyBiZSBhbiBBcnJvd0Z1bmN0aW9uXG4gICAgdmFyIG1heWJlX2Fzc2lnbiA9IGZ1bmN0aW9uKG5vX2luKSB7XG4gICAgICAgIGhhbmRsZV9yZWdleHAoKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcblxuICAgICAgICBpZiAoc3RhcnQudHlwZSA9PSBcIm5hbWVcIiAmJiBzdGFydC52YWx1ZSA9PSBcInlpZWxkXCIpIHtcbiAgICAgICAgICAgIGlmIChpc19pbl9nZW5lcmF0b3IoKSkge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3lpZWxkX2V4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUy5pbnB1dC5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKSkge1xuICAgICAgICAgICAgICAgIHRva2VuX2Vycm9yKFMudG9rZW4sIFwiVW5leHBlY3RlZCB5aWVsZCBpZGVudGlmaWVyIGluc2lkZSBzdHJpY3QgbW9kZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZWZ0ID0gbWF5YmVfY29uZGl0aW9uYWwobm9faW4pO1xuICAgICAgICB2YXIgdmFsID0gUy50b2tlbi52YWx1ZTtcblxuICAgICAgICBpZiAoaXMoXCJvcGVyYXRvclwiKSAmJiBBU1NJR05NRU5ULmhhcyh2YWwpKSB7XG4gICAgICAgICAgICBpZiAoaXNfYXNzaWduYWJsZShsZWZ0KSB8fCAobGVmdCA9IHRvX2Rlc3RydWN0dXJpbmcobGVmdCkpIGluc3RhbmNlb2YgQVNUX0Rlc3RydWN0dXJpbmcpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Bc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICBzdGFydCAgICA6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yIDogdmFsLFxuICAgICAgICAgICAgICAgICAgICByaWdodCAgICA6IG1heWJlX2Fzc2lnbihub19pbiksXG4gICAgICAgICAgICAgICAgICAgIGxvZ2ljYWwgIDogTE9HSUNBTF9BU1NJR05NRU5ULmhhcyh2YWwpLFxuICAgICAgICAgICAgICAgICAgICBlbmQgICAgICA6IHByZXYoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3JvYWsoXCJJbnZhbGlkIGFzc2lnbm1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfTtcblxuICAgIHZhciBleHByZXNzaW9uID0gZnVuY3Rpb24oY29tbWFzLCBub19pbikge1xuICAgICAgICB2YXIgc3RhcnQgPSBTLnRva2VuO1xuICAgICAgICB2YXIgZXhwcnMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGV4cHJzLnB1c2gobWF5YmVfYXNzaWduKG5vX2luKSk7XG4gICAgICAgICAgICBpZiAoIWNvbW1hcyB8fCAhaXMoXCJwdW5jXCIsIFwiLFwiKSkgYnJlYWs7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBjb21tYXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDogbmV3IEFTVF9TZXF1ZW5jZSh7XG4gICAgICAgICAgICBzdGFydCAgICAgICA6IHN0YXJ0LFxuICAgICAgICAgICAgZXhwcmVzc2lvbnMgOiBleHBycyxcbiAgICAgICAgICAgIGVuZCAgICAgICAgIDogcGVlaygpXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbl9sb29wKGNvbnQpIHtcbiAgICAgICAgKytTLmluX2xvb3A7XG4gICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgIC0tUy5pbl9sb29wO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24odHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChmdW5jdGlvbiBwYXJzZV90b3BsZXZlbCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gUy50b2tlbjtcbiAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgUy5pbnB1dC5wdXNoX2RpcmVjdGl2ZXNfc3RhY2soKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlKSBTLmlucHV0LmFkZF9kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpO1xuICAgICAgICB3aGlsZSAoIWlzKFwiZW9mXCIpKSB7XG4gICAgICAgICAgICBib2R5LnB1c2goc3RhdGVtZW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIFMuaW5wdXQucG9wX2RpcmVjdGl2ZXNfc3RhY2soKTtcbiAgICAgICAgdmFyIGVuZCA9IHByZXYoKTtcbiAgICAgICAgdmFyIHRvcGxldmVsID0gb3B0aW9ucy50b3BsZXZlbDtcbiAgICAgICAgaWYgKHRvcGxldmVsKSB7XG4gICAgICAgICAgICB0b3BsZXZlbC5ib2R5ID0gdG9wbGV2ZWwuYm9keS5jb25jYXQoYm9keSk7XG4gICAgICAgICAgICB0b3BsZXZlbC5lbmQgPSBlbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3BsZXZlbCA9IG5ldyBBU1RfVG9wbGV2ZWwoeyBzdGFydDogc3RhcnQsIGJvZHk6IGJvZHksIGVuZDogZW5kIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3BsZXZlbDtcbiAgICB9KSgpO1xuXG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZnVuY3Rpb24gREVGTk9ERSh0eXBlLCBwcm9wcywgbWV0aG9kcywgYmFzZSA9IEFTVF9Ob2RlKSB7XG4gICAgaWYgKCFwcm9wcykgcHJvcHMgPSBbXTtcbiAgICBlbHNlIHByb3BzID0gcHJvcHMuc3BsaXQoL1xccysvKTtcbiAgICB2YXIgc2VsZl9wcm9wcyA9IHByb3BzO1xuICAgIGlmIChiYXNlICYmIGJhc2UuUFJPUFMpXG4gICAgICAgIHByb3BzID0gcHJvcHMuY29uY2F0KGJhc2UuUFJPUFMpO1xuICAgIHZhciBjb2RlID0gXCJyZXR1cm4gZnVuY3Rpb24gQVNUX1wiICsgdHlwZSArIFwiKHByb3BzKXsgaWYgKHByb3BzKSB7IFwiO1xuICAgIGZvciAodmFyIGkgPSBwcm9wcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICBjb2RlICs9IFwidGhpcy5cIiArIHByb3BzW2ldICsgXCIgPSBwcm9wcy5cIiArIHByb3BzW2ldICsgXCI7XCI7XG4gICAgfVxuICAgIGNvbnN0IHByb3RvID0gYmFzZSAmJiBPYmplY3QuY3JlYXRlKGJhc2UucHJvdG90eXBlKTtcbiAgICBpZiAocHJvdG8gJiYgcHJvdG8uaW5pdGlhbGl6ZSB8fCAobWV0aG9kcyAmJiBtZXRob2RzLmluaXRpYWxpemUpKVxuICAgICAgICBjb2RlICs9IFwidGhpcy5pbml0aWFsaXplKCk7XCI7XG4gICAgY29kZSArPSBcIn1cIjtcbiAgICBjb2RlICs9IFwidGhpcy5mbGFncyA9IDA7XCI7XG4gICAgY29kZSArPSBcIn1cIjtcbiAgICB2YXIgY3RvciA9IG5ldyBGdW5jdGlvbihjb2RlKSgpO1xuICAgIGlmIChwcm90bykge1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICBjdG9yLkJBU0UgPSBiYXNlO1xuICAgIH1cbiAgICBpZiAoYmFzZSkgYmFzZS5TVUJDTEFTU0VTLnB1c2goY3Rvcik7XG4gICAgY3Rvci5wcm90b3R5cGUuQ1RPUiA9IGN0b3I7XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICAgIGN0b3IuUFJPUFMgPSBwcm9wcyB8fCBudWxsO1xuICAgIGN0b3IuU0VMRl9QUk9QUyA9IHNlbGZfcHJvcHM7XG4gICAgY3Rvci5TVUJDTEFTU0VTID0gW107XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUuVFlQRSA9IGN0b3IuVFlQRSA9IHR5cGU7XG4gICAgfVxuICAgIGlmIChtZXRob2RzKSBmb3IgKGkgaW4gbWV0aG9kcykgaWYgKEhPUChtZXRob2RzLCBpKSkge1xuICAgICAgICBpZiAoaVswXSA9PT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGN0b3JbaS5zdWJzdHIoMSldID0gbWV0aG9kc1tpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlW2ldID0gbWV0aG9kc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjdG9yLkRFRk1FVEhPRCA9IGZ1bmN0aW9uKG5hbWUsIG1ldGhvZCkge1xuICAgICAgICB0aGlzLnByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZDtcbiAgICB9O1xuICAgIHJldHVybiBjdG9yO1xufVxuXG5jb25zdCBoYXNfdG9rX2ZsYWcgPSAodG9rLCBmbGFnKSA9PiBCb29sZWFuKHRvay5mbGFncyAmIGZsYWcpO1xuY29uc3Qgc2V0X3Rva19mbGFnID0gKHRvaywgZmxhZywgdHJ1dGgpID0+IHtcbiAgICBpZiAodHJ1dGgpIHtcbiAgICAgICAgdG9rLmZsYWdzIHw9IGZsYWc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdG9rLmZsYWdzICY9IH5mbGFnO1xuICAgIH1cbn07XG5cbmNvbnN0IFRPS19GTEFHX05MQiAgICAgICAgICA9IDBiMDAwMTtcbmNvbnN0IFRPS19GTEFHX1FVT1RFX1NJTkdMRSA9IDBiMDAxMDtcbmNvbnN0IFRPS19GTEFHX1FVT1RFX0VYSVNUUyA9IDBiMDEwMDtcblxuY2xhc3MgQVNUX1Rva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCB2YWx1ZSwgbGluZSwgY29sLCBwb3MsIG5sYiwgY29tbWVudHNfYmVmb3JlLCBjb21tZW50c19hZnRlciwgZmlsZSkge1xuICAgICAgICB0aGlzLmZsYWdzID0gKG5sYiA/IDEgOiAwKTtcblxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuY29sID0gY29sO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5jb21tZW50c19iZWZvcmUgPSBjb21tZW50c19iZWZvcmU7XG4gICAgICAgIHRoaXMuY29tbWVudHNfYWZ0ZXIgPSBjb21tZW50c19hZnRlcjtcbiAgICAgICAgdGhpcy5maWxlID0gZmlsZTtcblxuICAgICAgICBPYmplY3Quc2VhbCh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXQgbmxiKCkge1xuICAgICAgICByZXR1cm4gaGFzX3Rva19mbGFnKHRoaXMsIFRPS19GTEFHX05MQik7XG4gICAgfVxuXG4gICAgc2V0IG5sYihuZXdfbmxiKSB7XG4gICAgICAgIHNldF90b2tfZmxhZyh0aGlzLCBUT0tfRkxBR19OTEIsIG5ld19ubGIpO1xuICAgIH1cblxuICAgIGdldCBxdW90ZSgpIHtcbiAgICAgICAgcmV0dXJuICFoYXNfdG9rX2ZsYWcodGhpcywgVE9LX0ZMQUdfUVVPVEVfRVhJU1RTKVxuICAgICAgICAgICAgPyBcIlwiXG4gICAgICAgICAgICA6IChoYXNfdG9rX2ZsYWcodGhpcywgVE9LX0ZMQUdfUVVPVEVfU0lOR0xFKSA/IFwiJ1wiIDogJ1wiJyk7XG4gICAgfVxuXG4gICAgc2V0IHF1b3RlKHF1b3RlX3R5cGUpIHtcbiAgICAgICAgc2V0X3Rva19mbGFnKHRoaXMsIFRPS19GTEFHX1FVT1RFX1NJTkdMRSwgcXVvdGVfdHlwZSA9PT0gXCInXCIpO1xuICAgICAgICBzZXRfdG9rX2ZsYWcodGhpcywgVE9LX0ZMQUdfUVVPVEVfRVhJU1RTLCAhIXF1b3RlX3R5cGUpO1xuICAgIH1cbn1cblxudmFyIEFTVF9Ob2RlID0gREVGTk9ERShcIk5vZGVcIiwgXCJzdGFydCBlbmRcIiwge1xuICAgIF9jbG9uZTogZnVuY3Rpb24oZGVlcCkge1xuICAgICAgICBpZiAoZGVlcCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi50cmFuc2Zvcm0obmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2xvbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5DVE9SKHRoaXMpO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGRlZXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lKGRlZXApO1xuICAgIH0sXG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBvZiBhbGwgQVNUIG5vZGVzXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgc3RhcnQ6IFwiW0FTVF9Ub2tlbl0gVGhlIGZpcnN0IHRva2VuIG9mIHRoaXMgbm9kZVwiLFxuICAgICAgICBlbmQ6IFwiW0FTVF9Ub2tlbl0gVGhlIGxhc3QgdG9rZW4gb2YgdGhpcyBub2RlXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzKTtcbiAgICB9LFxuICAgIHdhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhbGsodmlzaXRvcik7IC8vIG5vdCBzdXJlIHRoZSBpbmRpcmVjdGlvbiB3aWxsIGJlIGFueSBoZWxwXG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzOiAoKSA9PiB7fVxufSwgbnVsbCk7XG5cbi8qIC0tLS0tWyBzdGF0ZW1lbnRzIF0tLS0tLSAqL1xuXG52YXIgQVNUX1N0YXRlbWVudCA9IERFRk5PREUoXCJTdGF0ZW1lbnRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3Mgb2YgYWxsIHN0YXRlbWVudHNcIixcbn0pO1xuXG52YXIgQVNUX0RlYnVnZ2VyID0gREVGTk9ERShcIkRlYnVnZ2VyXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJSZXByZXNlbnRzIGEgZGVidWdnZXIgc3RhdGVtZW50XCIsXG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9EaXJlY3RpdmUgPSBERUZOT0RFKFwiRGlyZWN0aXZlXCIsIFwidmFsdWUgcXVvdGVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlJlcHJlc2VudHMgYSBkaXJlY3RpdmUsIGxpa2UgXFxcInVzZSBzdHJpY3RcXFwiO1wiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHZhbHVlOiBcIltzdHJpbmddIFRoZSB2YWx1ZSBvZiB0aGlzIGRpcmVjdGl2ZSBhcyBhIHBsYWluIHN0cmluZyAoaXQncyBub3QgYW4gQVNUX1N0cmluZyEpXCIsXG4gICAgICAgIHF1b3RlOiBcIltzdHJpbmddIHRoZSBvcmlnaW5hbCBxdW90ZSBjaGFyYWN0ZXJcIlxuICAgIH0sXG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9TaW1wbGVTdGF0ZW1lbnQgPSBERUZOT0RFKFwiU2ltcGxlU3RhdGVtZW50XCIsIFwiYm9keVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBzdGF0ZW1lbnQgY29uc2lzdGluZyBvZiBhbiBleHByZXNzaW9uLCBpLmUuIGEgPSAxICsgMlwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJvZHk6IFwiW0FTVF9Ob2RlXSBhbiBleHByZXNzaW9uIG5vZGUgKHNob3VsZCBub3QgYmUgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50KVwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy5ib2R5KTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50KTtcblxuZnVuY3Rpb24gd2Fsa19ib2R5KG5vZGUsIHZpc2l0b3IpIHtcbiAgICBjb25zdCBib2R5ID0gbm9kZS5ib2R5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGJvZHlbaV0uX3dhbGsodmlzaXRvcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZV9ibG9ja19zY29wZShkZWVwKSB7XG4gICAgdmFyIGNsb25lID0gdGhpcy5fY2xvbmUoZGVlcCk7XG4gICAgaWYgKHRoaXMuYmxvY2tfc2NvcGUpIHtcbiAgICAgICAgY2xvbmUuYmxvY2tfc2NvcGUgPSB0aGlzLmJsb2NrX3Njb3BlLmNsb25lKCk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZTtcbn1cblxudmFyIEFTVF9CbG9jayA9IERFRk5PREUoXCJCbG9ja1wiLCBcImJvZHkgYmxvY2tfc2NvcGVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYm9keSBvZiBzdGF0ZW1lbnRzICh1c3VhbGx5IGJyYWNlZClcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBib2R5OiBcIltBU1RfU3RhdGVtZW50Kl0gYW4gYXJyYXkgb2Ygc3RhdGVtZW50c1wiLFxuICAgICAgICBibG9ja19zY29wZTogXCJbQVNUX1Njb3BlXSB0aGUgYmxvY2sgc2NvcGVcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMuYm9keS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHB1c2godGhpcy5ib2R5W2ldKTtcbiAgICB9LFxuICAgIGNsb25lOiBjbG9uZV9ibG9ja19zY29wZVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfQmxvY2tTdGF0ZW1lbnQgPSBERUZOT0RFKFwiQmxvY2tTdGF0ZW1lbnRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYmxvY2sgc3RhdGVtZW50XCIsXG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX0VtcHR5U3RhdGVtZW50ID0gREVGTk9ERShcIkVtcHR5U3RhdGVtZW50XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgZW1wdHkgc3RhdGVtZW50IChlbXB0eSBibG9jayBvciBzaW1wbHkgYSBzZW1pY29sb24pXCJcbn0sIEFTVF9TdGF0ZW1lbnQpO1xuXG52YXIgQVNUX1N0YXRlbWVudFdpdGhCb2R5ID0gREVGTk9ERShcIlN0YXRlbWVudFdpdGhCb2R5XCIsIFwiYm9keVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYWxsIHN0YXRlbWVudHMgdGhhdCBjb250YWluIG9uZSBuZXN0ZWQgYm9keTogYEZvcmAsIGBGb3JJbmAsIGBEb2AsIGBXaGlsZWAsIGBXaXRoYFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGJvZHk6IFwiW0FTVF9TdGF0ZW1lbnRdIHRoZSBib2R5OyB0aGlzIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCwgZXZlbiBpZiBpdCdzIGFuIEFTVF9FbXB0eVN0YXRlbWVudFwiXG4gICAgfVxufSwgQVNUX1N0YXRlbWVudCk7XG5cbnZhciBBU1RfTGFiZWxlZFN0YXRlbWVudCA9IERFRk5PREUoXCJMYWJlbGVkU3RhdGVtZW50XCIsIFwibGFiZWxcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN0YXRlbWVudCB3aXRoIGEgbGFiZWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBsYWJlbDogXCJbQVNUX0xhYmVsXSBhIGxhYmVsIGRlZmluaXRpb25cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5sYWJlbC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLmJvZHkpO1xuICAgICAgICBwdXNoKHRoaXMubGFiZWwpO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKGRlZXApIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jbG9uZShkZWVwKTtcbiAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IG5vZGUubGFiZWw7XG4gICAgICAgICAgICB2YXIgZGVmID0gdGhpcy5sYWJlbDtcbiAgICAgICAgICAgIG5vZGUud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTG9vcENvbnRyb2xcbiAgICAgICAgICAgICAgICAgICAgJiYgbm9kZS5sYWJlbCAmJiBub2RlLmxhYmVsLnRoZWRlZiA9PT0gZGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGFiZWwudGhlZGVmID0gbGFiZWw7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLnJlZmVyZW5jZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudFdpdGhCb2R5KTtcblxudmFyIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQgPSBERUZOT0RFKFwiSXRlcmF0aW9uU3RhdGVtZW50XCIsIFwiYmxvY2tfc2NvcGVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkludGVybmFsIGNsYXNzLiAgQWxsIGxvb3BzIGluaGVyaXQgZnJvbSBpdC5cIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBibG9ja19zY29wZTogXCJbQVNUX1Njb3BlXSB0aGUgYmxvY2sgc2NvcGUgZm9yIHRoaXMgaXRlcmF0aW9uIHN0YXRlbWVudC5cIlxuICAgIH0sXG4gICAgY2xvbmU6IGNsb25lX2Jsb2NrX3Njb3BlXG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG52YXIgQVNUX0RXTG9vcCA9IERFRk5PREUoXCJEV0xvb3BcIiwgXCJjb25kaXRpb25cIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGRvL3doaWxlIHN0YXRlbWVudHNcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBjb25kaXRpb246IFwiW0FTVF9Ob2RlXSB0aGUgbG9vcCBjb25kaXRpb24uICBTaG91bGQgbm90IGJlIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudFwiXG4gICAgfVxufSwgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCk7XG5cbnZhciBBU1RfRG8gPSBERUZOT0RFKFwiRG9cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGRvYCBzdGF0ZW1lbnRcIixcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLmNvbmRpdGlvbik7XG4gICAgICAgIHB1c2godGhpcy5ib2R5KTtcbiAgICB9XG59LCBBU1RfRFdMb29wKTtcblxudmFyIEFTVF9XaGlsZSA9IERFRk5PREUoXCJXaGlsZVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgd2hpbGVgIHN0YXRlbWVudFwiLFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBwdXNoKHRoaXMuYm9keSk7XG4gICAgICAgIHB1c2godGhpcy5jb25kaXRpb24pO1xuICAgIH0sXG59LCBBU1RfRFdMb29wKTtcblxudmFyIEFTVF9Gb3IgPSBERUZOT0RFKFwiRm9yXCIsIFwiaW5pdCBjb25kaXRpb24gc3RlcFwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgZm9yYCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBpbml0OiBcIltBU1RfTm9kZT9dIHRoZSBgZm9yYCBpbml0aWFsaXphdGlvbiBjb2RlLCBvciBudWxsIGlmIGVtcHR5XCIsXG4gICAgICAgIGNvbmRpdGlvbjogXCJbQVNUX05vZGU/XSB0aGUgYGZvcmAgdGVybWluYXRpb24gY2xhdXNlLCBvciBudWxsIGlmIGVtcHR5XCIsXG4gICAgICAgIHN0ZXA6IFwiW0FTVF9Ob2RlP10gdGhlIGBmb3JgIHVwZGF0ZSBjbGF1c2UsIG9yIG51bGwgaWYgZW1wdHlcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5pdCkgdGhpcy5pbml0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uKSB0aGlzLmNvbmRpdGlvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0ZXApIHRoaXMuc3RlcC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLmJvZHkpO1xuICAgICAgICBpZiAodGhpcy5zdGVwKSBwdXNoKHRoaXMuc3RlcCk7XG4gICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbikgcHVzaCh0aGlzLmNvbmRpdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmluaXQpIHB1c2godGhpcy5pbml0KTtcbiAgICB9LFxufSwgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCk7XG5cbnZhciBBU1RfRm9ySW4gPSBERUZOT0RFKFwiRm9ySW5cIiwgXCJpbml0IG9iamVjdFwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgZm9yIC4uLiBpbmAgc3RhdGVtZW50XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgaW5pdDogXCJbQVNUX05vZGVdIHRoZSBgZm9yL2luYCBpbml0aWFsaXphdGlvbiBjb2RlXCIsXG4gICAgICAgIG9iamVjdDogXCJbQVNUX05vZGVdIHRoZSBvYmplY3QgdGhhdCB3ZSdyZSBsb29waW5nIHRocm91Z2hcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5vYmplY3QuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy5ib2R5KTtcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0KSBwdXNoKHRoaXMub2JqZWN0KTtcbiAgICAgICAgaWYgKHRoaXMuaW5pdCkgcHVzaCh0aGlzLmluaXQpO1xuICAgIH0sXG59LCBBU1RfSXRlcmF0aW9uU3RhdGVtZW50KTtcblxudmFyIEFTVF9Gb3JPZiA9IERFRk5PREUoXCJGb3JPZlwiLCBcImF3YWl0XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBmb3IgLi4uIG9mYCBzdGF0ZW1lbnRcIixcbn0sIEFTVF9Gb3JJbik7XG5cbnZhciBBU1RfV2l0aCA9IERFRk5PREUoXCJXaXRoXCIsIFwiZXhwcmVzc2lvblwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgd2l0aGAgc3RhdGVtZW50XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogXCJbQVNUX05vZGVdIHRoZSBgd2l0aGAgZXhwcmVzc2lvblwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLmJvZHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy5ib2R5KTtcbiAgICAgICAgcHVzaCh0aGlzLmV4cHJlc3Npb24pO1xuICAgIH0sXG59LCBBU1RfU3RhdGVtZW50V2l0aEJvZHkpO1xuXG4vKiAtLS0tLVsgc2NvcGUgYW5kIGZ1bmN0aW9ucyBdLS0tLS0gKi9cblxudmFyIEFTVF9TY29wZSA9IERFRk5PREUoXCJTY29wZVwiLCBcInZhcmlhYmxlcyBmdW5jdGlvbnMgdXNlc193aXRoIHVzZXNfZXZhbCBwYXJlbnRfc2NvcGUgZW5jbG9zZWQgY25hbWVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGFsbCBzdGF0ZW1lbnRzIGludHJvZHVjaW5nIGEgbGV4aWNhbCBzY29wZVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHZhcmlhYmxlczogXCJbTWFwL1NdIGEgbWFwIG9mIG5hbWUgLT4gU3ltYm9sRGVmIGZvciBhbGwgdmFyaWFibGVzL2Z1bmN0aW9ucyBkZWZpbmVkIGluIHRoaXMgc2NvcGVcIixcbiAgICAgICAgdXNlc193aXRoOiBcIltib29sZWFuL1NdIHRlbGxzIHdoZXRoZXIgdGhpcyBzY29wZSB1c2VzIHRoZSBgd2l0aGAgc3RhdGVtZW50XCIsXG4gICAgICAgIHVzZXNfZXZhbDogXCJbYm9vbGVhbi9TXSB0ZWxscyB3aGV0aGVyIHRoaXMgc2NvcGUgY29udGFpbnMgYSBkaXJlY3QgY2FsbCB0byB0aGUgZ2xvYmFsIGBldmFsYFwiLFxuICAgICAgICBwYXJlbnRfc2NvcGU6IFwiW0FTVF9TY29wZT8vU10gbGluayB0byB0aGUgcGFyZW50IHNjb3BlXCIsXG4gICAgICAgIGVuY2xvc2VkOiBcIltTeW1ib2xEZWYqL1NdIGEgbGlzdCBvZiBhbGwgc3ltYm9sIGRlZmluaXRpb25zIHRoYXQgYXJlIGFjY2Vzc2VkIGZyb20gdGhpcyBzY29wZSBvciBhbnkgc3Vic2NvcGVzXCIsXG4gICAgICAgIGNuYW1lOiBcIltpbnRlZ2VyL1NdIGN1cnJlbnQgaW5kZXggZm9yIG1hbmdsaW5nIHZhcmlhYmxlcyAodXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBtYW5nbGVyKVwiLFxuICAgIH0sXG4gICAgZ2V0X2RlZnVuX3Njb3BlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoc2VsZi5pc19ibG9ja19zY29wZSgpKSB7XG4gICAgICAgICAgICBzZWxmID0gc2VsZi5wYXJlbnRfc2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24oZGVlcCwgdG9wbGV2ZWwpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jbG9uZShkZWVwKTtcbiAgICAgICAgaWYgKGRlZXAgJiYgdGhpcy52YXJpYWJsZXMgJiYgdG9wbGV2ZWwgJiYgIXRoaXMuX2Jsb2NrX3Njb3BlKSB7XG4gICAgICAgICAgICBub2RlLmZpZ3VyZV9vdXRfc2NvcGUoe30sIHtcbiAgICAgICAgICAgICAgICB0b3BsZXZlbDogdG9wbGV2ZWwsXG4gICAgICAgICAgICAgICAgcGFyZW50X3Njb3BlOiB0aGlzLnBhcmVudF9zY29wZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy52YXJpYWJsZXMpIG5vZGUudmFyaWFibGVzID0gbmV3IE1hcCh0aGlzLnZhcmlhYmxlcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmNsb3NlZCkgbm9kZS5lbmNsb3NlZCA9IHRoaXMuZW5jbG9zZWQuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ibG9ja19zY29wZSkgbm9kZS5fYmxvY2tfc2NvcGUgPSB0aGlzLl9ibG9ja19zY29wZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIHBpbm5lZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXNfZXZhbCB8fCB0aGlzLnVzZXNfd2l0aDtcbiAgICB9XG59LCBBU1RfQmxvY2spO1xuXG52YXIgQVNUX1RvcGxldmVsID0gREVGTk9ERShcIlRvcGxldmVsXCIsIFwiZ2xvYmFsc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIHRvcGxldmVsIHNjb3BlXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZ2xvYmFsczogXCJbTWFwL1NdIGEgbWFwIG9mIG5hbWUgLT4gU3ltYm9sRGVmIGZvciBhbGwgdW5kZWNsYXJlZCBuYW1lc1wiLFxuICAgIH0sXG4gICAgd3JhcF9jb21tb25qczogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgYm9keSA9IHRoaXMuYm9keTtcbiAgICAgICAgdmFyIHdyYXBwZWRfdGwgPSBcIihmdW5jdGlvbihleHBvcnRzKXsnJE9SSUcnO30pKHR5cGVvZiBcIiArIG5hbWUgKyBcIj09J3VuZGVmaW5lZCc/KFwiICsgbmFtZSArIFwiPXt9KTpcIiArIG5hbWUgKyBcIik7XCI7XG4gICAgICAgIHdyYXBwZWRfdGwgPSBwYXJzZSh3cmFwcGVkX3RsKTtcbiAgICAgICAgd3JhcHBlZF90bCA9IHdyYXBwZWRfdGwudHJhbnNmb3JtKG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlICYmIG5vZGUudmFsdWUgPT0gXCIkT1JJR1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1BUC5zcGxpY2UoYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRfdGw7XG4gICAgfSxcbiAgICB3cmFwX2VuY2xvc2U6IGZ1bmN0aW9uKGFyZ3NfdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc192YWx1ZXMgIT0gXCJzdHJpbmdcIikgYXJnc192YWx1ZXMgPSBcIlwiO1xuICAgICAgICB2YXIgaW5kZXggPSBhcmdzX3ZhbHVlcy5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBhcmdzX3ZhbHVlcy5sZW5ndGg7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy5ib2R5O1xuICAgICAgICByZXR1cm4gcGFyc2UoW1xuICAgICAgICAgICAgXCIoZnVuY3Rpb24oXCIsXG4gICAgICAgICAgICBhcmdzX3ZhbHVlcy5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgICAnKXtcIiRPUklHXCJ9KSgnLFxuICAgICAgICAgICAgYXJnc192YWx1ZXMuc2xpY2UoaW5kZXggKyAxKSxcbiAgICAgICAgICAgIFwiKVwiXG4gICAgICAgIF0uam9pbihcIlwiKSkudHJhbnNmb3JtKG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlICYmIG5vZGUudmFsdWUgPT0gXCIkT1JJR1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1BUC5zcGxpY2UoYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG59LCBBU1RfU2NvcGUpO1xuXG52YXIgQVNUX0V4cGFuc2lvbiA9IERFRk5PREUoXCJFeHBhbnNpb25cIiwgXCJleHByZXNzaW9uXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBleHBhbmRpYmxlIGFyZ3VtZW50LCBzdWNoIGFzIC4uLnJlc3QsIGEgc3BsYXQsIHN1Y2ggYXMgWzEsMiwuLi5hbGxdLCBvciBhbiBleHBhbnNpb24gaW4gYSB2YXJpYWJsZSBkZWNsYXJhdGlvbiwgc3VjaCBhcyB2YXIgW2ZpcnN0LCAuLi5yZXN0XSA9IGxpc3RcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gdGhlIHRoaW5nIHRvIGJlIGV4cGFuZGVkXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi53YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBwdXNoKHRoaXMuZXhwcmVzc2lvbik7XG4gICAgfSxcbn0pO1xuXG52YXIgQVNUX0xhbWJkYSA9IERFRk5PREUoXCJMYW1iZGFcIiwgXCJuYW1lIGFyZ25hbWVzIHVzZXNfYXJndW1lbnRzIGlzX2dlbmVyYXRvciBhc3luY1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgZnVuY3Rpb25zXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgbmFtZTogXCJbQVNUX1N5bWJvbERlY2xhcmF0aW9uP10gdGhlIG5hbWUgb2YgdGhpcyBmdW5jdGlvblwiLFxuICAgICAgICBhcmduYW1lczogXCJbQVNUX1N5bWJvbEZ1bmFyZ3xBU1RfRGVzdHJ1Y3R1cmluZ3xBU1RfRXhwYW5zaW9ufEFTVF9EZWZhdWx0QXNzaWduKl0gYXJyYXkgb2YgZnVuY3Rpb24gYXJndW1lbnRzLCBkZXN0cnVjdHVyaW5ncywgb3IgZXhwYW5kaW5nIGFyZ3VtZW50c1wiLFxuICAgICAgICB1c2VzX2FyZ3VtZW50czogXCJbYm9vbGVhbi9TXSB0ZWxscyB3aGV0aGVyIHRoaXMgZnVuY3Rpb24gYWNjZXNzZXMgdGhlIGFyZ3VtZW50cyBhcnJheVwiLFxuICAgICAgICBpc19nZW5lcmF0b3I6IFwiW2Jvb2xlYW5dIGlzIHRoaXMgYSBnZW5lcmF0b3IgbWV0aG9kXCIsXG4gICAgICAgIGFzeW5jOiBcIltib29sZWFuXSBpcyB0aGlzIG1ldGhvZCBhc3luY1wiLFxuICAgIH0sXG4gICAgYXJnc19hc19uYW1lczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmduYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXJnbmFtZXNbaV0gaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZykge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKC4uLnRoaXMuYXJnbmFtZXNbaV0uYWxsX3N5bWJvbHMoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHRoaXMuYXJnbmFtZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uYW1lKSB0aGlzLm5hbWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB2YXIgYXJnbmFtZXMgPSB0aGlzLmFyZ25hbWVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ25hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnbmFtZXNbaV0uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5ib2R5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLmJvZHlbaV0pO1xuXG4gICAgICAgIGkgPSB0aGlzLmFyZ25hbWVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLmFyZ25hbWVzW2ldKTtcblxuICAgICAgICBpZiAodGhpcy5uYW1lKSBwdXNoKHRoaXMubmFtZSk7XG4gICAgfSxcbiAgICBpc19icmFjZWxlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHlbMF0gaW5zdGFuY2VvZiBBU1RfUmV0dXJuICYmIHRoaXMuYm9keVswXS52YWx1ZTtcbiAgICB9LFxuICAgIC8vIERlZmF1bHQgYXJncyBhbmQgZXhwYW5zaW9uIGRvbid0IGNvdW50LCBzbyAuYXJnbmFtZXMubGVuZ3RoIGRvZXNuJ3QgY3V0IGl0XG4gICAgbGVuZ3RoX3Byb3BlcnR5KCkge1xuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcblxuICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiB0aGlzLmFyZ25hbWVzKSB7XG4gICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZyB8fCBhcmcgaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG59LCBBU1RfU2NvcGUpO1xuXG52YXIgQVNUX0FjY2Vzc29yID0gREVGTk9ERShcIkFjY2Vzc29yXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHNldHRlci9nZXR0ZXIgZnVuY3Rpb24uICBUaGUgYG5hbWVgIHByb3BlcnR5IGlzIGFsd2F5cyBudWxsLlwiXG59LCBBU1RfTGFtYmRhKTtcblxudmFyIEFTVF9GdW5jdGlvbiA9IERFRk5PREUoXCJGdW5jdGlvblwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBmdW5jdGlvbiBleHByZXNzaW9uXCJcbn0sIEFTVF9MYW1iZGEpO1xuXG52YXIgQVNUX0Fycm93ID0gREVGTk9ERShcIkFycm93XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBFUzYgQXJyb3cgZnVuY3Rpb24gKChhKSA9PiBiKVwiXG59LCBBU1RfTGFtYmRhKTtcblxudmFyIEFTVF9EZWZ1biA9IERFRk5PREUoXCJEZWZ1blwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBmdW5jdGlvbiBkZWZpbml0aW9uXCJcbn0sIEFTVF9MYW1iZGEpO1xuXG4vKiAtLS0tLVsgREVTVFJVQ1RVUklORyBdLS0tLS0gKi9cbnZhciBBU1RfRGVzdHJ1Y3R1cmluZyA9IERFRk5PREUoXCJEZXN0cnVjdHVyaW5nXCIsIFwibmFtZXMgaXNfYXJyYXlcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgZGVzdHJ1Y3R1cmluZyBvZiBzZXZlcmFsIG5hbWVzLiBVc2VkIGluIGRlc3RydWN0dXJpbmcgYXNzaWdubWVudCBhbmQgd2l0aCBkZXN0cnVjdHVyaW5nIGZ1bmN0aW9uIGFyZ3VtZW50IG5hbWVzXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgXCJuYW1lc1wiOiBcIltBU1RfTm9kZSpdIEFycmF5IG9mIHByb3BlcnRpZXMgb3IgZWxlbWVudHNcIixcbiAgICAgICAgXCJpc19hcnJheVwiOiBcIltCb29sZWFuXSBXaGV0aGVyIHRoZSBkZXN0cnVjdHVyaW5nIHJlcHJlc2VudHMgYW4gb2JqZWN0IG9yIGFycmF5XCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZXMuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgbmFtZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMubmFtZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSBwdXNoKHRoaXMubmFtZXNbaV0pO1xuICAgIH0sXG4gICAgYWxsX3N5bWJvbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIHRoaXMud2FsayhuZXcgVHJlZVdhbGtlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG59KTtcblxudmFyIEFTVF9QcmVmaXhlZFRlbXBsYXRlU3RyaW5nID0gREVGTk9ERShcIlByZWZpeGVkVGVtcGxhdGVTdHJpbmdcIiwgXCJ0ZW1wbGF0ZV9zdHJpbmcgcHJlZml4XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHRlbXBsYXRlc3RyaW5nIHdpdGggYSBwcmVmaXgsIHN1Y2ggYXMgU3RyaW5nLnJhd2Bmb29iYXJiYXpgXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgdGVtcGxhdGVfc3RyaW5nOiBcIltBU1RfVGVtcGxhdGVTdHJpbmddIFRoZSB0ZW1wbGF0ZSBzdHJpbmdcIixcbiAgICAgICAgcHJlZml4OiBcIltBU1RfTm9kZV0gVGhlIHByZWZpeCwgd2hpY2ggd2lsbCBnZXQgY2FsbGVkLlwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXguX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlX3N0cmluZy5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLnRlbXBsYXRlX3N0cmluZyk7XG4gICAgICAgIHB1c2godGhpcy5wcmVmaXgpO1xuICAgIH0sXG59KTtcblxudmFyIEFTVF9UZW1wbGF0ZVN0cmluZyA9IERFRk5PREUoXCJUZW1wbGF0ZVN0cmluZ1wiLCBcInNlZ21lbnRzXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHRlbXBsYXRlIHN0cmluZyBsaXRlcmFsXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgc2VnbWVudHM6IFwiW0FTVF9Ob2RlKl0gT25lIG9yIG1vcmUgc2VnbWVudHMsIHN0YXJ0aW5nIHdpdGggQVNUX1RlbXBsYXRlU2VnbWVudC4gQVNUX05vZGUgbWF5IGZvbGxvdyBBU1RfVGVtcGxhdGVTZWdtZW50LCBidXQgZWFjaCBBU1RfTm9kZSBtdXN0IGJlIGZvbGxvd2VkIGJ5IEFTVF9UZW1wbGF0ZVNlZ21lbnQuXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbihzZWcpIHtcbiAgICAgICAgICAgICAgICBzZWcuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLnNlZ21lbnRzW2ldKTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9UZW1wbGF0ZVNlZ21lbnQgPSBERUZOT0RFKFwiVGVtcGxhdGVTZWdtZW50XCIsIFwidmFsdWUgcmF3XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHNlZ21lbnQgb2YgYSB0ZW1wbGF0ZSBzdHJpbmcgbGl0ZXJhbFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHZhbHVlOiBcIkNvbnRlbnQgb2YgdGhlIHNlZ21lbnRcIixcbiAgICAgICAgcmF3OiBcIlJhdyBzb3VyY2Ugb2YgdGhlIHNlZ21lbnRcIixcbiAgICB9XG59KTtcblxuLyogLS0tLS1bIEpVTVBTIF0tLS0tLSAqL1xuXG52YXIgQVNUX0p1bXAgPSBERUZOT0RFKFwiSnVtcFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3Ig4oCcanVtcHPigJ0gKGZvciBub3cgdGhhdCdzIGByZXR1cm5gLCBgdGhyb3dgLCBgYnJlYWtgIGFuZCBgY29udGludWVgKVwiXG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9FeGl0ID0gREVGTk9ERShcIkV4aXRcIiwgXCJ2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3Ig4oCcZXhpdHPigJ0gKGByZXR1cm5gIGFuZCBgdGhyb3dgKVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHZhbHVlOiBcIltBU1RfTm9kZT9dIHRoZSB2YWx1ZSByZXR1cm5lZCBvciB0aHJvd24gYnkgdGhpcyBzdGF0ZW1lbnQ7IGNvdWxkIGJlIG51bGwgZm9yIEFTVF9SZXR1cm5cIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIHRoaXMudmFsdWUgJiYgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSkgcHVzaCh0aGlzLnZhbHVlKTtcbiAgICB9LFxufSwgQVNUX0p1bXApO1xuXG52YXIgQVNUX1JldHVybiA9IERFRk5PREUoXCJSZXR1cm5cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHJldHVybmAgc3RhdGVtZW50XCJcbn0sIEFTVF9FeGl0KTtcblxudmFyIEFTVF9UaHJvdyA9IERFRk5PREUoXCJUaHJvd1wiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgdGhyb3dgIHN0YXRlbWVudFwiXG59LCBBU1RfRXhpdCk7XG5cbnZhciBBU1RfTG9vcENvbnRyb2wgPSBERUZOT0RFKFwiTG9vcENvbnRyb2xcIiwgXCJsYWJlbFwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgbG9vcCBjb250cm9sIHN0YXRlbWVudHMgKGBicmVha2AgYW5kIGBjb250aW51ZWApXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgbGFiZWw6IFwiW0FTVF9MYWJlbFJlZj9dIHRoZSBsYWJlbCwgb3IgbnVsbCBpZiBub25lXCIsXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgdGhpcy5sYWJlbCAmJiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWwuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsKSBwdXNoKHRoaXMubGFiZWwpO1xuICAgIH0sXG59LCBBU1RfSnVtcCk7XG5cbnZhciBBU1RfQnJlYWsgPSBERUZOT0RFKFwiQnJlYWtcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGJyZWFrYCBzdGF0ZW1lbnRcIlxufSwgQVNUX0xvb3BDb250cm9sKTtcblxudmFyIEFTVF9Db250aW51ZSA9IERFRk5PREUoXCJDb250aW51ZVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgY29udGludWVgIHN0YXRlbWVudFwiXG59LCBBU1RfTG9vcENvbnRyb2wpO1xuXG52YXIgQVNUX0F3YWl0ID0gREVGTk9ERShcIkF3YWl0XCIsIFwiZXhwcmVzc2lvblwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gYGF3YWl0YCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gdGhlIG1hbmRhdG9yeSBleHByZXNzaW9uIGJlaW5nIGF3YWl0ZWRcIixcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLmV4cHJlc3Npb24pO1xuICAgIH0sXG59KTtcblxudmFyIEFTVF9ZaWVsZCA9IERFRk5PREUoXCJZaWVsZFwiLCBcImV4cHJlc3Npb24gaXNfc3RhclwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgeWllbGRgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlP10gdGhlIHZhbHVlIHJldHVybmVkIG9yIHRocm93biBieSB0aGlzIHN0YXRlbWVudDsgY291bGQgYmUgbnVsbCAocmVwcmVzZW50aW5nIHVuZGVmaW5lZCkgYnV0IG9ubHkgd2hlbiBpc19zdGFyIGlzIHNldCB0byBmYWxzZVwiLFxuICAgICAgICBpc19zdGFyOiBcIltCb29sZWFuXSBXaGV0aGVyIHRoaXMgaXMgYSB5aWVsZCBvciB5aWVsZCogc3RhdGVtZW50XCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCB0aGlzLmV4cHJlc3Npb24gJiYgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cHJlc3Npb24pIHB1c2godGhpcy5leHByZXNzaW9uKTtcbiAgICB9XG59KTtcblxuLyogLS0tLS1bIElGIF0tLS0tLSAqL1xuXG52YXIgQVNUX0lmID0gREVGTk9ERShcIklmXCIsIFwiY29uZGl0aW9uIGFsdGVybmF0aXZlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBpZmAgc3RhdGVtZW50XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgY29uZGl0aW9uOiBcIltBU1RfTm9kZV0gdGhlIGBpZmAgY29uZGl0aW9uXCIsXG4gICAgICAgIGFsdGVybmF0aXZlOiBcIltBU1RfU3RhdGVtZW50P10gdGhlIGBlbHNlYCBwYXJ0LCBvciBudWxsIGlmIG5vdCBwcmVzZW50XCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5ib2R5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWx0ZXJuYXRpdmUpIHRoaXMuYWx0ZXJuYXRpdmUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGlmICh0aGlzLmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICBwdXNoKHRoaXMuYWx0ZXJuYXRpdmUpO1xuICAgICAgICB9XG4gICAgICAgIHB1c2godGhpcy5ib2R5KTtcbiAgICAgICAgcHVzaCh0aGlzLmNvbmRpdGlvbik7XG4gICAgfVxufSwgQVNUX1N0YXRlbWVudFdpdGhCb2R5KTtcblxuLyogLS0tLS1bIFNXSVRDSCBdLS0tLS0gKi9cblxudmFyIEFTVF9Td2l0Y2ggPSBERUZOT0RFKFwiU3dpdGNoXCIsIFwiZXhwcmVzc2lvblwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBgc3dpdGNoYCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gdGhlIGBzd2l0Y2hgIOKAnGRpc2NyaW1pbmFudOKAnVwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5ib2R5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLmJvZHlbaV0pO1xuICAgICAgICBwdXNoKHRoaXMuZXhwcmVzc2lvbik7XG4gICAgfVxufSwgQVNUX0Jsb2NrKTtcblxudmFyIEFTVF9Td2l0Y2hCcmFuY2ggPSBERUZOT0RFKFwiU3dpdGNoQnJhbmNoXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBgc3dpdGNoYCBicmFuY2hlc1wiLFxufSwgQVNUX0Jsb2NrKTtcblxudmFyIEFTVF9EZWZhdWx0ID0gREVGTk9ERShcIkRlZmF1bHRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGRlZmF1bHRgIHN3aXRjaCBicmFuY2hcIixcbn0sIEFTVF9Td2l0Y2hCcmFuY2gpO1xuXG52YXIgQVNUX0Nhc2UgPSBERUZOT0RFKFwiQ2FzZVwiLCBcImV4cHJlc3Npb25cIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGNhc2VgIHN3aXRjaCBicmFuY2hcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gdGhlIGBjYXNlYCBleHByZXNzaW9uXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHdhbGtfYm9keSh0aGlzLCB2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLmJvZHkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSBwdXNoKHRoaXMuYm9keVtpXSk7XG4gICAgICAgIHB1c2godGhpcy5leHByZXNzaW9uKTtcbiAgICB9LFxufSwgQVNUX1N3aXRjaEJyYW5jaCk7XG5cbi8qIC0tLS0tWyBFWENFUFRJT05TIF0tLS0tLSAqL1xuXG52YXIgQVNUX1RyeSA9IERFRk5PREUoXCJUcnlcIiwgXCJiY2F0Y2ggYmZpbmFsbHlcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYHRyeWAgc3RhdGVtZW50XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgYmNhdGNoOiBcIltBU1RfQ2F0Y2g/XSB0aGUgY2F0Y2ggYmxvY2ssIG9yIG51bGwgaWYgbm90IHByZXNlbnRcIixcbiAgICAgICAgYmZpbmFsbHk6IFwiW0FTVF9GaW5hbGx5P10gdGhlIGZpbmFsbHkgYmxvY2ssIG9yIG51bGwgaWYgbm90IHByZXNlbnRcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgd2Fsa19ib2R5KHRoaXMsIHZpc2l0b3IpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYmNhdGNoKSB0aGlzLmJjYXRjaC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmJmaW5hbGx5KSB0aGlzLmJmaW5hbGx5Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBpZiAodGhpcy5iZmluYWxseSkgcHVzaCh0aGlzLmJmaW5hbGx5KTtcbiAgICAgICAgaWYgKHRoaXMuYmNhdGNoKSBwdXNoKHRoaXMuYmNhdGNoKTtcbiAgICAgICAgbGV0IGkgPSB0aGlzLmJvZHkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSBwdXNoKHRoaXMuYm9keVtpXSk7XG4gICAgfSxcbn0sIEFTVF9CbG9jayk7XG5cbnZhciBBU1RfQ2F0Y2ggPSBERUZOT0RFKFwiQ2F0Y2hcIiwgXCJhcmduYW1lXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBjYXRjaGAgbm9kZTsgb25seSBtYWtlcyBzZW5zZSBhcyBwYXJ0IG9mIGEgYHRyeWAgc3RhdGVtZW50XCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgYXJnbmFtZTogXCJbQVNUX1N5bWJvbENhdGNofEFTVF9EZXN0cnVjdHVyaW5nfEFTVF9FeHBhbnNpb258QVNUX0RlZmF1bHRBc3NpZ25dIHN5bWJvbCBmb3IgdGhlIGV4Y2VwdGlvblwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcmduYW1lKSB0aGlzLmFyZ25hbWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB3YWxrX2JvZHkodGhpcywgdmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5ib2R5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLmJvZHlbaV0pO1xuICAgICAgICBpZiAodGhpcy5hcmduYW1lKSBwdXNoKHRoaXMuYXJnbmFtZSk7XG4gICAgfSxcbn0sIEFTVF9CbG9jayk7XG5cbnZhciBBU1RfRmluYWxseSA9IERFRk5PREUoXCJGaW5hbGx5XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGBmaW5hbGx5YCBub2RlOyBvbmx5IG1ha2VzIHNlbnNlIGFzIHBhcnQgb2YgYSBgdHJ5YCBzdGF0ZW1lbnRcIlxufSwgQVNUX0Jsb2NrKTtcblxuLyogLS0tLS1bIFZBUi9DT05TVCBdLS0tLS0gKi9cblxudmFyIEFTVF9EZWZpbml0aW9ucyA9IERFRk5PREUoXCJEZWZpbml0aW9uc1wiLCBcImRlZmluaXRpb25zXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBgdmFyYCBvciBgY29uc3RgIG5vZGVzICh2YXJpYWJsZSBkZWNsYXJhdGlvbnMvaW5pdGlhbGl6YXRpb25zKVwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGRlZmluaXRpb25zOiBcIltBU1RfVmFyRGVmKl0gYXJyYXkgb2YgdmFyaWFibGUgZGVmaW5pdGlvbnNcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGRlZmluaXRpb25zID0gdGhpcy5kZWZpbml0aW9ucztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkZWZpbml0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb25zW2ldLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMuZGVmaW5pdGlvbnMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSBwdXNoKHRoaXMuZGVmaW5pdGlvbnNbaV0pO1xuICAgIH0sXG59LCBBU1RfU3RhdGVtZW50KTtcblxudmFyIEFTVF9WYXIgPSBERUZOT0RFKFwiVmFyXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGB2YXJgIHN0YXRlbWVudFwiXG59LCBBU1RfRGVmaW5pdGlvbnMpO1xuXG52YXIgQVNUX0xldCA9IERFRk5PREUoXCJMZXRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGxldGAgc3RhdGVtZW50XCJcbn0sIEFTVF9EZWZpbml0aW9ucyk7XG5cbnZhciBBU1RfQ29uc3QgPSBERUZOT0RFKFwiQ29uc3RcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYGNvbnN0YCBzdGF0ZW1lbnRcIlxufSwgQVNUX0RlZmluaXRpb25zKTtcblxudmFyIEFTVF9WYXJEZWYgPSBERUZOT0RFKFwiVmFyRGVmXCIsIFwibmFtZSB2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSB2YXJpYWJsZSBkZWNsYXJhdGlvbjsgb25seSBhcHBlYXJzIGluIGEgQVNUX0RlZmluaXRpb25zIG5vZGVcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBuYW1lOiBcIltBU1RfRGVzdHJ1Y3R1cmluZ3xBU1RfU3ltYm9sQ29uc3R8QVNUX1N5bWJvbExldHxBU1RfU3ltYm9sVmFyXSBuYW1lIG9mIHRoZSB2YXJpYWJsZVwiLFxuICAgICAgICB2YWx1ZTogXCJbQVNUX05vZGU/XSBpbml0aWFsaXplciwgb3IgbnVsbCBvZiB0aGVyZSdzIG5vIGluaXRpYWxpemVyXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB0aGlzLnZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSkgcHVzaCh0aGlzLnZhbHVlKTtcbiAgICAgICAgcHVzaCh0aGlzLm5hbWUpO1xuICAgIH0sXG59KTtcblxudmFyIEFTVF9OYW1lTWFwcGluZyA9IERFRk5PREUoXCJOYW1lTWFwcGluZ1wiLCBcImZvcmVpZ25fbmFtZSBuYW1lXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgcGFydCBvZiB0aGUgZXhwb3J0L2ltcG9ydCBzdGF0ZW1lbnQgdGhhdCBkZWNsYXJlIG5hbWVzIGZyb20gYSBtb2R1bGUuXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZm9yZWlnbl9uYW1lOiBcIltBU1RfU3ltYm9sRXhwb3J0Rm9yZWlnbnxBU1RfU3ltYm9sSW1wb3J0Rm9yZWlnbl0gVGhlIG5hbWUgYmVpbmcgZXhwb3J0ZWQvaW1wb3J0ZWQgKGFzIHNwZWNpZmllZCBpbiB0aGUgbW9kdWxlKVwiLFxuICAgICAgICBuYW1lOiBcIltBU1RfU3ltYm9sRXhwb3J0fEFTVF9TeW1ib2xJbXBvcnRdIFRoZSBuYW1lIGFzIGl0IGlzIHZpc2libGUgdG8gdGhpcyBtb2R1bGUuXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmZvcmVpZ25fbmFtZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMubmFtZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLm5hbWUpO1xuICAgICAgICBwdXNoKHRoaXMuZm9yZWlnbl9uYW1lKTtcbiAgICB9LFxufSk7XG5cbnZhciBBU1RfSW1wb3J0ID0gREVGTk9ERShcIkltcG9ydFwiLCBcImltcG9ydGVkX25hbWUgaW1wb3J0ZWRfbmFtZXMgbW9kdWxlX25hbWVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIGBpbXBvcnRgIHN0YXRlbWVudFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGltcG9ydGVkX25hbWU6IFwiW0FTVF9TeW1ib2xJbXBvcnRdIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSBob2xkaW5nIHRoZSBtb2R1bGUncyBkZWZhdWx0IGV4cG9ydC5cIixcbiAgICAgICAgaW1wb3J0ZWRfbmFtZXM6IFwiW0FTVF9OYW1lTWFwcGluZypdIFRoZSBuYW1lcyBvZiBub24tZGVmYXVsdCBpbXBvcnRlZCB2YXJpYWJsZXNcIixcbiAgICAgICAgbW9kdWxlX25hbWU6IFwiW0FTVF9TdHJpbmddIFN0cmluZyBsaXRlcmFsIGRlc2NyaWJpbmcgd2hlcmUgdGhpcyBtb2R1bGUgY2FtZSBmcm9tXCIsXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbXBvcnRlZF9uYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbXBvcnRlZF9uYW1lLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaW1wb3J0ZWRfbmFtZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmltcG9ydGVkX25hbWVzLmZvckVhY2goZnVuY3Rpb24obmFtZV9pbXBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZV9pbXBvcnQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1vZHVsZV9uYW1lLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBwdXNoKHRoaXMubW9kdWxlX25hbWUpO1xuICAgICAgICBpZiAodGhpcy5pbXBvcnRlZF9uYW1lcykge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLmltcG9ydGVkX25hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHB1c2godGhpcy5pbXBvcnRlZF9uYW1lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW1wb3J0ZWRfbmFtZSkgcHVzaCh0aGlzLmltcG9ydGVkX25hbWUpO1xuICAgIH0sXG59KTtcblxudmFyIEFTVF9JbXBvcnRNZXRhID0gREVGTk9ERShcIkltcG9ydE1ldGFcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgcmVmZXJlbmNlIHRvIGltcG9ydC5tZXRhXCIsXG59KTtcblxudmFyIEFTVF9FeHBvcnQgPSBERUZOT0RFKFwiRXhwb3J0XCIsIFwiZXhwb3J0ZWRfZGVmaW5pdGlvbiBleHBvcnRlZF92YWx1ZSBpc19kZWZhdWx0IGV4cG9ydGVkX25hbWVzIG1vZHVsZV9uYW1lXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBgZXhwb3J0YCBzdGF0ZW1lbnRcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHBvcnRlZF9kZWZpbml0aW9uOiBcIltBU1RfRGVmdW58QVNUX0RlZmluaXRpb25zfEFTVF9EZWZDbGFzcz9dIEFuIGV4cG9ydGVkIGRlZmluaXRpb25cIixcbiAgICAgICAgZXhwb3J0ZWRfdmFsdWU6IFwiW0FTVF9Ob2RlP10gQW4gZXhwb3J0ZWQgdmFsdWVcIixcbiAgICAgICAgZXhwb3J0ZWRfbmFtZXM6IFwiW0FTVF9OYW1lTWFwcGluZyo/XSBMaXN0IG9mIGV4cG9ydGVkIG5hbWVzXCIsXG4gICAgICAgIG1vZHVsZV9uYW1lOiBcIltBU1RfU3RyaW5nP10gTmFtZSBvZiB0aGUgZmlsZSB0byBsb2FkIGV4cG9ydHMgZnJvbVwiLFxuICAgICAgICBpc19kZWZhdWx0OiBcIltCb29sZWFuXSBXaGV0aGVyIHRoaXMgaXMgdGhlIGRlZmF1bHQgZXhwb3J0ZWQgdmFsdWUgb2YgdGhpcyBtb2R1bGVcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uICh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5leHBvcnRlZF9kZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBvcnRlZF9kZWZpbml0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZXhwb3J0ZWRfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydGVkX3ZhbHVlLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZXhwb3J0ZWRfbmFtZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cG9ydGVkX25hbWVzLmZvckVhY2goZnVuY3Rpb24obmFtZV9leHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZV9leHBvcnQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5tb2R1bGVfbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubW9kdWxlX25hbWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZHVsZV9uYW1lKSBwdXNoKHRoaXMubW9kdWxlX25hbWUpO1xuICAgICAgICBpZiAodGhpcy5leHBvcnRlZF9uYW1lcykge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLmV4cG9ydGVkX25hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHB1c2godGhpcy5leHBvcnRlZF9uYW1lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhwb3J0ZWRfdmFsdWUpIHB1c2godGhpcy5leHBvcnRlZF92YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmV4cG9ydGVkX2RlZmluaXRpb24pIHB1c2godGhpcy5leHBvcnRlZF9kZWZpbml0aW9uKTtcbiAgICB9XG59LCBBU1RfU3RhdGVtZW50KTtcblxuLyogLS0tLS1bIE9USEVSIF0tLS0tLSAqL1xuXG52YXIgQVNUX0NhbGwgPSBERUZOT0RFKFwiQ2FsbFwiLCBcImV4cHJlc3Npb24gYXJncyBvcHRpb25hbCBfYW5ub3RhdGlvbnNcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgZnVuY3Rpb24gY2FsbCBleHByZXNzaW9uXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogXCJbQVNUX05vZGVdIGV4cHJlc3Npb24gdG8gaW52b2tlIGFzIGZ1bmN0aW9uXCIsXG4gICAgICAgIGFyZ3M6IFwiW0FTVF9Ob2RlKl0gYXJyYXkgb2YgYXJndW1lbnRzXCIsXG4gICAgICAgIG9wdGlvbmFsOiBcIltib29sZWFuXSB3aGV0aGVyIHRoaXMgaXMgYW4gb3B0aW9uYWwgY2FsbCAoSUUgPy4oKSApXCIsXG4gICAgICAgIF9hbm5vdGF0aW9uczogXCJbbnVtYmVyXSBiaXRmaWVsZCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjYWxsXCJcbiAgICB9LFxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbm5vdGF0aW9ucyA9PSBudWxsKSB0aGlzLl9hbm5vdGF0aW9ucyA9IDA7XG4gICAgfSxcbiAgICBfd2Fsayh2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5hcmdzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW2ldLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpOyAgLy8gVE9ETyB3aHkgZG8gd2UgbmVlZCB0byBjcmF3bCB0aGlzIGxhc3Q/XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5hcmdzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLmFyZ3NbaV0pO1xuICAgICAgICBwdXNoKHRoaXMuZXhwcmVzc2lvbik7XG4gICAgfSxcbn0pO1xuXG52YXIgQVNUX05ldyA9IERFRk5PREUoXCJOZXdcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIG9iamVjdCBpbnN0YW50aWF0aW9uLiAgRGVyaXZlcyBmcm9tIGEgZnVuY3Rpb24gY2FsbCBzaW5jZSBpdCBoYXMgZXhhY3RseSB0aGUgc2FtZSBwcm9wZXJ0aWVzXCJcbn0sIEFTVF9DYWxsKTtcblxudmFyIEFTVF9TZXF1ZW5jZSA9IERFRk5PREUoXCJTZXF1ZW5jZVwiLCBcImV4cHJlc3Npb25zXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHNlcXVlbmNlIGV4cHJlc3Npb24gKGNvbW1hLXNlcGFyYXRlZCBleHByZXNzaW9ucylcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHByZXNzaW9uczogXCJbQVNUX05vZGUqXSBhcnJheSBvZiBleHByZXNzaW9ucyAoYXQgbGVhc3QgdHdvKVwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLmV4cHJlc3Npb25zLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkgcHVzaCh0aGlzLmV4cHJlc3Npb25zW2ldKTtcbiAgICB9LFxufSk7XG5cbnZhciBBU1RfUHJvcEFjY2VzcyA9IERFRk5PREUoXCJQcm9wQWNjZXNzXCIsIFwiZXhwcmVzc2lvbiBwcm9wZXJ0eSBvcHRpb25hbFwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgcHJvcGVydHkgYWNjZXNzIGV4cHJlc3Npb25zLCBpLmUuIGBhLmZvb2Agb3IgYGFbXFxcImZvb1xcXCJdYFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGV4cHJlc3Npb246IFwiW0FTVF9Ob2RlXSB0aGUg4oCcY29udGFpbmVy4oCdIGV4cHJlc3Npb25cIixcbiAgICAgICAgcHJvcGVydHk6IFwiW0FTVF9Ob2RlfHN0cmluZ10gdGhlIHByb3BlcnR5IHRvIGFjY2Vzcy4gIEZvciBBU1RfRG90ICYgQVNUX0RvdEhhc2ggdGhpcyBpcyBhbHdheXMgYSBwbGFpbiBzdHJpbmcsIHdoaWxlIGZvciBBU1RfU3ViIGl0J3MgYW4gYXJiaXRyYXJ5IEFTVF9Ob2RlXCIsXG5cbiAgICAgICAgb3B0aW9uYWw6IFwiW2Jvb2xlYW5dIHdoZXRoZXIgdGhpcyBpcyBhbiBvcHRpb25hbCBwcm9wZXJ0eSBhY2Nlc3MgKElFID8uKVwiXG4gICAgfVxufSk7XG5cbnZhciBBU1RfRG90ID0gREVGTk9ERShcIkRvdFwiLCBcInF1b3RlXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGRvdHRlZCBwcm9wZXJ0eSBhY2Nlc3MgZXhwcmVzc2lvblwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHF1b3RlOiBcIltzdHJpbmddIHRoZSBvcmlnaW5hbCBxdW90ZSBjaGFyYWN0ZXIgd2hlbiB0cmFuc2Zvcm1lZCBmcm9tIEFTVF9TdWJcIixcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLmV4cHJlc3Npb24pO1xuICAgIH0sXG59LCBBU1RfUHJvcEFjY2Vzcyk7XG5cbnZhciBBU1RfRG90SGFzaCA9IERFRk5PREUoXCJEb3RIYXNoXCIsIFwiXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGRvdHRlZCBwcm9wZXJ0eSBhY2Nlc3MgdG8gYSBwcml2YXRlIHByb3BlcnR5XCIsXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5leHByZXNzaW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBwdXNoKHRoaXMuZXhwcmVzc2lvbik7XG4gICAgfSxcbn0sIEFTVF9Qcm9wQWNjZXNzKTtcblxudmFyIEFTVF9TdWIgPSBERUZOT0RFKFwiU3ViXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJJbmRleC1zdHlsZSBwcm9wZXJ0eSBhY2Nlc3MsIGkuZS4gYGFbXFxcImZvb1xcXCJdYFwiLFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbi5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydHkuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy5wcm9wZXJ0eSk7XG4gICAgICAgIHB1c2godGhpcy5leHByZXNzaW9uKTtcbiAgICB9LFxufSwgQVNUX1Byb3BBY2Nlc3MpO1xuXG52YXIgQVNUX0NoYWluID0gREVGTk9ERShcIkNoYWluXCIsIFwiZXhwcmVzc2lvblwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBjaGFpbiBleHByZXNzaW9uIGxpa2UgYT8uYj8uKGMpPy5bZF1cIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfQ2FsbHxBU1RfRG90fEFTVF9Eb3RIYXNofEFTVF9TdWJdIGNoYWluIGVsZW1lbnQuXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbiAodmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy5leHByZXNzaW9uKTtcbiAgICB9LFxufSk7XG5cbnZhciBBU1RfVW5hcnkgPSBERUZOT0RFKFwiVW5hcnlcIiwgXCJvcGVyYXRvciBleHByZXNzaW9uXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciB1bmFyeSBleHByZXNzaW9uc1wiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIG9wZXJhdG9yOiBcIltzdHJpbmddIHRoZSBvcGVyYXRvclwiLFxuICAgICAgICBleHByZXNzaW9uOiBcIltBU1RfTm9kZV0gZXhwcmVzc2lvbiB0aGF0IHRoaXMgdW5hcnkgb3BlcmF0b3IgYXBwbGllcyB0b1wiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24uX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy5leHByZXNzaW9uKTtcbiAgICB9LFxufSk7XG5cbnZhciBBU1RfVW5hcnlQcmVmaXggPSBERUZOT0RFKFwiVW5hcnlQcmVmaXhcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlVuYXJ5IHByZWZpeCBleHByZXNzaW9uLCBpLmUuIGB0eXBlb2YgaWAgb3IgYCsraWBcIlxufSwgQVNUX1VuYXJ5KTtcblxudmFyIEFTVF9VbmFyeVBvc3RmaXggPSBERUZOT0RFKFwiVW5hcnlQb3N0Zml4XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJVbmFyeSBwb3N0Zml4IGV4cHJlc3Npb24sIGkuZS4gYGkrK2BcIlxufSwgQVNUX1VuYXJ5KTtcblxudmFyIEFTVF9CaW5hcnkgPSBERUZOT0RFKFwiQmluYXJ5XCIsIFwib3BlcmF0b3IgbGVmdCByaWdodFwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQmluYXJ5IGV4cHJlc3Npb24sIGkuZS4gYGEgKyBiYFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGxlZnQ6IFwiW0FTVF9Ob2RlXSBsZWZ0LWhhbmQgc2lkZSBleHByZXNzaW9uXCIsXG4gICAgICAgIG9wZXJhdG9yOiBcIltzdHJpbmddIHRoZSBvcGVyYXRvclwiLFxuICAgICAgICByaWdodDogXCJbQVNUX05vZGVdIHJpZ2h0LWhhbmQgc2lkZSBleHByZXNzaW9uXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubGVmdC5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMucmlnaHQuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy5yaWdodCk7XG4gICAgICAgIHB1c2godGhpcy5sZWZ0KTtcbiAgICB9LFxufSk7XG5cbnZhciBBU1RfQ29uZGl0aW9uYWwgPSBERUZOT0RFKFwiQ29uZGl0aW9uYWxcIiwgXCJjb25kaXRpb24gY29uc2VxdWVudCBhbHRlcm5hdGl2ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQ29uZGl0aW9uYWwgZXhwcmVzc2lvbiB1c2luZyB0aGUgdGVybmFyeSBvcGVyYXRvciwgaS5lLiBgYSA/IGIgOiBjYFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIGNvbmRpdGlvbjogXCJbQVNUX05vZGVdXCIsXG4gICAgICAgIGNvbnNlcXVlbnQ6IFwiW0FTVF9Ob2RlXVwiLFxuICAgICAgICBhbHRlcm5hdGl2ZTogXCJbQVNUX05vZGVdXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5jb25zZXF1ZW50Ll93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgdGhpcy5hbHRlcm5hdGl2ZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgcHVzaCh0aGlzLmFsdGVybmF0aXZlKTtcbiAgICAgICAgcHVzaCh0aGlzLmNvbnNlcXVlbnQpO1xuICAgICAgICBwdXNoKHRoaXMuY29uZGl0aW9uKTtcbiAgICB9LFxufSk7XG5cbnZhciBBU1RfQXNzaWduID0gREVGTk9ERShcIkFzc2lnblwiLCBcImxvZ2ljYWxcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbiDigJQgYGEgPSBiICsgNWBcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBsb2dpY2FsOiBcIldoZXRoZXIgaXQncyBhIGxvZ2ljYWwgYXNzaWdubWVudFwiXG4gICAgfVxufSwgQVNUX0JpbmFyeSk7XG5cbnZhciBBU1RfRGVmYXVsdEFzc2lnbiA9IERFRk5PREUoXCJEZWZhdWx0QXNzaWduXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGRlZmF1bHQgYXNzaWdubWVudCBleHByZXNzaW9uIGxpa2UgaW4gYChhID0gMykgPT4gYWBcIlxufSwgQVNUX0JpbmFyeSk7XG5cbi8qIC0tLS0tWyBMSVRFUkFMUyBdLS0tLS0gKi9cblxudmFyIEFTVF9BcnJheSA9IERFRk5PREUoXCJBcnJheVwiLCBcImVsZW1lbnRzXCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBhcnJheSBsaXRlcmFsXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgZWxlbWVudHM6IFwiW0FTVF9Ob2RlKl0gYXJyYXkgb2YgZWxlbWVudHNcIlxuICAgIH0sXG4gICAgX3dhbGs6IGZ1bmN0aW9uKHZpc2l0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuX3Zpc2l0KHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzW2ldLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSBwdXNoKHRoaXMuZWxlbWVudHNbaV0pO1xuICAgIH0sXG59KTtcblxudmFyIEFTVF9PYmplY3QgPSBERUZOT0RFKFwiT2JqZWN0XCIsIFwicHJvcGVydGllc1wiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gb2JqZWN0IGxpdGVyYWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBwcm9wZXJ0aWVzOiBcIltBU1RfT2JqZWN0UHJvcGVydHkqXSBhcnJheSBvZiBwcm9wZXJ0aWVzXCJcbiAgICB9LFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzW2ldLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMucHJvcGVydGllcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHB1c2godGhpcy5wcm9wZXJ0aWVzW2ldKTtcbiAgICB9LFxufSk7XG5cbnZhciBBU1RfT2JqZWN0UHJvcGVydHkgPSBERUZOT0RFKFwiT2JqZWN0UHJvcGVydHlcIiwgXCJrZXkgdmFsdWVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGxpdGVyYWwgb2JqZWN0IHByb3BlcnRpZXNcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBrZXk6IFwiW3N0cmluZ3xBU1RfTm9kZV0gcHJvcGVydHkgbmFtZS4gRm9yIE9iamVjdEtleVZhbCB0aGlzIGlzIGEgc3RyaW5nLiBGb3IgZ2V0dGVycywgc2V0dGVycyBhbmQgY29tcHV0ZWQgcHJvcGVydHkgdGhpcyBpcyBhbiBBU1RfTm9kZS5cIixcbiAgICAgICAgdmFsdWU6IFwiW0FTVF9Ob2RlXSBwcm9wZXJ0eSB2YWx1ZS4gIEZvciBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoaXMgaXMgYW4gQVNUX0FjY2Vzc29yLlwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5rZXkgaW5zdGFuY2VvZiBBU1RfTm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmtleS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKSB7XG4gICAgICAgIHB1c2godGhpcy52YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmtleSBpbnN0YW5jZW9mIEFTVF9Ob2RlKSBwdXNoKHRoaXMua2V5KTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9PYmplY3RLZXlWYWwgPSBERUZOT0RFKFwiT2JqZWN0S2V5VmFsXCIsIFwicXVvdGVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEga2V5OiB2YWx1ZSBvYmplY3QgcHJvcGVydHlcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBxdW90ZTogXCJbc3RyaW5nXSB0aGUgb3JpZ2luYWwgcXVvdGUgY2hhcmFjdGVyXCJcbiAgICB9LFxuICAgIGNvbXB1dGVkX2tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5IGluc3RhbmNlb2YgQVNUX05vZGU7XG4gICAgfVxufSwgQVNUX09iamVjdFByb3BlcnR5KTtcblxudmFyIEFTVF9Qcml2YXRlU2V0dGVyID0gREVGTk9ERShcIlByaXZhdGVTZXR0ZXJcIiwgXCJzdGF0aWNcIiwge1xuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHN0YXRpYzogXCJbYm9vbGVhbl0gd2hldGhlciB0aGlzIGlzIGEgc3RhdGljIHByaXZhdGUgc2V0dGVyXCJcbiAgICB9LFxuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgcHJpdmF0ZSBzZXR0ZXIgcHJvcGVydHlcIixcbiAgICBjb21wdXRlZF9rZXkoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59LCBBU1RfT2JqZWN0UHJvcGVydHkpO1xuXG52YXIgQVNUX1ByaXZhdGVHZXR0ZXIgPSBERUZOT0RFKFwiUHJpdmF0ZUdldHRlclwiLCBcInN0YXRpY1wiLCB7XG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgc3RhdGljOiBcIltib29sZWFuXSB3aGV0aGVyIHRoaXMgaXMgYSBzdGF0aWMgcHJpdmF0ZSBnZXR0ZXJcIlxuICAgIH0sXG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBwcml2YXRlIGdldHRlciBwcm9wZXJ0eVwiLFxuICAgIGNvbXB1dGVkX2tleSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0sIEFTVF9PYmplY3RQcm9wZXJ0eSk7XG5cbnZhciBBU1RfT2JqZWN0U2V0dGVyID0gREVGTk9ERShcIk9iamVjdFNldHRlclwiLCBcInF1b3RlIHN0YXRpY1wiLCB7XG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgcXVvdGU6IFwiW3N0cmluZ3x1bmRlZmluZWRdIHRoZSBvcmlnaW5hbCBxdW90ZSBjaGFyYWN0ZXIsIGlmIGFueVwiLFxuICAgICAgICBzdGF0aWM6IFwiW2Jvb2xlYW5dIHdoZXRoZXIgdGhpcyBpcyBhIHN0YXRpYyBzZXR0ZXIgKGNsYXNzZXMgb25seSlcIlxuICAgIH0sXG4gICAgJGRvY3VtZW50YXRpb246IFwiQW4gb2JqZWN0IHNldHRlciBwcm9wZXJ0eVwiLFxuICAgIGNvbXB1dGVkX2tleSgpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy5rZXkgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTWV0aG9kKTtcbiAgICB9XG59LCBBU1RfT2JqZWN0UHJvcGVydHkpO1xuXG52YXIgQVNUX09iamVjdEdldHRlciA9IERFRk5PREUoXCJPYmplY3RHZXR0ZXJcIiwgXCJxdW90ZSBzdGF0aWNcIiwge1xuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHF1b3RlOiBcIltzdHJpbmd8dW5kZWZpbmVkXSB0aGUgb3JpZ2luYWwgcXVvdGUgY2hhcmFjdGVyLCBpZiBhbnlcIixcbiAgICAgICAgc3RhdGljOiBcIltib29sZWFuXSB3aGV0aGVyIHRoaXMgaXMgYSBzdGF0aWMgZ2V0dGVyIChjbGFzc2VzIG9ubHkpXCJcbiAgICB9LFxuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIG9iamVjdCBnZXR0ZXIgcHJvcGVydHlcIixcbiAgICBjb21wdXRlZF9rZXkoKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMua2V5IGluc3RhbmNlb2YgQVNUX1N5bWJvbE1ldGhvZCk7XG4gICAgfVxufSwgQVNUX09iamVjdFByb3BlcnR5KTtcblxudmFyIEFTVF9Db25jaXNlTWV0aG9kID0gREVGTk9ERShcIkNvbmNpc2VNZXRob2RcIiwgXCJxdW90ZSBzdGF0aWMgaXNfZ2VuZXJhdG9yIGFzeW5jXCIsIHtcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBxdW90ZTogXCJbc3RyaW5nfHVuZGVmaW5lZF0gdGhlIG9yaWdpbmFsIHF1b3RlIGNoYXJhY3RlciwgaWYgYW55XCIsXG4gICAgICAgIHN0YXRpYzogXCJbYm9vbGVhbl0gaXMgdGhpcyBtZXRob2Qgc3RhdGljIChjbGFzc2VzIG9ubHkpXCIsXG4gICAgICAgIGlzX2dlbmVyYXRvcjogXCJbYm9vbGVhbl0gaXMgdGhpcyBhIGdlbmVyYXRvciBtZXRob2RcIixcbiAgICAgICAgYXN5bmM6IFwiW2Jvb2xlYW5dIGlzIHRoaXMgbWV0aG9kIGFzeW5jXCIsXG4gICAgfSxcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBbiBFUzYgY29uY2lzZSBtZXRob2QgaW5zaWRlIGFuIG9iamVjdCBvciBjbGFzc1wiLFxuICAgIGNvbXB1dGVkX2tleSgpIHtcbiAgICAgICAgcmV0dXJuICEodGhpcy5rZXkgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTWV0aG9kKTtcbiAgICB9XG59LCBBU1RfT2JqZWN0UHJvcGVydHkpO1xuXG52YXIgQVNUX1ByaXZhdGVNZXRob2QgPSBERUZOT0RFKFwiUHJpdmF0ZU1ldGhvZFwiLCBcIlwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBwcml2YXRlIGNsYXNzIG1ldGhvZCBpbnNpZGUgYSBjbGFzc1wiLFxufSwgQVNUX0NvbmNpc2VNZXRob2QpO1xuXG52YXIgQVNUX0NsYXNzID0gREVGTk9ERShcIkNsYXNzXCIsIFwibmFtZSBleHRlbmRzIHByb3BlcnRpZXNcIiwge1xuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIG5hbWU6IFwiW0FTVF9TeW1ib2xDbGFzc3xBU1RfU3ltYm9sRGVmQ2xhc3M/XSBvcHRpb25hbCBjbGFzcyBuYW1lLlwiLFxuICAgICAgICBleHRlbmRzOiBcIltBU1RfTm9kZV0/IG9wdGlvbmFsIHBhcmVudCBjbGFzc1wiLFxuICAgICAgICBwcm9wZXJ0aWVzOiBcIltBU1RfT2JqZWN0UHJvcGVydHkqXSBhcnJheSBvZiBwcm9wZXJ0aWVzXCJcbiAgICB9LFxuICAgICRkb2N1bWVudGF0aW9uOiBcIkFuIEVTNiBjbGFzc1wiLFxuICAgIF93YWxrOiBmdW5jdGlvbih2aXNpdG9yKSB7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLl92aXNpdCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUuX3dhbGsodmlzaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5leHRlbmRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRzLl93YWxrKHZpc2l0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmZvckVhY2goKHByb3ApID0+IHByb3AuX3dhbGsodmlzaXRvcikpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIF9jaGlsZHJlbl9iYWNrd2FyZHMocHVzaCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMucHJvcGVydGllcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHB1c2godGhpcy5wcm9wZXJ0aWVzW2ldKTtcbiAgICAgICAgaWYgKHRoaXMuZXh0ZW5kcykgcHVzaCh0aGlzLmV4dGVuZHMpO1xuICAgICAgICBpZiAodGhpcy5uYW1lKSBwdXNoKHRoaXMubmFtZSk7XG4gICAgfSxcbn0sIEFTVF9TY29wZSAvKiBUT0RPIGEgY2xhc3MgbWlnaHQgaGF2ZSBhIHNjb3BlIGJ1dCBpdCdzIG5vdCBhIHNjb3BlICovKTtcblxudmFyIEFTVF9DbGFzc1Byb3BlcnR5ID0gREVGTk9ERShcIkNsYXNzUHJvcGVydHlcIiwgXCJzdGF0aWMgcXVvdGVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgY2xhc3MgcHJvcGVydHlcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICBzdGF0aWM6IFwiW2Jvb2xlYW5dIHdoZXRoZXIgdGhpcyBpcyBhIHN0YXRpYyBrZXlcIixcbiAgICAgICAgcXVvdGU6IFwiW3N0cmluZ10gd2hpY2ggcXVvdGUgaXMgYmVpbmcgdXNlZFwiXG4gICAgfSxcbiAgICBfd2FsazogZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICByZXR1cm4gdmlzaXRvci5fdmlzaXQodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5rZXkgaW5zdGFuY2VvZiBBU1RfTm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmtleS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgQVNUX05vZGUpXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5fd2Fsayh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBfY2hpbGRyZW5fYmFja3dhcmRzKHB1c2gpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBBU1RfTm9kZSkgcHVzaCh0aGlzLnZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMua2V5IGluc3RhbmNlb2YgQVNUX05vZGUpIHB1c2godGhpcy5rZXkpO1xuICAgIH0sXG4gICAgY29tcHV0ZWRfa2V5KCkge1xuICAgICAgICByZXR1cm4gISh0aGlzLmtleSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xDbGFzc1Byb3BlcnR5KTtcbiAgICB9XG59LCBBU1RfT2JqZWN0UHJvcGVydHkpO1xuXG52YXIgQVNUX0NsYXNzUHJpdmF0ZVByb3BlcnR5ID0gREVGTk9ERShcIkNsYXNzUHJvcGVydHlcIiwgXCJcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgY2xhc3MgcHJvcGVydHkgZm9yIGEgcHJpdmF0ZSBwcm9wZXJ0eVwiLFxufSwgQVNUX0NsYXNzUHJvcGVydHkpO1xuXG52YXIgQVNUX0RlZkNsYXNzID0gREVGTk9ERShcIkRlZkNsYXNzXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIGNsYXNzIGRlZmluaXRpb25cIixcbn0sIEFTVF9DbGFzcyk7XG5cbnZhciBBU1RfQ2xhc3NFeHByZXNzaW9uID0gREVGTk9ERShcIkNsYXNzRXhwcmVzc2lvblwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBjbGFzcyBleHByZXNzaW9uLlwiXG59LCBBU1RfQ2xhc3MpO1xuXG52YXIgQVNUX1N5bWJvbCA9IERFRk5PREUoXCJTeW1ib2xcIiwgXCJzY29wZSBuYW1lIHRoZWRlZlwiLCB7XG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgbmFtZTogXCJbc3RyaW5nXSBuYW1lIG9mIHRoaXMgc3ltYm9sXCIsXG4gICAgICAgIHNjb3BlOiBcIltBU1RfU2NvcGUvU10gdGhlIGN1cnJlbnQgc2NvcGUgKG5vdCBuZWNlc3NhcmlseSB0aGUgZGVmaW5pdGlvbiBzY29wZSlcIixcbiAgICAgICAgdGhlZGVmOiBcIltTeW1ib2xEZWYvU10gdGhlIGRlZmluaXRpb24gb2YgdGhpcyBzeW1ib2xcIlxuICAgIH0sXG4gICAgJGRvY3VtZW50YXRpb246IFwiQmFzZSBjbGFzcyBmb3IgYWxsIHN5bWJvbHNcIlxufSk7XG5cbnZhciBBU1RfTmV3VGFyZ2V0ID0gREVGTk9ERShcIk5ld1RhcmdldFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSByZWZlcmVuY2UgdG8gbmV3LnRhcmdldFwiXG59KTtcblxudmFyIEFTVF9TeW1ib2xEZWNsYXJhdGlvbiA9IERFRk5PREUoXCJTeW1ib2xEZWNsYXJhdGlvblwiLCBcImluaXRcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgZGVjbGFyYXRpb24gc3ltYm9sIChzeW1ib2wgaW4gdmFyL2NvbnN0LCBmdW5jdGlvbiBuYW1lIG9yIGFyZ3VtZW50LCBzeW1ib2wgaW4gY2F0Y2gpXCIsXG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9TeW1ib2xWYXIgPSBERUZOT0RFKFwiU3ltYm9sVmFyXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgZGVmaW5pbmcgYSB2YXJpYWJsZVwiLFxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xCbG9ja0RlY2xhcmF0aW9uID0gREVGTk9ERShcIlN5bWJvbEJsb2NrRGVjbGFyYXRpb25cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGJsb2NrLXNjb3BlZCBkZWNsYXJhdGlvbiBzeW1ib2xzXCJcbn0sIEFTVF9TeW1ib2xEZWNsYXJhdGlvbik7XG5cbnZhciBBU1RfU3ltYm9sQ29uc3QgPSBERUZOT0RFKFwiU3ltYm9sQ29uc3RcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgY29uc3RhbnQgZGVjbGFyYXRpb25cIlxufSwgQVNUX1N5bWJvbEJsb2NrRGVjbGFyYXRpb24pO1xuXG52YXIgQVNUX1N5bWJvbExldCA9IERFRk5PREUoXCJTeW1ib2xMZXRcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgYmxvY2stc2NvcGVkIGBsZXRgIGRlY2xhcmF0aW9uXCJcbn0sIEFTVF9TeW1ib2xCbG9ja0RlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xGdW5hcmcgPSBERUZOT0RFKFwiU3ltYm9sRnVuYXJnXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgbmFtaW5nIGEgZnVuY3Rpb24gYXJndW1lbnRcIixcbn0sIEFTVF9TeW1ib2xWYXIpO1xuXG52YXIgQVNUX1N5bWJvbERlZnVuID0gREVGTk9ERShcIlN5bWJvbERlZnVuXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgZGVmaW5pbmcgYSBmdW5jdGlvblwiLFxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xNZXRob2QgPSBERUZOT0RFKFwiU3ltYm9sTWV0aG9kXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgaW4gYW4gb2JqZWN0IGRlZmluaW5nIGEgbWV0aG9kXCIsXG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9TeW1ib2xDbGFzc1Byb3BlcnR5ID0gREVGTk9ERShcIlN5bWJvbENsYXNzUHJvcGVydHlcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN5bWJvbCBmb3IgYSBjbGFzcyBwcm9wZXJ0eVwiLFxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfU3ltYm9sTGFtYmRhID0gREVGTk9ERShcIlN5bWJvbExhbWJkYVwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIG5hbWluZyBhIGZ1bmN0aW9uIGV4cHJlc3Npb25cIixcbn0sIEFTVF9TeW1ib2xEZWNsYXJhdGlvbik7XG5cbnZhciBBU1RfU3ltYm9sRGVmQ2xhc3MgPSBERUZOT0RFKFwiU3ltYm9sRGVmQ2xhc3NcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN5bWJvbCBuYW1pbmcgYSBjbGFzcydzIG5hbWUgaW4gYSBjbGFzcyBkZWNsYXJhdGlvbi4gTGV4aWNhbGx5IHNjb3BlZCB0byBpdHMgY29udGFpbmluZyBzY29wZSwgYW5kIGFjY2Vzc2libGUgd2l0aGluIHRoZSBjbGFzcy5cIlxufSwgQVNUX1N5bWJvbEJsb2NrRGVjbGFyYXRpb24pO1xuXG52YXIgQVNUX1N5bWJvbENsYXNzID0gREVGTk9ERShcIlN5bWJvbENsYXNzXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgbmFtaW5nIGEgY2xhc3MncyBuYW1lLiBMZXhpY2FsbHkgc2NvcGVkIHRvIHRoZSBjbGFzcy5cIlxufSwgQVNUX1N5bWJvbERlY2xhcmF0aW9uKTtcblxudmFyIEFTVF9TeW1ib2xDYXRjaCA9IERFRk5PREUoXCJTeW1ib2xDYXRjaFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIG5hbWluZyB0aGUgZXhjZXB0aW9uIGluIGNhdGNoXCIsXG59LCBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbik7XG5cbnZhciBBU1RfU3ltYm9sSW1wb3J0ID0gREVGTk9ERShcIlN5bWJvbEltcG9ydFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiU3ltYm9sIHJlZmVycmluZyB0byBhbiBpbXBvcnRlZCBuYW1lXCIsXG59LCBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbik7XG5cbnZhciBBU1RfU3ltYm9sSW1wb3J0Rm9yZWlnbiA9IERFRk5PREUoXCJTeW1ib2xJbXBvcnRGb3JlaWduXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIHN5bWJvbCBpbXBvcnRlZCBmcm9tIGEgbW9kdWxlLCBidXQgaXQgaXMgZGVmaW5lZCBpbiB0aGUgb3RoZXIgbW9kdWxlLCBhbmQgaXRzIHJlYWwgbmFtZSBpcyBpcnJlbGV2YW50IGZvciB0aGlzIG1vZHVsZSdzIHB1cnBvc2VzXCIsXG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9MYWJlbCA9IERFRk5PREUoXCJMYWJlbFwiLCBcInJlZmVyZW5jZXNcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlN5bWJvbCBuYW1pbmcgYSBsYWJlbCAoZGVjbGFyYXRpb24pXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgcmVmZXJlbmNlczogXCJbQVNUX0xvb3BDb250cm9sKl0gYSBsaXN0IG9mIG5vZGVzIHJlZmVycmluZyB0byB0aGlzIGxhYmVsXCJcbiAgICB9LFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy50aGVkZWYgPSB0aGlzO1xuICAgIH1cbn0sIEFTVF9TeW1ib2wpO1xuXG52YXIgQVNUX1N5bWJvbFJlZiA9IERFRk5PREUoXCJTeW1ib2xSZWZcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlJlZmVyZW5jZSB0byBzb21lIHN5bWJvbCAobm90IGRlZmluaXRpb24vZGVjbGFyYXRpb24pXCIsXG59LCBBU1RfU3ltYm9sKTtcblxudmFyIEFTVF9TeW1ib2xFeHBvcnQgPSBERUZOT0RFKFwiU3ltYm9sRXhwb3J0XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJTeW1ib2wgcmVmZXJyaW5nIHRvIGEgbmFtZSB0byBleHBvcnRcIixcbn0sIEFTVF9TeW1ib2xSZWYpO1xuXG52YXIgQVNUX1N5bWJvbEV4cG9ydEZvcmVpZ24gPSBERUZOT0RFKFwiU3ltYm9sRXhwb3J0Rm9yZWlnblwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBzeW1ib2wgZXhwb3J0ZWQgZnJvbSB0aGlzIG1vZHVsZSwgYnV0IGl0IGlzIHVzZWQgaW4gdGhlIG90aGVyIG1vZHVsZSwgYW5kIGl0cyByZWFsIG5hbWUgaXMgaXJyZWxldmFudCBmb3IgdGhpcyBtb2R1bGUncyBwdXJwb3Nlc1wiLFxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfTGFiZWxSZWYgPSBERUZOT0RFKFwiTGFiZWxSZWZcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlJlZmVyZW5jZSB0byBhIGxhYmVsIHN5bWJvbFwiLFxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfVGhpcyA9IERFRk5PREUoXCJUaGlzXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgYHRoaXNgIHN5bWJvbFwiLFxufSwgQVNUX1N5bWJvbCk7XG5cbnZhciBBU1RfU3VwZXIgPSBERUZOT0RFKFwiU3VwZXJcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgc3VwZXJgIHN5bWJvbFwiLFxufSwgQVNUX1RoaXMpO1xuXG52YXIgQVNUX0NvbnN0YW50ID0gREVGTk9ERShcIkNvbnN0YW50XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJCYXNlIGNsYXNzIGZvciBhbGwgY29uc3RhbnRzXCIsXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG59KTtcblxudmFyIEFTVF9TdHJpbmcgPSBERUZOT0RFKFwiU3RyaW5nXCIsIFwidmFsdWUgcXVvdGVcIiwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgc3RyaW5nIGxpdGVyYWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbc3RyaW5nXSB0aGUgY29udGVudHMgb2YgdGhpcyBzdHJpbmdcIixcbiAgICAgICAgcXVvdGU6IFwiW3N0cmluZ10gdGhlIG9yaWdpbmFsIHF1b3RlIGNoYXJhY3RlclwiXG4gICAgfVxufSwgQVNUX0NvbnN0YW50KTtcblxudmFyIEFTVF9OdW1iZXIgPSBERUZOT0RFKFwiTnVtYmVyXCIsIFwidmFsdWUgcmF3XCIsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJBIG51bWJlciBsaXRlcmFsXCIsXG4gICAgJHByb3Bkb2M6IHtcbiAgICAgICAgdmFsdWU6IFwiW251bWJlcl0gdGhlIG51bWVyaWMgdmFsdWVcIixcbiAgICAgICAgcmF3OiBcIltzdHJpbmddIG51bWVyaWMgdmFsdWUgYXMgc3RyaW5nXCJcbiAgICB9XG59LCBBU1RfQ29uc3RhbnQpO1xuXG52YXIgQVNUX0JpZ0ludCA9IERFRk5PREUoXCJCaWdJbnRcIiwgXCJ2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSBiaWcgaW50IGxpdGVyYWxcIixcbiAgICAkcHJvcGRvYzoge1xuICAgICAgICB2YWx1ZTogXCJbc3RyaW5nXSBiaWcgaW50IHZhbHVlXCJcbiAgICB9XG59LCBBU1RfQ29uc3RhbnQpO1xuXG52YXIgQVNUX1JlZ0V4cCA9IERFRk5PREUoXCJSZWdFeHBcIiwgXCJ2YWx1ZVwiLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiQSByZWdleHAgbGl0ZXJhbFwiLFxuICAgICRwcm9wZG9jOiB7XG4gICAgICAgIHZhbHVlOiBcIltSZWdFeHBdIHRoZSBhY3R1YWwgcmVnZXhwXCIsXG4gICAgfVxufSwgQVNUX0NvbnN0YW50KTtcblxudmFyIEFTVF9BdG9tID0gREVGTk9ERShcIkF0b21cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGF0b21zXCIsXG59LCBBU1RfQ29uc3RhbnQpO1xuXG52YXIgQVNUX051bGwgPSBERUZOT0RFKFwiTnVsbFwiLCBudWxsLCB7XG4gICAgJGRvY3VtZW50YXRpb246IFwiVGhlIGBudWxsYCBhdG9tXCIsXG4gICAgdmFsdWU6IG51bGxcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9OYU4gPSBERUZOT0RFKFwiTmFOXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgaW1wb3NzaWJsZSB2YWx1ZVwiLFxuICAgIHZhbHVlOiAwLzBcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9VbmRlZmluZWQgPSBERUZOT0RFKFwiVW5kZWZpbmVkXCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgYHVuZGVmaW5lZGAgdmFsdWVcIixcbiAgICB2YWx1ZTogKGZ1bmN0aW9uKCkge30oKSlcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9Ib2xlID0gREVGTk9ERShcIkhvbGVcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkEgaG9sZSBpbiBhbiBhcnJheVwiLFxuICAgIHZhbHVlOiAoZnVuY3Rpb24oKSB7fSgpKVxufSwgQVNUX0F0b20pO1xuXG52YXIgQVNUX0luZmluaXR5ID0gREVGTk9ERShcIkluZmluaXR5XCIsIG51bGwsIHtcbiAgICAkZG9jdW1lbnRhdGlvbjogXCJUaGUgYEluZmluaXR5YCB2YWx1ZVwiLFxuICAgIHZhbHVlOiAxLzBcbn0sIEFTVF9BdG9tKTtcblxudmFyIEFTVF9Cb29sZWFuID0gREVGTk9ERShcIkJvb2xlYW5cIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIkJhc2UgY2xhc3MgZm9yIGJvb2xlYW5zXCIsXG59LCBBU1RfQXRvbSk7XG5cbnZhciBBU1RfRmFsc2UgPSBERUZOT0RFKFwiRmFsc2VcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgZmFsc2VgIGF0b21cIixcbiAgICB2YWx1ZTogZmFsc2Vcbn0sIEFTVF9Cb29sZWFuKTtcblxudmFyIEFTVF9UcnVlID0gREVGTk9ERShcIlRydWVcIiwgbnVsbCwge1xuICAgICRkb2N1bWVudGF0aW9uOiBcIlRoZSBgdHJ1ZWAgYXRvbVwiLFxuICAgIHZhbHVlOiB0cnVlXG59LCBBU1RfQm9vbGVhbik7XG5cbi8qIC0tLS0tWyBXYWxrIGZ1bmN0aW9uIF0tLS0tICovXG5cbi8qKlxuICogV2FsayBub2RlcyBpbiBkZXB0aC1maXJzdCBzZWFyY2ggZmFzaGlvbi5cbiAqIENhbGxiYWNrIGNhbiByZXR1cm4gYHdhbGtfYWJvcnRgIHN5bWJvbCB0byBzdG9wIGl0ZXJhdGlvbi5cbiAqIEl0IGNhbiBhbHNvIHJldHVybiBgdHJ1ZWAgdG8gc3RvcCBpdGVyYXRpb24ganVzdCBmb3IgY2hpbGQgbm9kZXMuXG4gKiBJdGVyYXRpb24gY2FuIGJlIHN0b3BwZWQgYW5kIGNvbnRpbnVlZCBieSBwYXNzaW5nIHRoZSBgdG9fdmlzaXRgIGFyZ3VtZW50LFxuICogd2hpY2ggaXMgZ2l2ZW4gdG8gdGhlIGNhbGxiYWNrIGluIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gKiovXG5mdW5jdGlvbiB3YWxrKG5vZGUsIGNiLCB0b192aXNpdCA9IFtub2RlXSkge1xuICAgIGNvbnN0IHB1c2ggPSB0b192aXNpdC5wdXNoLmJpbmQodG9fdmlzaXQpO1xuICAgIHdoaWxlICh0b192aXNpdC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRvX3Zpc2l0LnBvcCgpO1xuICAgICAgICBjb25zdCByZXQgPSBjYihub2RlLCB0b192aXNpdCk7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgaWYgKHJldCA9PT0gd2Fsa19hYm9ydCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB3YWxrX3BhcmVudChub2RlLCBjYiwgaW5pdGlhbF9zdGFjaykge1xuICAgIGNvbnN0IHRvX3Zpc2l0ID0gW25vZGVdO1xuICAgIGNvbnN0IHB1c2ggPSB0b192aXNpdC5wdXNoLmJpbmQodG9fdmlzaXQpO1xuICAgIGNvbnN0IHN0YWNrID0gaW5pdGlhbF9zdGFjayA/IGluaXRpYWxfc3RhY2suc2xpY2UoKSA6IFtdO1xuICAgIGNvbnN0IHBhcmVudF9wb3BfaW5kaWNlcyA9IFtdO1xuXG4gICAgbGV0IGN1cnJlbnQ7XG5cbiAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBwYXJlbnQ6IChuID0gMCkgPT4ge1xuICAgICAgICAgICAgaWYgKG4gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFsgcDEgcDAgXSBbIDEgMCBdXG4gICAgICAgICAgICBpZiAoaW5pdGlhbF9zdGFjayAmJiBuID49IHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG4gLT0gc3RhY2subGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0aWFsX3N0YWNrW1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsX3N0YWNrLmxlbmd0aCAtIChuICsgMSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gKDEgKyBuKV07XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIHdoaWxlICh0b192aXNpdC5sZW5ndGgpIHtcbiAgICAgICAgY3VycmVudCA9IHRvX3Zpc2l0LnBvcCgpO1xuXG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgIHBhcmVudF9wb3BfaW5kaWNlcy5sZW5ndGggJiZcbiAgICAgICAgICAgIHRvX3Zpc2l0Lmxlbmd0aCA9PSBwYXJlbnRfcG9wX2luZGljZXNbcGFyZW50X3BvcF9pbmRpY2VzLmxlbmd0aCAtIDFdXG4gICAgICAgICkge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBwYXJlbnRfcG9wX2luZGljZXMucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXQgPSBjYihjdXJyZW50LCBpbmZvKTtcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICBpZiAocmV0ID09PSB3YWxrX2Fib3J0KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmlzaXRfbGVuZ3RoID0gdG9fdmlzaXQubGVuZ3RoO1xuXG4gICAgICAgIGN1cnJlbnQuX2NoaWxkcmVuX2JhY2t3YXJkcyhwdXNoKTtcblxuICAgICAgICAvLyBQdXNoIG9ubHkgaWYgd2UncmUgZ29pbmcgdG8gdHJhdmVyc2UgdGhlIGNoaWxkcmVuXG4gICAgICAgIGlmICh0b192aXNpdC5sZW5ndGggPiB2aXNpdF9sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICBwYXJlbnRfcG9wX2luZGljZXMucHVzaCh2aXNpdF9sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3Qgd2Fsa19hYm9ydCA9IFN5bWJvbChcImFib3J0IHdhbGtcIik7XG5cbi8qIC0tLS0tWyBUcmVlV2Fsa2VyIF0tLS0tLSAqL1xuXG5jbGFzcyBUcmVlV2Fsa2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnZpc2l0ID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG5cbiAgICBfdmlzaXQobm9kZSwgZGVzY2VuZCkge1xuICAgICAgICB0aGlzLnB1c2gobm9kZSk7XG4gICAgICAgIHZhciByZXQgPSB0aGlzLnZpc2l0KG5vZGUsIGRlc2NlbmQgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRlc2NlbmQuY2FsbChub2RlKTtcbiAgICAgICAgfSA6IG5vb3ApO1xuICAgICAgICBpZiAoIXJldCAmJiBkZXNjZW5kKSB7XG4gICAgICAgICAgICBkZXNjZW5kLmNhbGwobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBwYXJlbnQobikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDIgLSAobiB8fCAwKV07XG4gICAgfVxuXG4gICAgcHVzaChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSkge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmRpcmVjdGl2ZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlICYmICF0aGlzLmRpcmVjdGl2ZXNbbm9kZS52YWx1ZV0pIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlc1tub2RlLnZhbHVlXSA9IG5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DbGFzcykge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRpcmVjdGl2ZXNbXCJ1c2Ugc3RyaWN0XCJdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzW1widXNlIHN0cmljdFwiXSA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xuICAgIH1cblxuICAgIHBvcCgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9DbGFzcykge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMuZGlyZWN0aXZlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGZpbmRfcGFyZW50KHR5cGUpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiB0eXBlKSByZXR1cm4geDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhc19kaXJlY3RpdmUodHlwZSkge1xuICAgICAgICB2YXIgZGlyID0gdGhpcy5kaXJlY3RpdmVzW3R5cGVdO1xuICAgICAgICBpZiAoZGlyKSByZXR1cm4gZGlyO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUgJiYgbm9kZS5ib2R5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuYm9keS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBzdCA9IG5vZGUuYm9keVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIShzdCBpbnN0YW5jZW9mIEFTVF9EaXJlY3RpdmUpKSBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoc3QudmFsdWUgPT0gdHlwZSkgcmV0dXJuIHN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9vcGNvbnRyb2xfdGFyZ2V0KG5vZGUpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5zdGFjaztcbiAgICAgICAgaWYgKG5vZGUubGFiZWwpIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgdmFyIHggPSBzdGFja1tpXTtcbiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgQVNUX0xhYmVsZWRTdGF0ZW1lbnQgJiYgeC5sYWJlbC5uYW1lID09IG5vZGUubGFiZWwubmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4geC5ib2R5O1xuICAgICAgICB9IGVsc2UgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHN0YWNrW2ldO1xuICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBBU1RfSXRlcmF0aW9uU3RhdGVtZW50XG4gICAgICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9CcmVhayAmJiB4IGluc3RhbmNlb2YgQVNUX1N3aXRjaClcbiAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gVHJlZSB0cmFuc2Zvcm1lciBoZWxwZXJzLlxuY2xhc3MgVHJlZVRyYW5zZm9ybWVyIGV4dGVuZHMgVHJlZVdhbGtlciB7XG4gICAgY29uc3RydWN0b3IoYmVmb3JlLCBhZnRlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJlZm9yZSA9IGJlZm9yZTtcbiAgICAgICAgdGhpcy5hZnRlciA9IGFmdGVyO1xuICAgIH1cbn1cblxuY29uc3QgX1BVUkUgICAgID0gMGIwMDAwMDAwMTtcbmNvbnN0IF9JTkxJTkUgICA9IDBiMDAwMDAwMTA7XG5jb25zdCBfTk9JTkxJTkUgPSAwYjAwMDAwMTAwO1xuXG52YXIgYXN0ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuQVNUX0FjY2Vzc29yOiBBU1RfQWNjZXNzb3IsXG5BU1RfQXJyYXk6IEFTVF9BcnJheSxcbkFTVF9BcnJvdzogQVNUX0Fycm93LFxuQVNUX0Fzc2lnbjogQVNUX0Fzc2lnbixcbkFTVF9BdG9tOiBBU1RfQXRvbSxcbkFTVF9Bd2FpdDogQVNUX0F3YWl0LFxuQVNUX0JpZ0ludDogQVNUX0JpZ0ludCxcbkFTVF9CaW5hcnk6IEFTVF9CaW5hcnksXG5BU1RfQmxvY2s6IEFTVF9CbG9jayxcbkFTVF9CbG9ja1N0YXRlbWVudDogQVNUX0Jsb2NrU3RhdGVtZW50LFxuQVNUX0Jvb2xlYW46IEFTVF9Cb29sZWFuLFxuQVNUX0JyZWFrOiBBU1RfQnJlYWssXG5BU1RfQ2FsbDogQVNUX0NhbGwsXG5BU1RfQ2FzZTogQVNUX0Nhc2UsXG5BU1RfQ2F0Y2g6IEFTVF9DYXRjaCxcbkFTVF9DaGFpbjogQVNUX0NoYWluLFxuQVNUX0NsYXNzOiBBU1RfQ2xhc3MsXG5BU1RfQ2xhc3NFeHByZXNzaW9uOiBBU1RfQ2xhc3NFeHByZXNzaW9uLFxuQVNUX0NsYXNzUHJpdmF0ZVByb3BlcnR5OiBBU1RfQ2xhc3NQcml2YXRlUHJvcGVydHksXG5BU1RfQ2xhc3NQcm9wZXJ0eTogQVNUX0NsYXNzUHJvcGVydHksXG5BU1RfQ29uY2lzZU1ldGhvZDogQVNUX0NvbmNpc2VNZXRob2QsXG5BU1RfQ29uZGl0aW9uYWw6IEFTVF9Db25kaXRpb25hbCxcbkFTVF9Db25zdDogQVNUX0NvbnN0LFxuQVNUX0NvbnN0YW50OiBBU1RfQ29uc3RhbnQsXG5BU1RfQ29udGludWU6IEFTVF9Db250aW51ZSxcbkFTVF9EZWJ1Z2dlcjogQVNUX0RlYnVnZ2VyLFxuQVNUX0RlZmF1bHQ6IEFTVF9EZWZhdWx0LFxuQVNUX0RlZmF1bHRBc3NpZ246IEFTVF9EZWZhdWx0QXNzaWduLFxuQVNUX0RlZkNsYXNzOiBBU1RfRGVmQ2xhc3MsXG5BU1RfRGVmaW5pdGlvbnM6IEFTVF9EZWZpbml0aW9ucyxcbkFTVF9EZWZ1bjogQVNUX0RlZnVuLFxuQVNUX0Rlc3RydWN0dXJpbmc6IEFTVF9EZXN0cnVjdHVyaW5nLFxuQVNUX0RpcmVjdGl2ZTogQVNUX0RpcmVjdGl2ZSxcbkFTVF9EbzogQVNUX0RvLFxuQVNUX0RvdDogQVNUX0RvdCxcbkFTVF9Eb3RIYXNoOiBBU1RfRG90SGFzaCxcbkFTVF9EV0xvb3A6IEFTVF9EV0xvb3AsXG5BU1RfRW1wdHlTdGF0ZW1lbnQ6IEFTVF9FbXB0eVN0YXRlbWVudCxcbkFTVF9FeGl0OiBBU1RfRXhpdCxcbkFTVF9FeHBhbnNpb246IEFTVF9FeHBhbnNpb24sXG5BU1RfRXhwb3J0OiBBU1RfRXhwb3J0LFxuQVNUX0ZhbHNlOiBBU1RfRmFsc2UsXG5BU1RfRmluYWxseTogQVNUX0ZpbmFsbHksXG5BU1RfRm9yOiBBU1RfRm9yLFxuQVNUX0ZvckluOiBBU1RfRm9ySW4sXG5BU1RfRm9yT2Y6IEFTVF9Gb3JPZixcbkFTVF9GdW5jdGlvbjogQVNUX0Z1bmN0aW9uLFxuQVNUX0hvbGU6IEFTVF9Ib2xlLFxuQVNUX0lmOiBBU1RfSWYsXG5BU1RfSW1wb3J0OiBBU1RfSW1wb3J0LFxuQVNUX0ltcG9ydE1ldGE6IEFTVF9JbXBvcnRNZXRhLFxuQVNUX0luZmluaXR5OiBBU1RfSW5maW5pdHksXG5BU1RfSXRlcmF0aW9uU3RhdGVtZW50OiBBU1RfSXRlcmF0aW9uU3RhdGVtZW50LFxuQVNUX0p1bXA6IEFTVF9KdW1wLFxuQVNUX0xhYmVsOiBBU1RfTGFiZWwsXG5BU1RfTGFiZWxlZFN0YXRlbWVudDogQVNUX0xhYmVsZWRTdGF0ZW1lbnQsXG5BU1RfTGFiZWxSZWY6IEFTVF9MYWJlbFJlZixcbkFTVF9MYW1iZGE6IEFTVF9MYW1iZGEsXG5BU1RfTGV0OiBBU1RfTGV0LFxuQVNUX0xvb3BDb250cm9sOiBBU1RfTG9vcENvbnRyb2wsXG5BU1RfTmFtZU1hcHBpbmc6IEFTVF9OYW1lTWFwcGluZyxcbkFTVF9OYU46IEFTVF9OYU4sXG5BU1RfTmV3OiBBU1RfTmV3LFxuQVNUX05ld1RhcmdldDogQVNUX05ld1RhcmdldCxcbkFTVF9Ob2RlOiBBU1RfTm9kZSxcbkFTVF9OdWxsOiBBU1RfTnVsbCxcbkFTVF9OdW1iZXI6IEFTVF9OdW1iZXIsXG5BU1RfT2JqZWN0OiBBU1RfT2JqZWN0LFxuQVNUX09iamVjdEdldHRlcjogQVNUX09iamVjdEdldHRlcixcbkFTVF9PYmplY3RLZXlWYWw6IEFTVF9PYmplY3RLZXlWYWwsXG5BU1RfT2JqZWN0UHJvcGVydHk6IEFTVF9PYmplY3RQcm9wZXJ0eSxcbkFTVF9PYmplY3RTZXR0ZXI6IEFTVF9PYmplY3RTZXR0ZXIsXG5BU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZzogQVNUX1ByZWZpeGVkVGVtcGxhdGVTdHJpbmcsXG5BU1RfUHJpdmF0ZUdldHRlcjogQVNUX1ByaXZhdGVHZXR0ZXIsXG5BU1RfUHJpdmF0ZU1ldGhvZDogQVNUX1ByaXZhdGVNZXRob2QsXG5BU1RfUHJpdmF0ZVNldHRlcjogQVNUX1ByaXZhdGVTZXR0ZXIsXG5BU1RfUHJvcEFjY2VzczogQVNUX1Byb3BBY2Nlc3MsXG5BU1RfUmVnRXhwOiBBU1RfUmVnRXhwLFxuQVNUX1JldHVybjogQVNUX1JldHVybixcbkFTVF9TY29wZTogQVNUX1Njb3BlLFxuQVNUX1NlcXVlbmNlOiBBU1RfU2VxdWVuY2UsXG5BU1RfU2ltcGxlU3RhdGVtZW50OiBBU1RfU2ltcGxlU3RhdGVtZW50LFxuQVNUX1N0YXRlbWVudDogQVNUX1N0YXRlbWVudCxcbkFTVF9TdGF0ZW1lbnRXaXRoQm9keTogQVNUX1N0YXRlbWVudFdpdGhCb2R5LFxuQVNUX1N0cmluZzogQVNUX1N0cmluZyxcbkFTVF9TdWI6IEFTVF9TdWIsXG5BU1RfU3VwZXI6IEFTVF9TdXBlcixcbkFTVF9Td2l0Y2g6IEFTVF9Td2l0Y2gsXG5BU1RfU3dpdGNoQnJhbmNoOiBBU1RfU3dpdGNoQnJhbmNoLFxuQVNUX1N5bWJvbDogQVNUX1N5bWJvbCxcbkFTVF9TeW1ib2xCbG9ja0RlY2xhcmF0aW9uOiBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbixcbkFTVF9TeW1ib2xDYXRjaDogQVNUX1N5bWJvbENhdGNoLFxuQVNUX1N5bWJvbENsYXNzOiBBU1RfU3ltYm9sQ2xhc3MsXG5BU1RfU3ltYm9sQ2xhc3NQcm9wZXJ0eTogQVNUX1N5bWJvbENsYXNzUHJvcGVydHksXG5BU1RfU3ltYm9sQ29uc3Q6IEFTVF9TeW1ib2xDb25zdCxcbkFTVF9TeW1ib2xEZWNsYXJhdGlvbjogQVNUX1N5bWJvbERlY2xhcmF0aW9uLFxuQVNUX1N5bWJvbERlZkNsYXNzOiBBU1RfU3ltYm9sRGVmQ2xhc3MsXG5BU1RfU3ltYm9sRGVmdW46IEFTVF9TeW1ib2xEZWZ1bixcbkFTVF9TeW1ib2xFeHBvcnQ6IEFTVF9TeW1ib2xFeHBvcnQsXG5BU1RfU3ltYm9sRXhwb3J0Rm9yZWlnbjogQVNUX1N5bWJvbEV4cG9ydEZvcmVpZ24sXG5BU1RfU3ltYm9sRnVuYXJnOiBBU1RfU3ltYm9sRnVuYXJnLFxuQVNUX1N5bWJvbEltcG9ydDogQVNUX1N5bWJvbEltcG9ydCxcbkFTVF9TeW1ib2xJbXBvcnRGb3JlaWduOiBBU1RfU3ltYm9sSW1wb3J0Rm9yZWlnbixcbkFTVF9TeW1ib2xMYW1iZGE6IEFTVF9TeW1ib2xMYW1iZGEsXG5BU1RfU3ltYm9sTGV0OiBBU1RfU3ltYm9sTGV0LFxuQVNUX1N5bWJvbE1ldGhvZDogQVNUX1N5bWJvbE1ldGhvZCxcbkFTVF9TeW1ib2xSZWY6IEFTVF9TeW1ib2xSZWYsXG5BU1RfU3ltYm9sVmFyOiBBU1RfU3ltYm9sVmFyLFxuQVNUX1RlbXBsYXRlU2VnbWVudDogQVNUX1RlbXBsYXRlU2VnbWVudCxcbkFTVF9UZW1wbGF0ZVN0cmluZzogQVNUX1RlbXBsYXRlU3RyaW5nLFxuQVNUX1RoaXM6IEFTVF9UaGlzLFxuQVNUX1Rocm93OiBBU1RfVGhyb3csXG5BU1RfVG9rZW46IEFTVF9Ub2tlbixcbkFTVF9Ub3BsZXZlbDogQVNUX1RvcGxldmVsLFxuQVNUX1RydWU6IEFTVF9UcnVlLFxuQVNUX1RyeTogQVNUX1RyeSxcbkFTVF9VbmFyeTogQVNUX1VuYXJ5LFxuQVNUX1VuYXJ5UG9zdGZpeDogQVNUX1VuYXJ5UG9zdGZpeCxcbkFTVF9VbmFyeVByZWZpeDogQVNUX1VuYXJ5UHJlZml4LFxuQVNUX1VuZGVmaW5lZDogQVNUX1VuZGVmaW5lZCxcbkFTVF9WYXI6IEFTVF9WYXIsXG5BU1RfVmFyRGVmOiBBU1RfVmFyRGVmLFxuQVNUX1doaWxlOiBBU1RfV2hpbGUsXG5BU1RfV2l0aDogQVNUX1dpdGgsXG5BU1RfWWllbGQ6IEFTVF9ZaWVsZCxcblRyZWVUcmFuc2Zvcm1lcjogVHJlZVRyYW5zZm9ybWVyLFxuVHJlZVdhbGtlcjogVHJlZVdhbGtlcixcbndhbGs6IHdhbGssXG53YWxrX2Fib3J0OiB3YWxrX2Fib3J0LFxud2Fsa19ib2R5OiB3YWxrX2JvZHksXG53YWxrX3BhcmVudDogd2Fsa19wYXJlbnQsXG5fSU5MSU5FOiBfSU5MSU5FLFxuX05PSU5MSU5FOiBfTk9JTkxJTkUsXG5fUFVSRTogX1BVUkVcbn0pO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIGRlZl90cmFuc2Zvcm0obm9kZSwgZGVzY2VuZCkge1xuICAgIG5vZGUuREVGTUVUSE9EKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKHR3LCBpbl9saXN0KSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHcucHVzaCh0aGlzKTtcbiAgICAgICAgaWYgKHR3LmJlZm9yZSkgdHJhbnNmb3JtZWQgPSB0dy5iZWZvcmUodGhpcywgZGVzY2VuZCwgaW5fbGlzdCk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZCA9IHRoaXM7XG4gICAgICAgICAgICBkZXNjZW5kKHRyYW5zZm9ybWVkLCB0dyk7XG4gICAgICAgICAgICBpZiAodHcuYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZnRlcl9yZXQgPSB0dy5hZnRlcih0cmFuc2Zvcm1lZCwgaW5fbGlzdCk7XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyX3JldCAhPT0gdW5kZWZpbmVkKSB0cmFuc2Zvcm1lZCA9IGFmdGVyX3JldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0dy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBkb19saXN0KGxpc3QsIHR3KSB7XG4gICAgcmV0dXJuIE1BUChsaXN0LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnRyYW5zZm9ybSh0dywgdHJ1ZSk7XG4gICAgfSk7XG59XG5cbmRlZl90cmFuc2Zvcm0oQVNUX05vZGUsIG5vb3ApO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9MYWJlbGVkU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYubGFiZWwgPSBzZWxmLmxhYmVsLnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfU2ltcGxlU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0Jsb2NrLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfRG8sIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi5jb25kaXRpb24gPSBzZWxmLmNvbmRpdGlvbi50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX1doaWxlLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuY29uZGl0aW9uID0gc2VsZi5jb25kaXRpb24udHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9Gb3IsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgaWYgKHNlbGYuaW5pdCkgc2VsZi5pbml0ID0gc2VsZi5pbml0LnRyYW5zZm9ybSh0dyk7XG4gICAgaWYgKHNlbGYuY29uZGl0aW9uKSBzZWxmLmNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgaWYgKHNlbGYuc3RlcCkgc2VsZi5zdGVwID0gc2VsZi5zdGVwLnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfRm9ySW4sIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5pbml0ID0gc2VsZi5pbml0LnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi5vYmplY3QgPSBzZWxmLm9iamVjdC50cmFuc2Zvcm0odHcpO1xuICAgIHNlbGYuYm9keSA9IHNlbGYuYm9keS50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX1dpdGgsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfRXhpdCwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBpZiAoc2VsZi52YWx1ZSkgc2VsZi52YWx1ZSA9IHNlbGYudmFsdWUudHJhbnNmb3JtKHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9Mb29wQ29udHJvbCwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBpZiAoc2VsZi5sYWJlbCkgc2VsZi5sYWJlbCA9IHNlbGYubGFiZWwudHJhbnNmb3JtKHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9JZiwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLmNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybSh0dyk7XG4gICAgaWYgKHNlbGYuYWx0ZXJuYXRpdmUpIHNlbGYuYWx0ZXJuYXRpdmUgPSBzZWxmLmFsdGVybmF0aXZlLnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfU3dpdGNoLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfQ2FzZSwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLmV4cHJlc3Npb24gPSBzZWxmLmV4cHJlc3Npb24udHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLmJvZHkgPSBkb19saXN0KHNlbGYuYm9keSwgdHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX1RyeSwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLmJvZHkgPSBkb19saXN0KHNlbGYuYm9keSwgdHcpO1xuICAgIGlmIChzZWxmLmJjYXRjaCkgc2VsZi5iY2F0Y2ggPSBzZWxmLmJjYXRjaC50cmFuc2Zvcm0odHcpO1xuICAgIGlmIChzZWxmLmJmaW5hbGx5KSBzZWxmLmJmaW5hbGx5ID0gc2VsZi5iZmluYWxseS50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0NhdGNoLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIGlmIChzZWxmLmFyZ25hbWUpIHNlbGYuYXJnbmFtZSA9IHNlbGYuYXJnbmFtZS50cmFuc2Zvcm0odHcpO1xuICAgIHNlbGYuYm9keSA9IGRvX2xpc3Qoc2VsZi5ib2R5LCB0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfRGVmaW5pdGlvbnMsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5kZWZpbml0aW9ucyA9IGRvX2xpc3Qoc2VsZi5kZWZpbml0aW9ucywgdHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX1ZhckRlZiwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLm5hbWUgPSBzZWxmLm5hbWUudHJhbnNmb3JtKHR3KTtcbiAgICBpZiAoc2VsZi52YWx1ZSkgc2VsZi52YWx1ZSA9IHNlbGYudmFsdWUudHJhbnNmb3JtKHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9EZXN0cnVjdHVyaW5nLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYubmFtZXMgPSBkb19saXN0KHNlbGYubmFtZXMsIHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9MYW1iZGEsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgaWYgKHNlbGYubmFtZSkgc2VsZi5uYW1lID0gc2VsZi5uYW1lLnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi5hcmduYW1lcyA9IGRvX2xpc3Qoc2VsZi5hcmduYW1lcywgdHcpO1xuICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfTm9kZSkge1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkudHJhbnNmb3JtKHR3KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmJvZHkgPSBkb19saXN0KHNlbGYuYm9keSwgdHcpO1xuICAgIH1cbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9DYWxsLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xuICAgIHNlbGYuYXJncyA9IGRvX2xpc3Qoc2VsZi5hcmdzLCB0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfU2VxdWVuY2UsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZG9fbGlzdChzZWxmLmV4cHJlc3Npb25zLCB0dyk7XG4gICAgc2VsZi5leHByZXNzaW9ucyA9IHJlc3VsdC5sZW5ndGhcbiAgICAgICAgPyByZXN1bHRcbiAgICAgICAgOiBbbmV3IEFTVF9OdW1iZXIoeyB2YWx1ZTogMCB9KV07XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfRG90LCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX1N1YiwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLmV4cHJlc3Npb24gPSBzZWxmLmV4cHJlc3Npb24udHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLnByb3BlcnR5ID0gc2VsZi5wcm9wZXJ0eS50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0NoYWluLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX1lpZWxkLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIGlmIChzZWxmLmV4cHJlc3Npb24pIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0F3YWl0LCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX1VuYXJ5LCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0JpbmFyeSwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLmxlZnQgPSBzZWxmLmxlZnQudHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLnJpZ2h0ID0gc2VsZi5yaWdodC50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuY29uZGl0aW9uID0gc2VsZi5jb25kaXRpb24udHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLmNvbnNlcXVlbnQgPSBzZWxmLmNvbnNlcXVlbnQudHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLmFsdGVybmF0aXZlID0gc2VsZi5hbHRlcm5hdGl2ZS50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0FycmF5LCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZWxlbWVudHMgPSBkb19saXN0KHNlbGYuZWxlbWVudHMsIHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9PYmplY3QsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgc2VsZi5wcm9wZXJ0aWVzID0gZG9fbGlzdChzZWxmLnByb3BlcnRpZXMsIHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9PYmplY3RQcm9wZXJ0eSwgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBpZiAoc2VsZi5rZXkgaW5zdGFuY2VvZiBBU1RfTm9kZSkge1xuICAgICAgICBzZWxmLmtleSA9IHNlbGYua2V5LnRyYW5zZm9ybSh0dyk7XG4gICAgfVxuICAgIGlmIChzZWxmLnZhbHVlKSBzZWxmLnZhbHVlID0gc2VsZi52YWx1ZS50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX0NsYXNzLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIGlmIChzZWxmLm5hbWUpIHNlbGYubmFtZSA9IHNlbGYubmFtZS50cmFuc2Zvcm0odHcpO1xuICAgIGlmIChzZWxmLmV4dGVuZHMpIHNlbGYuZXh0ZW5kcyA9IHNlbGYuZXh0ZW5kcy50cmFuc2Zvcm0odHcpO1xuICAgIHNlbGYucHJvcGVydGllcyA9IGRvX2xpc3Qoc2VsZi5wcm9wZXJ0aWVzLCB0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfRXhwYW5zaW9uLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZXhwcmVzc2lvbiA9IHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0odHcpO1xufSk7XG5cbmRlZl90cmFuc2Zvcm0oQVNUX05hbWVNYXBwaW5nLCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIHNlbGYuZm9yZWlnbl9uYW1lID0gc2VsZi5mb3JlaWduX25hbWUudHJhbnNmb3JtKHR3KTtcbiAgICBzZWxmLm5hbWUgPSBzZWxmLm5hbWUudHJhbnNmb3JtKHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9JbXBvcnQsIGZ1bmN0aW9uKHNlbGYsIHR3KSB7XG4gICAgaWYgKHNlbGYuaW1wb3J0ZWRfbmFtZSkgc2VsZi5pbXBvcnRlZF9uYW1lID0gc2VsZi5pbXBvcnRlZF9uYW1lLnRyYW5zZm9ybSh0dyk7XG4gICAgaWYgKHNlbGYuaW1wb3J0ZWRfbmFtZXMpIGRvX2xpc3Qoc2VsZi5pbXBvcnRlZF9uYW1lcywgdHcpO1xuICAgIHNlbGYubW9kdWxlX25hbWUgPSBzZWxmLm1vZHVsZV9uYW1lLnRyYW5zZm9ybSh0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfRXhwb3J0LCBmdW5jdGlvbihzZWxmLCB0dykge1xuICAgIGlmIChzZWxmLmV4cG9ydGVkX2RlZmluaXRpb24pIHNlbGYuZXhwb3J0ZWRfZGVmaW5pdGlvbiA9IHNlbGYuZXhwb3J0ZWRfZGVmaW5pdGlvbi50cmFuc2Zvcm0odHcpO1xuICAgIGlmIChzZWxmLmV4cG9ydGVkX3ZhbHVlKSBzZWxmLmV4cG9ydGVkX3ZhbHVlID0gc2VsZi5leHBvcnRlZF92YWx1ZS50cmFuc2Zvcm0odHcpO1xuICAgIGlmIChzZWxmLmV4cG9ydGVkX25hbWVzKSBkb19saXN0KHNlbGYuZXhwb3J0ZWRfbmFtZXMsIHR3KTtcbiAgICBpZiAoc2VsZi5tb2R1bGVfbmFtZSkgc2VsZi5tb2R1bGVfbmFtZSA9IHNlbGYubW9kdWxlX25hbWUudHJhbnNmb3JtKHR3KTtcbn0pO1xuXG5kZWZfdHJhbnNmb3JtKEFTVF9UZW1wbGF0ZVN0cmluZywgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLnNlZ21lbnRzID0gZG9fbGlzdChzZWxmLnNlZ21lbnRzLCB0dyk7XG59KTtcblxuZGVmX3RyYW5zZm9ybShBU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZywgZnVuY3Rpb24oc2VsZiwgdHcpIHtcbiAgICBzZWxmLnByZWZpeCA9IHNlbGYucHJlZml4LnRyYW5zZm9ybSh0dyk7XG4gICAgc2VsZi50ZW1wbGF0ZV9zdHJpbmcgPSBzZWxmLnRlbXBsYXRlX3N0cmluZy50cmFuc2Zvcm0odHcpO1xufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIG5vcm1hbGl6ZV9kaXJlY3RpdmVzID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgICB2YXIgaW5fZGlyZWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbl9kaXJlY3RpdmUgJiYgYm9keVtpXSBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQgJiYgYm9keVtpXS5ib2R5IGluc3RhbmNlb2YgQVNUX1N0cmluZykge1xuICAgICAgICAgICAgICAgIGJvZHlbaV0gPSBuZXcgQVNUX0RpcmVjdGl2ZSh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBib2R5W2ldLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGJvZHlbaV0uZW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYm9keVtpXS5ib2R5LnZhbHVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluX2RpcmVjdGl2ZSAmJiAhKGJvZHlbaV0gaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50ICYmIGJvZHlbaV0uYm9keSBpbnN0YW5jZW9mIEFTVF9TdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgaW5fZGlyZWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9O1xuXG4gICAgdmFyIE1PWl9UT19NRSA9IHtcbiAgICAgICAgUHJvZ3JhbTogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfVG9wbGV2ZWwoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBib2R5OiBub3JtYWxpemVfZGlyZWN0aXZlcyhNLmJvZHkubWFwKGZyb21fbW96KSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBBcnJheVBhdHRlcm46IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0Rlc3RydWN0dXJpbmcoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBuYW1lczogTS5lbGVtZW50cy5tYXAoZnVuY3Rpb24oZWxtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbG0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0hvbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnJvbV9tb3ooZWxtKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBpc19hcnJheTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIE9iamVjdFBhdHRlcm46IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0Rlc3RydWN0dXJpbmcoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBuYW1lczogTS5wcm9wZXJ0aWVzLm1hcChmcm9tX21veiksXG4gICAgICAgICAgICAgICAgaXNfYXJyYXk6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgQXNzaWdubWVudFBhdHRlcm46IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0RlZmF1bHRBc3NpZ24oe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmcm9tX21veihNLmxlZnQpLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgICAgICByaWdodDogZnJvbV9tb3ooTS5yaWdodClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBTcHJlYWRFbGVtZW50OiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9FeHBhbnNpb24oe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBmcm9tX21veihNLmFyZ3VtZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFJlc3RFbGVtZW50OiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9FeHBhbnNpb24oe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBmcm9tX21veihNLmFyZ3VtZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFRlbXBsYXRlRWxlbWVudDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfVGVtcGxhdGVTZWdtZW50KHtcbiAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IE0udmFsdWUuY29va2VkLFxuICAgICAgICAgICAgICAgIHJhdzogTS52YWx1ZS5yYXdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBUZW1wbGF0ZUxpdGVyYWw6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNLnF1YXNpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goZnJvbV9tb3ooTS5xdWFzaXNbaV0pKTtcbiAgICAgICAgICAgICAgICBpZiAoTS5leHByZXNzaW9uc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKGZyb21fbW96KE0uZXhwcmVzc2lvbnNbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9UZW1wbGF0ZVN0cmluZyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIHNlZ21lbnRzOiBzZWdtZW50c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlX3N0cmluZzogZnJvbV9tb3ooTS5xdWFzaSksXG4gICAgICAgICAgICAgICAgcHJlZml4OiBmcm9tX21veihNLnRhZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBGdW5jdGlvbkRlY2xhcmF0aW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9EZWZ1bih7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIG5hbWU6IGZyb21fbW96KE0uaWQpLFxuICAgICAgICAgICAgICAgIGFyZ25hbWVzOiBNLnBhcmFtcy5tYXAoZnJvbV9tb3opLFxuICAgICAgICAgICAgICAgIGlzX2dlbmVyYXRvcjogTS5nZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgYXN5bmM6IE0uYXN5bmMsXG4gICAgICAgICAgICAgICAgYm9keTogbm9ybWFsaXplX2RpcmVjdGl2ZXMoZnJvbV9tb3ooTS5ib2R5KS5ib2R5KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIEZ1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfRnVuY3Rpb24oe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBuYW1lOiBmcm9tX21veihNLmlkKSxcbiAgICAgICAgICAgICAgICBhcmduYW1lczogTS5wYXJhbXMubWFwKGZyb21fbW96KSxcbiAgICAgICAgICAgICAgICBpc19nZW5lcmF0b3I6IE0uZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIGFzeW5jOiBNLmFzeW5jLFxuICAgICAgICAgICAgICAgIGJvZHk6IG5vcm1hbGl6ZV9kaXJlY3RpdmVzKGZyb21fbW96KE0uYm9keSkuYm9keSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IE0uYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCJcbiAgICAgICAgICAgICAgICA/IGZyb21fbW96KE0uYm9keSkuYm9keVxuICAgICAgICAgICAgICAgIDogW21ha2Vfbm9kZShBU1RfUmV0dXJuLCB7fSwgeyB2YWx1ZTogZnJvbV9tb3ooTS5ib2R5KSB9KV07XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9BcnJvdyh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGFyZ25hbWVzOiBNLnBhcmFtcy5tYXAoZnJvbV9tb3opLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgYXN5bmM6IE0uYXN5bmMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfU2ltcGxlU3RhdGVtZW50KHtcbiAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgYm9keTogZnJvbV9tb3ooTS5leHByZXNzaW9uKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFRyeVN0YXRlbWVudDogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZXJzID0gTS5oYW5kbGVycyB8fCBbTS5oYW5kbGVyXTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPiAxIHx8IE0uZ3VhcmRlZEhhbmRsZXJzICYmIE0uZ3VhcmRlZEhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpcGxlIGNhdGNoIGNsYXVzZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfVHJ5KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGJvZHkgICAgIDogZnJvbV9tb3ooTS5ibG9jaykuYm9keSxcbiAgICAgICAgICAgICAgICBiY2F0Y2ggICA6IGZyb21fbW96KGhhbmRsZXJzWzBdKSxcbiAgICAgICAgICAgICAgICBiZmluYWxseSA6IE0uZmluYWxpemVyID8gbmV3IEFTVF9GaW5hbGx5KGZyb21fbW96KE0uZmluYWxpemVyKSkgOiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgUHJvcGVydHk6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBNLmtleTtcbiAgICAgICAgICAgIHZhciBhcmdzID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogbXlfc3RhcnRfdG9rZW4oa2V5IHx8IE0udmFsdWUpLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgIDogbXlfZW5kX3Rva2VuKE0udmFsdWUpLFxuICAgICAgICAgICAgICAgIGtleSAgICAgIDoga2V5LnR5cGUgPT0gXCJJZGVudGlmaWVyXCIgPyBrZXkubmFtZSA6IGtleS52YWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IGZyb21fbW96KE0udmFsdWUpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKE0uY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICBhcmdzLmtleSA9IGZyb21fbW96KE0ua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGFyZ3MuaXNfZ2VuZXJhdG9yID0gTS52YWx1ZS5nZW5lcmF0b3I7XG4gICAgICAgICAgICAgICAgYXJncy5hc3luYyA9IE0udmFsdWUuYXN5bmM7XG4gICAgICAgICAgICAgICAgaWYgKCFNLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3Mua2V5ID0gbmV3IEFTVF9TeW1ib2xNZXRob2QoeyBuYW1lOiBhcmdzLmtleSB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcmdzLmtleSA9IGZyb21fbW96KE0ua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ29uY2lzZU1ldGhvZChhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNLmtpbmQgPT0gXCJpbml0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnR5cGUgIT0gXCJJZGVudGlmaWVyXCIgJiYga2V5LnR5cGUgIT0gXCJMaXRlcmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5rZXkgPSBmcm9tX21veihrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9PYmplY3RLZXlWYWwoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3Mua2V5ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBhcmdzLmtleSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGFyZ3Mua2V5ID0gbmV3IEFTVF9TeW1ib2xNZXRob2Qoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBhcmdzLmtleVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy52YWx1ZSA9IG5ldyBBU1RfQWNjZXNzb3IoYXJncy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoTS5raW5kID09IFwiZ2V0XCIpIHJldHVybiBuZXcgQVNUX09iamVjdEdldHRlcihhcmdzKTtcbiAgICAgICAgICAgIGlmIChNLmtpbmQgPT0gXCJzZXRcIikgcmV0dXJuIG5ldyBBU1RfT2JqZWN0U2V0dGVyKGFyZ3MpO1xuICAgICAgICAgICAgaWYgKE0ua2luZCA9PSBcIm1ldGhvZFwiKSB7XG4gICAgICAgICAgICAgICAgYXJncy5hc3luYyA9IE0udmFsdWUuYXN5bmM7XG4gICAgICAgICAgICAgICAgYXJncy5pc19nZW5lcmF0b3IgPSBNLnZhbHVlLmdlbmVyYXRvcjtcbiAgICAgICAgICAgICAgICBhcmdzLnF1b3RlID0gTS5jb21wdXRlZCA/IFwiXFxcIlwiIDogbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9Db25jaXNlTWV0aG9kKGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBNZXRob2REZWZpbml0aW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGtleSAgICAgIDogTS5jb21wdXRlZCA/IGZyb21fbW96KE0ua2V5KSA6IG5ldyBBU1RfU3ltYm9sTWV0aG9kKHsgbmFtZTogTS5rZXkubmFtZSB8fCBNLmtleS52YWx1ZSB9KSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IGZyb21fbW96KE0udmFsdWUpLFxuICAgICAgICAgICAgICAgIHN0YXRpYyAgIDogTS5zdGF0aWMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKE0ua2luZCA9PSBcImdldFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfT2JqZWN0R2V0dGVyKGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE0ua2luZCA9PSBcInNldFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfT2JqZWN0U2V0dGVyKGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy5pc19nZW5lcmF0b3IgPSBNLnZhbHVlLmdlbmVyYXRvcjtcbiAgICAgICAgICAgIGFyZ3MuYXN5bmMgPSBNLnZhbHVlLmFzeW5jO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQ29uY2lzZU1ldGhvZChhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgRmllbGREZWZpbml0aW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgaWYgKE0uY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBmcm9tX21veihNLmtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChNLmtleS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiTm9uLUlkZW50aWZpZXIga2V5IGluIEZpZWxkRGVmaW5pdGlvblwiKTtcbiAgICAgICAgICAgICAgICBrZXkgPSBmcm9tX21veihNLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9DbGFzc1Byb3BlcnR5KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgICA6IGZyb21fbW96KE0udmFsdWUpLFxuICAgICAgICAgICAgICAgIHN0YXRpYyAgIDogTS5zdGF0aWMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgUHJvcGVydHlEZWZpbml0aW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgaWYgKE0uY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBmcm9tX21veihNLmtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChNLmtleS50eXBlICE9PSBcIklkZW50aWZpZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiTm9uLUlkZW50aWZpZXIga2V5IGluIFByb3BlcnR5RGVmaW5pdGlvblwiKTtcbiAgICAgICAgICAgICAgICBrZXkgPSBmcm9tX21veihNLmtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0NsYXNzUHJvcGVydHkoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlICAgIDogZnJvbV9tb3ooTS52YWx1ZSksXG4gICAgICAgICAgICAgICAgc3RhdGljICAgOiBNLnN0YXRpYyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBBcnJheUV4cHJlc3Npb246IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0FycmF5KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzIDogTS5lbGVtZW50cy5tYXAoZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbSA9PT0gbnVsbCA/IG5ldyBBU1RfSG9sZSgpIDogZnJvbV9tb3ooZWxlbSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBPYmplY3RFeHByZXNzaW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9PYmplY3Qoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMgOiBNLnByb3BlcnRpZXMubWFwKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tX21veihwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9wLnR5cGUgPSBcIlByb3BlcnR5XCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tX21veihwcm9wKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfU2VxdWVuY2Uoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQgICAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBNLmV4cHJlc3Npb25zLm1hcChmcm9tX21veilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IChNLmNvbXB1dGVkID8gQVNUX1N1YiA6IEFTVF9Eb3QpKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eSAgIDogTS5jb21wdXRlZCA/IGZyb21fbW96KE0ucHJvcGVydHkpIDogTS5wcm9wZXJ0eS5uYW1lLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gOiBmcm9tX21veihNLm9iamVjdCksXG4gICAgICAgICAgICAgICAgb3B0aW9uYWwgICA6IE0ub3B0aW9uYWwgfHwgZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBDaGFpbkV4cHJlc3Npb246IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0NoYWluKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZnJvbV9tb3ooTS5leHByZXNzaW9uKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIFN3aXRjaENhc2U6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgKE0udGVzdCA/IEFTVF9DYXNlIDogQVNUX0RlZmF1bHQpKHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZnJvbV9tb3ooTS50ZXN0KSxcbiAgICAgICAgICAgICAgICBib2R5ICAgICAgIDogTS5jb25zZXF1ZW50Lm1hcChmcm9tX21veilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBWYXJpYWJsZURlY2xhcmF0aW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IChNLmtpbmQgPT09IFwiY29uc3RcIiA/IEFTVF9Db25zdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICBNLmtpbmQgPT09IFwibGV0XCIgPyBBU1RfTGV0IDogQVNUX1Zhcikoe1xuICAgICAgICAgICAgICAgIHN0YXJ0ICAgICAgIDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZW5kICAgICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbnMgOiBNLmRlY2xhcmF0aW9ucy5tYXAoZnJvbV9tb3opXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBJbXBvcnREZWNsYXJhdGlvbjogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgdmFyIGltcG9ydGVkX25hbWUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGltcG9ydGVkX25hbWVzID0gbnVsbDtcbiAgICAgICAgICAgIE0uc3BlY2lmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChzcGVjaWZpZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlY2lmaWVyLnR5cGUgPT09IFwiSW1wb3J0U3BlY2lmaWVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbXBvcnRlZF9uYW1lcykgeyBpbXBvcnRlZF9uYW1lcyA9IFtdOyB9XG4gICAgICAgICAgICAgICAgICAgIGltcG9ydGVkX25hbWVzLnB1c2gobmV3IEFTVF9OYW1lTWFwcGluZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oc3BlY2lmaWVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKHNwZWNpZmllciksXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JlaWduX25hbWU6IGZyb21fbW96KHNwZWNpZmllci5pbXBvcnRlZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmcm9tX21veihzcGVjaWZpZXIubG9jYWwpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNpZmllci50eXBlID09PSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZF9uYW1lID0gZnJvbV9tb3ooc3BlY2lmaWVyLmxvY2FsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNpZmllci50eXBlID09PSBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1wb3J0ZWRfbmFtZXMpIHsgaW1wb3J0ZWRfbmFtZXMgPSBbXTsgfVxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRlZF9uYW1lcy5wdXNoKG5ldyBBU1RfTmFtZU1hcHBpbmcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKHNwZWNpZmllciksXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihzcGVjaWZpZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yZWlnbl9uYW1lOiBuZXcgQVNUX1N5bWJvbEltcG9ydEZvcmVpZ24oeyBuYW1lOiBcIipcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZyb21fbW96KHNwZWNpZmllci5sb2NhbClcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfSW1wb3J0KHtcbiAgICAgICAgICAgICAgICBzdGFydCAgICAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICAgICAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGltcG9ydGVkX25hbWU6IGltcG9ydGVkX25hbWUsXG4gICAgICAgICAgICAgICAgaW1wb3J0ZWRfbmFtZXMgOiBpbXBvcnRlZF9uYW1lcyxcbiAgICAgICAgICAgICAgICBtb2R1bGVfbmFtZSA6IGZyb21fbW96KE0uc291cmNlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIEV4cG9ydEFsbERlY2xhcmF0aW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9FeHBvcnQoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBleHBvcnRlZF9uYW1lczogW1xuICAgICAgICAgICAgICAgICAgICBuZXcgQVNUX05hbWVNYXBwaW5nKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5ldyBBU1RfU3ltYm9sRXhwb3J0Rm9yZWlnbih7IG5hbWU6IFwiKlwiIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yZWlnbl9uYW1lOiBuZXcgQVNUX1N5bWJvbEV4cG9ydEZvcmVpZ24oeyBuYW1lOiBcIipcIiB9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgbW9kdWxlX25hbWU6IGZyb21fbW96KE0uc291cmNlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb246IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0V4cG9ydCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGV4cG9ydGVkX2RlZmluaXRpb246IGZyb21fbW96KE0uZGVjbGFyYXRpb24pLFxuICAgICAgICAgICAgICAgIGV4cG9ydGVkX25hbWVzOiBNLnNwZWNpZmllcnMgJiYgTS5zcGVjaWZpZXJzLmxlbmd0aCA/IE0uc3BlY2lmaWVycy5tYXAoZnVuY3Rpb24gKHNwZWNpZmllcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9OYW1lTWFwcGluZyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JlaWduX25hbWU6IGZyb21fbW96KHNwZWNpZmllci5leHBvcnRlZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmcm9tX21veihzcGVjaWZpZXIubG9jYWwpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pIDogbnVsbCxcbiAgICAgICAgICAgICAgICBtb2R1bGVfbmFtZTogZnJvbV9tb3ooTS5zb3VyY2UpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOiBmdW5jdGlvbihNKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9FeHBvcnQoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBlbmQ6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICBleHBvcnRlZF92YWx1ZTogZnJvbV9tb3ooTS5kZWNsYXJhdGlvbiksXG4gICAgICAgICAgICAgICAgaXNfZGVmYXVsdDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIExpdGVyYWw6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBNLnZhbHVlLCBhcmdzID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0ICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgICA6IG15X2VuZF90b2tlbihNKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByeCA9IE0ucmVnZXg7XG4gICAgICAgICAgICBpZiAocnggJiYgcngucGF0dGVybikge1xuICAgICAgICAgICAgICAgIC8vIFJlZ0V4cExpdGVyYWwgYXMgcGVyIEVTVHJlZSBBU1Qgc3BlY1xuICAgICAgICAgICAgICAgIGFyZ3MudmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogcngucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IHJ4LmZsYWdzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFTVF9SZWdFeHAoYXJncyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJ4KSB7XG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCBsZWdhY3kgUmVnRXhwXG4gICAgICAgICAgICAgICAgY29uc3Qgcnhfc291cmNlID0gTS5yYXcgfHwgdmFsO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcnhfc291cmNlLm1hdGNoKC9eXFwvKC4qKVxcLyhcXHcqKSQvKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlZ2V4IHNvdXJjZSBcIiArIHJ4X3NvdXJjZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgW18sIHNvdXJjZSwgZmxhZ3NdID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgYXJncy52YWx1ZSA9IHsgc291cmNlLCBmbGFncyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX1JlZ0V4cChhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwgPT09IG51bGwpIHJldHVybiBuZXcgQVNUX051bGwoYXJncyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGFyZ3MudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfU3RyaW5nKGFyZ3MpO1xuICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgYXJncy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICBhcmdzLnJhdyA9IE0ucmF3IHx8IHZhbC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX051bWJlcihhcmdzKTtcbiAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3ICh2YWwgPyBBU1RfVHJ1ZSA6IEFTVF9GYWxzZSkoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIE1ldGFQcm9wZXJ0eTogZnVuY3Rpb24oTSkge1xuICAgICAgICAgICAgaWYgKE0ubWV0YS5uYW1lID09PSBcIm5ld1wiICYmIE0ucHJvcGVydHkubmFtZSA9PT0gXCJ0YXJnZXRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX05ld1RhcmdldCh7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBteV9lbmRfdG9rZW4oTSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTS5tZXRhLm5hbWUgPT09IFwiaW1wb3J0XCIgJiYgTS5wcm9wZXJ0eS5uYW1lID09PSBcIm1ldGFcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQVNUX0ltcG9ydE1ldGEoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbXlfZW5kX3Rva2VuKE0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIElkZW50aWZpZXI6IGZ1bmN0aW9uKE0pIHtcbiAgICAgICAgICAgIHZhciBwID0gRlJPTV9NT1pfU1RBQ0tbRlJPTV9NT1pfU1RBQ0subGVuZ3RoIC0gMl07XG4gICAgICAgICAgICByZXR1cm4gbmV3ICggIHAudHlwZSA9PSBcIkxhYmVsZWRTdGF0ZW1lbnRcIiA/IEFTVF9MYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLnR5cGUgPT0gXCJWYXJpYWJsZURlY2xhcmF0b3JcIiAmJiBwLmlkID09PSBNID8gKHAua2luZCA9PSBcImNvbnN0XCIgPyBBU1RfU3ltYm9sQ29uc3QgOiBwLmtpbmQgPT0gXCJsZXRcIiA/IEFTVF9TeW1ib2xMZXQgOiBBU1RfU3ltYm9sVmFyKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAvSW1wb3J0LipTcGVjaWZpZXIvLnRlc3QocC50eXBlKSA/IChwLmxvY2FsID09PSBNID8gQVNUX1N5bWJvbEltcG9ydCA6IEFTVF9TeW1ib2xJbXBvcnRGb3JlaWduKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLnR5cGUgPT0gXCJFeHBvcnRTcGVjaWZpZXJcIiA/IChwLmxvY2FsID09PSBNID8gQVNUX1N5bWJvbEV4cG9ydCA6IEFTVF9TeW1ib2xFeHBvcnRGb3JlaWduKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLnR5cGUgPT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiA/IChwLmlkID09PSBNID8gQVNUX1N5bWJvbExhbWJkYSA6IEFTVF9TeW1ib2xGdW5hcmcpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAudHlwZSA9PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA/IChwLmlkID09PSBNID8gQVNUX1N5bWJvbERlZnVuIDogQVNUX1N5bWJvbEZ1bmFyZylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA/IChwLnBhcmFtcy5pbmNsdWRlcyhNKSkgPyBBU1RfU3ltYm9sRnVuYXJnIDogQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLnR5cGUgPT0gXCJDbGFzc0V4cHJlc3Npb25cIiA/IChwLmlkID09PSBNID8gQVNUX1N5bWJvbENsYXNzIDogQVNUX1N5bWJvbFJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiUHJvcGVydHlcIiA/IChwLmtleSA9PT0gTSAmJiBwLmNvbXB1dGVkIHx8IHAudmFsdWUgPT09IE0gPyBBU1RfU3ltYm9sUmVmIDogQVNUX1N5bWJvbE1ldGhvZClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiUHJvcGVydHlEZWZpbml0aW9uXCIgfHwgcC50eXBlID09PSBcIkZpZWxkRGVmaW5pdGlvblwiID8gKHAua2V5ID09PSBNICYmIHAuY29tcHV0ZWQgfHwgcC52YWx1ZSA9PT0gTSA/IEFTVF9TeW1ib2xSZWYgOiBBU1RfU3ltYm9sQ2xhc3NQcm9wZXJ0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcC50eXBlID09IFwiQ2xhc3NEZWNsYXJhdGlvblwiID8gKHAuaWQgPT09IE0gPyBBU1RfU3ltYm9sRGVmQ2xhc3MgOiBBU1RfU3ltYm9sUmVmKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLnR5cGUgPT0gXCJNZXRob2REZWZpbml0aW9uXCIgPyAocC5jb21wdXRlZCA/IEFTVF9TeW1ib2xSZWYgOiBBU1RfU3ltYm9sTWV0aG9kKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwLnR5cGUgPT0gXCJDYXRjaENsYXVzZVwiID8gQVNUX1N5bWJvbENhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHAudHlwZSA9PSBcIkJyZWFrU3RhdGVtZW50XCIgfHwgcC50eXBlID09IFwiQ29udGludWVTdGF0ZW1lbnRcIiA/IEFTVF9MYWJlbFJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBBU1RfU3ltYm9sUmVmKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgICA6IG15X2VuZF90b2tlbihNKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lICA6IE0ubmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIEJpZ0ludExpdGVyYWwoTSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQmlnSW50KHtcbiAgICAgICAgICAgICAgICBzdGFydCA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIGVuZCAgIDogbXlfZW5kX3Rva2VuKE0pLFxuICAgICAgICAgICAgICAgIHZhbHVlIDogTS52YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTU9aX1RPX01FLlVwZGF0ZUV4cHJlc3Npb24gPVxuICAgIE1PWl9UT19NRS5VbmFyeUV4cHJlc3Npb24gPSBmdW5jdGlvbiBUb19Nb3pfVW5hcnkoTSkge1xuICAgICAgICB2YXIgcHJlZml4ID0gXCJwcmVmaXhcIiBpbiBNID8gTS5wcmVmaXhcbiAgICAgICAgICAgIDogTS50eXBlID09IFwiVW5hcnlFeHByZXNzaW9uXCIgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIHJldHVybiBuZXcgKHByZWZpeCA/IEFTVF9VbmFyeVByZWZpeCA6IEFTVF9VbmFyeVBvc3RmaXgpKHtcbiAgICAgICAgICAgIHN0YXJ0ICAgICAgOiBteV9zdGFydF90b2tlbihNKSxcbiAgICAgICAgICAgIGVuZCAgICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICBvcGVyYXRvciAgIDogTS5vcGVyYXRvcixcbiAgICAgICAgICAgIGV4cHJlc3Npb24gOiBmcm9tX21veihNLmFyZ3VtZW50KVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgTU9aX1RPX01FLkNsYXNzRGVjbGFyYXRpb24gPVxuICAgIE1PWl9UT19NRS5DbGFzc0V4cHJlc3Npb24gPSBmdW5jdGlvbiBGcm9tX01vel9DbGFzcyhNKSB7XG4gICAgICAgIHJldHVybiBuZXcgKE0udHlwZSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIgPyBBU1RfRGVmQ2xhc3MgOiBBU1RfQ2xhc3NFeHByZXNzaW9uKSh7XG4gICAgICAgICAgICBzdGFydCAgICA6IG15X3N0YXJ0X3Rva2VuKE0pLFxuICAgICAgICAgICAgZW5kICAgICAgOiBteV9lbmRfdG9rZW4oTSksXG4gICAgICAgICAgICBuYW1lICAgICA6IGZyb21fbW96KE0uaWQpLFxuICAgICAgICAgICAgZXh0ZW5kcyAgOiBmcm9tX21veihNLnN1cGVyQ2xhc3MpLFxuICAgICAgICAgICAgcHJvcGVydGllczogTS5ib2R5LmJvZHkubWFwKGZyb21fbW96KVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgbWFwKFwiRW1wdHlTdGF0ZW1lbnRcIiwgQVNUX0VtcHR5U3RhdGVtZW50KTtcbiAgICBtYXAoXCJCbG9ja1N0YXRlbWVudFwiLCBBU1RfQmxvY2tTdGF0ZW1lbnQsIFwiYm9keUBib2R5XCIpO1xuICAgIG1hcChcIklmU3RhdGVtZW50XCIsIEFTVF9JZiwgXCJ0ZXN0PmNvbmRpdGlvbiwgY29uc2VxdWVudD5ib2R5LCBhbHRlcm5hdGU+YWx0ZXJuYXRpdmVcIik7XG4gICAgbWFwKFwiTGFiZWxlZFN0YXRlbWVudFwiLCBBU1RfTGFiZWxlZFN0YXRlbWVudCwgXCJsYWJlbD5sYWJlbCwgYm9keT5ib2R5XCIpO1xuICAgIG1hcChcIkJyZWFrU3RhdGVtZW50XCIsIEFTVF9CcmVhaywgXCJsYWJlbD5sYWJlbFwiKTtcbiAgICBtYXAoXCJDb250aW51ZVN0YXRlbWVudFwiLCBBU1RfQ29udGludWUsIFwibGFiZWw+bGFiZWxcIik7XG4gICAgbWFwKFwiV2l0aFN0YXRlbWVudFwiLCBBU1RfV2l0aCwgXCJvYmplY3Q+ZXhwcmVzc2lvbiwgYm9keT5ib2R5XCIpO1xuICAgIG1hcChcIlN3aXRjaFN0YXRlbWVudFwiLCBBU1RfU3dpdGNoLCBcImRpc2NyaW1pbmFudD5leHByZXNzaW9uLCBjYXNlc0Bib2R5XCIpO1xuICAgIG1hcChcIlJldHVyblN0YXRlbWVudFwiLCBBU1RfUmV0dXJuLCBcImFyZ3VtZW50PnZhbHVlXCIpO1xuICAgIG1hcChcIlRocm93U3RhdGVtZW50XCIsIEFTVF9UaHJvdywgXCJhcmd1bWVudD52YWx1ZVwiKTtcbiAgICBtYXAoXCJXaGlsZVN0YXRlbWVudFwiLCBBU1RfV2hpbGUsIFwidGVzdD5jb25kaXRpb24sIGJvZHk+Ym9keVwiKTtcbiAgICBtYXAoXCJEb1doaWxlU3RhdGVtZW50XCIsIEFTVF9EbywgXCJ0ZXN0PmNvbmRpdGlvbiwgYm9keT5ib2R5XCIpO1xuICAgIG1hcChcIkZvclN0YXRlbWVudFwiLCBBU1RfRm9yLCBcImluaXQ+aW5pdCwgdGVzdD5jb25kaXRpb24sIHVwZGF0ZT5zdGVwLCBib2R5PmJvZHlcIik7XG4gICAgbWFwKFwiRm9ySW5TdGF0ZW1lbnRcIiwgQVNUX0ZvckluLCBcImxlZnQ+aW5pdCwgcmlnaHQ+b2JqZWN0LCBib2R5PmJvZHlcIik7XG4gICAgbWFwKFwiRm9yT2ZTdGF0ZW1lbnRcIiwgQVNUX0Zvck9mLCBcImxlZnQ+aW5pdCwgcmlnaHQ+b2JqZWN0LCBib2R5PmJvZHksIGF3YWl0PWF3YWl0XCIpO1xuICAgIG1hcChcIkF3YWl0RXhwcmVzc2lvblwiLCBBU1RfQXdhaXQsIFwiYXJndW1lbnQ+ZXhwcmVzc2lvblwiKTtcbiAgICBtYXAoXCJZaWVsZEV4cHJlc3Npb25cIiwgQVNUX1lpZWxkLCBcImFyZ3VtZW50PmV4cHJlc3Npb24sIGRlbGVnYXRlPWlzX3N0YXJcIik7XG4gICAgbWFwKFwiRGVidWdnZXJTdGF0ZW1lbnRcIiwgQVNUX0RlYnVnZ2VyKTtcbiAgICBtYXAoXCJWYXJpYWJsZURlY2xhcmF0b3JcIiwgQVNUX1ZhckRlZiwgXCJpZD5uYW1lLCBpbml0PnZhbHVlXCIpO1xuICAgIG1hcChcIkNhdGNoQ2xhdXNlXCIsIEFTVF9DYXRjaCwgXCJwYXJhbT5hcmduYW1lLCBib2R5JWJvZHlcIik7XG5cbiAgICBtYXAoXCJUaGlzRXhwcmVzc2lvblwiLCBBU1RfVGhpcyk7XG4gICAgbWFwKFwiU3VwZXJcIiwgQVNUX1N1cGVyKTtcbiAgICBtYXAoXCJCaW5hcnlFeHByZXNzaW9uXCIsIEFTVF9CaW5hcnksIFwib3BlcmF0b3I9b3BlcmF0b3IsIGxlZnQ+bGVmdCwgcmlnaHQ+cmlnaHRcIik7XG4gICAgbWFwKFwiTG9naWNhbEV4cHJlc3Npb25cIiwgQVNUX0JpbmFyeSwgXCJvcGVyYXRvcj1vcGVyYXRvciwgbGVmdD5sZWZ0LCByaWdodD5yaWdodFwiKTtcbiAgICBtYXAoXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCBBU1RfQXNzaWduLCBcIm9wZXJhdG9yPW9wZXJhdG9yLCBsZWZ0PmxlZnQsIHJpZ2h0PnJpZ2h0XCIpO1xuICAgIG1hcChcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCBBU1RfQ29uZGl0aW9uYWwsIFwidGVzdD5jb25kaXRpb24sIGNvbnNlcXVlbnQ+Y29uc2VxdWVudCwgYWx0ZXJuYXRlPmFsdGVybmF0aXZlXCIpO1xuICAgIG1hcChcIk5ld0V4cHJlc3Npb25cIiwgQVNUX05ldywgXCJjYWxsZWU+ZXhwcmVzc2lvbiwgYXJndW1lbnRzQGFyZ3NcIik7XG4gICAgbWFwKFwiQ2FsbEV4cHJlc3Npb25cIiwgQVNUX0NhbGwsIFwiY2FsbGVlPmV4cHJlc3Npb24sIG9wdGlvbmFsPW9wdGlvbmFsLCBhcmd1bWVudHNAYXJnc1wiKTtcblxuICAgIGRlZl90b19tb3ooQVNUX1RvcGxldmVsLCBmdW5jdGlvbiBUb19Nb3pfUHJvZ3JhbShNKSB7XG4gICAgICAgIHJldHVybiB0b19tb3pfc2NvcGUoXCJQcm9ncmFtXCIsIE0pO1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfRXhwYW5zaW9uLCBmdW5jdGlvbiBUb19Nb3pfU3ByZWFkKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHRvX21vel9pbl9kZXN0cnVjdHVyaW5nKCkgPyBcIlJlc3RFbGVtZW50XCIgOiBcIlNwcmVhZEVsZW1lbnRcIixcbiAgICAgICAgICAgIGFyZ3VtZW50OiB0b19tb3ooTS5leHByZXNzaW9uKVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZywgZnVuY3Rpb24gVG9fTW96X1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihNKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgdGFnOiB0b19tb3ooTS5wcmVmaXgpLFxuICAgICAgICAgICAgcXVhc2k6IHRvX21veihNLnRlbXBsYXRlX3N0cmluZylcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX1RlbXBsYXRlU3RyaW5nLCBmdW5jdGlvbiBUb19Nb3pfVGVtcGxhdGVMaXRlcmFsKE0pIHtcbiAgICAgICAgdmFyIHF1YXNpcyA9IFtdO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNLnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSAlIDIgIT09IDApIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHRvX21veihNLnNlZ21lbnRzW2ldKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1YXNpcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJUZW1wbGF0ZUVsZW1lbnRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdzogTS5zZWdtZW50c1tpXS5yYXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29rZWQ6IE0uc2VnbWVudHNbaV0udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdGFpbDogaSA9PT0gTS5zZWdtZW50cy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiVGVtcGxhdGVMaXRlcmFsXCIsXG4gICAgICAgICAgICBxdWFzaXM6IHF1YXNpcyxcbiAgICAgICAgICAgIGV4cHJlc3Npb25zOiBleHByZXNzaW9uc1xuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfRGVmdW4sIGZ1bmN0aW9uIFRvX01vel9GdW5jdGlvbkRlY2xhcmF0aW9uKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLFxuICAgICAgICAgICAgaWQ6IHRvX21veihNLm5hbWUpLFxuICAgICAgICAgICAgcGFyYW1zOiBNLmFyZ25hbWVzLm1hcCh0b19tb3opLFxuICAgICAgICAgICAgZ2VuZXJhdG9yOiBNLmlzX2dlbmVyYXRvcixcbiAgICAgICAgICAgIGFzeW5jOiBNLmFzeW5jLFxuICAgICAgICAgICAgYm9keTogdG9fbW96X3Njb3BlKFwiQmxvY2tTdGF0ZW1lbnRcIiwgTSlcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX0Z1bmN0aW9uLCBmdW5jdGlvbiBUb19Nb3pfRnVuY3Rpb25FeHByZXNzaW9uKE0sIHBhcmVudCkge1xuICAgICAgICB2YXIgaXNfZ2VuZXJhdG9yID0gcGFyZW50LmlzX2dlbmVyYXRvciAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIHBhcmVudC5pc19nZW5lcmF0b3IgOiBNLmlzX2dlbmVyYXRvcjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsXG4gICAgICAgICAgICBpZDogdG9fbW96KE0ubmFtZSksXG4gICAgICAgICAgICBwYXJhbXM6IE0uYXJnbmFtZXMubWFwKHRvX21veiksXG4gICAgICAgICAgICBnZW5lcmF0b3I6IGlzX2dlbmVyYXRvcixcbiAgICAgICAgICAgIGFzeW5jOiBNLmFzeW5jLFxuICAgICAgICAgICAgYm9keTogdG9fbW96X3Njb3BlKFwiQmxvY2tTdGF0ZW1lbnRcIiwgTSlcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX0Fycm93LCBmdW5jdGlvbiBUb19Nb3pfQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oTSkge1xuICAgICAgICB2YXIgYm9keSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiQmxvY2tTdGF0ZW1lbnRcIixcbiAgICAgICAgICAgIGJvZHk6IE0uYm9keS5tYXAodG9fbW96KVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgcGFyYW1zOiBNLmFyZ25hbWVzLm1hcCh0b19tb3opLFxuICAgICAgICAgICAgYXN5bmM6IE0uYXN5bmMsXG4gICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9EZXN0cnVjdHVyaW5nLCBmdW5jdGlvbiBUb19Nb3pfT2JqZWN0UGF0dGVybihNKSB7XG4gICAgICAgIGlmIChNLmlzX2FycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiQXJyYXlQYXR0ZXJuXCIsXG4gICAgICAgICAgICAgICAgZWxlbWVudHM6IE0ubmFtZXMubWFwKHRvX21veilcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiT2JqZWN0UGF0dGVyblwiLFxuICAgICAgICAgICAgcHJvcGVydGllczogTS5uYW1lcy5tYXAodG9fbW96KVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfRGlyZWN0aXZlLCBmdW5jdGlvbiBUb19Nb3pfRGlyZWN0aXZlKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiTGl0ZXJhbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBNLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJhdzogTS5wcmludF90b19zdHJpbmcoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpcmVjdGl2ZTogTS52YWx1ZVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfU2ltcGxlU3RhdGVtZW50LCBmdW5jdGlvbiBUb19Nb3pfRXhwcmVzc2lvblN0YXRlbWVudChNKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHRvX21veihNLmJvZHkpXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9Td2l0Y2hCcmFuY2gsIGZ1bmN0aW9uIFRvX01vel9Td2l0Y2hDYXNlKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiU3dpdGNoQ2FzZVwiLFxuICAgICAgICAgICAgdGVzdDogdG9fbW96KE0uZXhwcmVzc2lvbiksXG4gICAgICAgICAgICBjb25zZXF1ZW50OiBNLmJvZHkubWFwKHRvX21veilcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX1RyeSwgZnVuY3Rpb24gVG9fTW96X1RyeVN0YXRlbWVudChNKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlRyeVN0YXRlbWVudFwiLFxuICAgICAgICAgICAgYmxvY2s6IHRvX21vel9ibG9jayhNKSxcbiAgICAgICAgICAgIGhhbmRsZXI6IHRvX21veihNLmJjYXRjaCksXG4gICAgICAgICAgICBndWFyZGVkSGFuZGxlcnM6IFtdLFxuICAgICAgICAgICAgZmluYWxpemVyOiB0b19tb3ooTS5iZmluYWxseSlcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX0NhdGNoLCBmdW5jdGlvbiBUb19Nb3pfQ2F0Y2hDbGF1c2UoTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJDYXRjaENsYXVzZVwiLFxuICAgICAgICAgICAgcGFyYW06IHRvX21veihNLmFyZ25hbWUpLFxuICAgICAgICAgICAgZ3VhcmQ6IG51bGwsXG4gICAgICAgICAgICBib2R5OiB0b19tb3pfYmxvY2soTSlcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX0RlZmluaXRpb25zLCBmdW5jdGlvbiBUb19Nb3pfVmFyaWFibGVEZWNsYXJhdGlvbihNKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIixcbiAgICAgICAgICAgIGtpbmQ6XG4gICAgICAgICAgICAgICAgTSBpbnN0YW5jZW9mIEFTVF9Db25zdCA/IFwiY29uc3RcIiA6XG4gICAgICAgICAgICAgICAgTSBpbnN0YW5jZW9mIEFTVF9MZXQgPyBcImxldFwiIDogXCJ2YXJcIixcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogTS5kZWZpbml0aW9ucy5tYXAodG9fbW96KVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfRXhwb3J0LCBmdW5jdGlvbiBUb19Nb3pfRXhwb3J0RGVjbGFyYXRpb24oTSkge1xuICAgICAgICBpZiAoTS5leHBvcnRlZF9uYW1lcykge1xuICAgICAgICAgICAgaWYgKE0uZXhwb3J0ZWRfbmFtZXNbMF0ubmFtZS5uYW1lID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiB0b19tb3ooTS5tb2R1bGVfbmFtZSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIixcbiAgICAgICAgICAgICAgICBzcGVjaWZpZXJzOiBNLmV4cG9ydGVkX25hbWVzLm1hcChmdW5jdGlvbiAobmFtZV9tYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkV4cG9ydFNwZWNpZmllclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWQ6IHRvX21veihuYW1lX21hcHBpbmcuZm9yZWlnbl9uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsOiB0b19tb3oobmFtZV9tYXBwaW5nLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgZGVjbGFyYXRpb246IHRvX21veihNLmV4cG9ydGVkX2RlZmluaXRpb24pLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdG9fbW96KE0ubW9kdWxlX25hbWUpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBNLmlzX2RlZmF1bHQgPyBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiIDogXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIsXG4gICAgICAgICAgICBkZWNsYXJhdGlvbjogdG9fbW96KE0uZXhwb3J0ZWRfdmFsdWUgfHwgTS5leHBvcnRlZF9kZWZpbml0aW9uKVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfSW1wb3J0LCBmdW5jdGlvbiBUb19Nb3pfSW1wb3J0RGVjbGFyYXRpb24oTSkge1xuICAgICAgICB2YXIgc3BlY2lmaWVycyA9IFtdO1xuICAgICAgICBpZiAoTS5pbXBvcnRlZF9uYW1lKSB7XG4gICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiLFxuICAgICAgICAgICAgICAgIGxvY2FsOiB0b19tb3ooTS5pbXBvcnRlZF9uYW1lKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE0uaW1wb3J0ZWRfbmFtZXMgJiYgTS5pbXBvcnRlZF9uYW1lc1swXS5mb3JlaWduX25hbWUubmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIHNwZWNpZmllcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIixcbiAgICAgICAgICAgICAgICBsb2NhbDogdG9fbW96KE0uaW1wb3J0ZWRfbmFtZXNbMF0ubmFtZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKE0uaW1wb3J0ZWRfbmFtZXMpIHtcbiAgICAgICAgICAgIE0uaW1wb3J0ZWRfbmFtZXMuZm9yRWFjaChmdW5jdGlvbihuYW1lX21hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICBzcGVjaWZpZXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkltcG9ydFNwZWNpZmllclwiLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbDogdG9fbW96KG5hbWVfbWFwcGluZy5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWQ6IHRvX21veihuYW1lX21hcHBpbmcuZm9yZWlnbl9uYW1lKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiSW1wb3J0RGVjbGFyYXRpb25cIixcbiAgICAgICAgICAgIHNwZWNpZmllcnM6IHNwZWNpZmllcnMsXG4gICAgICAgICAgICBzb3VyY2U6IHRvX21veihNLm1vZHVsZV9uYW1lKVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfSW1wb3J0TWV0YSwgZnVuY3Rpb24gVG9fTW96X01ldGFQcm9wZXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiTWV0YVByb3BlcnR5XCIsXG4gICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJJZGVudGlmaWVyXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJpbXBvcnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJJZGVudGlmaWVyXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJtZXRhXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX1NlcXVlbmNlLCBmdW5jdGlvbiBUb19Nb3pfU2VxdWVuY2VFeHByZXNzaW9uKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsXG4gICAgICAgICAgICBleHByZXNzaW9uczogTS5leHByZXNzaW9ucy5tYXAodG9fbW96KVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfRG90SGFzaCwgZnVuY3Rpb24gVG9fTW96X1ByaXZhdGVNZW1iZXJFeHByZXNzaW9uKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiTWVtYmVyRXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgb2JqZWN0OiB0b19tb3ooTS5leHByZXNzaW9uKSxcbiAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHByb3BlcnR5OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJQcml2YXRlSWRlbnRpZmllclwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IE0ucHJvcGVydHlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcHRpb25hbDogTS5vcHRpb25hbFxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfUHJvcEFjY2VzcywgZnVuY3Rpb24gVG9fTW96X01lbWJlckV4cHJlc3Npb24oTSkge1xuICAgICAgICB2YXIgaXNDb21wdXRlZCA9IE0gaW5zdGFuY2VvZiBBU1RfU3ViO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJNZW1iZXJFeHByZXNzaW9uXCIsXG4gICAgICAgICAgICBvYmplY3Q6IHRvX21veihNLmV4cHJlc3Npb24pLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IGlzQ29tcHV0ZWQsXG4gICAgICAgICAgICBwcm9wZXJ0eTogaXNDb21wdXRlZCA/IHRvX21veihNLnByb3BlcnR5KSA6IHt0eXBlOiBcIklkZW50aWZpZXJcIiwgbmFtZTogTS5wcm9wZXJ0eX0sXG4gICAgICAgICAgICBvcHRpb25hbDogTS5vcHRpb25hbFxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfQ2hhaW4sIGZ1bmN0aW9uIFRvX01vel9DaGFpbkV4cHJlc3Npb24oTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJDaGFpbkV4cHJlc3Npb25cIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHRvX21veihNLmV4cHJlc3Npb24pXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9VbmFyeSwgZnVuY3Rpb24gVG9fTW96X1VuYXJ5KE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IE0ub3BlcmF0b3IgPT0gXCIrK1wiIHx8IE0ub3BlcmF0b3IgPT0gXCItLVwiID8gXCJVcGRhdGVFeHByZXNzaW9uXCIgOiBcIlVuYXJ5RXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgb3BlcmF0b3I6IE0ub3BlcmF0b3IsXG4gICAgICAgICAgICBwcmVmaXg6IE0gaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXgsXG4gICAgICAgICAgICBhcmd1bWVudDogdG9fbW96KE0uZXhwcmVzc2lvbilcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX0JpbmFyeSwgZnVuY3Rpb24gVG9fTW96X0JpbmFyeUV4cHJlc3Npb24oTSkge1xuICAgICAgICBpZiAoTS5vcGVyYXRvciA9PSBcIj1cIiAmJiB0b19tb3pfaW5fZGVzdHJ1Y3R1cmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiQXNzaWdubWVudFBhdHRlcm5cIixcbiAgICAgICAgICAgICAgICBsZWZ0OiB0b19tb3ooTS5sZWZ0KSxcbiAgICAgICAgICAgICAgICByaWdodDogdG9fbW96KE0ucmlnaHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZSA9IE0ub3BlcmF0b3IgPT0gXCImJlwiIHx8IE0ub3BlcmF0b3IgPT0gXCJ8fFwiIHx8IE0ub3BlcmF0b3IgPT09IFwiPz9cIlxuICAgICAgICAgICAgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCJcbiAgICAgICAgICAgIDogXCJCaW5hcnlFeHByZXNzaW9uXCI7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBsZWZ0OiB0b19tb3ooTS5sZWZ0KSxcbiAgICAgICAgICAgIG9wZXJhdG9yOiBNLm9wZXJhdG9yLFxuICAgICAgICAgICAgcmlnaHQ6IHRvX21veihNLnJpZ2h0KVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfQXJyYXksIGZ1bmN0aW9uIFRvX01vel9BcnJheUV4cHJlc3Npb24oTSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJBcnJheUV4cHJlc3Npb25cIixcbiAgICAgICAgICAgIGVsZW1lbnRzOiBNLmVsZW1lbnRzLm1hcCh0b19tb3opXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9PYmplY3QsIGZ1bmN0aW9uIFRvX01vel9PYmplY3RFeHByZXNzaW9uKE0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiT2JqZWN0RXhwcmVzc2lvblwiLFxuICAgICAgICAgICAgcHJvcGVydGllczogTS5wcm9wZXJ0aWVzLm1hcCh0b19tb3opXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9PYmplY3RQcm9wZXJ0eSwgZnVuY3Rpb24gVG9fTW96X1Byb3BlcnR5KE0sIHBhcmVudCkge1xuICAgICAgICB2YXIga2V5ID0gTS5rZXkgaW5zdGFuY2VvZiBBU1RfTm9kZSA/IHRvX21veihNLmtleSkgOiB7XG4gICAgICAgICAgICB0eXBlOiBcIklkZW50aWZpZXJcIixcbiAgICAgICAgICAgIHZhbHVlOiBNLmtleVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIE0ua2V5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBrZXkgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJMaXRlcmFsXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IE51bWJlcihNLmtleSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBNLmtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAga2V5ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiSWRlbnRpZmllclwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IE0ua2V5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBraW5kO1xuICAgICAgICB2YXIgc3RyaW5nX29yX251bSA9IHR5cGVvZiBNLmtleSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgTS5rZXkgPT09IFwibnVtYmVyXCI7XG4gICAgICAgIHZhciBjb21wdXRlZCA9IHN0cmluZ19vcl9udW0gPyBmYWxzZSA6ICEoTS5rZXkgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSB8fCBNLmtleSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWY7XG4gICAgICAgIGlmIChNIGluc3RhbmNlb2YgQVNUX09iamVjdEtleVZhbCkge1xuICAgICAgICAgICAga2luZCA9IFwiaW5pdFwiO1xuICAgICAgICAgICAgY29tcHV0ZWQgPSAhc3RyaW5nX29yX251bTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgIGlmIChNIGluc3RhbmNlb2YgQVNUX09iamVjdEdldHRlcikge1xuICAgICAgICAgICAga2luZCA9IFwiZ2V0XCI7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICBpZiAoTSBpbnN0YW5jZW9mIEFTVF9PYmplY3RTZXR0ZXIpIHtcbiAgICAgICAgICAgIGtpbmQgPSBcInNldFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNIGluc3RhbmNlb2YgQVNUX1ByaXZhdGVHZXR0ZXIgfHwgTSBpbnN0YW5jZW9mIEFTVF9Qcml2YXRlU2V0dGVyKSB7XG4gICAgICAgICAgICBjb25zdCBraW5kID0gTSBpbnN0YW5jZW9mIEFTVF9Qcml2YXRlR2V0dGVyID8gXCJnZXRcIiA6IFwic2V0XCI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiTWV0aG9kRGVmaW5pdGlvblwiLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAgICAgIHN0YXRpYzogTS5zdGF0aWMsXG4gICAgICAgICAgICAgICAga2V5OiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUHJpdmF0ZUlkZW50aWZpZXJcIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogTS5rZXkubmFtZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRvX21veihNLnZhbHVlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTSBpbnN0YW5jZW9mIEFTVF9DbGFzc1ByaXZhdGVQcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlByb3BlcnR5RGVmaW5pdGlvblwiLFxuICAgICAgICAgICAgICAgIGtleToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlByaXZhdGVJZGVudGlmaWVyXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IE0ua2V5Lm5hbWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0b19tb3ooTS52YWx1ZSksXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0YXRpYzogTS5zdGF0aWNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE0gaW5zdGFuY2VvZiBBU1RfQ2xhc3NQcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlByb3BlcnR5RGVmaW5pdGlvblwiLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdG9fbW96KE0udmFsdWUpLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkLFxuICAgICAgICAgICAgICAgIHN0YXRpYzogTS5zdGF0aWNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9DbGFzcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIk1ldGhvZERlZmluaXRpb25cIixcbiAgICAgICAgICAgICAgICBjb21wdXRlZDogY29tcHV0ZWQsXG4gICAgICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgICAgICBzdGF0aWM6IE0uc3RhdGljLFxuICAgICAgICAgICAgICAgIGtleTogdG9fbW96KE0ua2V5KSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdG9fbW96KE0udmFsdWUpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlByb3BlcnR5XCIsXG4gICAgICAgICAgICBjb21wdXRlZDogY29tcHV0ZWQsXG4gICAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdG9fbW96KE0udmFsdWUpXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9Db25jaXNlTWV0aG9kLCBmdW5jdGlvbiBUb19Nb3pfTWV0aG9kRGVmaW5pdGlvbihNLCBwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9PYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJQcm9wZXJ0eVwiLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkOiAhKE0ua2V5IGluc3RhbmNlb2YgQVNUX1N5bWJvbCkgfHwgTS5rZXkgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmLFxuICAgICAgICAgICAgICAgIGtpbmQ6IFwiaW5pdFwiLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaG9ydGhhbmQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGtleTogdG9fbW96KE0ua2V5KSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdG9fbW96KE0udmFsdWUpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qga2V5ID0gTSBpbnN0YW5jZW9mIEFTVF9Qcml2YXRlTWV0aG9kXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlByaXZhdGVJZGVudGlmaWVyXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogTS5rZXkubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB0b19tb3ooTS5rZXkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIk1ldGhvZERlZmluaXRpb25cIixcbiAgICAgICAgICAgIGtpbmQ6IE0ua2V5ID09PSBcImNvbnN0cnVjdG9yXCIgPyBcImNvbnN0cnVjdG9yXCIgOiBcIm1ldGhvZFwiLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHRvX21veihNLnZhbHVlKSxcbiAgICAgICAgICAgIGNvbXB1dGVkOiAhKE0ua2V5IGluc3RhbmNlb2YgQVNUX1N5bWJvbCkgfHwgTS5rZXkgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmLFxuICAgICAgICAgICAgc3RhdGljOiBNLnN0YXRpYyxcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIGRlZl90b19tb3ooQVNUX0NsYXNzLCBmdW5jdGlvbiBUb19Nb3pfQ2xhc3MoTSkge1xuICAgICAgICB2YXIgdHlwZSA9IE0gaW5zdGFuY2VvZiBBU1RfQ2xhc3NFeHByZXNzaW9uID8gXCJDbGFzc0V4cHJlc3Npb25cIiA6IFwiQ2xhc3NEZWNsYXJhdGlvblwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHN1cGVyQ2xhc3M6IHRvX21veihNLmV4dGVuZHMpLFxuICAgICAgICAgICAgaWQ6IE0ubmFtZSA/IHRvX21veihNLm5hbWUpIDogbnVsbCxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkNsYXNzQm9keVwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IE0ucHJvcGVydGllcy5tYXAodG9fbW96KVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfTmV3VGFyZ2V0LCBmdW5jdGlvbiBUb19Nb3pfTWV0YVByb3BlcnR5KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJNZXRhUHJvcGVydHlcIixcbiAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIklkZW50aWZpZXJcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm5ld1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvcGVydHk6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIklkZW50aWZpZXJcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcInRhcmdldFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9TeW1ib2wsIGZ1bmN0aW9uIFRvX01vel9JZGVudGlmaWVyKE0sIHBhcmVudCkge1xuICAgICAgICBpZiAoTSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xNZXRob2QgJiYgcGFyZW50LnF1b3RlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiTGl0ZXJhbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBNLm5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlZiA9IE0uZGVmaW5pdGlvbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJJZGVudGlmaWVyXCIsXG4gICAgICAgICAgICBuYW1lOiBkZWYgPyBkZWYubWFuZ2xlZF9uYW1lIHx8IGRlZi5uYW1lIDogTS5uYW1lXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9SZWdFeHAsIGZ1bmN0aW9uIFRvX01vel9SZWdFeHBMaXRlcmFsKE0pIHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IE0udmFsdWUuc291cmNlO1xuICAgICAgICBjb25zdCBmbGFncyA9IE0udmFsdWUuZmxhZ3M7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkxpdGVyYWxcIixcbiAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgcmF3OiBNLnByaW50X3RvX3N0cmluZygpLFxuICAgICAgICAgICAgcmVnZXg6IHsgcGF0dGVybiwgZmxhZ3MgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfQ29uc3RhbnQsIGZ1bmN0aW9uIFRvX01vel9MaXRlcmFsKE0pIHtcbiAgICAgICAgdmFyIHZhbHVlID0gTS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiTGl0ZXJhbFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcmF3OiBNLnJhdyB8fCBNLnByaW50X3RvX3N0cmluZygpXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBkZWZfdG9fbW96KEFTVF9BdG9tLCBmdW5jdGlvbiBUb19Nb3pfQXRvbShNKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIklkZW50aWZpZXJcIixcbiAgICAgICAgICAgIG5hbWU6IFN0cmluZyhNLnZhbHVlKVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgZGVmX3RvX21veihBU1RfQmlnSW50LCBNID0+ICh7XG4gICAgICAgIHR5cGU6IFwiQmlnSW50TGl0ZXJhbFwiLFxuICAgICAgICB2YWx1ZTogTS52YWx1ZVxuICAgIH0pKTtcblxuICAgIEFTVF9Cb29sZWFuLkRFRk1FVEhPRChcInRvX21vemlsbGFfYXN0XCIsIEFTVF9Db25zdGFudC5wcm90b3R5cGUudG9fbW96aWxsYV9hc3QpO1xuICAgIEFTVF9OdWxsLkRFRk1FVEhPRChcInRvX21vemlsbGFfYXN0XCIsIEFTVF9Db25zdGFudC5wcm90b3R5cGUudG9fbW96aWxsYV9hc3QpO1xuICAgIEFTVF9Ib2xlLkRFRk1FVEhPRChcInRvX21vemlsbGFfYXN0XCIsIGZ1bmN0aW9uIFRvX01vel9BcnJheUhvbGUoKSB7IHJldHVybiBudWxsOyB9KTtcblxuICAgIEFTVF9CbG9jay5ERUZNRVRIT0QoXCJ0b19tb3ppbGxhX2FzdFwiLCBBU1RfQmxvY2tTdGF0ZW1lbnQucHJvdG90eXBlLnRvX21vemlsbGFfYXN0KTtcbiAgICBBU1RfTGFtYmRhLkRFRk1FVEhPRChcInRvX21vemlsbGFfYXN0XCIsIEFTVF9GdW5jdGlvbi5wcm90b3R5cGUudG9fbW96aWxsYV9hc3QpO1xuXG4gICAgLyogLS0tLS1bIHRvb2xzIF0tLS0tLSAqL1xuXG4gICAgZnVuY3Rpb24gbXlfc3RhcnRfdG9rZW4obW96bm9kZSkge1xuICAgICAgICB2YXIgbG9jID0gbW96bm9kZS5sb2MsIHN0YXJ0ID0gbG9jICYmIGxvYy5zdGFydDtcbiAgICAgICAgdmFyIHJhbmdlID0gbW96bm9kZS5yYW5nZTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVG9rZW4oXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIHN0YXJ0ICYmIHN0YXJ0LmxpbmUgfHwgMCxcbiAgICAgICAgICAgIHN0YXJ0ICYmIHN0YXJ0LmNvbHVtbiB8fCAwLFxuICAgICAgICAgICAgcmFuZ2UgPyByYW5nZSBbMF0gOiBtb3pub2RlLnN0YXJ0LFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICBbXSxcbiAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgbG9jICYmIGxvYy5zb3VyY2UsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXlfZW5kX3Rva2VuKG1vem5vZGUpIHtcbiAgICAgICAgdmFyIGxvYyA9IG1vem5vZGUubG9jLCBlbmQgPSBsb2MgJiYgbG9jLmVuZDtcbiAgICAgICAgdmFyIHJhbmdlID0gbW96bm9kZS5yYW5nZTtcbiAgICAgICAgcmV0dXJuIG5ldyBBU1RfVG9rZW4oXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIGVuZCAmJiBlbmQubGluZSB8fCAwLFxuICAgICAgICAgICAgZW5kICYmIGVuZC5jb2x1bW4gfHwgMCxcbiAgICAgICAgICAgIHJhbmdlID8gcmFuZ2UgWzBdIDogbW96bm9kZS5lbmQsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgW10sXG4gICAgICAgICAgICBsb2MgJiYgbG9jLnNvdXJjZSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAobW96dHlwZSwgbXl0eXBlLCBwcm9wbWFwKSB7XG4gICAgICAgIHZhciBtb3pfdG9fbWUgPSBcImZ1bmN0aW9uIEZyb21fTW96X1wiICsgbW96dHlwZSArIFwiKE0pe1xcblwiO1xuICAgICAgICBtb3pfdG9fbWUgKz0gXCJyZXR1cm4gbmV3IFUyLlwiICsgbXl0eXBlLm5hbWUgKyBcIih7XFxuXCIgK1xuICAgICAgICAgICAgXCJzdGFydDogbXlfc3RhcnRfdG9rZW4oTSksXFxuXCIgK1xuICAgICAgICAgICAgXCJlbmQ6IG15X2VuZF90b2tlbihNKVwiO1xuXG4gICAgICAgIHZhciBtZV90b19tb3ogPSBcImZ1bmN0aW9uIFRvX01vel9cIiArIG1venR5cGUgKyBcIihNKXtcXG5cIjtcbiAgICAgICAgbWVfdG9fbW96ICs9IFwicmV0dXJuIHtcXG5cIiArXG4gICAgICAgICAgICBcInR5cGU6IFwiICsgSlNPTi5zdHJpbmdpZnkobW96dHlwZSk7XG5cbiAgICAgICAgaWYgKHByb3BtYXApIHByb3BtYXAuc3BsaXQoL1xccyosXFxzKi8pLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgdmFyIG0gPSAvKFthLXowLTkkX10rKShbPUA+JV0pKFthLXowLTkkX10rKS9pLmV4ZWMocHJvcCk7XG4gICAgICAgICAgICBpZiAoIW0pIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHVuZGVyc3RhbmQgcHJvcGVydHkgbWFwOiBcIiArIHByb3ApO1xuICAgICAgICAgICAgdmFyIG1veiA9IG1bMV0sIGhvdyA9IG1bMl0sIG15ID0gbVszXTtcbiAgICAgICAgICAgIG1vel90b19tZSArPSBcIixcXG5cIiArIG15ICsgXCI6IFwiO1xuICAgICAgICAgICAgbWVfdG9fbW96ICs9IFwiLFxcblwiICsgbW96ICsgXCI6IFwiO1xuICAgICAgICAgICAgc3dpdGNoIChob3cpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiQFwiOlxuICAgICAgICAgICAgICAgICAgICBtb3pfdG9fbWUgKz0gXCJNLlwiICsgbW96ICsgXCIubWFwKGZyb21fbW96KVwiO1xuICAgICAgICAgICAgICAgICAgICBtZV90b19tb3ogKz0gXCJNLlwiICsgIG15ICsgXCIubWFwKHRvX21veilcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgICAgICAgICAgbW96X3RvX21lICs9IFwiZnJvbV9tb3ooTS5cIiArIG1veiArIFwiKVwiO1xuICAgICAgICAgICAgICAgICAgICBtZV90b19tb3ogKz0gXCJ0b19tb3ooTS5cIiArIG15ICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgICAgICAgICAgIG1vel90b19tZSArPSBcIk0uXCIgKyBtb3o7XG4gICAgICAgICAgICAgICAgICAgIG1lX3RvX21veiArPSBcIk0uXCIgKyBteTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgICAgICAgICAgICAgbW96X3RvX21lICs9IFwiZnJvbV9tb3ooTS5cIiArIG1veiArIFwiKS5ib2R5XCI7XG4gICAgICAgICAgICAgICAgICAgIG1lX3RvX21veiArPSBcInRvX21vel9ibG9jayhNKVwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1bmRlcnN0YW5kIG9wZXJhdG9yIGluIHByb3BtYXA6IFwiICsgcHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vel90b19tZSArPSBcIlxcbn0pXFxufVwiO1xuICAgICAgICBtZV90b19tb3ogKz0gXCJcXG59XFxufVwiO1xuXG4gICAgICAgIG1vel90b19tZSA9IG5ldyBGdW5jdGlvbihcIlUyXCIsIFwibXlfc3RhcnRfdG9rZW5cIiwgXCJteV9lbmRfdG9rZW5cIiwgXCJmcm9tX21velwiLCBcInJldHVybihcIiArIG1vel90b19tZSArIFwiKVwiKShcbiAgICAgICAgICAgIGFzdCwgbXlfc3RhcnRfdG9rZW4sIG15X2VuZF90b2tlbiwgZnJvbV9tb3pcbiAgICAgICAgKTtcbiAgICAgICAgbWVfdG9fbW96ID0gbmV3IEZ1bmN0aW9uKFwidG9fbW96XCIsIFwidG9fbW96X2Jsb2NrXCIsIFwidG9fbW96X3Njb3BlXCIsIFwicmV0dXJuKFwiICsgbWVfdG9fbW96ICsgXCIpXCIpKFxuICAgICAgICAgICAgdG9fbW96LCB0b19tb3pfYmxvY2ssIHRvX21vel9zY29wZVxuICAgICAgICApO1xuICAgICAgICBNT1pfVE9fTUVbbW96dHlwZV0gPSBtb3pfdG9fbWU7XG4gICAgICAgIGRlZl90b19tb3oobXl0eXBlLCBtZV90b19tb3opO1xuICAgIH1cblxuICAgIHZhciBGUk9NX01PWl9TVEFDSyA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBmcm9tX21veihub2RlKSB7XG4gICAgICAgIEZST01fTU9aX1NUQUNLLnB1c2gobm9kZSk7XG4gICAgICAgIHZhciByZXQgPSBub2RlICE9IG51bGwgPyBNT1pfVE9fTUVbbm9kZS50eXBlXShub2RlKSA6IG51bGw7XG4gICAgICAgIEZST01fTU9aX1NUQUNLLnBvcCgpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIEFTVF9Ob2RlLmZyb21fbW96aWxsYV9hc3QgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBzYXZlX3N0YWNrID0gRlJPTV9NT1pfU1RBQ0s7XG4gICAgICAgIEZST01fTU9aX1NUQUNLID0gW107XG4gICAgICAgIHZhciBhc3QgPSBmcm9tX21veihub2RlKTtcbiAgICAgICAgRlJPTV9NT1pfU1RBQ0sgPSBzYXZlX3N0YWNrO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRfbW96X2xvYyhteW5vZGUsIG1vem5vZGUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbXlub2RlLnN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gbXlub2RlLmVuZDtcbiAgICAgICAgaWYgKCEoc3RhcnQgJiYgZW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vem5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0LnBvcyAhPSBudWxsICYmIGVuZC5lbmRwb3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgbW96bm9kZS5yYW5nZSA9IFtzdGFydC5wb3MsIGVuZC5lbmRwb3NdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydC5saW5lKSB7XG4gICAgICAgICAgICBtb3pub2RlLmxvYyA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDoge2xpbmU6IHN0YXJ0LmxpbmUsIGNvbHVtbjogc3RhcnQuY29sfSxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZC5lbmRsaW5lID8ge2xpbmU6IGVuZC5lbmRsaW5lLCBjb2x1bW46IGVuZC5lbmRjb2x9IDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzdGFydC5maWxlKSB7XG4gICAgICAgICAgICAgICAgbW96bm9kZS5sb2Muc291cmNlID0gc3RhcnQuZmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW96bm9kZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZfdG9fbW96KG15dHlwZSwgaGFuZGxlcikge1xuICAgICAgICBteXR5cGUuREVGTUVUSE9EKFwidG9fbW96aWxsYV9hc3RcIiwgZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0X21vel9sb2ModGhpcywgaGFuZGxlcih0aGlzLCBwYXJlbnQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIFRPX01PWl9TVEFDSyA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiB0b19tb3oobm9kZSkge1xuICAgICAgICBpZiAoVE9fTU9aX1NUQUNLID09PSBudWxsKSB7IFRPX01PWl9TVEFDSyA9IFtdOyB9XG4gICAgICAgIFRPX01PWl9TVEFDSy5wdXNoKG5vZGUpO1xuICAgICAgICB2YXIgYXN0ID0gbm9kZSAhPSBudWxsID8gbm9kZS50b19tb3ppbGxhX2FzdChUT19NT1pfU1RBQ0tbVE9fTU9aX1NUQUNLLmxlbmd0aCAtIDJdKSA6IG51bGw7XG4gICAgICAgIFRPX01PWl9TVEFDSy5wb3AoKTtcbiAgICAgICAgaWYgKFRPX01PWl9TVEFDSy5sZW5ndGggPT09IDApIHsgVE9fTU9aX1NUQUNLID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvX21vel9pbl9kZXN0cnVjdHVyaW5nKCkge1xuICAgICAgICB2YXIgaSA9IFRPX01PWl9TVEFDSy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmIChUT19NT1pfU1RBQ0tbaV0gaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b19tb3pfYmxvY2sobm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJCbG9ja1N0YXRlbWVudFwiLFxuICAgICAgICAgICAgYm9keTogbm9kZS5ib2R5Lm1hcCh0b19tb3opXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9fbW96X3Njb3BlKHR5cGUsIG5vZGUpIHtcbiAgICAgICAgdmFyIGJvZHkgPSBub2RlLmJvZHkubWFwKHRvX21veik7XG4gICAgICAgIGlmIChub2RlLmJvZHlbMF0gaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50ICYmIG5vZGUuYm9keVswXS5ib2R5IGluc3RhbmNlb2YgQVNUX1N0cmluZykge1xuICAgICAgICAgICAgYm9keS51bnNoaWZ0KHRvX21veihuZXcgQVNUX0VtcHR5U3RhdGVtZW50KG5vZGUuYm9keVswXSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgfTtcbiAgICB9XG59KSgpO1xuXG4vLyByZXR1cm4gdHJ1ZSBpZiB0aGUgbm9kZSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjayAodGhhdCBtZWFucyB0aGVcbi8vIGlubmVybW9zdCBub2RlIGluIHRoZSBjdXJyZW50IG91dHB1dCkgaXMgbGV4aWNhbGx5IHRoZSBmaXJzdCBpblxuLy8gYSBzdGF0ZW1lbnQuXG5mdW5jdGlvbiBmaXJzdF9pbl9zdGF0ZW1lbnQoc3RhY2spIHtcbiAgICBsZXQgbm9kZSA9IHN0YWNrLnBhcmVudCgtMSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHA7IHAgPSBzdGFjay5wYXJlbnQoaSk7IGkrKykge1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQgJiYgcC5ib2R5ID09PSBub2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICgocCBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSAmJiBwLmV4cHJlc3Npb25zWzBdID09PSBub2RlKSB8fFxuICAgICAgICAgICAgKHAuVFlQRSA9PT0gXCJDYWxsXCIgJiYgcC5leHByZXNzaW9uID09PSBub2RlKSB8fFxuICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZyAmJiBwLnByZWZpeCA9PT0gbm9kZSkgfHxcbiAgICAgICAgICAgIChwIGluc3RhbmNlb2YgQVNUX0RvdCAmJiBwLmV4cHJlc3Npb24gPT09IG5vZGUpIHx8XG4gICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9TdWIgJiYgcC5leHByZXNzaW9uID09PSBub2RlKSB8fFxuICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWwgJiYgcC5jb25kaXRpb24gPT09IG5vZGUpIHx8XG4gICAgICAgICAgICAocCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgcC5sZWZ0ID09PSBub2RlKSB8fFxuICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfVW5hcnlQb3N0Zml4ICYmIHAuZXhwcmVzc2lvbiA9PT0gbm9kZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBub2RlID0gcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gUmV0dXJucyB3aGV0aGVyIHRoZSBsZWZ0bW9zdCBpdGVtIGluIHRoZSBleHByZXNzaW9uIGlzIGFuIG9iamVjdFxuZnVuY3Rpb24gbGVmdF9pc19vYmplY3Qobm9kZSkge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX09iamVjdCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2UpIHJldHVybiBsZWZ0X2lzX29iamVjdChub2RlLmV4cHJlc3Npb25zWzBdKTtcbiAgICBpZiAobm9kZS5UWVBFID09PSBcIkNhbGxcIikgcmV0dXJuIGxlZnRfaXNfb2JqZWN0KG5vZGUuZXhwcmVzc2lvbik7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZykgcmV0dXJuIGxlZnRfaXNfb2JqZWN0KG5vZGUucHJlZml4KTtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Eb3QgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9TdWIpIHJldHVybiBsZWZ0X2lzX29iamVjdChub2RlLmV4cHJlc3Npb24pO1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsKSByZXR1cm4gbGVmdF9pc19vYmplY3Qobm9kZS5jb25kaXRpb24pO1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0JpbmFyeSkgcmV0dXJuIGxlZnRfaXNfb2JqZWN0KG5vZGUubGVmdCk7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVW5hcnlQb3N0Zml4KSByZXR1cm4gbGVmdF9pc19vYmplY3Qobm9kZS5leHByZXNzaW9uKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuY29uc3QgRVhQRUNUX0RJUkVDVElWRSA9IC9eJHxbO3tdW1xcc1xcbl0qJC87XG5jb25zdCBDT0RFX0xJTkVfQlJFQUsgPSAxMDtcbmNvbnN0IENPREVfU1BBQ0UgPSAzMjtcblxuY29uc3Qgcl9hbm5vdGF0aW9uID0gL1tAI11fXyhQVVJFfElOTElORXxOT0lOTElORSlfXy9nO1xuXG5mdW5jdGlvbiBpc19zb21lX2NvbW1lbnRzKGNvbW1lbnQpIHtcbiAgICAvLyBtdWx0aWxpbmUgY29tbWVudFxuICAgIHJldHVybiAoXG4gICAgICAgIChjb21tZW50LnR5cGUgPT09IFwiY29tbWVudDJcIiB8fCBjb21tZW50LnR5cGUgPT09IFwiY29tbWVudDFcIilcbiAgICAgICAgJiYgL0BwcmVzZXJ2ZXxAbGljfEBjY19vbnxeXFwqKiEvaS50ZXN0KGNvbW1lbnQudmFsdWUpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gT3V0cHV0U3RyZWFtKG9wdGlvbnMpIHtcblxuICAgIHZhciByZWFkb25seSA9ICFvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGFzY2lpX29ubHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGJlYXV0aWZ5ICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGJyYWNlcyAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGNvbW1lbnRzICAgICAgICAgICAgIDogXCJzb21lXCIsXG4gICAgICAgIGVjbWEgICAgICAgICAgICAgICAgIDogNSxcbiAgICAgICAgaWU4ICAgICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgaW5kZW50X2xldmVsICAgICAgICAgOiA0LFxuICAgICAgICBpbmRlbnRfc3RhcnQgICAgICAgICA6IDAsXG4gICAgICAgIGlubGluZV9zY3JpcHQgICAgICAgIDogdHJ1ZSxcbiAgICAgICAga2VlcF9udW1iZXJzICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAga2VlcF9xdW90ZWRfcHJvcHMgICAgOiBmYWxzZSxcbiAgICAgICAgbWF4X2xpbmVfbGVuICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgcHJlYW1ibGUgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICBwcmVzZXJ2ZV9hbm5vdGF0aW9ucyA6IGZhbHNlLFxuICAgICAgICBxdW90ZV9rZXlzICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBxdW90ZV9zdHlsZSAgICAgICAgICA6IDAsXG4gICAgICAgIHNhZmFyaTEwICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHNlbWljb2xvbnMgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgc2hlYmFuZyAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICBzaG9ydGhhbmQgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgc291cmNlX21hcCAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB3ZWJraXQgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICB3aWR0aCAgICAgICAgICAgICAgICA6IDgwLFxuICAgICAgICB3cmFwX2lpZmUgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICB3cmFwX2Z1bmNfYXJncyAgICAgICA6IHRydWUsXG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBpZiAob3B0aW9ucy5zaG9ydGhhbmQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgb3B0aW9ucy5zaG9ydGhhbmQgPSBvcHRpb25zLmVjbWEgPiA1O1xuXG4gICAgLy8gQ29udmVydCBjb21tZW50IG9wdGlvbiB0byBSZWdFeHAgaWYgbmVjY2Vzc2FyeSBhbmQgc2V0IHVwIGNvbW1lbnRzIGZpbHRlclxuICAgIHZhciBjb21tZW50X2ZpbHRlciA9IHJldHVybl9mYWxzZTsgLy8gRGVmYXVsdCBjYXNlLCB0aHJvdyBhbGwgY29tbWVudHMgYXdheVxuICAgIGlmIChvcHRpb25zLmNvbW1lbnRzKSB7XG4gICAgICAgIGxldCBjb21tZW50cyA9IG9wdGlvbnMuY29tbWVudHM7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb21tZW50cyA9PT0gXCJzdHJpbmdcIiAmJiAvXlxcLy4qXFwvW2EtekEtWl0qJC8udGVzdChvcHRpb25zLmNvbW1lbnRzKSkge1xuICAgICAgICAgICAgdmFyIHJlZ2V4X3BvcyA9IG9wdGlvbnMuY29tbWVudHMubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgICAgICAgY29tbWVudHMgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudHMuc3Vic3RyKDEsIHJlZ2V4X3BvcyAtIDEpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudHMuc3Vic3RyKHJlZ2V4X3BvcyArIDEpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tZW50cyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgY29tbWVudF9maWx0ZXIgPSBmdW5jdGlvbihjb21tZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnQudHlwZSAhPSBcImNvbW1lbnQ1XCIgJiYgY29tbWVudHMudGVzdChjb21tZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbW1lbnRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbW1lbnRfZmlsdGVyID0gZnVuY3Rpb24oY29tbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tZW50LnR5cGUgIT0gXCJjb21tZW50NVwiICYmIGNvbW1lbnRzKHRoaXMsIGNvbW1lbnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChjb21tZW50cyA9PT0gXCJzb21lXCIpIHtcbiAgICAgICAgICAgIGNvbW1lbnRfZmlsdGVyID0gaXNfc29tZV9jb21tZW50cztcbiAgICAgICAgfSBlbHNlIHsgLy8gTk9URSBpbmNsdWRlcyBcImFsbFwiIG9wdGlvblxuICAgICAgICAgICAgY29tbWVudF9maWx0ZXIgPSByZXR1cm5fdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpbmRlbnRhdGlvbiA9IDA7XG4gICAgdmFyIGN1cnJlbnRfY29sID0gMDtcbiAgICB2YXIgY3VycmVudF9saW5lID0gMTtcbiAgICB2YXIgY3VycmVudF9wb3MgPSAwO1xuICAgIHZhciBPVVRQVVQgPSBcIlwiO1xuICAgIGxldCBwcmludGVkX2NvbW1lbnRzID0gbmV3IFNldCgpO1xuXG4gICAgdmFyIHRvX3V0ZjggPSBvcHRpb25zLmFzY2lpX29ubHkgPyBmdW5jdGlvbihzdHIsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZWNtYSA+PSAyMDE1ICYmICFvcHRpb25zLnNhZmFyaTEwKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvW1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gZ2V0X2Z1bGxfY2hhcl9jb2RlKGNoLCAwKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXFxcXHV7XCIgKyBjb2RlICsgXCJ9XCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHUwMDAwLVxcdTAwMWZcXHUwMDdmLVxcdWZmZmZdL2csIGZ1bmN0aW9uKGNoKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKGNvZGUubGVuZ3RoIDw9IDIgJiYgIWlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29kZS5sZW5ndGggPCAyKSBjb2RlID0gXCIwXCIgKyBjb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFx4XCIgKyBjb2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29kZS5sZW5ndGggPCA0KSBjb2RlID0gXCIwXCIgKyBjb2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1XCIgKyBjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IDogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXXwoW1xcdWQ4MDAtXFx1ZGJmZl18W1xcdWRjMDAtXFx1ZGZmZl0pL2csIGZ1bmN0aW9uKG1hdGNoLCBsb25lKSB7XG4gICAgICAgICAgICBpZiAobG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlxcXFx1XCIgKyBsb25lLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbWFrZV9zdHJpbmcoc3RyLCBxdW90ZSkge1xuICAgICAgICB2YXIgZHEgPSAwLCBzcSA9IDA7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9bXFxcXFxcYlxcZlxcblxcclxcdlxcdFxceDIyXFx4MjdcXHUyMDI4XFx1MjAyOVxcMFxcdWZlZmZdL2csXG4gICAgICAgICAgZnVuY3Rpb24ocywgaSkge1xuICAgICAgICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ1wiJzogKytkcTsgcmV0dXJuICdcIic7XG4gICAgICAgICAgICAgIGNhc2UgXCInXCI6ICsrc3E7IHJldHVybiBcIidcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjogcmV0dXJuIFwiXFxcXFxcXFxcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcblwiOiByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFxyXCI6IHJldHVybiBcIlxcXFxyXCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHRcIjogcmV0dXJuIFwiXFxcXHRcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcYlwiOiByZXR1cm4gXCJcXFxcYlwiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFxmXCI6IHJldHVybiBcIlxcXFxmXCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHgwQlwiOiByZXR1cm4gb3B0aW9ucy5pZTggPyBcIlxcXFx4MEJcIiA6IFwiXFxcXHZcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjogcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG4gICAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6IHJldHVybiBcIlxcXFx1MjAyOVwiO1xuICAgICAgICAgICAgICBjYXNlIFwiXFx1ZmVmZlwiOiByZXR1cm4gXCJcXFxcdWZlZmZcIjtcbiAgICAgICAgICAgICAgY2FzZSBcIlxcMFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIC9bMC05XS8udGVzdChnZXRfZnVsbF9jaGFyKHN0ciwgaSsxKSkgPyBcIlxcXFx4MDBcIiA6IFwiXFxcXDBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gcXVvdGVfc2luZ2xlKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiJ1wiICsgc3RyLnJlcGxhY2UoL1xceDI3L2csIFwiXFxcXCdcIikgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBxdW90ZV9kb3VibGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1wiJyArIHN0ci5yZXBsYWNlKC9cXHgyMi9nLCAnXFxcXFwiJykgKyAnXCInO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHF1b3RlX3RlbXBsYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiYFwiICsgc3RyLnJlcGxhY2UoL2AvZywgXCJcXFxcYFwiKSArIFwiYFwiO1xuICAgICAgICB9XG4gICAgICAgIHN0ciA9IHRvX3V0Zjgoc3RyKTtcbiAgICAgICAgaWYgKHF1b3RlID09PSBcImBcIikgcmV0dXJuIHF1b3RlX3RlbXBsYXRlKCk7XG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5xdW90ZV9zdHlsZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZV9zaW5nbGUoKTtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gcXVvdGVfZG91YmxlKCk7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlID09IFwiJ1wiID8gcXVvdGVfc2luZ2xlKCkgOiBxdW90ZV9kb3VibGUoKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGRxID4gc3EgPyBxdW90ZV9zaW5nbGUoKSA6IHF1b3RlX2RvdWJsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5jb2RlX3N0cmluZyhzdHIsIHF1b3RlKSB7XG4gICAgICAgIHZhciByZXQgPSBtYWtlX3N0cmluZyhzdHIsIHF1b3RlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5saW5lX3NjcmlwdCkge1xuICAgICAgICAgICAgcmV0ID0gcmV0LnJlcGxhY2UoLzxcXHgyZihzY3JpcHQpKFs+XFwvXFx0XFxuXFxmXFxyIF0pL2dpLCBcIjxcXFxcLyQxJDJcIik7XG4gICAgICAgICAgICByZXQgPSByZXQucmVwbGFjZSgvXFx4M2MhLS0vZywgXCJcXFxceDNjIS0tXCIpO1xuICAgICAgICAgICAgcmV0ID0gcmV0LnJlcGxhY2UoLy0tXFx4M2UvZywgXCItLVxcXFx4M2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlX25hbWUobmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b1N0cmluZygpO1xuICAgICAgICBuYW1lID0gdG9fdXRmOChuYW1lLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZV9pbmRlbnQoYmFjaykge1xuICAgICAgICByZXR1cm4gXCIgXCIucmVwZWF0KG9wdGlvbnMuaW5kZW50X3N0YXJ0ICsgaW5kZW50YXRpb24gLSBiYWNrICogb3B0aW9ucy5pbmRlbnRfbGV2ZWwpO1xuICAgIH1cblxuICAgIC8qIC0tLS0tWyBiZWF1dGlmaWNhdGlvbi9taW5pZmljYXRpb24gXS0tLS0tICovXG5cbiAgICB2YXIgaGFzX3BhcmVucyA9IGZhbHNlO1xuICAgIHZhciBtaWdodF9uZWVkX3NwYWNlID0gZmFsc2U7XG4gICAgdmFyIG1pZ2h0X25lZWRfc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgdmFyIG1pZ2h0X2FkZF9uZXdsaW5lID0gMDtcbiAgICB2YXIgbmVlZF9uZXdsaW5lX2luZGVudGVkID0gZmFsc2U7XG4gICAgdmFyIG5lZWRfc3BhY2UgPSBmYWxzZTtcbiAgICB2YXIgbmV3bGluZV9pbnNlcnQgPSAtMTtcbiAgICB2YXIgbGFzdCA9IFwiXCI7XG4gICAgdmFyIG1hcHBpbmdfdG9rZW4sIG1hcHBpbmdfbmFtZSwgbWFwcGluZ3MgPSBvcHRpb25zLnNvdXJjZV9tYXAgJiYgW107XG5cbiAgICB2YXIgZG9fYWRkX21hcHBpbmcgPSBtYXBwaW5ncyA/IGZ1bmN0aW9uKCkge1xuICAgICAgICBtYXBwaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKG1hcHBpbmcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSAhbWFwcGluZy5uYW1lICYmIG1hcHBpbmcudG9rZW4udHlwZSA9PSBcIm5hbWVcIiA/IG1hcHBpbmcudG9rZW4udmFsdWUgOiBtYXBwaW5nLm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc291cmNlX21hcC5hZGQoXG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcudG9rZW4uZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5saW5lLCBtYXBwaW5nLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy50b2tlbi5saW5lLCBtYXBwaW5nLnRva2VuLmNvbCxcbiAgICAgICAgICAgICAgICAgICAgaXNfYmFzaWNfaWRlbnRpZmllcl9zdHJpbmcobmFtZSkgPyBuYW1lIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgYmFkIG1hcHBpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1hcHBpbmdzID0gW107XG4gICAgfSA6IG5vb3A7XG5cbiAgICB2YXIgZW5zdXJlX2xpbmVfbGVuID0gb3B0aW9ucy5tYXhfbGluZV9sZW4gPyBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRfY29sID4gb3B0aW9ucy5tYXhfbGluZV9sZW4pIHtcbiAgICAgICAgICAgIGlmIChtaWdodF9hZGRfbmV3bGluZSkge1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gT1VUUFVULnNsaWNlKDAsIG1pZ2h0X2FkZF9uZXdsaW5lKTtcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSBPVVRQVVQuc2xpY2UobWlnaHRfYWRkX25ld2xpbmUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBwaW5ncykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSByaWdodC5sZW5ndGggLSBjdXJyZW50X2NvbDtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZ3MuZm9yRWFjaChmdW5jdGlvbihtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmxpbmUrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuY29sICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT1VUUFVUID0gbGVmdCArIFwiXFxuXCIgKyByaWdodDtcbiAgICAgICAgICAgICAgICBjdXJyZW50X2xpbmUrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50X3BvcysrO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfY29sID0gcmlnaHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaWdodF9hZGRfbmV3bGluZSkge1xuICAgICAgICAgICAgbWlnaHRfYWRkX25ld2xpbmUgPSAwO1xuICAgICAgICAgICAgZG9fYWRkX21hcHBpbmcoKTtcbiAgICAgICAgfVxuICAgIH0gOiBub29wO1xuXG4gICAgdmFyIHJlcXVpcmVTZW1pY29sb25DaGFycyA9IG1ha2VQcmVkaWNhdGUoXCIoIFsgKyAqIC8gLSAsIC4gYFwiKTtcblxuICAgIGZ1bmN0aW9uIHByaW50KHN0cikge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgdmFyIGNoID0gZ2V0X2Z1bGxfY2hhcihzdHIsIDApO1xuICAgICAgICBpZiAobmVlZF9uZXdsaW5lX2luZGVudGVkICYmIGNoKSB7XG4gICAgICAgICAgICBuZWVkX25ld2xpbmVfaW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjaCAhPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIHByaW50KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIGluZGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkX3NwYWNlICYmIGNoKSB7XG4gICAgICAgICAgICBuZWVkX3NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIS9bXFxzO30pXS8udGVzdChjaCkpIHtcbiAgICAgICAgICAgICAgICBzcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld2xpbmVfaW5zZXJ0ID0gLTE7XG4gICAgICAgIHZhciBwcmV2ID0gbGFzdC5jaGFyQXQobGFzdC5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKG1pZ2h0X25lZWRfc2VtaWNvbG9uKSB7XG4gICAgICAgICAgICBtaWdodF9uZWVkX3NlbWljb2xvbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAocHJldiA9PT0gXCI6XCIgJiYgY2ggPT09IFwifVwiIHx8ICghY2ggfHwgIVwiO31cIi5pbmNsdWRlcyhjaCkpICYmIHByZXYgIT09IFwiO1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2VtaWNvbG9ucyB8fCByZXF1aXJlU2VtaWNvbG9uQ2hhcnMuaGFzKGNoKSkge1xuICAgICAgICAgICAgICAgICAgICBPVVRQVVQgKz0gXCI7XCI7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfY29sKys7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfcG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5zdXJlX2xpbmVfbGVuKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50X2NvbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9VVFBVVCArPSBcIlxcblwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9wb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfbGluZSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9jb2wgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eXFxzKyQvLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIHNlbWljb2xvbiBmbGFnLCBzaW5jZSB3ZSBkaWRuJ3QgcHJpbnQgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3cgYW5kIG1pZ2h0IHN0aWxsIGhhdmUgdG8gbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZ2h0X25lZWRfc2VtaWNvbG9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5iZWF1dGlmeSlcbiAgICAgICAgICAgICAgICAgICAgbWlnaHRfbmVlZF9zcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pZ2h0X25lZWRfc3BhY2UpIHtcbiAgICAgICAgICAgIGlmICgoaXNfaWRlbnRpZmllcl9jaGFyKHByZXYpXG4gICAgICAgICAgICAgICAgICAgICYmIChpc19pZGVudGlmaWVyX2NoYXIoY2gpIHx8IGNoID09IFwiXFxcXFwiKSlcbiAgICAgICAgICAgICAgICB8fCAoY2ggPT0gXCIvXCIgJiYgY2ggPT0gcHJldilcbiAgICAgICAgICAgICAgICB8fCAoKGNoID09IFwiK1wiIHx8IGNoID09IFwiLVwiKSAmJiBjaCA9PSBsYXN0KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgT1VUUFVUICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfY29sKys7XG4gICAgICAgICAgICAgICAgY3VycmVudF9wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pZ2h0X25lZWRfc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXBwaW5nX3Rva2VuKSB7XG4gICAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0b2tlbjogbWFwcGluZ190b2tlbixcbiAgICAgICAgICAgICAgICBuYW1lOiBtYXBwaW5nX25hbWUsXG4gICAgICAgICAgICAgICAgbGluZTogY3VycmVudF9saW5lLFxuICAgICAgICAgICAgICAgIGNvbDogY3VycmVudF9jb2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWFwcGluZ190b2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFtaWdodF9hZGRfbmV3bGluZSkgZG9fYWRkX21hcHBpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9VVFBVVCArPSBzdHI7XG4gICAgICAgIGhhc19wYXJlbnMgPSBzdHJbc3RyLmxlbmd0aCAtIDFdID09IFwiKFwiO1xuICAgICAgICBjdXJyZW50X3BvcyArPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgYSA9IHN0ci5zcGxpdCgvXFxyP1xcbi8pLCBuID0gYS5sZW5ndGggLSAxO1xuICAgICAgICBjdXJyZW50X2xpbmUgKz0gbjtcbiAgICAgICAgY3VycmVudF9jb2wgKz0gYVswXS5sZW5ndGg7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgZW5zdXJlX2xpbmVfbGVuKCk7XG4gICAgICAgICAgICBjdXJyZW50X2NvbCA9IGFbbl0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QgPSBzdHI7XG4gICAgfVxuXG4gICAgdmFyIHN0YXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJpbnQoXCIqXCIpO1xuICAgIH07XG5cbiAgICB2YXIgc3BhY2UgPSBvcHRpb25zLmJlYXV0aWZ5ID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByaW50KFwiIFwiKTtcbiAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgIG1pZ2h0X25lZWRfc3BhY2UgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgaW5kZW50ID0gb3B0aW9ucy5iZWF1dGlmeSA/IGZ1bmN0aW9uKGhhbGYpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYmVhdXRpZnkpIHtcbiAgICAgICAgICAgIHByaW50KG1ha2VfaW5kZW50KGhhbGYgPyAwLjUgOiAwKSk7XG4gICAgICAgIH1cbiAgICB9IDogbm9vcDtcblxuICAgIHZhciB3aXRoX2luZGVudCA9IG9wdGlvbnMuYmVhdXRpZnkgPyBmdW5jdGlvbihjb2wsIGNvbnQpIHtcbiAgICAgICAgaWYgKGNvbCA9PT0gdHJ1ZSkgY29sID0gbmV4dF9pbmRlbnQoKTtcbiAgICAgICAgdmFyIHNhdmVfaW5kZW50YXRpb24gPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgaW5kZW50YXRpb24gPSBjb2w7XG4gICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgIGluZGVudGF0aW9uID0gc2F2ZV9pbmRlbnRhdGlvbjtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9IDogZnVuY3Rpb24oY29sLCBjb250KSB7IHJldHVybiBjb250KCk7IH07XG5cbiAgICB2YXIgbmV3bGluZSA9IG9wdGlvbnMuYmVhdXRpZnkgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG5ld2xpbmVfaW5zZXJ0IDwgMCkgcmV0dXJuIHByaW50KFwiXFxuXCIpO1xuICAgICAgICBpZiAoT1VUUFVUW25ld2xpbmVfaW5zZXJ0XSAhPSBcIlxcblwiKSB7XG4gICAgICAgICAgICBPVVRQVVQgPSBPVVRQVVQuc2xpY2UoMCwgbmV3bGluZV9pbnNlcnQpICsgXCJcXG5cIiArIE9VVFBVVC5zbGljZShuZXdsaW5lX2luc2VydCk7XG4gICAgICAgICAgICBjdXJyZW50X3BvcysrO1xuICAgICAgICAgICAgY3VycmVudF9saW5lKys7XG4gICAgICAgIH1cbiAgICAgICAgbmV3bGluZV9pbnNlcnQrKztcbiAgICB9IDogb3B0aW9ucy5tYXhfbGluZV9sZW4gPyBmdW5jdGlvbigpIHtcbiAgICAgICAgZW5zdXJlX2xpbmVfbGVuKCk7XG4gICAgICAgIG1pZ2h0X2FkZF9uZXdsaW5lID0gT1VUUFVULmxlbmd0aDtcbiAgICB9IDogbm9vcDtcblxuICAgIHZhciBzZW1pY29sb24gPSBvcHRpb25zLmJlYXV0aWZ5ID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByaW50KFwiO1wiKTtcbiAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgIG1pZ2h0X25lZWRfc2VtaWNvbG9uID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZm9yY2Vfc2VtaWNvbG9uKCkge1xuICAgICAgICBtaWdodF9uZWVkX3NlbWljb2xvbiA9IGZhbHNlO1xuICAgICAgICBwcmludChcIjtcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbmV4dF9pbmRlbnQoKSB7XG4gICAgICAgIHJldHVybiBpbmRlbnRhdGlvbiArIG9wdGlvbnMuaW5kZW50X2xldmVsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpdGhfYmxvY2soY29udCkge1xuICAgICAgICB2YXIgcmV0O1xuICAgICAgICBwcmludChcIntcIik7XG4gICAgICAgIG5ld2xpbmUoKTtcbiAgICAgICAgd2l0aF9pbmRlbnQobmV4dF9pbmRlbnQoKSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXQgPSBjb250KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbmRlbnQoKTtcbiAgICAgICAgcHJpbnQoXCJ9XCIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpdGhfcGFyZW5zKGNvbnQpIHtcbiAgICAgICAgcHJpbnQoXCIoXCIpO1xuICAgICAgICAvL1hYWDogc3RpbGwgbmljZSB0byBoYXZlIHRoYXQgZm9yIGFyZ3VtZW50IGxpc3RzXG4gICAgICAgIC8vdmFyIHJldCA9IHdpdGhfaW5kZW50KGN1cnJlbnRfY29sLCBjb250KTtcbiAgICAgICAgdmFyIHJldCA9IGNvbnQoKTtcbiAgICAgICAgcHJpbnQoXCIpXCIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdpdGhfc3F1YXJlKGNvbnQpIHtcbiAgICAgICAgcHJpbnQoXCJbXCIpO1xuICAgICAgICAvL3ZhciByZXQgPSB3aXRoX2luZGVudChjdXJyZW50X2NvbCwgY29udCk7XG4gICAgICAgIHZhciByZXQgPSBjb250KCk7XG4gICAgICAgIHByaW50KFwiXVwiKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21tYSgpIHtcbiAgICAgICAgcHJpbnQoXCIsXCIpO1xuICAgICAgICBzcGFjZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbG9uKCkge1xuICAgICAgICBwcmludChcIjpcIik7XG4gICAgICAgIHNwYWNlKCk7XG4gICAgfVxuXG4gICAgdmFyIGFkZF9tYXBwaW5nID0gbWFwcGluZ3MgPyBmdW5jdGlvbih0b2tlbiwgbmFtZSkge1xuICAgICAgICBtYXBwaW5nX3Rva2VuID0gdG9rZW47XG4gICAgICAgIG1hcHBpbmdfbmFtZSA9IG5hbWU7XG4gICAgfSA6IG5vb3A7XG5cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmIChtaWdodF9hZGRfbmV3bGluZSkge1xuICAgICAgICAgICAgZW5zdXJlX2xpbmVfbGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9VVFBVVDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNfbmxiKCkge1xuICAgICAgICBsZXQgbiA9IE9VVFBVVC5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAobiA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gT1VUUFVULmNoYXJDb2RlQXQobik7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ09ERV9MSU5FX0JSRUFLKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb2RlICE9PSBDT0RFX1NQQUNFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbHRlcl9jb21tZW50KGNvbW1lbnQpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnByZXNlcnZlX2Fubm90YXRpb25zKSB7XG4gICAgICAgICAgICBjb21tZW50ID0gY29tbWVudC5yZXBsYWNlKHJfYW5ub3RhdGlvbiwgXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXlxccyokLy50ZXN0KGNvbW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWVudC5yZXBsYWNlKC8oPFxccypcXC9cXHMqKShzY3JpcHQpL2ksIFwiPFxcXFwvJDJcIik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGVuZF9jb21tZW50cyhub2RlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXJ0ID0gbm9kZS5zdGFydDtcbiAgICAgICAgaWYgKCFzdGFydCkgcmV0dXJuO1xuICAgICAgICB2YXIgcHJpbnRlZF9jb21tZW50cyA9IHNlbGYucHJpbnRlZF9jb21tZW50cztcblxuICAgICAgICAvLyBUaGVyZSBjYW5ub3QgYmUgYSBuZXdsaW5lIGJldHdlZW4gcmV0dXJuIGFuZCBpdHMgdmFsdWUuXG4gICAgICAgIGNvbnN0IHJldHVybl93aXRoX3ZhbHVlID0gbm9kZSBpbnN0YW5jZW9mIEFTVF9FeGl0ICYmIG5vZGUudmFsdWU7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgc3RhcnQuY29tbWVudHNfYmVmb3JlXG4gICAgICAgICAgICAmJiBwcmludGVkX2NvbW1lbnRzLmhhcyhzdGFydC5jb21tZW50c19iZWZvcmUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKHJldHVybl93aXRoX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQuY29tbWVudHNfYmVmb3JlID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21tZW50cyA9IHN0YXJ0LmNvbW1lbnRzX2JlZm9yZTtcbiAgICAgICAgaWYgKCFjb21tZW50cykge1xuICAgICAgICAgICAgY29tbWVudHMgPSBzdGFydC5jb21tZW50c19iZWZvcmUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBwcmludGVkX2NvbW1lbnRzLmFkZChjb21tZW50cyk7XG5cbiAgICAgICAgaWYgKHJldHVybl93aXRoX3ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHR3LnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfRXhpdFxuICAgICAgICAgICAgICAgICAgICB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIHBhcmVudC5sZWZ0ID09PSBub2RlXG4gICAgICAgICAgICAgICAgICAgIHx8IHBhcmVudC5UWVBFID09IFwiQ2FsbFwiICYmIHBhcmVudC5leHByZXNzaW9uID09PSBub2RlXG4gICAgICAgICAgICAgICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAmJiBwYXJlbnQuY29uZGl0aW9uID09PSBub2RlXG4gICAgICAgICAgICAgICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Eb3QgJiYgcGFyZW50LmV4cHJlc3Npb24gPT09IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlICYmIHBhcmVudC5leHByZXNzaW9uc1swXSA9PT0gbm9kZVxuICAgICAgICAgICAgICAgICAgICB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfU3ViICYmIHBhcmVudC5leHByZXNzaW9uID09PSBub2RlXG4gICAgICAgICAgICAgICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9VbmFyeVBvc3RmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnN0YXJ0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gbm9kZS5zdGFydC5jb21tZW50c19iZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0ICYmICFwcmludGVkX2NvbW1lbnRzLmhhcyh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbnRlZF9jb21tZW50cy5hZGQodGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50cyA9IGNvbW1lbnRzLmNvbmNhdCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHcucHVzaChub2RlKTtcbiAgICAgICAgICAgIG5vZGUudmFsdWUud2Fsayh0dyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudF9wb3MgPT0gMCkge1xuICAgICAgICAgICAgaWYgKGNvbW1lbnRzLmxlbmd0aCA+IDAgJiYgb3B0aW9ucy5zaGViYW5nICYmIGNvbW1lbnRzWzBdLnR5cGUgPT09IFwiY29tbWVudDVcIlxuICAgICAgICAgICAgICAgICYmICFwcmludGVkX2NvbW1lbnRzLmhhcyhjb21tZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICBwcmludChcIiMhXCIgKyBjb21tZW50cy5zaGlmdCgpLnZhbHVlICsgXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgaW5kZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJlYW1ibGUgPSBvcHRpb25zLnByZWFtYmxlO1xuICAgICAgICAgICAgaWYgKHByZWFtYmxlKSB7XG4gICAgICAgICAgICAgICAgcHJpbnQocHJlYW1ibGUucmVwbGFjZSgvXFxyXFxuP3xbXFxuXFx1MjAyOFxcdTIwMjldfFxccyokL2csIFwiXFxuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbW1lbnRzID0gY29tbWVudHMuZmlsdGVyKGNvbW1lbnRfZmlsdGVyLCBub2RlKS5maWx0ZXIoYyA9PiAhcHJpbnRlZF9jb21tZW50cy5oYXMoYykpO1xuICAgICAgICBpZiAoY29tbWVudHMubGVuZ3RoID09IDApIHJldHVybjtcbiAgICAgICAgdmFyIGxhc3RfbmxiID0gaGFzX25sYigpO1xuICAgICAgICBjb21tZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGMsIGkpIHtcbiAgICAgICAgICAgIHByaW50ZWRfY29tbWVudHMuYWRkKGMpO1xuICAgICAgICAgICAgaWYgKCFsYXN0X25sYikge1xuICAgICAgICAgICAgICAgIGlmIChjLm5sYikge1xuICAgICAgICAgICAgICAgICAgICBwcmludChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RfbmxiID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoL2NvbW1lbnRbMTM0XS8udGVzdChjLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZmlsdGVyX2NvbW1lbnQoYy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW50KFwiLy9cIiArIHZhbHVlICsgXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0X25sYiA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMudHlwZSA9PSBcImNvbW1lbnQyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBmaWx0ZXJfY29tbWVudChjLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnQoXCIvKlwiICsgdmFsdWUgKyBcIiovXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0X25sYiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFsYXN0X25sYikge1xuICAgICAgICAgICAgaWYgKHN0YXJ0Lm5sYikge1xuICAgICAgICAgICAgICAgIHByaW50KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIGluZGVudCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kX2NvbW1lbnRzKG5vZGUsIHRhaWwpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgdG9rZW4gPSBub2RlLmVuZDtcbiAgICAgICAgaWYgKCF0b2tlbikgcmV0dXJuO1xuICAgICAgICB2YXIgcHJpbnRlZF9jb21tZW50cyA9IHNlbGYucHJpbnRlZF9jb21tZW50cztcbiAgICAgICAgdmFyIGNvbW1lbnRzID0gdG9rZW5bdGFpbCA/IFwiY29tbWVudHNfYmVmb3JlXCIgOiBcImNvbW1lbnRzX2FmdGVyXCJdO1xuICAgICAgICBpZiAoIWNvbW1lbnRzIHx8IHByaW50ZWRfY29tbWVudHMuaGFzKGNvbW1lbnRzKSkgcmV0dXJuO1xuICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudCB8fCBjb21tZW50cy5ldmVyeSgoYykgPT5cbiAgICAgICAgICAgICEvY29tbWVudFsxMzRdLy50ZXN0KGMudHlwZSlcbiAgICAgICAgKSkpIHJldHVybjtcbiAgICAgICAgcHJpbnRlZF9jb21tZW50cy5hZGQoY29tbWVudHMpO1xuICAgICAgICB2YXIgaW5zZXJ0ID0gT1VUUFVULmxlbmd0aDtcbiAgICAgICAgY29tbWVudHMuZmlsdGVyKGNvbW1lbnRfZmlsdGVyLCBub2RlKS5mb3JFYWNoKGZ1bmN0aW9uKGMsIGkpIHtcbiAgICAgICAgICAgIGlmIChwcmludGVkX2NvbW1lbnRzLmhhcyhjKSkgcmV0dXJuO1xuICAgICAgICAgICAgcHJpbnRlZF9jb21tZW50cy5hZGQoYyk7XG4gICAgICAgICAgICBuZWVkX3NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmVlZF9uZXdsaW5lX2luZGVudGVkKSB7XG4gICAgICAgICAgICAgICAgcHJpbnQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgbmVlZF9uZXdsaW5lX2luZGVudGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGMubmxiICYmIChpID4gMCB8fCAhaGFzX25sYigpKSkge1xuICAgICAgICAgICAgICAgIHByaW50KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIGluZGVudCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpID4gMCB8fCAhdGFpbCkge1xuICAgICAgICAgICAgICAgIHNwYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoL2NvbW1lbnRbMTM0XS8udGVzdChjLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWx0ZXJfY29tbWVudChjLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnQoXCIvL1wiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZWVkX25ld2xpbmVfaW5kZW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjLnR5cGUgPT0gXCJjb21tZW50MlwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWx0ZXJfY29tbWVudChjLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnQoXCIvKlwiICsgdmFsdWUgKyBcIiovXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZWVkX3NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChPVVRQVVQubGVuZ3RoID4gaW5zZXJ0KSBuZXdsaW5lX2luc2VydCA9IGluc2VydDtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQgICAgICAgICAgICAgOiBnZXQsXG4gICAgICAgIHRvU3RyaW5nICAgICAgICA6IGdldCxcbiAgICAgICAgaW5kZW50ICAgICAgICAgIDogaW5kZW50LFxuICAgICAgICBpbl9kaXJlY3RpdmUgICAgOiBmYWxzZSxcbiAgICAgICAgdXNlX2FzbSAgICAgICAgIDogbnVsbCxcbiAgICAgICAgYWN0aXZlX3Njb3BlICAgIDogbnVsbCxcbiAgICAgICAgaW5kZW50YXRpb24gICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBpbmRlbnRhdGlvbjsgfSxcbiAgICAgICAgY3VycmVudF93aWR0aCAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50X2NvbCAtIGluZGVudGF0aW9uOyB9LFxuICAgICAgICBzaG91bGRfYnJlYWsgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIG9wdGlvbnMud2lkdGggJiYgdGhpcy5jdXJyZW50X3dpZHRoKCkgPj0gb3B0aW9ucy53aWR0aDsgfSxcbiAgICAgICAgaGFzX3BhcmVucyAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBoYXNfcGFyZW5zOyB9LFxuICAgICAgICBuZXdsaW5lICAgICAgICAgOiBuZXdsaW5lLFxuICAgICAgICBwcmludCAgICAgICAgICAgOiBwcmludCxcbiAgICAgICAgc3RhciAgICAgICAgICAgIDogc3RhcixcbiAgICAgICAgc3BhY2UgICAgICAgICAgIDogc3BhY2UsXG4gICAgICAgIGNvbW1hICAgICAgICAgICA6IGNvbW1hLFxuICAgICAgICBjb2xvbiAgICAgICAgICAgOiBjb2xvbixcbiAgICAgICAgbGFzdCAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBsYXN0OyB9LFxuICAgICAgICBzZW1pY29sb24gICAgICAgOiBzZW1pY29sb24sXG4gICAgICAgIGZvcmNlX3NlbWljb2xvbiA6IGZvcmNlX3NlbWljb2xvbixcbiAgICAgICAgdG9fdXRmOCAgICAgICAgIDogdG9fdXRmOCxcbiAgICAgICAgcHJpbnRfbmFtZSAgICAgIDogZnVuY3Rpb24obmFtZSkgeyBwcmludChtYWtlX25hbWUobmFtZSkpOyB9LFxuICAgICAgICBwcmludF9zdHJpbmcgICAgOiBmdW5jdGlvbihzdHIsIHF1b3RlLCBlc2NhcGVfZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICB2YXIgZW5jb2RlZCA9IGVuY29kZV9zdHJpbmcoc3RyLCBxdW90ZSk7XG4gICAgICAgICAgICBpZiAoZXNjYXBlX2RpcmVjdGl2ZSA9PT0gdHJ1ZSAmJiAhZW5jb2RlZC5pbmNsdWRlcyhcIlxcXFxcIikpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQgc2VtaWNvbG9ucyB0byBicmVhayBkaXJlY3RpdmUgcHJvbG9ndWVcbiAgICAgICAgICAgICAgICBpZiAoIUVYUEVDVF9ESVJFQ1RJVkUudGVzdChPVVRQVVQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlX3NlbWljb2xvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3JjZV9zZW1pY29sb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByaW50KGVuY29kZWQpO1xuICAgICAgICB9LFxuICAgICAgICBwcmludF90ZW1wbGF0ZV9zdHJpbmdfY2hhcnM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgdmFyIGVuY29kZWQgPSBlbmNvZGVfc3RyaW5nKHN0ciwgXCJgXCIpLnJlcGxhY2UoL1xcJHsvZywgXCJcXFxcJHtcIik7XG4gICAgICAgICAgICByZXR1cm4gcHJpbnQoZW5jb2RlZC5zdWJzdHIoMSwgZW5jb2RlZC5sZW5ndGggLSAyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVuY29kZV9zdHJpbmcgICA6IGVuY29kZV9zdHJpbmcsXG4gICAgICAgIG5leHRfaW5kZW50ICAgICA6IG5leHRfaW5kZW50LFxuICAgICAgICB3aXRoX2luZGVudCAgICAgOiB3aXRoX2luZGVudCxcbiAgICAgICAgd2l0aF9ibG9jayAgICAgIDogd2l0aF9ibG9jayxcbiAgICAgICAgd2l0aF9wYXJlbnMgICAgIDogd2l0aF9wYXJlbnMsXG4gICAgICAgIHdpdGhfc3F1YXJlICAgICA6IHdpdGhfc3F1YXJlLFxuICAgICAgICBhZGRfbWFwcGluZyAgICAgOiBhZGRfbWFwcGluZyxcbiAgICAgICAgb3B0aW9uICAgICAgICAgIDogZnVuY3Rpb24ob3B0KSB7IHJldHVybiBvcHRpb25zW29wdF07IH0sXG4gICAgICAgIHByaW50ZWRfY29tbWVudHM6IHByaW50ZWRfY29tbWVudHMsXG4gICAgICAgIHByZXBlbmRfY29tbWVudHM6IHJlYWRvbmx5ID8gbm9vcCA6IHByZXBlbmRfY29tbWVudHMsXG4gICAgICAgIGFwcGVuZF9jb21tZW50cyA6IHJlYWRvbmx5IHx8IGNvbW1lbnRfZmlsdGVyID09PSByZXR1cm5fZmFsc2UgPyBub29wIDogYXBwZW5kX2NvbW1lbnRzLFxuICAgICAgICBsaW5lICAgICAgICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGN1cnJlbnRfbGluZTsgfSxcbiAgICAgICAgY29sICAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50X2NvbDsgfSxcbiAgICAgICAgcG9zICAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50X3BvczsgfSxcbiAgICAgICAgcHVzaF9ub2RlICAgICAgIDogZnVuY3Rpb24obm9kZSkgeyBzdGFjay5wdXNoKG5vZGUpOyB9LFxuICAgICAgICBwb3Bfbm9kZSAgICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHN0YWNrLnBvcCgpOyB9LFxuICAgICAgICBwYXJlbnQgICAgICAgICAgOiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMiAtIChuIHx8IDApXTtcbiAgICAgICAgfVxuICAgIH07XG5cbn1cblxuLyogLS0tLS1bIGNvZGUgZ2VuZXJhdG9ycyBdLS0tLS0gKi9cblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgLyogLS0tLS1bIHV0aWxzIF0tLS0tLSAqL1xuXG4gICAgZnVuY3Rpb24gREVGUFJJTlQobm9kZXR5cGUsIGdlbmVyYXRvcikge1xuICAgICAgICBub2RldHlwZS5ERUZNRVRIT0QoXCJfY29kZWdlblwiLCBnZW5lcmF0b3IpO1xuICAgIH1cblxuICAgIEFTVF9Ob2RlLkRFRk1FVEhPRChcInByaW50XCIsIGZ1bmN0aW9uKG91dHB1dCwgZm9yY2VfcGFyZW5zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgZ2VuZXJhdG9yID0gc2VsZi5fY29kZWdlbjtcbiAgICAgICAgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgIG91dHB1dC5hY3RpdmVfc2NvcGUgPSBzZWxmO1xuICAgICAgICB9IGVsc2UgaWYgKCFvdXRwdXQudXNlX2FzbSAmJiBzZWxmIGluc3RhbmNlb2YgQVNUX0RpcmVjdGl2ZSAmJiBzZWxmLnZhbHVlID09IFwidXNlIGFzbVwiKSB7XG4gICAgICAgICAgICBvdXRwdXQudXNlX2FzbSA9IG91dHB1dC5hY3RpdmVfc2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZG9pdCgpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmVwZW5kX2NvbW1lbnRzKHNlbGYpO1xuICAgICAgICAgICAgc2VsZi5hZGRfc291cmNlX21hcChvdXRwdXQpO1xuICAgICAgICAgICAgZ2VuZXJhdG9yKHNlbGYsIG91dHB1dCk7XG4gICAgICAgICAgICBvdXRwdXQuYXBwZW5kX2NvbW1lbnRzKHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXNoX25vZGUoc2VsZik7XG4gICAgICAgIGlmIChmb3JjZV9wYXJlbnMgfHwgc2VsZi5uZWVkc19wYXJlbnMob3V0cHV0KSkge1xuICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGRvaXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9pdCgpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wb3Bfbm9kZSgpO1xuICAgICAgICBpZiAoc2VsZiA9PT0gb3V0cHV0LnVzZV9hc20pIHtcbiAgICAgICAgICAgIG91dHB1dC51c2VfYXNtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIEFTVF9Ob2RlLkRFRk1FVEhPRChcIl9wcmludFwiLCBBU1RfTm9kZS5wcm90b3R5cGUucHJpbnQpO1xuXG4gICAgQVNUX05vZGUuREVGTUVUSE9EKFwicHJpbnRfdG9fc3RyaW5nXCIsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IE91dHB1dFN0cmVhbShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wcmludChvdXRwdXQpO1xuICAgICAgICByZXR1cm4gb3V0cHV0LmdldCgpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIFBBUkVOVEhFU0VTIF0tLS0tLSAqL1xuXG4gICAgZnVuY3Rpb24gUEFSRU5TKG5vZGV0eXBlLCBmdW5jKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGV0eXBlKSkge1xuICAgICAgICAgICAgbm9kZXR5cGUuZm9yRWFjaChmdW5jdGlvbihub2RldHlwZSkge1xuICAgICAgICAgICAgICAgIFBBUkVOUyhub2RldHlwZSwgZnVuYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGV0eXBlLkRFRk1FVEhPRChcIm5lZWRzX3BhcmVuc1wiLCBmdW5jKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFBBUkVOUyhBU1RfTm9kZSwgcmV0dXJuX2ZhbHNlKTtcblxuICAgIC8vIGEgZnVuY3Rpb24gZXhwcmVzc2lvbiBuZWVkcyBwYXJlbnMgYXJvdW5kIGl0IHdoZW4gaXQncyBwcm92YWJseVxuICAgIC8vIHRoZSBmaXJzdCB0b2tlbiB0byBhcHBlYXIgaW4gYSBzdGF0ZW1lbnQuXG4gICAgUEFSRU5TKEFTVF9GdW5jdGlvbiwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIGlmICghb3V0cHV0Lmhhc19wYXJlbnMoKSAmJiBmaXJzdF9pbl9zdGF0ZW1lbnQob3V0cHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcIndlYmtpdFwiKSkge1xuICAgICAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJ3cmFwX2lpZmVcIikpIHtcbiAgICAgICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdXRwdXQub3B0aW9uKFwid3JhcF9mdW5jX2FyZ3NcIikpIHtcbiAgICAgICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBwLmFyZ3MuaW5jbHVkZXModGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfQXJyb3csIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBvdXRwdXQub3B0aW9uKFwid3JhcF9mdW5jX2FyZ3NcIilcbiAgICAgICAgICAgICYmIHAgaW5zdGFuY2VvZiBBU1RfQ2FsbFxuICAgICAgICAgICAgJiYgcC5hcmdzLmluY2x1ZGVzKHRoaXMpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXM7XG4gICAgfSk7XG5cbiAgICAvLyBzYW1lIGdvZXMgZm9yIGFuIG9iamVjdCBsaXRlcmFsIChhcyBpbiBBU1RfRnVuY3Rpb24pLCBiZWNhdXNlXG4gICAgLy8gb3RoZXJ3aXNlIHsuLi59IHdvdWxkIGJlIGludGVycHJldGVkIGFzIGEgYmxvY2sgb2YgY29kZS5cbiAgICBQQVJFTlMoQVNUX09iamVjdCwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHJldHVybiAhb3V0cHV0Lmhhc19wYXJlbnMoKSAmJiBmaXJzdF9pbl9zdGF0ZW1lbnQob3V0cHV0KTtcbiAgICB9KTtcblxuICAgIFBBUkVOUyhBU1RfQ2xhc3NFeHByZXNzaW9uLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuXG4gICAgUEFSRU5TKEFTVF9VbmFyeSwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICByZXR1cm4gcCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpc1xuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpc1xuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAmJiBwLm9wZXJhdG9yID09PSBcIioqXCJcbiAgICAgICAgICAgICAgICAmJiB0aGlzIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAgICAgJiYgcC5sZWZ0ID09PSB0aGlzXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5vcGVyYXRvciAhPT0gXCIrK1wiXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5vcGVyYXRvciAhPT0gXCItLVwiO1xuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9Bd2FpdCwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICByZXR1cm4gcCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpc1xuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpc1xuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgcC5vcGVyYXRvciA9PT0gXCIqKlwiICYmIHAubGVmdCA9PT0gdGhpc1xuICAgICAgICAgICAgfHwgb3V0cHV0Lm9wdGlvbihcInNhZmFyaTEwXCIpICYmIHAgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXg7XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX1NlcXVlbmNlLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIHJldHVybiBwIGluc3RhbmNlb2YgQVNUX0NhbGwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChmb28sIGJhcikoKSBvciBmb28oMSwgKDIsIDMpLCA0KVxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9VbmFyeSAgICAgICAgICAgICAgICAgICAgICAgICAvLyAhKGZvbywgYmFyLCBiYXopXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgKyAoMiwgMykgKyA0ID09PiA4XG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX1ZhckRlZiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciBhID0gKDEsIDIpLCBiID0gYSArIGE7ID09PiBiID09IDRcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAgICAgICAgICAgICAgICAgICAgLy8gKDEsIHtmb286Mn0pLmZvbyBvciAoMSwge2ZvbzoyfSlbXCJmb29cIl0gPT0+IDJcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfQXJyYXkgICAgICAgICAgICAgICAgICAgICAgICAgLy8gWyAxLCAoMiwgMyksIDQgXSA9PT4gWyAxLCAzLCA0IF1cbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfT2JqZWN0UHJvcGVydHkgICAgICAgICAgICAgICAgLy8geyBmb286ICgxLCAyKSB9LmZvbyA9PT4gMlxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAgICAgICAgICAgICAgICAgICAvKiAoZmFsc2UsIHRydWUpID8gKGEgPSAxMCwgYiA9IDIwKSA6IChjID0gMzApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqID09PiAyMCAoc2lkZSBlZmZlY3QsIHNldCBhIDo9IDEwIGFuZCBiIDo9IDIwKSAqL1xuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9BcnJvdyAgICAgICAgICAgICAgICAgICAgICAgICAvLyB4ID0+ICh4LCB4KVxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9EZWZhdWx0QXNzaWduICAgICAgICAgICAgICAgICAvLyB4ID0+ICh4ID0gKDAsIGZ1bmN0aW9uKCl7fSkpXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbiAgICAgICAgICAgICAgICAgICAgIC8vIFsuLi4oYSwgYildXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0Zvck9mICYmIHRoaXMgPT09IHAub2JqZWN0ICAgIC8vIGZvciAoZSBvZiAoZm9vLCBiYXIpKSB7fVxuICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9ZaWVsZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyB5aWVsZCAoZm9vLCBiYXIpXG4gICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0V4cG9ydCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cG9ydCBkZWZhdWx0IChmb28sIGJhcilcbiAgICAgICAgO1xuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9CaW5hcnksIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgLy8gKGZvbyAmJiBiYXIpKClcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gdHlwZW9mIChmb28gJiYgYmFyKVxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9VbmFyeSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAoZm9vICYmIGJhcilbXCJwcm9wXCJdLCAoZm9vICYmIGJhcikucHJvcFxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyB0aGlzIGRlYWxzIHdpdGggcHJlY2VkZW5jZTogMyAqICgyICsgMSlcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5KSB7XG4gICAgICAgICAgICBjb25zdCBwbyA9IHAub3BlcmF0b3I7XG4gICAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlcmF0b3I7XG5cbiAgICAgICAgICAgIGlmIChzbyA9PT0gXCI/P1wiICYmIChwbyA9PT0gXCJ8fFwiIHx8IHBvID09PSBcIiYmXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwbyA9PT0gXCI/P1wiICYmIChzbyA9PT0gXCJ8fFwiIHx8IHNvID09PSBcIiYmXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHBwID0gUFJFQ0VERU5DRVtwb107XG4gICAgICAgICAgICBjb25zdCBzcCA9IFBSRUNFREVOQ0Vbc29dO1xuICAgICAgICAgICAgaWYgKHBwID4gc3BcbiAgICAgICAgICAgICAgICB8fCAocHAgPT0gc3BcbiAgICAgICAgICAgICAgICAgICAgJiYgKHRoaXMgPT09IHAucmlnaHQgfHwgcG8gPT0gXCIqKlwiKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9ZaWVsZCwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAvLyAoeWllbGQgMSkgKyAoeWllbGQgMilcbiAgICAgICAgLy8gYSA9IHlpZWxkIDNcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIHAub3BlcmF0b3IgIT09IFwiPVwiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vICh5aWVsZCAxKSgpXG4gICAgICAgIC8vIG5ldyAoeWllbGQgMSkoKVxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAoeWllbGQgMSkgPyB5aWVsZCAyIDogeWllbGQgM1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAmJiBwLmNvbmRpdGlvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAtKHlpZWxkIDQpXG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX1VuYXJ5KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vICh5aWVsZCB4KS5mb29cbiAgICAgICAgLy8gKHlpZWxkIHgpWydmb28nXVxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgUEFSRU5TKEFTVF9Qcm9wQWNjZXNzLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX05ldyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIC8vIGkuZS4gbmV3IChmb28uYmFyKCkuYmF6KVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgb25lIGNhbGwgaW50byB0aGlzIHN1YnRyZWUsIHRoZW4gd2UgbmVlZFxuICAgICAgICAgICAgLy8gcGFyZW5zIGFyb3VuZCBpdCB0b28sIG90aGVyd2lzZSB0aGUgY2FsbCB3aWxsIGJlXG4gICAgICAgICAgICAvLyBpbnRlcnByZXRlZCBhcyBwYXNzaW5nIHRoZSBhcmd1bWVudHMgdG8gdGhlIHVwcGVyIE5ld1xuICAgICAgICAgICAgLy8gZXhwcmVzc2lvbi5cbiAgICAgICAgICAgIHJldHVybiB3YWxrKHRoaXMsIG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxrX2Fib3J0OyAgLy8gbWFrZXMgd2FsaygpIHJldHVybiB0cnVlLlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX0NhbGwsIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKSwgcDE7XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX05ldyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXNcbiAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfRXhwb3J0ICYmIHAuaXNfZGVmYXVsdCAmJiB0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciBTYWZhcmkgYnVnLlxuICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIzNTA2XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb25cbiAgICAgICAgICAgICYmIHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2Vzc1xuICAgICAgICAgICAgJiYgcC5leHByZXNzaW9uID09PSB0aGlzXG4gICAgICAgICAgICAmJiAocDEgPSBvdXRwdXQucGFyZW50KDEpKSBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICYmIHAxLmxlZnQgPT09IHA7XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX05ldywgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICBpZiAodGhpcy5hcmdzLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgJiYgKHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAvLyAobmV3IERhdGUpLmdldFRpbWUoKSwgKG5ldyBEYXRlKVtcImdldFRpbWVcIl0oKVxuICAgICAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpKSAvLyAobmV3IGZvbykoYmFyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX051bWJlciwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCAvXjAvLnRlc3QobWFrZV9udW0odmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBQQVJFTlMoQVNUX0JpZ0ludCwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIHAuZXhwcmVzc2lvbiA9PT0gdGhpcykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoXCItXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFBBUkVOUyhbIEFTVF9Bc3NpZ24sIEFTVF9Db25kaXRpb25hbCBdLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIHAgPSBvdXRwdXQucGFyZW50KCk7XG4gICAgICAgIC8vICEoYSA9IGZhbHNlKSDihpIgdHJ1ZVxuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9VbmFyeSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyAxICsgKGEgPSAyKSArIDMg4oaSIDYsIHNpZGUgZWZmZWN0IHNldHRpbmcgYSA9IDJcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmICEocCBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIChhID0gZnVuYykoKSDigJRvcuKAlCBuZXcgKGEgPSBPYmplY3QpKClcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gKGEgPSBmb28pID8gYmFyIDogYmF6XG4gICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsICYmIHAuY29uZGl0aW9uID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIChhID0gZm9vKVtcInByb3BcIl0g4oCUb3LigJQgKGEgPSBmb28pLnByb3BcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAmJiBwLmV4cHJlc3Npb24gPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gKHthLCBifSA9IHthOiAxLCBiOiAyfSksIGEgZGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQVNUX0Fzc2lnbiAmJiB0aGlzLmxlZnQgaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZyAmJiB0aGlzLmxlZnQuaXNfYXJyYXkgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgUFJJTlRFUlMgXS0tLS0tICovXG5cbiAgICBERUZQUklOVChBU1RfRGlyZWN0aXZlLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50X3N0cmluZyhzZWxmLnZhbHVlLCBzZWxmLnF1b3RlKTtcbiAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuXG4gICAgREVGUFJJTlQoQVNUX0V4cGFuc2lvbiwgZnVuY3Rpb24gKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCIuLi5cIik7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgREVGUFJJTlQoQVNUX0Rlc3RydWN0dXJpbmcsIGZ1bmN0aW9uIChzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KHNlbGYuaXNfYXJyYXkgPyBcIltcIiA6IFwie1wiKTtcbiAgICAgICAgdmFyIGxlbiA9IHNlbGYubmFtZXMubGVuZ3RoO1xuICAgICAgICBzZWxmLm5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUsIGkpIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkgb3V0cHV0LmNvbW1hKCk7XG4gICAgICAgICAgICBuYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZmluYWwgZWxlbWVudCBpcyBhIGhvbGUsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGl0XG4gICAgICAgICAgICAvLyBkb2Vzbid0IGxvb2sgbGlrZSBhIHRyYWlsaW5nIGNvbW1hLCBieSBpbnNlcnRpbmcgYW4gYWN0dWFsXG4gICAgICAgICAgICAvLyB0cmFpbGluZyBjb21tYS5cbiAgICAgICAgICAgIGlmIChpID09IGxlbiAtIDEgJiYgbmFtZSBpbnN0YW5jZW9mIEFTVF9Ib2xlKSBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5wcmludChzZWxmLmlzX2FycmF5ID8gXCJdXCIgOiBcIn1cIik7XG4gICAgfSk7XG5cbiAgICBERUZQUklOVChBU1RfRGVidWdnZXIsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJkZWJ1Z2dlclwiKTtcbiAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIHN0YXRlbWVudHMgXS0tLS0tICovXG5cbiAgICBmdW5jdGlvbiBkaXNwbGF5X2JvZHkoYm9keSwgaXNfdG9wbGV2ZWwsIG91dHB1dCwgYWxsb3dfZGlyZWN0aXZlcykge1xuICAgICAgICB2YXIgbGFzdCA9IGJvZHkubGVuZ3RoIC0gMTtcbiAgICAgICAgb3V0cHV0LmluX2RpcmVjdGl2ZSA9IGFsbG93X2RpcmVjdGl2ZXM7XG4gICAgICAgIGJvZHkuZm9yRWFjaChmdW5jdGlvbihzdG10LCBpKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0LmluX2RpcmVjdGl2ZSA9PT0gdHJ1ZSAmJiAhKHN0bXQgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlIHx8XG4gICAgICAgICAgICAgICAgc3RtdCBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudCB8fFxuICAgICAgICAgICAgICAgIChzdG10IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCAmJiBzdG10LmJvZHkgaW5zdGFuY2VvZiBBU1RfU3RyaW5nKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbl9kaXJlY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHN0bXQgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIHN0bXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoIShpID09IGxhc3QgJiYgaXNfdG9wbGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc190b3BsZXZlbCkgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0cHV0LmluX2RpcmVjdGl2ZSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgIHN0bXQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50ICYmXG4gICAgICAgICAgICAgICAgc3RtdC5ib2R5IGluc3RhbmNlb2YgQVNUX1N0cmluZ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluX2RpcmVjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LmluX2RpcmVjdGl2ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIEFTVF9TdGF0ZW1lbnRXaXRoQm9keS5ERUZNRVRIT0QoXCJfZG9fcHJpbnRfYm9keVwiLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgZm9yY2Vfc3RhdGVtZW50KHRoaXMuYm9keSwgb3V0cHV0KTtcbiAgICB9KTtcblxuICAgIERFRlBSSU5UKEFTVF9TdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLmJvZHkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Ub3BsZXZlbCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIGRpc3BsYXlfYm9keShzZWxmLmJvZHksIHRydWUsIG91dHB1dCwgdHJ1ZSk7XG4gICAgICAgIG91dHB1dC5wcmludChcIlwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfTGFiZWxlZFN0YXRlbWVudCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYubGFiZWwucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LmNvbG9uKCk7XG4gICAgICAgIHNlbGYuYm9keS5wcmludChvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLmJvZHkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHByaW50X2JyYWNlZF9lbXB0eShzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwie1wiKTtcbiAgICAgICAgb3V0cHV0LndpdGhfaW5kZW50KG91dHB1dC5uZXh0X2luZGVudCgpLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG91dHB1dC5hcHBlbmRfY29tbWVudHMoc2VsZiwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJ9XCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmludF9icmFjZWQoc2VsZiwgb3V0cHV0LCBhbGxvd19kaXJlY3RpdmVzKSB7XG4gICAgICAgIGlmIChzZWxmLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheV9ib2R5KHNlbGYuYm9keSwgZmFsc2UsIG91dHB1dCwgYWxsb3dfZGlyZWN0aXZlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHByaW50X2JyYWNlZF9lbXB0eShzZWxmLCBvdXRwdXQpO1xuICAgIH1cbiAgICBERUZQUklOVChBU1RfQmxvY2tTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBwcmludF9icmFjZWQoc2VsZiwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRW1wdHlTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0RvLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZG9cIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBtYWtlX2Jsb2NrKHNlbGYuYm9keSwgb3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC5wcmludChcIndoaWxlXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfV2hpbGUsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJ3aGlsZVwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Gb3IsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJmb3JcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5pbml0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuaW5pdCBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmluaXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRoZXNpemVfZm9yX25vaW4oc2VsZi5pbml0LCBvdXRwdXQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI7XCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI7XCIpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuc3RlcCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc3RlcC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRm9ySW4sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJmb3JcIik7XG4gICAgICAgIGlmIChzZWxmLmF3YWl0KSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImF3YWl0XCIpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmluaXQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KHNlbGYgaW5zdGFuY2VvZiBBU1RfRm9yT2YgPyBcIm9mXCIgOiBcImluXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBzZWxmLm9iamVjdC5wcmludChvdXRwdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfV2l0aCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcIndpdGhcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgZnVuY3Rpb25zIF0tLS0tLSAqL1xuICAgIEFTVF9MYW1iZGEuREVGTUVUSE9EKFwiX2RvX3ByaW50XCIsIGZ1bmN0aW9uKG91dHB1dCwgbm9rZXl3b3JkKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCFub2tleXdvcmQpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiYXN5bmNcIik7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJmdW5jdGlvblwiKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzX2dlbmVyYXRvcikge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zdGFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYubmFtZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2wpIHtcbiAgICAgICAgICAgIHNlbGYubmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKG5va2V5d29yZCAmJiBzZWxmLm5hbWUgaW5zdGFuY2VvZiBBU1RfTm9kZSkge1xuICAgICAgICAgICAgb3V0cHV0LndpdGhfc3F1YXJlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYubmFtZS5wcmludChvdXRwdXQpOyAvLyBDb21wdXRlZCBtZXRob2QgbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5hcmduYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGFyZywgaSkge1xuICAgICAgICAgICAgICAgIGlmIChpKSBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICBhcmcucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHByaW50X2JyYWNlZChzZWxmLCBvdXRwdXQsIHRydWUpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9MYW1iZGEsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgREVGUFJJTlQoQVNUX1ByZWZpeGVkVGVtcGxhdGVTdHJpbmcsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICB2YXIgdGFnID0gc2VsZi5wcmVmaXg7XG4gICAgICAgIHZhciBwYXJlbnRoZXNpemVfdGFnID0gdGFnIGluc3RhbmNlb2YgQVNUX0xhbWJkYVxuICAgICAgICAgICAgfHwgdGFnIGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgfHwgdGFnIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsXG4gICAgICAgICAgICB8fCB0YWcgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2VcbiAgICAgICAgICAgIHx8IHRhZyBpbnN0YW5jZW9mIEFTVF9VbmFyeVxuICAgICAgICAgICAgfHwgdGFnIGluc3RhbmNlb2YgQVNUX0RvdCAmJiB0YWcuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9PYmplY3Q7XG4gICAgICAgIGlmIChwYXJlbnRoZXNpemVfdGFnKSBvdXRwdXQucHJpbnQoXCIoXCIpO1xuICAgICAgICBzZWxmLnByZWZpeC5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAocGFyZW50aGVzaXplX3RhZykgb3V0cHV0LnByaW50KFwiKVwiKTtcbiAgICAgICAgc2VsZi50ZW1wbGF0ZV9zdHJpbmcucHJpbnQob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfVGVtcGxhdGVTdHJpbmcsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICB2YXIgaXNfdGFnZ2VkID0gb3V0cHV0LnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX1ByZWZpeGVkVGVtcGxhdGVTdHJpbmc7XG5cbiAgICAgICAgb3V0cHV0LnByaW50KFwiYFwiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIShzZWxmLnNlZ21lbnRzW2ldIGluc3RhbmNlb2YgQVNUX1RlbXBsYXRlU2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIke1wiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNlZ21lbnRzW2ldLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwifVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNfdGFnZ2VkKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KHNlbGYuc2VnbWVudHNbaV0ucmF3KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50X3RlbXBsYXRlX3N0cmluZ19jaGFycyhzZWxmLnNlZ21lbnRzW2ldLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucHJpbnQoXCJgXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9UZW1wbGF0ZVNlZ21lbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnRfdGVtcGxhdGVfc3RyaW5nX2NoYXJzKHNlbGYudmFsdWUpO1xuICAgIH0pO1xuXG4gICAgQVNUX0Fycm93LkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcGFyZW50ID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICB2YXIgbmVlZHNfcGFyZW5zID0gKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgIShwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQXNzaWduKSkgfHxcbiAgICAgICAgICAgIHBhcmVudCBpbnN0YW5jZW9mIEFTVF9VbmFyeSB8fFxuICAgICAgICAgICAgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIHNlbGYgPT09IHBhcmVudC5leHByZXNzaW9uKTtcbiAgICAgICAgaWYgKG5lZWRzX3BhcmVucykgeyBvdXRwdXQucHJpbnQoXCIoXCIpOyB9XG4gICAgICAgIGlmIChzZWxmLmFzeW5jKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJhc3luY1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmFyZ25hbWVzLmxlbmd0aCA9PT0gMSAmJiBzZWxmLmFyZ25hbWVzWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbCkge1xuICAgICAgICAgICAgc2VsZi5hcmduYW1lc1swXS5wcmludChvdXRwdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYXJnbmFtZXMuZm9yRWFjaChmdW5jdGlvbihhcmcsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkpIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgICAgICBhcmcucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCI9PlwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIGNvbnN0IGZpcnN0X3N0YXRlbWVudCA9IHNlbGYuYm9keVswXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgc2VsZi5ib2R5Lmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgJiYgZmlyc3Rfc3RhdGVtZW50IGluc3RhbmNlb2YgQVNUX1JldHVyblxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHJldHVybmVkID0gZmlyc3Rfc3RhdGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgaWYgKCFyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcInt9XCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0X2lzX29iamVjdChyZXR1cm5lZCkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIoXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybmVkLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiKVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuZWQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByaW50X2JyYWNlZChzZWxmLCBvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc19wYXJlbnMpIHsgb3V0cHV0LnByaW50KFwiKVwiKTsgfVxuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGV4aXRzIF0tLS0tLSAqL1xuICAgIEFTVF9FeGl0LkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQsIGtpbmQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KGtpbmQpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50cyA9IHRoaXMudmFsdWUuc3RhcnQuY29tbWVudHNfYmVmb3JlO1xuICAgICAgICAgICAgaWYgKGNvbW1lbnRzICYmIGNvbW1lbnRzLmxlbmd0aCAmJiAhb3V0cHV0LnByaW50ZWRfY29tbWVudHMuaGFzKGNvbW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIihcIik7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIilcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1JldHVybiwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJyZXR1cm5cIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1Rocm93LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcInRocm93XCIpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIHlpZWxkIF0tLS0tLSAqL1xuXG4gICAgREVGUFJJTlQoQVNUX1lpZWxkLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIHN0YXIgPSBzZWxmLmlzX3N0YXIgPyBcIipcIiA6IFwiXCI7XG4gICAgICAgIG91dHB1dC5wcmludChcInlpZWxkXCIgKyBzdGFyKTtcbiAgICAgICAgaWYgKHNlbGYuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgREVGUFJJTlQoQVNUX0F3YWl0LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiYXdhaXRcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB2YXIgZSA9IHNlbGYuZXhwcmVzc2lvbjtcbiAgICAgICAgdmFyIHBhcmVucyA9ICEoXG4gICAgICAgICAgICAgICBlIGluc3RhbmNlb2YgQVNUX0NhbGxcbiAgICAgICAgICAgIHx8IGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICB8fCBlIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3NcbiAgICAgICAgICAgIHx8IGUgaW5zdGFuY2VvZiBBU1RfVW5hcnlcbiAgICAgICAgICAgIHx8IGUgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgIHx8IGUgaW5zdGFuY2VvZiBBU1RfQXdhaXRcbiAgICAgICAgICAgIHx8IGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0XG4gICAgICAgICk7XG4gICAgICAgIGlmIChwYXJlbnMpIG91dHB1dC5wcmludChcIihcIik7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAocGFyZW5zKSBvdXRwdXQucHJpbnQoXCIpXCIpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGxvb3AgY29udHJvbCBdLS0tLS0gKi9cbiAgICBBU1RfTG9vcENvbnRyb2wuREVGTUVUSE9EKFwiX2RvX3ByaW50XCIsIGZ1bmN0aW9uKG91dHB1dCwga2luZCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoa2luZCk7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHRoaXMubGFiZWwucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0JyZWFrLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcImJyZWFrXCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Db250aW51ZSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJjb250aW51ZVwiKTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyBpZiBdLS0tLS0gKi9cbiAgICBmdW5jdGlvbiBtYWtlX3RoZW4oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBiID0gc2VsZi5ib2R5O1xuICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcImJyYWNlc1wiKVxuICAgICAgICAgICAgfHwgb3V0cHV0Lm9wdGlvbihcImllOFwiKSAmJiBiIGluc3RhbmNlb2YgQVNUX0RvKVxuICAgICAgICAgICAgcmV0dXJuIG1ha2VfYmxvY2soYiwgb3V0cHV0KTtcbiAgICAgICAgLy8gVGhlIHNxdWVlemVyIHJlcGxhY2VzIFwiYmxvY2tcIi1zIHRoYXQgY29udGFpbiBvbmx5IGEgc2luZ2xlXG4gICAgICAgIC8vIHN0YXRlbWVudCB3aXRoIHRoZSBzdGF0ZW1lbnQgaXRzZWxmOyB0ZWNobmljYWxseSwgdGhlIEFTVFxuICAgICAgICAvLyBpcyBjb3JyZWN0LCBidXQgdGhpcyBjYW4gY3JlYXRlIHByb2JsZW1zIHdoZW4gd2Ugb3V0cHV0IGFuXG4gICAgICAgIC8vIElGIGhhdmluZyBhbiBFTFNFIGNsYXVzZSB3aGVyZSB0aGUgVEhFTiBjbGF1c2UgZW5kcyBpbiBhblxuICAgICAgICAvLyBJRiAqd2l0aG91dCogYW4gRUxTRSBibG9jayAodGhlbiB0aGUgb3V0ZXIgRUxTRSB3b3VsZCByZWZlclxuICAgICAgICAvLyB0byB0aGUgaW5uZXIgSUYpLiAgVGhpcyBmdW5jdGlvbiBjaGVja3MgZm9yIHRoaXMgY2FzZSBhbmRcbiAgICAgICAgLy8gYWRkcyB0aGUgYmxvY2sgYnJhY2VzIGlmIG5lZWRlZC5cbiAgICAgICAgaWYgKCFiKSByZXR1cm4gb3V0cHV0LmZvcmNlX3NlbWljb2xvbigpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGIgaW5zdGFuY2VvZiBBU1RfSWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWIuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9ibG9jayhzZWxmLmJvZHksIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYiA9IGIuYWx0ZXJuYXRpdmU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGIgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50V2l0aEJvZHkpIHtcbiAgICAgICAgICAgICAgICBiID0gYi5ib2R5O1xuICAgICAgICAgICAgfSBlbHNlIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZvcmNlX3N0YXRlbWVudChzZWxmLmJvZHksIG91dHB1dCk7XG4gICAgfVxuICAgIERFRlBSSU5UKEFTVF9JZiwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcImlmXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5jb25kaXRpb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgbWFrZV90aGVuKHNlbGYsIG91dHB1dCk7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImVsc2VcIik7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX0lmKVxuICAgICAgICAgICAgICAgIHNlbGYuYWx0ZXJuYXRpdmUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmb3JjZV9zdGF0ZW1lbnQoc2VsZi5hbHRlcm5hdGl2ZSwgb3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuX2RvX3ByaW50X2JvZHkob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIHN3aXRjaCBdLS0tLS0gKi9cbiAgICBERUZQUklOVChBU1RfU3dpdGNoLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwic3dpdGNoXCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgb3V0cHV0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgdmFyIGxhc3QgPSBzZWxmLmJvZHkubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3QgPCAwKSBwcmludF9icmFjZWRfZW1wdHkoc2VsZiwgb3V0cHV0KTtcbiAgICAgICAgZWxzZSBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKGJyYW5jaCwgaSkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJhbmNoLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBsYXN0ICYmIGJyYW5jaC5ib2R5Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgQVNUX1N3aXRjaEJyYW5jaC5ERUZNRVRIT0QoXCJfZG9fcHJpbnRfYm9keVwiLCBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgdGhpcy5ib2R5LmZvckVhY2goZnVuY3Rpb24oc3RtdCkge1xuICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgc3RtdC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0RlZmF1bHQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJkZWZhdWx0OlwiKTtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnRfYm9keShvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9DYXNlLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiY2FzZVwiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCI6XCIpO1xuICAgICAgICBzZWxmLl9kb19wcmludF9ib2R5KG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgZXhjZXB0aW9ucyBdLS0tLS0gKi9cbiAgICBERUZQUklOVChBU1RfVHJ5LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwidHJ5XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgcHJpbnRfYnJhY2VkKHNlbGYsIG91dHB1dCk7XG4gICAgICAgIGlmIChzZWxmLmJjYXRjaCkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBzZWxmLmJjYXRjaC5wcmludChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmJmaW5hbGx5KSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHNlbGYuYmZpbmFsbHkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9DYXRjaCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcImNhdGNoXCIpO1xuICAgICAgICBpZiAoc2VsZi5hcmduYW1lKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFyZ25hbWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBwcmludF9icmFjZWQoc2VsZiwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfRmluYWxseSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcImZpbmFsbHlcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBwcmludF9icmFjZWQoc2VsZiwgb3V0cHV0KTtcbiAgICB9KTtcblxuICAgIC8qIC0tLS0tWyB2YXIvY29uc3QgXS0tLS0tICovXG4gICAgQVNUX0RlZmluaXRpb25zLkRFRk1FVEhPRChcIl9kb19wcmludFwiLCBmdW5jdGlvbihvdXRwdXQsIGtpbmQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KGtpbmQpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlZiwgaSkge1xuICAgICAgICAgICAgaWYgKGkpIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgZGVmLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcCA9IG91dHB1dC5wYXJlbnQoKTtcbiAgICAgICAgdmFyIGluX2ZvciA9IHAgaW5zdGFuY2VvZiBBU1RfRm9yIHx8IHAgaW5zdGFuY2VvZiBBU1RfRm9ySW47XG4gICAgICAgIHZhciBvdXRwdXRfc2VtaWNvbG9uID0gIWluX2ZvciB8fCBwICYmIHAuaW5pdCAhPT0gdGhpcztcbiAgICAgICAgaWYgKG91dHB1dF9zZW1pY29sb24pXG4gICAgICAgICAgICBvdXRwdXQuc2VtaWNvbG9uKCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0xldCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJsZXRcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1ZhciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCwgXCJ2YXJcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0NvbnN0LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5fZG9fcHJpbnQob3V0cHV0LCBcImNvbnN0XCIpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9JbXBvcnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJpbXBvcnRcIik7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBpZiAoc2VsZi5pbXBvcnRlZF9uYW1lKSB7XG4gICAgICAgICAgICBzZWxmLmltcG9ydGVkX25hbWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5pbXBvcnRlZF9uYW1lICYmIHNlbGYuaW1wb3J0ZWRfbmFtZXMpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIixcIik7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5pbXBvcnRlZF9uYW1lcykge1xuICAgICAgICAgICAgaWYgKHNlbGYuaW1wb3J0ZWRfbmFtZXMubGVuZ3RoID09PSAxICYmIHNlbGYuaW1wb3J0ZWRfbmFtZXNbMF0uZm9yZWlnbl9uYW1lLm5hbWUgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbXBvcnRlZF9uYW1lc1swXS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ7XCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuaW1wb3J0ZWRfbmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZV9pbXBvcnQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVfaW1wb3J0LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgc2VsZi5pbXBvcnRlZF9uYW1lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnByaW50KFwifVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5pbXBvcnRlZF9uYW1lIHx8IHNlbGYuaW1wb3J0ZWRfbmFtZXMpIHtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiZnJvbVwiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYubW9kdWxlX25hbWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9JbXBvcnRNZXRhLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiaW1wb3J0Lm1ldGFcIik7XG4gICAgfSk7XG5cbiAgICBERUZQUklOVChBU1RfTmFtZU1hcHBpbmcsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICB2YXIgaXNfaW1wb3J0ID0gb3V0cHV0LnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX0ltcG9ydDtcbiAgICAgICAgdmFyIGRlZmluaXRpb24gPSBzZWxmLm5hbWUuZGVmaW5pdGlvbigpO1xuICAgICAgICB2YXIgbmFtZXNfYXJlX2RpZmZlcmVudCA9XG4gICAgICAgICAgICAoZGVmaW5pdGlvbiAmJiBkZWZpbml0aW9uLm1hbmdsZWRfbmFtZSB8fCBzZWxmLm5hbWUubmFtZSkgIT09XG4gICAgICAgICAgICBzZWxmLmZvcmVpZ25fbmFtZS5uYW1lO1xuICAgICAgICBpZiAobmFtZXNfYXJlX2RpZmZlcmVudCkge1xuICAgICAgICAgICAgaWYgKGlzX2ltcG9ydCkge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChzZWxmLmZvcmVpZ25fbmFtZS5uYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5uYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImFzXCIpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBpZiAoaXNfaW1wb3J0KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5uYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChzZWxmLmZvcmVpZ25fbmFtZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYubmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBERUZQUklOVChBU1RfRXhwb3J0LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiZXhwb3J0XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgaWYgKHNlbGYuaXNfZGVmYXVsdCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiZGVmYXVsdFwiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLmV4cG9ydGVkX25hbWVzKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5leHBvcnRlZF9uYW1lcy5sZW5ndGggPT09IDEgJiYgc2VsZi5leHBvcnRlZF9uYW1lc1swXS5uYW1lLm5hbWUgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5leHBvcnRlZF9uYW1lc1swXS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ7XCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuZXhwb3J0ZWRfbmFtZXMuZm9yRWFjaChmdW5jdGlvbihuYW1lX2V4cG9ydCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZV9leHBvcnQucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBzZWxmLmV4cG9ydGVkX25hbWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIixcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCJ9XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuZXhwb3J0ZWRfdmFsdWUpIHtcbiAgICAgICAgICAgIHNlbGYuZXhwb3J0ZWRfdmFsdWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmV4cG9ydGVkX2RlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHNlbGYuZXhwb3J0ZWRfZGVmaW5pdGlvbi5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgaWYgKHNlbGYuZXhwb3J0ZWRfZGVmaW5pdGlvbiBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucykgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm1vZHVsZV9uYW1lKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcImZyb21cIik7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHNlbGYubW9kdWxlX25hbWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5leHBvcnRlZF92YWx1ZVxuICAgICAgICAgICAgICAgICYmICEoc2VsZi5leHBvcnRlZF92YWx1ZSBpbnN0YW5jZW9mIEFTVF9EZWZ1biB8fFxuICAgICAgICAgICAgICAgICAgICBzZWxmLmV4cG9ydGVkX3ZhbHVlIGluc3RhbmNlb2YgQVNUX0Z1bmN0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZXhwb3J0ZWRfdmFsdWUgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpXG4gICAgICAgICAgICB8fCBzZWxmLm1vZHVsZV9uYW1lXG4gICAgICAgICAgICB8fCBzZWxmLmV4cG9ydGVkX25hbWVzXG4gICAgICAgICkge1xuICAgICAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBwYXJlbnRoZXNpemVfZm9yX25vaW4obm9kZSwgb3V0cHV0LCBub2luKSB7XG4gICAgICAgIHZhciBwYXJlbnMgPSBmYWxzZTtcbiAgICAgICAgLy8gbmVlZCB0byB0YWtlIHNvbWUgcHJlY2F1dGlvbnMgaGVyZTpcbiAgICAgICAgLy8gICAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzYwXG4gICAgICAgIGlmIChub2luKSB7XG4gICAgICAgICAgICBwYXJlbnMgPSB3YWxrKG5vZGUsIG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgbm9kZS5vcGVyYXRvciA9PSBcImluXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGtfYWJvcnQ7ICAvLyBtYWtlcyB3YWxrKCkgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnByaW50KG91dHB1dCwgcGFyZW5zKTtcbiAgICB9XG5cbiAgICBERUZQUklOVChBU1RfVmFyRGVmLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5uYW1lLnByaW50KG91dHB1dCk7XG4gICAgICAgIGlmIChzZWxmLnZhbHVlKSB7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIj1cIik7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIHZhciBwID0gb3V0cHV0LnBhcmVudCgxKTtcbiAgICAgICAgICAgIHZhciBub2luID0gcCBpbnN0YW5jZW9mIEFTVF9Gb3IgfHwgcCBpbnN0YW5jZW9mIEFTVF9Gb3JJbjtcbiAgICAgICAgICAgIHBhcmVudGhlc2l6ZV9mb3Jfbm9pbihzZWxmLnZhbHVlLCBvdXRwdXQsIG5vaW4pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvKiAtLS0tLVsgb3RoZXIgZXhwcmVzc2lvbnMgXS0tLS0tICovXG4gICAgREVGUFJJTlQoQVNUX0NhbGwsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICAgICAgaWYgKHNlbGYgaW5zdGFuY2VvZiBBU1RfTmV3ICYmIHNlbGYuYXJncy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChzZWxmLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfQ2FsbCB8fCBzZWxmLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfTGFtYmRhKSB7XG4gICAgICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcoc2VsZi5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYub3B0aW9uYWwpIG91dHB1dC5wcmludChcIj8uXCIpO1xuICAgICAgICBvdXRwdXQud2l0aF9wYXJlbnMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmFyZ3MuZm9yRWFjaChmdW5jdGlvbihleHByLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkpIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgIGV4cHIucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfTmV3LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwibmV3XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgQVNUX0NhbGwucHJvdG90eXBlLl9jb2RlZ2VuKHNlbGYsIG91dHB1dCk7XG4gICAgfSk7XG5cbiAgICBBU1RfU2VxdWVuY2UuREVGTUVUSE9EKFwiX2RvX3ByaW50XCIsIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zLmZvckVhY2goZnVuY3Rpb24obm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0cHV0LnNob3VsZF9icmVhaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5pbmRlbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLnByaW50KG91dHB1dCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9TZXF1ZW5jZSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuX2RvX3ByaW50KG91dHB1dCk7XG4gICAgICAgIC8vIHZhciBwID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICAvLyBpZiAocCBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQpIHtcbiAgICAgICAgLy8gICAgIG91dHB1dC53aXRoX2luZGVudChvdXRwdXQubmV4dF9pbmRlbnQoKSwgZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgICAgICAvLyB9XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0RvdCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBleHByID0gc2VsZi5leHByZXNzaW9uO1xuICAgICAgICBleHByLnByaW50KG91dHB1dCk7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0eTtcbiAgICAgICAgdmFyIHByaW50X2NvbXB1dGVkID0gUkVTRVJWRURfV09SRFMuaGFzKHByb3ApXG4gICAgICAgICAgICA/IG91dHB1dC5vcHRpb24oXCJpZThcIilcbiAgICAgICAgICAgIDogIWlzX2lkZW50aWZpZXJfc3RyaW5nKFxuICAgICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgICAgb3V0cHV0Lm9wdGlvbihcImVjbWFcIikgPj0gMjAxNSB8fCBvdXRwdXQub3B0aW9uKFwic2FmYXJpMTBcIilcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgaWYgKHNlbGYub3B0aW9uYWwpIG91dHB1dC5wcmludChcIj8uXCIpO1xuXG4gICAgICAgIGlmIChwcmludF9jb21wdXRlZCkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiW1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5hZGRfbWFwcGluZyhzZWxmLmVuZCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnRfc3RyaW5nKHByb3ApO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiXVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgQVNUX051bWJlciAmJiBleHByLmdldFZhbHVlKCkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICghL1t4YS1mLildL2kudGVzdChvdXRwdXQubGFzdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5vcHRpb25hbCkgb3V0cHV0LnByaW50KFwiLlwiKTtcbiAgICAgICAgICAgIC8vIHRoZSBuYW1lIGFmdGVyIGRvdCB3b3VsZCBiZSBtYXBwZWQgYWJvdXQgaGVyZS5cbiAgICAgICAgICAgIG91dHB1dC5hZGRfbWFwcGluZyhzZWxmLmVuZCk7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnRfbmFtZShwcm9wKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Eb3RIYXNoLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGV4cHIgPSBzZWxmLmV4cHJlc3Npb247XG4gICAgICAgIGV4cHIucHJpbnQob3V0cHV0KTtcbiAgICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnR5O1xuXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbmFsKSBvdXRwdXQucHJpbnQoXCI/XCIpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCIuI1wiKTtcbiAgICAgICAgb3V0cHV0LnByaW50X25hbWUocHJvcCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1N1YiwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAoc2VsZi5vcHRpb25hbCkgb3V0cHV0LnByaW50KFwiPy5cIik7XG4gICAgICAgIG91dHB1dC5wcmludChcIltcIik7XG4gICAgICAgIHNlbGYucHJvcGVydHkucHJpbnQob3V0cHV0KTtcbiAgICAgICAgb3V0cHV0LnByaW50KFwiXVwiKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ2hhaW4sIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24ucHJpbnQob3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICB2YXIgb3AgPSBzZWxmLm9wZXJhdG9yO1xuICAgICAgICBvdXRwdXQucHJpbnQob3ApO1xuICAgICAgICBpZiAoL15bYS16XS9pLnRlc3Qob3ApXG4gICAgICAgICAgICB8fCAoL1srLV0kLy50ZXN0KG9wKVxuICAgICAgICAgICAgICAgICYmIHNlbGYuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeFxuICAgICAgICAgICAgICAgICYmIC9eWystXS8udGVzdChzZWxmLmV4cHJlc3Npb24ub3BlcmF0b3IpKSkge1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5leHByZXNzaW9uLnByaW50KG91dHB1dCk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1VuYXJ5UG9zdGZpeCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbi5wcmludChvdXRwdXQpO1xuICAgICAgICBvdXRwdXQucHJpbnQoc2VsZi5vcGVyYXRvcik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0JpbmFyeSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBvcCA9IHNlbGYub3BlcmF0b3I7XG4gICAgICAgIHNlbGYubGVmdC5wcmludChvdXRwdXQpO1xuICAgICAgICBpZiAob3BbMF0gPT0gXCI+XCIgLyogXCI+PlwiIFwiPj4+XCIgXCI+XCIgXCI+PVwiICovXG4gICAgICAgICAgICAmJiBzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfVW5hcnlQb3N0Zml4XG4gICAgICAgICAgICAmJiBzZWxmLmxlZnQub3BlcmF0b3IgPT0gXCItLVwiKSB7XG4gICAgICAgICAgICAvLyBzcGFjZSBpcyBtYW5kYXRvcnkgdG8gYXZvaWQgb3V0cHV0dGluZyAtLT5cbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIiBcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGUgc3BhY2UgaXMgb3B0aW9uYWwgZGVwZW5kaW5nIG9uIFwiYmVhdXRpZnlcIlxuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnByaW50KG9wKTtcbiAgICAgICAgaWYgKChvcCA9PSBcIjxcIiB8fCBvcCA9PSBcIjw8XCIpXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0Lm9wZXJhdG9yID09IFwiIVwiXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQuZXhwcmVzc2lvbi5vcGVyYXRvciA9PSBcIi0tXCIpIHtcbiAgICAgICAgICAgIC8vIHNwYWNlIGlzIG1hbmRhdG9yeSB0byBhdm9pZCBvdXRwdXR0aW5nIDwhLS1cbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIiBcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGUgc3BhY2UgaXMgb3B0aW9uYWwgZGVwZW5kaW5nIG9uIFwiYmVhdXRpZnlcIlxuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5yaWdodC5wcmludChvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuY29uZGl0aW9uLnByaW50KG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQucHJpbnQoXCI/XCIpO1xuICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgc2VsZi5jb25zZXF1ZW50LnByaW50KG91dHB1dCk7XG4gICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICBvdXRwdXQuY29sb24oKTtcbiAgICAgICAgc2VsZi5hbHRlcm5hdGl2ZS5wcmludChvdXRwdXQpO1xuICAgIH0pO1xuXG4gICAgLyogLS0tLS1bIGxpdGVyYWxzIF0tLS0tLSAqL1xuICAgIERFRlBSSU5UKEFTVF9BcnJheSwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC53aXRoX3NxdWFyZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhID0gc2VsZi5lbGVtZW50cywgbGVuID0gYS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuID4gMCkgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24oZXhwLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkpIG91dHB1dC5jb21tYSgpO1xuICAgICAgICAgICAgICAgIGV4cC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmaW5hbCBlbGVtZW50IGlzIGEgaG9sZSwgd2UgbmVlZCB0byBtYWtlIHN1cmUgaXRcbiAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IGxvb2sgbGlrZSBhIHRyYWlsaW5nIGNvbW1hLCBieSBpbnNlcnRpbmcgYW4gYWN0dWFsXG4gICAgICAgICAgICAgICAgLy8gdHJhaWxpbmcgY29tbWEuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGxlbiAtIDEgJiYgZXhwIGluc3RhbmNlb2YgQVNUX0hvbGUpXG4gICAgICAgICAgICAgICAgICBvdXRwdXQuY29tbWEoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGxlbiA+IDApIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfT2JqZWN0LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKHNlbGYucHJvcGVydGllcy5sZW5ndGggPiAwKSBvdXRwdXQud2l0aF9ibG9jayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3AsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIsXCIpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICAgICAgcHJvcC5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxzZSBwcmludF9icmFjZWRfZW1wdHkoc2VsZiwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ2xhc3MsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoXCJjbGFzc1wiKTtcbiAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIGlmIChzZWxmLm5hbWUpIHtcbiAgICAgICAgICAgIHNlbGYubmFtZS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0LnNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuZXh0ZW5kcykge1xuICAgICAgICAgICAgdmFyIHBhcmVucyA9IChcbiAgICAgICAgICAgICAgICAgICAhKHNlbGYuZXh0ZW5kcyBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpXG4gICAgICAgICAgICAgICAgJiYgIShzZWxmLmV4dGVuZHMgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcylcbiAgICAgICAgICAgICAgICAmJiAhKHNlbGYuZXh0ZW5kcyBpbnN0YW5jZW9mIEFTVF9DbGFzc0V4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgJiYgIShzZWxmLmV4dGVuZHMgaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb24pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiZXh0ZW5kc1wiKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnMpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHJpbnQoXCIoXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZXh0ZW5kcy5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgaWYgKHBhcmVucykge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wcmludChcIilcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnByb3BlcnRpZXMubGVuZ3RoID4gMCkgb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbihwcm9wLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0cHV0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgIHByb3AucHJpbnQob3V0cHV0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3V0cHV0Lm5ld2xpbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsc2Ugb3V0cHV0LnByaW50KFwie31cIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX05ld1RhcmdldCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcIm5ldy50YXJnZXRcIik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBwcmludF9wcm9wZXJ0eV9uYW1lKGtleSwgcXVvdGUsIG91dHB1dCkge1xuICAgICAgICBpZiAob3V0cHV0Lm9wdGlvbihcInF1b3RlX2tleXNcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQucHJpbnRfc3RyaW5nKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiXCIgKyAra2V5ID09IGtleSAmJiBrZXkgPj0gMCkge1xuICAgICAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJrZWVwX251bWJlcnNcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0LnByaW50KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0LnByaW50KG1ha2VfbnVtKGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmludF9zdHJpbmcgPSBSRVNFUlZFRF9XT1JEUy5oYXMoa2V5KVxuICAgICAgICAgICAgPyBvdXRwdXQub3B0aW9uKFwiaWU4XCIpXG4gICAgICAgICAgICA6IChcbiAgICAgICAgICAgICAgICBvdXRwdXQub3B0aW9uKFwiZWNtYVwiKSA8IDIwMTUgfHwgb3V0cHV0Lm9wdGlvbihcInNhZmFyaTEwXCIpXG4gICAgICAgICAgICAgICAgICAgID8gIWlzX2Jhc2ljX2lkZW50aWZpZXJfc3RyaW5nKGtleSlcbiAgICAgICAgICAgICAgICAgICAgOiAhaXNfaWRlbnRpZmllcl9zdHJpbmcoa2V5LCB0cnVlKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgaWYgKHByaW50X3N0cmluZyB8fCAocXVvdGUgJiYgb3V0cHV0Lm9wdGlvbihcImtlZXBfcXVvdGVkX3Byb3BzXCIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5wcmludF9zdHJpbmcoa2V5LCBxdW90ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC5wcmludF9uYW1lKGtleSk7XG4gICAgfVxuXG4gICAgREVGUFJJTlQoQVNUX09iamVjdEtleVZhbCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGdldF9uYW1lKHNlbGYpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBzZWxmLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBkZWYgPyBkZWYubWFuZ2xlZF9uYW1lIHx8IGRlZi5uYW1lIDogc2VsZi5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFsbG93U2hvcnRIYW5kID0gb3V0cHV0Lm9wdGlvbihcInNob3J0aGFuZFwiKTtcbiAgICAgICAgaWYgKGFsbG93U2hvcnRIYW5kICYmXG4gICAgICAgICAgICBzZWxmLnZhbHVlIGluc3RhbmNlb2YgQVNUX1N5bWJvbCAmJlxuICAgICAgICAgICAgaXNfaWRlbnRpZmllcl9zdHJpbmcoXG4gICAgICAgICAgICAgICAgc2VsZi5rZXksXG4gICAgICAgICAgICAgICAgb3V0cHV0Lm9wdGlvbihcImVjbWFcIikgPj0gMjAxNSB8fCBvdXRwdXQub3B0aW9uKFwic2FmYXJpMTBcIilcbiAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgIGdldF9uYW1lKHNlbGYudmFsdWUpID09PSBzZWxmLmtleSAmJlxuICAgICAgICAgICAgIVJFU0VSVkVEX1dPUkRTLmhhcyhzZWxmLmtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludF9wcm9wZXJ0eV9uYW1lKHNlbGYua2V5LCBzZWxmLnF1b3RlLCBvdXRwdXQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoYWxsb3dTaG9ydEhhbmQgJiZcbiAgICAgICAgICAgIHNlbGYudmFsdWUgaW5zdGFuY2VvZiBBU1RfRGVmYXVsdEFzc2lnbiAmJlxuICAgICAgICAgICAgc2VsZi52YWx1ZS5sZWZ0IGluc3RhbmNlb2YgQVNUX1N5bWJvbCAmJlxuICAgICAgICAgICAgaXNfaWRlbnRpZmllcl9zdHJpbmcoXG4gICAgICAgICAgICAgICAgc2VsZi5rZXksXG4gICAgICAgICAgICAgICAgb3V0cHV0Lm9wdGlvbihcImVjbWFcIikgPj0gMjAxNSB8fCBvdXRwdXQub3B0aW9uKFwic2FmYXJpMTBcIilcbiAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgIGdldF9uYW1lKHNlbGYudmFsdWUubGVmdCkgPT09IHNlbGYua2V5XG4gICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRfcHJvcGVydHlfbmFtZShzZWxmLmtleSwgc2VsZi5xdW90ZSwgb3V0cHV0KTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiPVwiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICAgICAgc2VsZi52YWx1ZS5yaWdodC5wcmludChvdXRwdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEoc2VsZi5rZXkgaW5zdGFuY2VvZiBBU1RfTm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwcmludF9wcm9wZXJ0eV9uYW1lKHNlbGYua2V5LCBzZWxmLnF1b3RlLCBvdXRwdXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQud2l0aF9zcXVhcmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYua2V5LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQuY29sb24oKTtcbiAgICAgICAgICAgIHNlbGYudmFsdWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9DbGFzc1ByaXZhdGVQcm9wZXJ0eSwgKHNlbGYsIG91dHB1dCkgPT4ge1xuICAgICAgICBpZiAoc2VsZi5zdGF0aWMpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcInN0YXRpY1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnByaW50KFwiI1wiKTtcbiAgICAgICAgXG4gICAgICAgIHByaW50X3Byb3BlcnR5X25hbWUoc2VsZi5rZXkubmFtZSwgc2VsZi5xdW90ZSwgb3V0cHV0KTtcblxuICAgICAgICBpZiAoc2VsZi52YWx1ZSkge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiPVwiKTtcbiAgICAgICAgICAgIHNlbGYudmFsdWUucHJpbnQob3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5zZW1pY29sb24oKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ2xhc3NQcm9wZXJ0eSwgKHNlbGYsIG91dHB1dCkgPT4ge1xuICAgICAgICBpZiAoc2VsZi5zdGF0aWMpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcInN0YXRpY1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYua2V5IGluc3RhbmNlb2YgQVNUX1N5bWJvbENsYXNzUHJvcGVydHkpIHtcbiAgICAgICAgICAgIHByaW50X3Byb3BlcnR5X25hbWUoc2VsZi5rZXkubmFtZSwgc2VsZi5xdW90ZSwgb3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIltcIik7XG4gICAgICAgICAgICBzZWxmLmtleS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwiXVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnZhbHVlKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQoXCI9XCIpO1xuICAgICAgICAgICAgc2VsZi52YWx1ZS5wcmludChvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0LnNlbWljb2xvbigpO1xuICAgIH0pO1xuICAgIEFTVF9PYmplY3RQcm9wZXJ0eS5ERUZNRVRIT0QoXCJfcHJpbnRfZ2V0dGVyX3NldHRlclwiLCBmdW5jdGlvbih0eXBlLCBpc19wcml2YXRlLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZi5zdGF0aWMpIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcInN0YXRpY1wiKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGFjZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICBvdXRwdXQucHJpbnQodHlwZSk7XG4gICAgICAgICAgICBvdXRwdXQuc3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5rZXkgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAoaXNfcHJpdmF0ZSkgb3V0cHV0LnByaW50KFwiI1wiKTtcbiAgICAgICAgICAgIHByaW50X3Byb3BlcnR5X25hbWUoc2VsZi5rZXkubmFtZSwgc2VsZi5xdW90ZSwgb3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC53aXRoX3NxdWFyZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmtleS5wcmludChvdXRwdXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi52YWx1ZS5fZG9fcHJpbnQob3V0cHV0LCB0cnVlKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfT2JqZWN0U2V0dGVyLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5fcHJpbnRfZ2V0dGVyX3NldHRlcihcInNldFwiLCBmYWxzZSwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfT2JqZWN0R2V0dGVyLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgc2VsZi5fcHJpbnRfZ2V0dGVyX3NldHRlcihcImdldFwiLCBmYWxzZSwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfUHJpdmF0ZVNldHRlciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuX3ByaW50X2dldHRlcl9zZXR0ZXIoXCJzZXRcIiwgdHJ1ZSwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfUHJpdmF0ZUdldHRlciwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHNlbGYuX3ByaW50X2dldHRlcl9zZXR0ZXIoXCJnZXRcIiwgdHJ1ZSwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfUHJpdmF0ZU1ldGhvZCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciB0eXBlO1xuICAgICAgICBpZiAoc2VsZi5pc19nZW5lcmF0b3IgJiYgc2VsZi5hc3luYykge1xuICAgICAgICAgICAgdHlwZSA9IFwiYXN5bmMqXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi5pc19nZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcIipcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmFzeW5jKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJhc3luY1wiO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX3ByaW50X2dldHRlcl9zZXR0ZXIodHlwZSwgdHJ1ZSwgb3V0cHV0KTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfQ29uY2lzZU1ldGhvZCwgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciB0eXBlO1xuICAgICAgICBpZiAoc2VsZi5pc19nZW5lcmF0b3IgJiYgc2VsZi5hc3luYykge1xuICAgICAgICAgICAgdHlwZSA9IFwiYXN5bmMqXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi5pc19nZW5lcmF0b3IpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcIipcIjtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmFzeW5jKSB7XG4gICAgICAgICAgICB0eXBlID0gXCJhc3luY1wiO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuX3ByaW50X2dldHRlcl9zZXR0ZXIodHlwZSwgZmFsc2UsIG91dHB1dCk7XG4gICAgfSk7XG4gICAgQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJfZG9fcHJpbnRcIiwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIHZhciBkZWYgPSB0aGlzLmRlZmluaXRpb24oKTtcbiAgICAgICAgb3V0cHV0LnByaW50X25hbWUoZGVmID8gZGVmLm1hbmdsZWRfbmFtZSB8fCBkZWYubmFtZSA6IHRoaXMubmFtZSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1N5bWJvbCwgZnVuY3Rpb24gKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBzZWxmLl9kb19wcmludChvdXRwdXQpO1xuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9Ib2xlLCBub29wKTtcbiAgICBERUZQUklOVChBU1RfVGhpcywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludChcInRoaXNcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1N1cGVyLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KFwic3VwZXJcIik7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX0NvbnN0YW50LCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0LnByaW50KHNlbGYuZ2V0VmFsdWUoKSk7XG4gICAgfSk7XG4gICAgREVGUFJJTlQoQVNUX1N0cmluZywgZnVuY3Rpb24oc2VsZiwgb3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5wcmludF9zdHJpbmcoc2VsZi5nZXRWYWx1ZSgpLCBzZWxmLnF1b3RlLCBvdXRwdXQuaW5fZGlyZWN0aXZlKTtcbiAgICB9KTtcbiAgICBERUZQUklOVChBU1RfTnVtYmVyLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKChvdXRwdXQub3B0aW9uKFwia2VlcF9udW1iZXJzXCIpIHx8IG91dHB1dC51c2VfYXNtKSAmJiBzZWxmLnJhdykge1xuICAgICAgICAgICAgb3V0cHV0LnByaW50KHNlbGYucmF3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChtYWtlX251bShzZWxmLmdldFZhbHVlKCkpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIERFRlBSSU5UKEFTVF9CaWdJbnQsIGZ1bmN0aW9uKHNlbGYsIG91dHB1dCkge1xuICAgICAgICBvdXRwdXQucHJpbnQoc2VsZi5nZXRWYWx1ZSgpICsgXCJuXCIpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgcl9zbGFzaF9zY3JpcHQgPSAvKDxcXHMqXFwvXFxzKnNjcmlwdCkvaTtcbiAgICBjb25zdCBzbGFzaF9zY3JpcHRfcmVwbGFjZSA9IChfLCAkMSkgPT4gJDEucmVwbGFjZShcIi9cIiwgXCJcXFxcL1wiKTtcbiAgICBERUZQUklOVChBU1RfUmVnRXhwLCBmdW5jdGlvbihzZWxmLCBvdXRwdXQpIHtcbiAgICAgICAgbGV0IHsgc291cmNlLCBmbGFncyB9ID0gc2VsZi5nZXRWYWx1ZSgpO1xuICAgICAgICBzb3VyY2UgPSByZWdleHBfc291cmNlX2ZpeChzb3VyY2UpO1xuICAgICAgICBmbGFncyA9IGZsYWdzID8gc29ydF9yZWdleHBfZmxhZ3MoZmxhZ3MpIDogXCJcIjtcbiAgICAgICAgc291cmNlID0gc291cmNlLnJlcGxhY2Uocl9zbGFzaF9zY3JpcHQsIHNsYXNoX3NjcmlwdF9yZXBsYWNlKTtcblxuICAgICAgICBvdXRwdXQucHJpbnQob3V0cHV0LnRvX3V0ZjgoYC8ke3NvdXJjZX0vJHtmbGFnc31gKSk7XG5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gb3V0cHV0LnBhcmVudCgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAmJiAvXlxcdy8udGVzdChwYXJlbnQub3BlcmF0b3IpXG4gICAgICAgICAgICAmJiBwYXJlbnQubGVmdCA9PT0gc2VsZlxuICAgICAgICApIHtcbiAgICAgICAgICAgIG91dHB1dC5wcmludChcIiBcIik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGZvcmNlX3N0YXRlbWVudChzdGF0LCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKG91dHB1dC5vcHRpb24oXCJicmFjZXNcIikpIHtcbiAgICAgICAgICAgIG1ha2VfYmxvY2soc3RhdCwgb3V0cHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc3RhdCB8fCBzdGF0IGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KVxuICAgICAgICAgICAgICAgIG91dHB1dC5mb3JjZV9zZW1pY29sb24oKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdGF0LnByaW50KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiZXN0X29mKGEpIHtcbiAgICAgICAgdmFyIGJlc3QgPSBhWzBdLCBsZW4gPSBiZXN0Lmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYVtpXS5sZW5ndGggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBiZXN0ID0gYVtpXTtcbiAgICAgICAgICAgICAgICBsZW4gPSBiZXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlX251bShudW0pIHtcbiAgICAgICAgdmFyIHN0ciA9IG51bS50b1N0cmluZygxMCkucmVwbGFjZSgvXjBcXC4vLCBcIi5cIikucmVwbGFjZShcImUrXCIsIFwiZVwiKTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbIHN0ciBdO1xuICAgICAgICBpZiAoTWF0aC5mbG9vcihudW0pID09PSBudW0pIHtcbiAgICAgICAgICAgIGlmIChudW0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKFwiLTB4XCIgKyAoLW51bSkudG9TdHJpbmcoMTYpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goXCIweFwiICsgbnVtLnRvU3RyaW5nKDE2KS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0Y2gsIGxlbiwgZGlnaXRzO1xuICAgICAgICBpZiAobWF0Y2ggPSAvXlxcLjArLy5leGVjKHN0cikpIHtcbiAgICAgICAgICAgIGxlbiA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGRpZ2l0cyA9IHN0ci5zbGljZShsZW4pO1xuICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKGRpZ2l0cyArIFwiZS1cIiArIChkaWdpdHMubGVuZ3RoICsgbGVuIC0gMSkpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID0gLzArJC8uZXhlYyhzdHIpKSB7XG4gICAgICAgICAgICBsZW4gPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goc3RyLnNsaWNlKDAsIC1sZW4pICsgXCJlXCIgKyBsZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID0gL14oXFxkKVxcLihcXGQrKWUoLT9cXGQrKSQvLmV4ZWMoc3RyKSkge1xuICAgICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKG1hdGNoWzFdICsgbWF0Y2hbMl0gKyBcImVcIiArIChtYXRjaFszXSAtIG1hdGNoWzJdLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0X29mKGNhbmRpZGF0ZXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VfYmxvY2soc3RtdCwgb3V0cHV0KSB7XG4gICAgICAgIGlmICghc3RtdCB8fCBzdG10IGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KVxuICAgICAgICAgICAgb3V0cHV0LnByaW50KFwie31cIik7XG4gICAgICAgIGVsc2UgaWYgKHN0bXQgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpXG4gICAgICAgICAgICBzdG10LnByaW50KG91dHB1dCk7XG4gICAgICAgIGVsc2Ugb3V0cHV0LndpdGhfYmxvY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBvdXRwdXQuaW5kZW50KCk7XG4gICAgICAgICAgICBzdG10LnByaW50KG91dHB1dCk7XG4gICAgICAgICAgICBvdXRwdXQubmV3bGluZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiAtLS0tLVsgc291cmNlIG1hcCBnZW5lcmF0b3JzIF0tLS0tLSAqL1xuXG4gICAgZnVuY3Rpb24gREVGTUFQKG5vZGV0eXBlLCBnZW5lcmF0b3IpIHtcbiAgICAgICAgbm9kZXR5cGUuZm9yRWFjaChmdW5jdGlvbihub2RldHlwZSkge1xuICAgICAgICAgICAgbm9kZXR5cGUuREVGTUVUSE9EKFwiYWRkX3NvdXJjZV9tYXBcIiwgZ2VuZXJhdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgREVGTUFQKFtcbiAgICAgICAgLy8gV2UgY291bGQgZWFzaWx5IGFkZCBpbmZvIGZvciBBTEwgbm9kZXMsIGJ1dCBpdCBzZWVtcyB0byBtZSB0aGF0XG4gICAgICAgIC8vIHdvdWxkIGJlIHF1aXRlIHdhc3RlZnVsLCBoZW5jZSB0aGlzIG5vb3AgaW4gdGhlIGJhc2UgY2xhc3MuXG4gICAgICAgIEFTVF9Ob2RlLFxuICAgICAgICAvLyBzaW5jZSB0aGUgbGFiZWwgc3ltYm9sIHdpbGwgbWFyayBpdFxuICAgICAgICBBU1RfTGFiZWxlZFN0YXRlbWVudCxcbiAgICAgICAgQVNUX1RvcGxldmVsLFxuICAgIF0sIG5vb3ApO1xuXG4gICAgLy8gWFhYOiBJJ20gbm90IGV4YWN0bHkgc3VyZSBpZiB3ZSBuZWVkIGl0IGZvciBhbGwgb2YgdGhlc2Ugbm9kZXMsXG4gICAgLy8gb3IgaWYgd2Ugc2hvdWxkIGFkZCBldmVuIG1vcmUuXG4gICAgREVGTUFQKFtcbiAgICAgICAgQVNUX0FycmF5LFxuICAgICAgICBBU1RfQmxvY2tTdGF0ZW1lbnQsXG4gICAgICAgIEFTVF9DYXRjaCxcbiAgICAgICAgQVNUX0NsYXNzLFxuICAgICAgICBBU1RfQ29uc3RhbnQsXG4gICAgICAgIEFTVF9EZWJ1Z2dlcixcbiAgICAgICAgQVNUX0RlZmluaXRpb25zLFxuICAgICAgICBBU1RfRGlyZWN0aXZlLFxuICAgICAgICBBU1RfRmluYWxseSxcbiAgICAgICAgQVNUX0p1bXAsXG4gICAgICAgIEFTVF9MYW1iZGEsXG4gICAgICAgIEFTVF9OZXcsXG4gICAgICAgIEFTVF9PYmplY3QsXG4gICAgICAgIEFTVF9TdGF0ZW1lbnRXaXRoQm9keSxcbiAgICAgICAgQVNUX1N5bWJvbCxcbiAgICAgICAgQVNUX1N3aXRjaCxcbiAgICAgICAgQVNUX1N3aXRjaEJyYW5jaCxcbiAgICAgICAgQVNUX1RlbXBsYXRlU3RyaW5nLFxuICAgICAgICBBU1RfVGVtcGxhdGVTZWdtZW50LFxuICAgICAgICBBU1RfVHJ5LFxuICAgIF0sIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcodGhpcy5zdGFydCk7XG4gICAgfSk7XG5cbiAgICBERUZNQVAoW1xuICAgICAgICBBU1RfT2JqZWN0R2V0dGVyLFxuICAgICAgICBBU1RfT2JqZWN0U2V0dGVyLFxuICAgIF0sIGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICBvdXRwdXQuYWRkX21hcHBpbmcodGhpcy5zdGFydCwgdGhpcy5rZXkubmFtZSk7XG4gICAgfSk7XG5cbiAgICBERUZNQVAoWyBBU1RfT2JqZWN0UHJvcGVydHkgXSwgZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIG91dHB1dC5hZGRfbWFwcGluZyh0aGlzLnN0YXJ0LCB0aGlzLmtleSk7XG4gICAgfSk7XG59KSgpO1xuXG5jb25zdCBzaGFsbG93X2NtcCA9IChub2RlMSwgbm9kZTIpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgICBub2RlMSA9PT0gbnVsbCAmJiBub2RlMiA9PT0gbnVsbFxuICAgICAgICB8fCBub2RlMS5UWVBFID09PSBub2RlMi5UWVBFICYmIG5vZGUxLnNoYWxsb3dfY21wKG5vZGUyKVxuICAgICk7XG59O1xuXG5jb25zdCBlcXVpdmFsZW50X3RvID0gKHRyZWUxLCB0cmVlMikgPT4ge1xuICAgIGlmICghc2hhbGxvd19jbXAodHJlZTEsIHRyZWUyKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHdhbGtfMV9zdGF0ZSA9IFt0cmVlMV07XG4gICAgY29uc3Qgd2Fsa18yX3N0YXRlID0gW3RyZWUyXTtcblxuICAgIGNvbnN0IHdhbGtfMV9wdXNoID0gd2Fsa18xX3N0YXRlLnB1c2guYmluZCh3YWxrXzFfc3RhdGUpO1xuICAgIGNvbnN0IHdhbGtfMl9wdXNoID0gd2Fsa18yX3N0YXRlLnB1c2guYmluZCh3YWxrXzJfc3RhdGUpO1xuXG4gICAgd2hpbGUgKHdhbGtfMV9zdGF0ZS5sZW5ndGggJiYgd2Fsa18yX3N0YXRlLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBub2RlXzEgPSB3YWxrXzFfc3RhdGUucG9wKCk7XG4gICAgICAgIGNvbnN0IG5vZGVfMiA9IHdhbGtfMl9zdGF0ZS5wb3AoKTtcblxuICAgICAgICBpZiAoIXNoYWxsb3dfY21wKG5vZGVfMSwgbm9kZV8yKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIG5vZGVfMS5fY2hpbGRyZW5fYmFja3dhcmRzKHdhbGtfMV9wdXNoKTtcbiAgICAgICAgbm9kZV8yLl9jaGlsZHJlbl9iYWNrd2FyZHMod2Fsa18yX3B1c2gpO1xuXG4gICAgICAgIGlmICh3YWxrXzFfc3RhdGUubGVuZ3RoICE9PSB3YWxrXzJfc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBEaWZmZXJlbnQgbnVtYmVyIG9mIGNoaWxkcmVuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd2Fsa18xX3N0YXRlLmxlbmd0aCA9PSAwICYmIHdhbGtfMl9zdGF0ZS5sZW5ndGggPT0gMDtcbn07XG5cbi8vIENyZWF0ZXMgYSBzaGFsbG93IGNvbXBhcmUgZnVuY3Rpb25cbmNvbnN0IG1rc2hhbGxvdyA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IGNvbXBhcmlzb25zID0gT2JqZWN0XG4gICAgICAgIC5rZXlzKHByb3BzKVxuICAgICAgICAubWFwKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvcHNba2V5XSA9PT0gXCJlcVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGB0aGlzLiR7a2V5fSA9PT0gb3RoZXIuJHtrZXl9YDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcHNba2V5XSA9PT0gXCJleGlzdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAodGhpcy4ke2tleX0gPT0gbnVsbCA/IG90aGVyLiR7a2V5fSA9PSBudWxsIDogdGhpcy4ke2tleX0gPT09IG90aGVyLiR7a2V5fSlgO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1rc2hhbGxvdzogVW5leHBlY3RlZCBpbnN0cnVjdGlvbjogJHtwcm9wc1trZXldfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuam9pbihcIiAmJiBcIik7XG5cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwib3RoZXJcIiwgXCJyZXR1cm4gXCIgKyBjb21wYXJpc29ucyk7XG59O1xuXG5jb25zdCBwYXNzX3Rocm91Z2ggPSAoKSA9PiB0cnVlO1xuXG5BU1RfTm9kZS5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGlkIG5vdCBmaW5kIGEgc2hhbGxvd19jbXAgZnVuY3Rpb24gZm9yIFwiICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lKTtcbn07XG5cbkFTVF9EZWJ1Z2dlci5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9EaXJlY3RpdmUucHJvdG90eXBlLnNoYWxsb3dfY21wID0gbWtzaGFsbG93KHsgdmFsdWU6IFwiZXFcIiB9KTtcblxuQVNUX1NpbXBsZVN0YXRlbWVudC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9CbG9jay5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9FbXB0eVN0YXRlbWVudC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9MYWJlbGVkU3RhdGVtZW50LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IG1rc2hhbGxvdyh7IFwibGFiZWwubmFtZVwiOiBcImVxXCIgfSk7XG5cbkFTVF9Eby5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9XaGlsZS5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9Gb3IucHJvdG90eXBlLnNoYWxsb3dfY21wID0gbWtzaGFsbG93KHtcbiAgICBpbml0OiBcImV4aXN0XCIsXG4gICAgY29uZGl0aW9uOiBcImV4aXN0XCIsXG4gICAgc3RlcDogXCJleGlzdFwiXG59KTtcblxuQVNUX0ZvckluLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0Zvck9mLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX1dpdGgucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfVG9wbGV2ZWwucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfRXhwYW5zaW9uLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0xhbWJkYS5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBta3NoYWxsb3coe1xuICAgIGlzX2dlbmVyYXRvcjogXCJlcVwiLFxuICAgIGFzeW5jOiBcImVxXCJcbn0pO1xuXG5BU1RfRGVzdHJ1Y3R1cmluZy5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBta3NoYWxsb3coe1xuICAgIGlzX2FycmF5OiBcImVxXCJcbn0pO1xuXG5BU1RfUHJlZml4ZWRUZW1wbGF0ZVN0cmluZy5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9UZW1wbGF0ZVN0cmluZy5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9UZW1wbGF0ZVNlZ21lbnQucHJvdG90eXBlLnNoYWxsb3dfY21wID0gbWtzaGFsbG93KHtcbiAgICBcInZhbHVlXCI6IFwiZXFcIlxufSk7XG5cbkFTVF9KdW1wLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0xvb3BDb250cm9sLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0F3YWl0LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX1lpZWxkLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IG1rc2hhbGxvdyh7XG4gICAgaXNfc3RhcjogXCJlcVwiXG59KTtcblxuQVNUX0lmLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IG1rc2hhbGxvdyh7XG4gICAgYWx0ZXJuYXRpdmU6IFwiZXhpc3RcIlxufSk7XG5cbkFTVF9Td2l0Y2gucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfU3dpdGNoQnJhbmNoLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX1RyeS5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBta3NoYWxsb3coe1xuICAgIGJjYXRjaDogXCJleGlzdFwiLFxuICAgIGJmaW5hbGx5OiBcImV4aXN0XCJcbn0pO1xuXG5BU1RfQ2F0Y2gucHJvdG90eXBlLnNoYWxsb3dfY21wID0gbWtzaGFsbG93KHtcbiAgICBhcmduYW1lOiBcImV4aXN0XCJcbn0pO1xuXG5BU1RfRmluYWxseS5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9EZWZpbml0aW9ucy5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9WYXJEZWYucHJvdG90eXBlLnNoYWxsb3dfY21wID0gbWtzaGFsbG93KHtcbiAgICB2YWx1ZTogXCJleGlzdFwiXG59KTtcblxuQVNUX05hbWVNYXBwaW5nLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0ltcG9ydC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBta3NoYWxsb3coe1xuICAgIGltcG9ydGVkX25hbWU6IFwiZXhpc3RcIixcbiAgICBpbXBvcnRlZF9uYW1lczogXCJleGlzdFwiXG59KTtcblxuQVNUX0ltcG9ydE1ldGEucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfRXhwb3J0LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IG1rc2hhbGxvdyh7XG4gICAgZXhwb3J0ZWRfZGVmaW5pdGlvbjogXCJleGlzdFwiLFxuICAgIGV4cG9ydGVkX3ZhbHVlOiBcImV4aXN0XCIsXG4gICAgZXhwb3J0ZWRfbmFtZXM6IFwiZXhpc3RcIixcbiAgICBtb2R1bGVfbmFtZTogXCJlcVwiLFxuICAgIGlzX2RlZmF1bHQ6IFwiZXFcIixcbn0pO1xuXG5BU1RfQ2FsbC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9TZXF1ZW5jZS5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBwYXNzX3Rocm91Z2g7XG5cbkFTVF9Qcm9wQWNjZXNzLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0NoYWluLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX0RvdC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBta3NoYWxsb3coe1xuICAgIHByb3BlcnR5OiBcImVxXCJcbn0pO1xuXG5BU1RfRG90SGFzaC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBta3NoYWxsb3coe1xuICAgIHByb3BlcnR5OiBcImVxXCJcbn0pO1xuXG5BU1RfVW5hcnkucHJvdG90eXBlLnNoYWxsb3dfY21wID0gbWtzaGFsbG93KHtcbiAgICBvcGVyYXRvcjogXCJlcVwiXG59KTtcblxuQVNUX0JpbmFyeS5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBta3NoYWxsb3coe1xuICAgIG9wZXJhdG9yOiBcImVxXCJcbn0pO1xuXG5BU1RfQ29uZGl0aW9uYWwucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfQXJyYXkucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfT2JqZWN0LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX09iamVjdFByb3BlcnR5LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX09iamVjdEtleVZhbC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBta3NoYWxsb3coe1xuICAgIGtleTogXCJlcVwiXG59KTtcblxuQVNUX09iamVjdFNldHRlci5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBta3NoYWxsb3coe1xuICAgIHN0YXRpYzogXCJlcVwiXG59KTtcblxuQVNUX09iamVjdEdldHRlci5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBta3NoYWxsb3coe1xuICAgIHN0YXRpYzogXCJlcVwiXG59KTtcblxuQVNUX0NvbmNpc2VNZXRob2QucHJvdG90eXBlLnNoYWxsb3dfY21wID0gbWtzaGFsbG93KHtcbiAgICBzdGF0aWM6IFwiZXFcIixcbiAgICBpc19nZW5lcmF0b3I6IFwiZXFcIixcbiAgICBhc3luYzogXCJlcVwiLFxufSk7XG5cbkFTVF9DbGFzcy5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBta3NoYWxsb3coe1xuICAgIG5hbWU6IFwiZXhpc3RcIixcbiAgICBleHRlbmRzOiBcImV4aXN0XCIsXG59KTtcblxuQVNUX0NsYXNzUHJvcGVydHkucHJvdG90eXBlLnNoYWxsb3dfY21wID0gbWtzaGFsbG93KHtcbiAgICBzdGF0aWM6IFwiZXFcIlxufSk7XG5cbkFTVF9TeW1ib2wucHJvdG90eXBlLnNoYWxsb3dfY21wID0gbWtzaGFsbG93KHtcbiAgICBuYW1lOiBcImVxXCJcbn0pO1xuXG5BU1RfTmV3VGFyZ2V0LnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IHBhc3NfdGhyb3VnaDtcblxuQVNUX1RoaXMucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfU3VwZXIucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG5BU1RfU3RyaW5nLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IG1rc2hhbGxvdyh7XG4gICAgdmFsdWU6IFwiZXFcIlxufSk7XG5cbkFTVF9OdW1iZXIucHJvdG90eXBlLnNoYWxsb3dfY21wID0gbWtzaGFsbG93KHtcbiAgICB2YWx1ZTogXCJlcVwiXG59KTtcblxuQVNUX0JpZ0ludC5wcm90b3R5cGUuc2hhbGxvd19jbXAgPSBta3NoYWxsb3coe1xuICAgIHZhbHVlOiBcImVxXCJcbn0pO1xuXG5BU1RfUmVnRXhwLnByb3RvdHlwZS5zaGFsbG93X2NtcCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudmFsdWUuZmxhZ3MgPT09IG90aGVyLnZhbHVlLmZsYWdzXG4gICAgICAgICYmIHRoaXMudmFsdWUuc291cmNlID09PSBvdGhlci52YWx1ZS5zb3VyY2VcbiAgICApO1xufTtcblxuQVNUX0F0b20ucHJvdG90eXBlLnNoYWxsb3dfY21wID0gcGFzc190aHJvdWdoO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmNvbnN0IE1BU0tfRVhQT1JUX0RPTlRfTUFOR0xFID0gMSA8PCAwO1xuY29uc3QgTUFTS19FWFBPUlRfV0FOVF9NQU5HTEUgPSAxIDw8IDE7XG5cbmxldCBmdW5jdGlvbl9kZWZzID0gbnVsbDtcbmxldCB1bm1hbmdsZWFibGVfbmFtZXMgPSBudWxsO1xuXG5jbGFzcyBTeW1ib2xEZWYge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlLCBvcmlnLCBpbml0KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG9yaWcubmFtZTtcbiAgICAgICAgdGhpcy5vcmlnID0gWyBvcmlnIF07XG4gICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgICAgIHRoaXMuZWxpbWluYXRlZCA9IDA7XG4gICAgICAgIHRoaXMuYXNzaWdubWVudHMgPSAwO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMucmVwbGFjZWQgPSAwO1xuICAgICAgICB0aGlzLmdsb2JhbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV4cG9ydCA9IDA7XG4gICAgICAgIHRoaXMubWFuZ2xlZF9uYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy51bmRlY2xhcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaWQgPSBTeW1ib2xEZWYubmV4dF9pZCsrO1xuICAgICAgICB0aGlzLmNoYWluZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXJlY3RfYWNjZXNzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXNjYXBlZCA9IDA7XG4gICAgICAgIHRoaXMucmVjdXJzaXZlX3JlZnMgPSAwO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5zaG91bGRfcmVwbGFjZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zaW5nbGVfdXNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZml4ZWQgPSBmYWxzZTtcbiAgICAgICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gICAgfVxuICAgIGZpeGVkX3ZhbHVlKCkge1xuICAgICAgICBpZiAoIXRoaXMuZml4ZWQgfHwgdGhpcy5maXhlZCBpbnN0YW5jZW9mIEFTVF9Ob2RlKSByZXR1cm4gdGhpcy5maXhlZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZml4ZWQoKTtcbiAgICB9XG4gICAgdW5tYW5nbGVhYmxlKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZnVuY3Rpb25fZGVmcyAmJlxuICAgICAgICAgICAgZnVuY3Rpb25fZGVmcy5oYXModGhpcy5pZCkgJiZcbiAgICAgICAgICAgIGtlZXBfbmFtZShvcHRpb25zLmtlZXBfZm5hbWVzLCB0aGlzLm9yaWdbMF0ubmFtZSlcbiAgICAgICAgKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWwgJiYgIW9wdGlvbnMudG9wbGV2ZWxcbiAgICAgICAgICAgIHx8ICh0aGlzLmV4cG9ydCAmIE1BU0tfRVhQT1JUX0RPTlRfTUFOR0xFKVxuICAgICAgICAgICAgfHwgdGhpcy51bmRlY2xhcmVkXG4gICAgICAgICAgICB8fCAhb3B0aW9ucy5ldmFsICYmIHRoaXMuc2NvcGUucGlubmVkKClcbiAgICAgICAgICAgIHx8ICh0aGlzLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sTGFtYmRhXG4gICAgICAgICAgICAgICAgICB8fCB0aGlzLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVmdW4pICYmIGtlZXBfbmFtZShvcHRpb25zLmtlZXBfZm5hbWVzLCB0aGlzLm9yaWdbMF0ubmFtZSlcbiAgICAgICAgICAgIHx8IHRoaXMub3JpZ1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xNZXRob2RcbiAgICAgICAgICAgIHx8ICh0aGlzLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2xhc3NcbiAgICAgICAgICAgICAgICAgIHx8IHRoaXMub3JpZ1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWZDbGFzcykgJiYga2VlcF9uYW1lKG9wdGlvbnMua2VlcF9jbGFzc25hbWVzLCB0aGlzLm9yaWdbMF0ubmFtZSk7XG4gICAgfVxuICAgIG1hbmdsZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gb3B0aW9ucy5jYWNoZSAmJiBvcHRpb25zLmNhY2hlLnByb3BzO1xuICAgICAgICBpZiAodGhpcy5nbG9iYWwgJiYgY2FjaGUgJiYgY2FjaGUuaGFzKHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMubWFuZ2xlZF9uYW1lID0gY2FjaGUuZ2V0KHRoaXMubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMubWFuZ2xlZF9uYW1lICYmICF0aGlzLnVubWFuZ2xlYWJsZShvcHRpb25zKSkge1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnNjb3BlO1xuICAgICAgICAgICAgdmFyIHN5bSA9IHRoaXMub3JpZ1swXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmllOCAmJiBzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sTGFtYmRhKVxuICAgICAgICAgICAgICAgIHMgPSBzLnBhcmVudF9zY29wZTtcbiAgICAgICAgICAgIGNvbnN0IHJlZGVmaW5pdGlvbiA9IHJlZGVmaW5lZF9jYXRjaF9kZWYodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm1hbmdsZWRfbmFtZSA9IHJlZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgID8gcmVkZWZpbml0aW9uLm1hbmdsZWRfbmFtZSB8fCByZWRlZmluaXRpb24ubmFtZVxuICAgICAgICAgICAgICAgIDogcy5uZXh0X21hbmdsZWQob3B0aW9ucywgdGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5nbG9iYWwgJiYgY2FjaGUpIHtcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXQodGhpcy5uYW1lLCB0aGlzLm1hbmdsZWRfbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblN5bWJvbERlZi5uZXh0X2lkID0gMTtcblxuZnVuY3Rpb24gcmVkZWZpbmVkX2NhdGNoX2RlZihkZWYpIHtcbiAgICBpZiAoZGVmLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2F0Y2hcbiAgICAgICAgJiYgZGVmLnNjb3BlLmlzX2Jsb2NrX3Njb3BlKClcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIGRlZi5zY29wZS5nZXRfZGVmdW5fc2NvcGUoKS52YXJpYWJsZXMuZ2V0KGRlZi5uYW1lKTtcbiAgICB9XG59XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJmaWd1cmVfb3V0X3Njb3BlXCIsIGZ1bmN0aW9uKG9wdGlvbnMsIHsgcGFyZW50X3Njb3BlID0gbnVsbCwgdG9wbGV2ZWwgPSB0aGlzIH0gPSB7fSkge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGNhY2hlOiBudWxsLFxuICAgICAgICBpZTg6IGZhbHNlLFxuICAgICAgICBzYWZhcmkxMDogZmFsc2UsXG4gICAgfSk7XG5cbiAgICBpZiAoISh0b3BsZXZlbCBpbnN0YW5jZW9mIEFTVF9Ub3BsZXZlbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0b3BsZXZlbCBzY29wZVwiKTtcbiAgICB9XG5cbiAgICAvLyBwYXNzIDE6IHNldHVwIHNjb3BlIGNoYWluaW5nIGFuZCBoYW5kbGUgZGVmaW5pdGlvbnNcbiAgICB2YXIgc2NvcGUgPSB0aGlzLnBhcmVudF9zY29wZSA9IHBhcmVudF9zY29wZTtcbiAgICB2YXIgbGFiZWxzID0gbmV3IE1hcCgpO1xuICAgIHZhciBkZWZ1biA9IG51bGw7XG4gICAgdmFyIGluX2Rlc3RydWN0dXJpbmcgPSBudWxsO1xuICAgIHZhciBmb3Jfc2NvcGVzID0gW107XG4gICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoKG5vZGUsIGRlc2NlbmQpID0+IHtcbiAgICAgICAgaWYgKG5vZGUuaXNfYmxvY2tfc2NvcGUoKSkge1xuICAgICAgICAgICAgY29uc3Qgc2F2ZV9zY29wZSA9IHNjb3BlO1xuICAgICAgICAgICAgbm9kZS5ibG9ja19zY29wZSA9IHNjb3BlID0gbmV3IEFTVF9TY29wZShub2RlKTtcbiAgICAgICAgICAgIHNjb3BlLl9ibG9ja19zY29wZSA9IHRydWU7XG4gICAgICAgICAgICAvLyBBU1RfVHJ5IGluIHRoZSBBU1Qgc2FkbHkgKmlzKiAobm90IGhhcykgYSBib2R5IGl0c2VsZixcbiAgICAgICAgICAgIC8vIGFuZCBpdHMgY2F0Y2ggYW5kIGZpbmFsbHkgYnJhbmNoZXMgYXJlIGNoaWxkcmVuIG9mIHRoZSBBU1RfVHJ5IGl0c2VsZlxuICAgICAgICAgICAgY29uc3QgcGFyZW50X3Njb3BlID0gbm9kZSBpbnN0YW5jZW9mIEFTVF9DYXRjaFxuICAgICAgICAgICAgICAgID8gc2F2ZV9zY29wZS5wYXJlbnRfc2NvcGVcbiAgICAgICAgICAgICAgICA6IHNhdmVfc2NvcGU7XG4gICAgICAgICAgICBzY29wZS5pbml0X3Njb3BlX3ZhcnMocGFyZW50X3Njb3BlKTtcbiAgICAgICAgICAgIHNjb3BlLnVzZXNfd2l0aCA9IHNhdmVfc2NvcGUudXNlc193aXRoO1xuICAgICAgICAgICAgc2NvcGUudXNlc19ldmFsID0gc2F2ZV9zY29wZS51c2VzX2V2YWw7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zYWZhcmkxMCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0ZvciB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0ZvckluKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcl9zY29wZXMucHVzaChzY29wZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBYWFg6IEhBQ0shIEVuc3VyZSB0aGUgc3dpdGNoIGV4cHJlc3Npb24gZ2V0cyB0aGUgY29ycmVjdCBzY29wZSAodGhlIHBhcmVudCBzY29wZSkgYW5kIHRoZSBib2R5IGdldHMgdGhlIGNvbnRhaW5lZCBzY29wZVxuICAgICAgICAgICAgICAgIC8vIEFTVF9Td2l0Y2ggaGFzIGEgc2NvcGUgd2l0aGluIHRoZSBib2R5LCBidXQgaXQgaXRzZWxmIFwiaXMgYSBibG9jayBzY29wZVwiXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGUgc3dpdGNoZWQgZXhwcmVzc2lvbiBoYXMgdG8gYmVsb25nIHRvIHRoZSBvdXRlciBzY29wZVxuICAgICAgICAgICAgICAgIC8vIHdoaWxlIHRoZSBib2R5IGluc2lkZSBiZWxvbmdzIHRvIHRoZSBzd2l0Y2ggaXRzZWxmLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcHJldHR5IG5hc3R5IGFuZCB3YXJyYW50cyBhbiBBU1QgY2hhbmdlIHNpbWlsYXIgdG8gQVNUX1RyeSAocmVhZCBhYm92ZSlcbiAgICAgICAgICAgICAgICBjb25zdCB0aGVfYmxvY2tfc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgICAgICBzY29wZSA9IHNhdmVfc2NvcGU7XG4gICAgICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uLndhbGsodHcpO1xuICAgICAgICAgICAgICAgIHNjb3BlID0gdGhlX2Jsb2NrX3Njb3BlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYm9keVtpXS53YWxrKHR3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc2NlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjb3BlID0gc2F2ZV9zY29wZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Rlc3RydWN0dXJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhdmVfZGVzdHJ1Y3R1cmluZyA9IGluX2Rlc3RydWN0dXJpbmc7XG4gICAgICAgICAgICBpbl9kZXN0cnVjdHVyaW5nID0gbm9kZTtcbiAgICAgICAgICAgIGRlc2NlbmQoKTtcbiAgICAgICAgICAgIGluX2Rlc3RydWN0dXJpbmcgPSBzYXZlX2Rlc3RydWN0dXJpbmc7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgbm9kZS5pbml0X3Njb3BlX3ZhcnMoc2NvcGUpO1xuICAgICAgICAgICAgdmFyIHNhdmVfc2NvcGUgPSBzY29wZTtcbiAgICAgICAgICAgIHZhciBzYXZlX2RlZnVuID0gZGVmdW47XG4gICAgICAgICAgICB2YXIgc2F2ZV9sYWJlbHMgPSBsYWJlbHM7XG4gICAgICAgICAgICBkZWZ1biA9IHNjb3BlID0gbm9kZTtcbiAgICAgICAgICAgIGxhYmVscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGRlc2NlbmQoKTtcbiAgICAgICAgICAgIHNjb3BlID0gc2F2ZV9zY29wZTtcbiAgICAgICAgICAgIGRlZnVuID0gc2F2ZV9kZWZ1bjtcbiAgICAgICAgICAgIGxhYmVscyA9IHNhdmVfbGFiZWxzO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7ICAgICAgICAvLyBkb24ndCBkZXNjZW5kIGFnYWluIGluIFRyZWVXYWxrZXJcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYWJlbGVkU3RhdGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgbCA9IG5vZGUubGFiZWw7XG4gICAgICAgICAgICBpZiAobGFiZWxzLmhhcyhsLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmluZ190ZW1wbGF0ZShcIkxhYmVsIHtuYW1lfSBkZWZpbmVkIHR3aWNlXCIsIGwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhYmVscy5zZXQobC5uYW1lLCBsKTtcbiAgICAgICAgICAgIGRlc2NlbmQoKTtcbiAgICAgICAgICAgIGxhYmVscy5kZWxldGUobC5uYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAgICAgICAgLy8gbm8gZGVzY2VuZCBhZ2FpblxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1dpdGgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHMgPSBzY29wZTsgczsgcyA9IHMucGFyZW50X3Njb3BlKVxuICAgICAgICAgICAgICAgIHMudXNlc193aXRoID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2wpIHtcbiAgICAgICAgICAgIG5vZGUuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYWJlbCkge1xuICAgICAgICAgICAgbm9kZS50aGVkZWYgPSBub2RlO1xuICAgICAgICAgICAgbm9kZS5yZWZlcmVuY2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTGFtYmRhKSB7XG4gICAgICAgICAgICBkZWZ1bi5kZWZfZnVuY3Rpb24obm9kZSwgbm9kZS5uYW1lID09IFwiYXJndW1lbnRzXCIgPyB1bmRlZmluZWQgOiBkZWZ1bik7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWZ1bikge1xuICAgICAgICAgICAgLy8gQ2FyZWZ1bCBoZXJlLCB0aGUgc2NvcGUgd2hlcmUgdGhpcyBzaG91bGQgYmUgZGVmaW5lZCBpc1xuICAgICAgICAgICAgLy8gdGhlIHBhcmVudCBzY29wZS4gIFRoZSByZWFzb24gaXMgdGhhdCB3ZSBlbnRlciBhIG5ld1xuICAgICAgICAgICAgLy8gc2NvcGUgd2hlbiB3ZSBlbmNvdW50ZXIgdGhlIEFTVF9EZWZ1biBub2RlICh3aGljaCBpc1xuICAgICAgICAgICAgLy8gaW5zdGFuY2VvZiBBU1RfU2NvcGUpIGJ1dCB3ZSBnZXQgdG8gdGhlIHN5bWJvbCBhIGJpdFxuICAgICAgICAgICAgLy8gbGF0ZXIuXG4gICAgICAgICAgICBjb25zdCBjbG9zZXN0X3Njb3BlID0gZGVmdW4ucGFyZW50X3Njb3BlO1xuXG4gICAgICAgICAgICAvLyBJbiBzdHJpY3QgbW9kZSwgZnVuY3Rpb24gZGVmaW5pdGlvbnMgYXJlIGJsb2NrLXNjb3BlZFxuICAgICAgICAgICAgbm9kZS5zY29wZSA9IHR3LmRpcmVjdGl2ZXNbXCJ1c2Ugc3RyaWN0XCJdXG4gICAgICAgICAgICAgICAgPyBjbG9zZXN0X3Njb3BlXG4gICAgICAgICAgICAgICAgOiBjbG9zZXN0X3Njb3BlLmdldF9kZWZ1bl9zY29wZSgpO1xuXG4gICAgICAgICAgICBtYXJrX2V4cG9ydChub2RlLnNjb3BlLmRlZl9mdW5jdGlvbihub2RlLCBkZWZ1biksIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2xhc3MpIHtcbiAgICAgICAgICAgIG1hcmtfZXhwb3J0KGRlZnVuLmRlZl92YXJpYWJsZShub2RlLCBkZWZ1biksIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sSW1wb3J0KSB7XG4gICAgICAgICAgICBzY29wZS5kZWZfdmFyaWFibGUobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWZDbGFzcykge1xuICAgICAgICAgICAgLy8gVGhpcyBkZWFscyB3aXRoIHRoZSBuYW1lIG9mIHRoZSBjbGFzcyBiZWluZyBhdmFpbGFibGVcbiAgICAgICAgICAgIC8vIGluc2lkZSB0aGUgY2xhc3MuXG4gICAgICAgICAgICBtYXJrX2V4cG9ydCgobm9kZS5zY29wZSA9IGRlZnVuLnBhcmVudF9zY29wZSkuZGVmX2Z1bmN0aW9uKG5vZGUsIGRlZnVuKSwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFZhclxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xMZXRcbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ29uc3RcbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2F0Y2hcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgZGVmO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGRlZiA9IHNjb3BlLmRlZl92YXJpYWJsZShub2RlLCBudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmID0gZGVmdW4uZGVmX3ZhcmlhYmxlKG5vZGUsIG5vZGUuVFlQRSA9PSBcIlN5bWJvbFZhclwiID8gbnVsbCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRlZi5vcmlnLmV2ZXJ5KChzeW0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3ltID09PSBub2RlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xCbG9ja0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sTGFtYmRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gIShzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sTGV0IHx8IHN5bSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xDb25zdCk7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGpzX2Vycm9yKFxuICAgICAgICAgICAgICAgICAgICBgXCIke25vZGUubmFtZX1cIiBpcyByZWRlY2xhcmVkYCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhcnQuY29sLFxuICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXJ0LnBvc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZykpIG1hcmtfZXhwb3J0KGRlZiwgMik7XG4gICAgICAgICAgICBpZiAoZGVmdW4gIT09IHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5tYXJrX2VuY2xvc2VkKCk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZiA9IHNjb3BlLmZpbmRfdmFyaWFibGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudGhlZGVmICE9PSBkZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS50aGVkZWYgPSBkZWY7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVmZXJlbmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFiZWxSZWYpIHtcbiAgICAgICAgICAgIHZhciBzeW0gPSBsYWJlbHMuZ2V0KG5vZGUubmFtZSk7XG4gICAgICAgICAgICBpZiAoIXN5bSkgdGhyb3cgbmV3IEVycm9yKHN0cmluZ190ZW1wbGF0ZShcIlVuZGVmaW5lZCBsYWJlbCB7bmFtZX0gW3tsaW5lfSx7Y29sfV1cIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgICAgICBsaW5lOiBub2RlLnN0YXJ0LmxpbmUsXG4gICAgICAgICAgICAgICAgY29sOiBub2RlLnN0YXJ0LmNvbFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbm9kZS50aGVkZWYgPSBzeW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc2NvcGUgaW5zdGFuY2VvZiBBU1RfVG9wbGV2ZWwpICYmIChub2RlIGluc3RhbmNlb2YgQVNUX0V4cG9ydCB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0ltcG9ydCkpIHtcbiAgICAgICAgICAgIGpzX2Vycm9yKFxuICAgICAgICAgICAgICAgIGBcIiR7bm9kZS5UWVBFfVwiIHN0YXRlbWVudCBtYXkgb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbGAsXG4gICAgICAgICAgICAgICAgbm9kZS5zdGFydC5maWxlLFxuICAgICAgICAgICAgICAgIG5vZGUuc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICBub2RlLnN0YXJ0LmNvbCxcbiAgICAgICAgICAgICAgICBub2RlLnN0YXJ0LnBvc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2Fsayh0dyk7XG5cbiAgICBmdW5jdGlvbiBtYXJrX2V4cG9ydChkZWYsIGxldmVsKSB7XG4gICAgICAgIGlmIChpbl9kZXN0cnVjdHVyaW5nKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICAgIH0gd2hpbGUgKHR3LnBhcmVudChpKyspICE9PSBpbl9kZXN0cnVjdHVyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IHR3LnBhcmVudChsZXZlbCk7XG4gICAgICAgIGlmIChkZWYuZXhwb3J0ID0gbm9kZSBpbnN0YW5jZW9mIEFTVF9FeHBvcnQgPyBNQVNLX0VYUE9SVF9ET05UX01BTkdMRSA6IDApIHtcbiAgICAgICAgICAgIHZhciBleHBvcnRlZCA9IG5vZGUuZXhwb3J0ZWRfZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGlmICgoZXhwb3J0ZWQgaW5zdGFuY2VvZiBBU1RfRGVmdW4gfHwgZXhwb3J0ZWQgaW5zdGFuY2VvZiBBU1RfRGVmQ2xhc3MpICYmIG5vZGUuaXNfZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGRlZi5leHBvcnQgPSBNQVNLX0VYUE9SVF9XQU5UX01BTkdMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhc3MgMjogZmluZCBiYWNrIHJlZmVyZW5jZXMgYW5kIGV2YWxcbiAgICBjb25zdCBpc190b3BsZXZlbCA9IHRoaXMgaW5zdGFuY2VvZiBBU1RfVG9wbGV2ZWw7XG4gICAgaWYgKGlzX3RvcGxldmVsKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFscyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTG9vcENvbnRyb2wgJiYgbm9kZS5sYWJlbCkge1xuICAgICAgICAgICAgbm9kZS5sYWJlbC50aGVkZWYucmVmZXJlbmNlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwiZXZhbFwiICYmIHR3LnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX0NhbGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gbm9kZS5zY29wZTsgcyAmJiAhcy51c2VzX2V2YWw7IHMgPSBzLnBhcmVudF9zY29wZSkge1xuICAgICAgICAgICAgICAgICAgICBzLnVzZXNfZXZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN5bTtcbiAgICAgICAgICAgIGlmICh0dy5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9OYW1lTWFwcGluZyAmJiB0dy5wYXJlbnQoMSkubW9kdWxlX25hbWVcbiAgICAgICAgICAgICAgICB8fCAhKHN5bSA9IG5vZGUuc2NvcGUuZmluZF92YXJpYWJsZShuYW1lKSkpIHtcblxuICAgICAgICAgICAgICAgIHN5bSA9IHRvcGxldmVsLmRlZl9nbG9iYWwobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRXhwb3J0KSBzeW0uZXhwb3J0ID0gTUFTS19FWFBPUlRfRE9OVF9NQU5HTEU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN5bS5zY29wZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEgJiYgbmFtZSA9PSBcImFyZ3VtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgc3ltLnNjb3BlLnVzZXNfYXJndW1lbnRzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUudGhlZGVmID0gc3ltO1xuICAgICAgICAgICAgbm9kZS5yZWZlcmVuY2UoKTtcbiAgICAgICAgICAgIGlmIChub2RlLnNjb3BlLmlzX2Jsb2NrX3Njb3BlKClcbiAgICAgICAgICAgICAgICAmJiAhKHN5bS5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbEJsb2NrRGVjbGFyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zY29wZSA9IG5vZGUuc2NvcGUuZ2V0X2RlZnVuX3Njb3BlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgbWFuZ2xpbmcgd29ya3MgaWYgY2F0Y2ggcmV1c2VzIGEgc2NvcGUgdmFyaWFibGVcbiAgICAgICAgdmFyIGRlZjtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2F0Y2ggJiYgKGRlZiA9IHJlZGVmaW5lZF9jYXRjaF9kZWYobm9kZS5kZWZpbml0aW9uKCkpKSkge1xuICAgICAgICAgICAgdmFyIHMgPSBub2RlLnNjb3BlO1xuICAgICAgICAgICAgd2hpbGUgKHMpIHtcbiAgICAgICAgICAgICAgICBwdXNoX3VuaXEocy5lbmNsb3NlZCwgZGVmKTtcbiAgICAgICAgICAgICAgICBpZiAocyA9PT0gZGVmLnNjb3BlKSBicmVhaztcbiAgICAgICAgICAgICAgICBzID0gcy5wYXJlbnRfc2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndhbGsodHcpO1xuXG4gICAgLy8gcGFzcyAzOiB3b3JrIGFyb3VuZCBJRTggYW5kIFNhZmFyaSBjYXRjaCBzY29wZSBidWdzXG4gICAgaWYgKG9wdGlvbnMuaWU4IHx8IG9wdGlvbnMuc2FmYXJpMTApIHtcbiAgICAgICAgd2Fsayh0aGlzLCBub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbENhdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIHJlZnMgPSBub2RlLnRoZWRlZi5yZWZlcmVuY2VzO1xuICAgICAgICAgICAgICAgIHZhciBzY29wZSA9IG5vZGUuc2NvcGUuZ2V0X2RlZnVuX3Njb3BlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZiA9IHNjb3BlLmZpbmRfdmFyaWFibGUobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgdG9wbGV2ZWwuZ2xvYmFscy5nZXQobmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgc2NvcGUuZGVmX3ZhcmlhYmxlKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJlZnMuZm9yRWFjaChmdW5jdGlvbihyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLnRoZWRlZiA9IGRlZjtcbiAgICAgICAgICAgICAgICAgICAgcmVmLnJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5vZGUudGhlZGVmID0gZGVmO1xuICAgICAgICAgICAgICAgIG5vZGUucmVmZXJlbmNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHBhc3MgNDogYWRkIHN5bWJvbCBkZWZpbml0aW9ucyB0byBsb29wIHNjb3Blc1xuICAgIC8vIFNhZmFyaS9XZWJraXQgYnVnIHdvcmthcm91bmQgLSBsb29wIGluaXQgbGV0IHZhcmlhYmxlIHNoYWRvd2luZyBhcmd1bWVudC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvMTc1M1xuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzEwNDFcbiAgICBpZiAob3B0aW9ucy5zYWZhcmkxMCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIGZvcl9zY29wZXMpIHtcbiAgICAgICAgICAgIHNjb3BlLnBhcmVudF9zY29wZS52YXJpYWJsZXMuZm9yRWFjaChmdW5jdGlvbihkZWYpIHtcbiAgICAgICAgICAgICAgICBwdXNoX3VuaXEoc2NvcGUuZW5jbG9zZWQsIGRlZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwiZGVmX2dsb2JhbFwiLCBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGdsb2JhbHMgPSB0aGlzLmdsb2JhbHMsIG5hbWUgPSBub2RlLm5hbWU7XG4gICAgaWYgKGdsb2JhbHMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxzLmdldChuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZyA9IG5ldyBTeW1ib2xEZWYodGhpcywgbm9kZSk7XG4gICAgICAgIGcudW5kZWNsYXJlZCA9IHRydWU7XG4gICAgICAgIGcuZ2xvYmFsID0gdHJ1ZTtcbiAgICAgICAgZ2xvYmFscy5zZXQobmFtZSwgZyk7XG4gICAgICAgIHJldHVybiBnO1xuICAgIH1cbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiaW5pdF9zY29wZV92YXJzXCIsIGZ1bmN0aW9uKHBhcmVudF9zY29wZSkge1xuICAgIHRoaXMudmFyaWFibGVzID0gbmV3IE1hcCgpOyAgICAgICAgIC8vIG1hcCBuYW1lIHRvIEFTVF9TeW1ib2xWYXIgKHZhcmlhYmxlcyBkZWZpbmVkIGluIHRoaXMgc2NvcGU7IGluY2x1ZGVzIGZ1bmN0aW9ucylcbiAgICB0aGlzLnVzZXNfd2l0aCA9IGZhbHNlOyAgICAgICAgICAgICAvLyB3aWxsIGJlIHNldCB0byB0cnVlIGlmIHRoaXMgb3Igc29tZSBuZXN0ZWQgc2NvcGUgdXNlcyB0aGUgYHdpdGhgIHN0YXRlbWVudFxuICAgIHRoaXMudXNlc19ldmFsID0gZmFsc2U7ICAgICAgICAgICAgIC8vIHdpbGwgYmUgc2V0IHRvIHRydWUgaWYgdGhpcyBvciBuZXN0ZWQgc2NvcGUgdXNlcyB0aGUgZ2xvYmFsIGBldmFsYFxuICAgIHRoaXMucGFyZW50X3Njb3BlID0gcGFyZW50X3Njb3BlOyAgIC8vIHRoZSBwYXJlbnQgc2NvcGVcbiAgICB0aGlzLmVuY2xvc2VkID0gW107ICAgICAgICAgICAgICAgICAvLyBhIGxpc3Qgb2YgdmFyaWFibGVzIGZyb20gdGhpcyBvciBvdXRlciBzY29wZShzKSB0aGF0IGFyZSByZWZlcmVuY2VkIGZyb20gdGhpcyBvciBpbm5lciBzY29wZXNcbiAgICB0aGlzLmNuYW1lID0gLTE7ICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBpbmRleCBmb3IgbWFuZ2xpbmcgZnVuY3Rpb25zL3ZhcmlhYmxlc1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJjb25mbGljdGluZ19kZWZcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLmVuY2xvc2VkLmZpbmQoZGVmID0+IGRlZi5uYW1lID09PSBuYW1lKVxuICAgICAgICB8fCB0aGlzLnZhcmlhYmxlcy5oYXMobmFtZSlcbiAgICAgICAgfHwgKHRoaXMucGFyZW50X3Njb3BlICYmIHRoaXMucGFyZW50X3Njb3BlLmNvbmZsaWN0aW5nX2RlZihuYW1lKSlcbiAgICApO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJjb25mbGljdGluZ19kZWZfc2hhbGxvd1wiLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuZW5jbG9zZWQuZmluZChkZWYgPT4gZGVmLm5hbWUgPT09IG5hbWUpXG4gICAgICAgIHx8IHRoaXMudmFyaWFibGVzLmhhcyhuYW1lKVxuICAgICk7XG59KTtcblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcImFkZF9jaGlsZF9zY29wZVwiLCBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAvLyBgc2NvcGVgIGlzIGdvaW5nIHRvIGJlIG1vdmVkIGludG8gYHRoaXNgIHJpZ2h0IG5vdy5cbiAgICAvLyBVcGRhdGUgdGhlIHJlcXVpcmVkIHNjb3BlcycgaW5mb3JtYXRpb25cblxuICAgIGlmIChzY29wZS5wYXJlbnRfc2NvcGUgPT09IHRoaXMpIHJldHVybjtcblxuICAgIHNjb3BlLnBhcmVudF9zY29wZSA9IHRoaXM7XG5cbiAgICAvLyBUT0RPIHVzZXNfd2l0aCwgdXNlc19ldmFsLCBldGNcblxuICAgIGNvbnN0IHNjb3BlX2FuY2VzdHJ5ID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgYW5jZXN0cnkgPSBbXTtcbiAgICAgICAgbGV0IGN1ciA9IHRoaXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGFuY2VzdHJ5LnB1c2goY3VyKTtcbiAgICAgICAgfSB3aGlsZSAoKGN1ciA9IGN1ci5wYXJlbnRfc2NvcGUpKTtcbiAgICAgICAgYW5jZXN0cnkucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gYW5jZXN0cnk7XG4gICAgfSkoKTtcblxuICAgIGNvbnN0IG5ld19zY29wZV9lbmNsb3NlZF9zZXQgPSBuZXcgU2V0KHNjb3BlLmVuY2xvc2VkKTtcbiAgICBjb25zdCB0b19lbmNsb3NlID0gW107XG4gICAgZm9yIChjb25zdCBzY29wZV90b3Bkb3duIG9mIHNjb3BlX2FuY2VzdHJ5KSB7XG4gICAgICAgIHRvX2VuY2xvc2UuZm9yRWFjaChlID0+IHB1c2hfdW5pcShzY29wZV90b3Bkb3duLmVuY2xvc2VkLCBlKSk7XG4gICAgICAgIGZvciAoY29uc3QgZGVmIG9mIHNjb3BlX3RvcGRvd24udmFyaWFibGVzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAobmV3X3Njb3BlX2VuY2xvc2VkX3NldC5oYXMoZGVmKSkge1xuICAgICAgICAgICAgICAgIHB1c2hfdW5pcSh0b19lbmNsb3NlLCBkZWYpO1xuICAgICAgICAgICAgICAgIHB1c2hfdW5pcShzY29wZV90b3Bkb3duLmVuY2xvc2VkLCBkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGZpbmRfc2NvcGVzX3Zpc2libGVfZnJvbShzY29wZXMpIHtcbiAgICBjb25zdCBmb3VuZF9zY29wZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIG5ldyBTZXQoc2NvcGVzKSkge1xuICAgICAgICAoZnVuY3Rpb24gYnViYmxlX3VwKHNjb3BlKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUgPT0gbnVsbCB8fCBmb3VuZF9zY29wZXMuaGFzKHNjb3BlKSkgcmV0dXJuO1xuXG4gICAgICAgICAgICBmb3VuZF9zY29wZXMuYWRkKHNjb3BlKTtcblxuICAgICAgICAgICAgYnViYmxlX3VwKHNjb3BlLnBhcmVudF9zY29wZSk7XG4gICAgICAgIH0pKHNjb3BlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gWy4uLmZvdW5kX3Njb3Blc107XG59XG5cbi8vIENyZWF0ZXMgYSBzeW1ib2wgZHVyaW5nIGNvbXByZXNzaW9uXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiY3JlYXRlX3N5bWJvbFwiLCBmdW5jdGlvbihTeW1DbGFzcywge1xuICAgIHNvdXJjZSxcbiAgICB0ZW50YXRpdmVfbmFtZSxcbiAgICBzY29wZSxcbiAgICBjb25mbGljdF9zY29wZXMgPSBbc2NvcGVdLFxuICAgIGluaXQgPSBudWxsXG59ID0ge30pIHtcbiAgICBsZXQgc3ltYm9sX25hbWU7XG5cbiAgICBjb25mbGljdF9zY29wZXMgPSBmaW5kX3Njb3Blc192aXNpYmxlX2Zyb20oY29uZmxpY3Rfc2NvcGVzKTtcblxuICAgIGlmICh0ZW50YXRpdmVfbmFtZSkge1xuICAgICAgICAvLyBJbXBsZW1lbnQgaHlnaWVuZSAobm8gbmV3IG5hbWVzIGFyZSBjb25mbGljdGluZyB3aXRoIGV4aXN0aW5nIG5hbWVzKVxuICAgICAgICB0ZW50YXRpdmVfbmFtZSA9XG4gICAgICAgICAgICBzeW1ib2xfbmFtZSA9XG4gICAgICAgICAgICB0ZW50YXRpdmVfbmFtZS5yZXBsYWNlKC8oPzpeW15hLXpfJF18W15hLXowLTlfJF0pL2lnLCBcIl9cIik7XG5cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoY29uZmxpY3Rfc2NvcGVzLmZpbmQocyA9PiBzLmNvbmZsaWN0aW5nX2RlZl9zaGFsbG93KHN5bWJvbF9uYW1lKSkpIHtcbiAgICAgICAgICAgIHN5bWJvbF9uYW1lID0gdGVudGF0aXZlX25hbWUgKyBcIiRcIiArIGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc3ltYm9sX25hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3ltYm9sIG5hbWUgY291bGQgYmUgZ2VuZXJhdGVkIGluIGNyZWF0ZV9zeW1ib2woKVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBzeW1ib2wgPSBtYWtlX25vZGUoU3ltQ2xhc3MsIHNvdXJjZSwge1xuICAgICAgICBuYW1lOiBzeW1ib2xfbmFtZSxcbiAgICAgICAgc2NvcGVcbiAgICB9KTtcblxuICAgIHRoaXMuZGVmX3ZhcmlhYmxlKHN5bWJvbCwgaW5pdCB8fCBudWxsKTtcblxuICAgIHN5bWJvbC5tYXJrX2VuY2xvc2VkKCk7XG5cbiAgICByZXR1cm4gc3ltYm9sO1xufSk7XG5cblxuQVNUX05vZGUuREVGTUVUSE9EKFwiaXNfYmxvY2tfc2NvcGVcIiwgcmV0dXJuX2ZhbHNlKTtcbkFTVF9DbGFzcy5ERUZNRVRIT0QoXCJpc19ibG9ja19zY29wZVwiLCByZXR1cm5fZmFsc2UpO1xuQVNUX0xhbWJkYS5ERUZNRVRIT0QoXCJpc19ibG9ja19zY29wZVwiLCByZXR1cm5fZmFsc2UpO1xuQVNUX1RvcGxldmVsLkRFRk1FVEhPRChcImlzX2Jsb2NrX3Njb3BlXCIsIHJldHVybl9mYWxzZSk7XG5BU1RfU3dpdGNoQnJhbmNoLkRFRk1FVEhPRChcImlzX2Jsb2NrX3Njb3BlXCIsIHJldHVybl9mYWxzZSk7XG5BU1RfQmxvY2suREVGTUVUSE9EKFwiaXNfYmxvY2tfc2NvcGVcIiwgcmV0dXJuX3RydWUpO1xuQVNUX1Njb3BlLkRFRk1FVEhPRChcImlzX2Jsb2NrX3Njb3BlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tfc2NvcGUgfHwgZmFsc2U7XG59KTtcbkFTVF9JdGVyYXRpb25TdGF0ZW1lbnQuREVGTUVUSE9EKFwiaXNfYmxvY2tfc2NvcGVcIiwgcmV0dXJuX3RydWUpO1xuXG5BU1RfTGFtYmRhLkRFRk1FVEhPRChcImluaXRfc2NvcGVfdmFyc1wiLCBmdW5jdGlvbigpIHtcbiAgICBBU1RfU2NvcGUucHJvdG90eXBlLmluaXRfc2NvcGVfdmFycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMudXNlc19hcmd1bWVudHMgPSBmYWxzZTtcbiAgICB0aGlzLmRlZl92YXJpYWJsZShuZXcgQVNUX1N5bWJvbEZ1bmFyZyh7XG4gICAgICAgIG5hbWU6IFwiYXJndW1lbnRzXCIsXG4gICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgICBlbmQ6IHRoaXMuZW5kXG4gICAgfSkpO1xufSk7XG5cbkFTVF9BcnJvdy5ERUZNRVRIT0QoXCJpbml0X3Njb3BlX3ZhcnNcIiwgZnVuY3Rpb24oKSB7XG4gICAgQVNUX1Njb3BlLnByb3RvdHlwZS5pbml0X3Njb3BlX3ZhcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnVzZXNfYXJndW1lbnRzID0gZmFsc2U7XG59KTtcblxuQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJtYXJrX2VuY2xvc2VkXCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWYgPSB0aGlzLmRlZmluaXRpb24oKTtcbiAgICB2YXIgcyA9IHRoaXMuc2NvcGU7XG4gICAgd2hpbGUgKHMpIHtcbiAgICAgICAgcHVzaF91bmlxKHMuZW5jbG9zZWQsIGRlZik7XG4gICAgICAgIGlmIChzID09PSBkZWYuc2NvcGUpIGJyZWFrO1xuICAgICAgICBzID0gcy5wYXJlbnRfc2NvcGU7XG4gICAgfVxufSk7XG5cbkFTVF9TeW1ib2wuREVGTUVUSE9EKFwicmVmZXJlbmNlXCIsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGVmaW5pdGlvbigpLnJlZmVyZW5jZXMucHVzaCh0aGlzKTtcbiAgICB0aGlzLm1hcmtfZW5jbG9zZWQoKTtcbn0pO1xuXG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiZmluZF92YXJpYWJsZVwiLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKSBuYW1lID0gbmFtZS5uYW1lO1xuICAgIHJldHVybiB0aGlzLnZhcmlhYmxlcy5nZXQobmFtZSlcbiAgICAgICAgfHwgKHRoaXMucGFyZW50X3Njb3BlICYmIHRoaXMucGFyZW50X3Njb3BlLmZpbmRfdmFyaWFibGUobmFtZSkpO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJkZWZfZnVuY3Rpb25cIiwgZnVuY3Rpb24oc3ltYm9sLCBpbml0KSB7XG4gICAgdmFyIGRlZiA9IHRoaXMuZGVmX3ZhcmlhYmxlKHN5bWJvbCwgaW5pdCk7XG4gICAgaWYgKCFkZWYuaW5pdCB8fCBkZWYuaW5pdCBpbnN0YW5jZW9mIEFTVF9EZWZ1bikgZGVmLmluaXQgPSBpbml0O1xuICAgIHJldHVybiBkZWY7XG59KTtcblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcImRlZl92YXJpYWJsZVwiLCBmdW5jdGlvbihzeW1ib2wsIGluaXQpIHtcbiAgICB2YXIgZGVmID0gdGhpcy52YXJpYWJsZXMuZ2V0KHN5bWJvbC5uYW1lKTtcbiAgICBpZiAoZGVmKSB7XG4gICAgICAgIGRlZi5vcmlnLnB1c2goc3ltYm9sKTtcbiAgICAgICAgaWYgKGRlZi5pbml0ICYmIChkZWYuc2NvcGUgIT09IHN5bWJvbC5zY29wZSB8fCBkZWYuaW5pdCBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvbikpIHtcbiAgICAgICAgICAgIGRlZi5pbml0ID0gaW5pdDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZiA9IG5ldyBTeW1ib2xEZWYodGhpcywgc3ltYm9sLCBpbml0KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXMuc2V0KHN5bWJvbC5uYW1lLCBkZWYpO1xuICAgICAgICBkZWYuZ2xvYmFsID0gIXRoaXMucGFyZW50X3Njb3BlO1xuICAgIH1cbiAgICByZXR1cm4gc3ltYm9sLnRoZWRlZiA9IGRlZjtcbn0pO1xuXG5mdW5jdGlvbiBuZXh0X21hbmdsZWQoc2NvcGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZXh0ID0gc2NvcGUuZW5jbG9zZWQ7XG4gICAgb3V0OiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgbSA9IGJhc2U1NCgrK3Njb3BlLmNuYW1lKTtcbiAgICAgICAgaWYgKFJFU0VSVkVEX1dPUkRTLmhhcyhtKSkgY29udGludWU7IC8vIHNraXAgb3ZlciBcImRvXCJcblxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvMjQyIC0tIGRvIG5vdFxuICAgICAgICAvLyBzaGFkb3cgYSBuYW1lIHJlc2VydmVkIGZyb20gbWFuZ2xpbmcuXG4gICAgICAgIGlmIChvcHRpb25zLnJlc2VydmVkLmhhcyhtKSkgY29udGludWU7XG5cbiAgICAgICAgLy8gRnVuY3Rpb25zIHdpdGggc2hvcnQgbmFtZXMgbWlnaHQgY29sbGlkZSB3aXRoIGJhc2U1NCBvdXRwdXRcbiAgICAgICAgLy8gYW5kIHRoZXJlZm9yZSBjYXVzZSBjb2xsaXNpb25zIHdoZW4ga2VlcF9mbmFtZXMgaXMgdHJ1ZS5cbiAgICAgICAgaWYgKHVubWFuZ2xlYWJsZV9uYW1lcyAmJiB1bm1hbmdsZWFibGVfbmFtZXMuaGFzKG0pKSBjb250aW51ZSBvdXQ7XG5cbiAgICAgICAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCB0aGUgbWFuZ2xlZCBuYW1lIGRvZXMgbm90IHNoYWRvdyBhIG5hbWVcbiAgICAgICAgLy8gZnJvbSBzb21lIHBhcmVudCBzY29wZSB0aGF0IGlzIHJlZmVyZW5jZWQgaW4gdGhpcyBvciBpblxuICAgICAgICAvLyBpbm5lciBzY29wZXMuXG4gICAgICAgIGZvciAobGV0IGkgPSBleHQubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZiA9IGV4dFtpXTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBkZWYubWFuZ2xlZF9uYW1lIHx8IChkZWYudW5tYW5nbGVhYmxlKG9wdGlvbnMpICYmIGRlZi5uYW1lKTtcbiAgICAgICAgICAgIGlmIChtID09IG5hbWUpIGNvbnRpbnVlIG91dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG59XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJuZXh0X21hbmdsZWRcIiwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXh0X21hbmdsZWQodGhpcywgb3B0aW9ucyk7XG59KTtcblxuQVNUX1RvcGxldmVsLkRFRk1FVEhPRChcIm5leHRfbWFuZ2xlZFwiLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgbGV0IG5hbWU7XG4gICAgY29uc3QgbWFuZ2xlZF9uYW1lcyA9IHRoaXMubWFuZ2xlZF9uYW1lcztcbiAgICBkbyB7XG4gICAgICAgIG5hbWUgPSBuZXh0X21hbmdsZWQodGhpcywgb3B0aW9ucyk7XG4gICAgfSB3aGlsZSAobWFuZ2xlZF9uYW1lcy5oYXMobmFtZSkpO1xuICAgIHJldHVybiBuYW1lO1xufSk7XG5cbkFTVF9GdW5jdGlvbi5ERUZNRVRIT0QoXCJuZXh0X21hbmdsZWRcIiwgZnVuY3Rpb24ob3B0aW9ucywgZGVmKSB7XG4gICAgLy8gIzE3OSwgIzMyNlxuICAgIC8vIGluIFNhZmFyaSBzdHJpY3QgbW9kZSwgc29tZXRoaW5nIGxpa2UgKGZ1bmN0aW9uIHgoeCl7Li4ufSkgaXMgYSBzeW50YXggZXJyb3I7XG4gICAgLy8gYSBmdW5jdGlvbiBleHByZXNzaW9uJ3MgYXJndW1lbnQgY2Fubm90IHNoYWRvdyB0aGUgZnVuY3Rpb24gZXhwcmVzc2lvbidzIG5hbWVcblxuICAgIHZhciB0cmlja3lfZGVmID0gZGVmLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sRnVuYXJnICYmIHRoaXMubmFtZSAmJiB0aGlzLm5hbWUuZGVmaW5pdGlvbigpO1xuXG4gICAgLy8gdGhlIGZ1bmN0aW9uJ3MgbWFuZ2xlZF9uYW1lIGlzIG51bGwgd2hlbiBrZWVwX2ZuYW1lcyBpcyB0cnVlXG4gICAgdmFyIHRyaWNreV9uYW1lID0gdHJpY2t5X2RlZiA/IHRyaWNreV9kZWYubWFuZ2xlZF9uYW1lIHx8IHRyaWNreV9kZWYubmFtZSA6IG51bGw7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5leHRfbWFuZ2xlZCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCF0cmlja3lfbmFtZSB8fCB0cmlja3lfbmFtZSAhPSBuYW1lKVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxufSk7XG5cbkFTVF9TeW1ib2wuREVGTUVUSE9EKFwidW5tYW5nbGVhYmxlXCIsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZGVmID0gdGhpcy5kZWZpbml0aW9uKCk7XG4gICAgcmV0dXJuICFkZWYgfHwgZGVmLnVubWFuZ2xlYWJsZShvcHRpb25zKTtcbn0pO1xuXG4vLyBsYWJlbHMgYXJlIGFsd2F5cyBtYW5nbGVhYmxlXG5BU1RfTGFiZWwuREVGTUVUSE9EKFwidW5tYW5nbGVhYmxlXCIsIHJldHVybl9mYWxzZSk7XG5cbkFTVF9TeW1ib2wuREVGTUVUSE9EKFwidW5yZWZlcmVuY2VkXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5kZWZpbml0aW9uKCkucmVmZXJlbmNlcy5sZW5ndGggJiYgIXRoaXMuc2NvcGUucGlubmVkKCk7XG59KTtcblxuQVNUX1N5bWJvbC5ERUZNRVRIT0QoXCJkZWZpbml0aW9uXCIsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRoZWRlZjtcbn0pO1xuXG5BU1RfU3ltYm9sLkRFRk1FVEhPRChcImdsb2JhbFwiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50aGVkZWYuZ2xvYmFsO1xufSk7XG5cbkFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJfZGVmYXVsdF9tYW5nbGVyX29wdGlvbnNcIiwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGV2YWwgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGllOCAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGtlZXBfY2xhc3NuYW1lczogZmFsc2UsXG4gICAgICAgIGtlZXBfZm5hbWVzIDogZmFsc2UsXG4gICAgICAgIG1vZHVsZSAgICAgIDogZmFsc2UsXG4gICAgICAgIHJlc2VydmVkICAgIDogW10sXG4gICAgICAgIHRvcGxldmVsICAgIDogZmFsc2UsXG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMubW9kdWxlKSBvcHRpb25zLnRvcGxldmVsID0gdHJ1ZTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5yZXNlcnZlZClcbiAgICAgICAgJiYgIShvcHRpb25zLnJlc2VydmVkIGluc3RhbmNlb2YgU2V0KVxuICAgICkge1xuICAgICAgICBvcHRpb25zLnJlc2VydmVkID0gW107XG4gICAgfVxuICAgIG9wdGlvbnMucmVzZXJ2ZWQgPSBuZXcgU2V0KG9wdGlvbnMucmVzZXJ2ZWQpO1xuICAgIC8vIE5ldmVyIG1hbmdsZSBhcmd1bWVudHNcbiAgICBvcHRpb25zLnJlc2VydmVkLmFkZChcImFyZ3VtZW50c1wiKTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn0pO1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwibWFuZ2xlX25hbWVzXCIsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdGhpcy5fZGVmYXVsdF9tYW5nbGVyX29wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gbWFuZ2xlIGRlY2xhcmF0aW9uIG5vZGVzLiAgU3BlY2lhbCBsb2dpYyB3aXJlZFxuICAgIC8vIGludG8gdGhlIGNvZGUgZ2VuZXJhdG9yIHdpbGwgZGlzcGxheSB0aGUgbWFuZ2xlZCBuYW1lIGlmIGl0J3NcbiAgICAvLyBwcmVzZW50IChhbmQgZm9yIEFTVF9TeW1ib2xSZWYtcyBpdCdsbCB1c2UgdGhlIG1hbmdsZWQgbmFtZSBvZlxuICAgIC8vIHRoZSBBU1RfU3ltYm9sRGVjbGFyYXRpb24gdGhhdCBpdCBwb2ludHMgdG8pLlxuICAgIHZhciBsbmFtZSA9IC0xO1xuICAgIHZhciB0b19tYW5nbGUgPSBbXTtcblxuICAgIGlmIChvcHRpb25zLmtlZXBfZm5hbWVzKSB7XG4gICAgICAgIGZ1bmN0aW9uX2RlZnMgPSBuZXcgU2V0KCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWFuZ2xlZF9uYW1lcyA9IHRoaXMubWFuZ2xlZF9uYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBpZiAob3B0aW9ucy5jYWNoZSkge1xuICAgICAgICB0aGlzLmdsb2JhbHMuZm9yRWFjaChjb2xsZWN0KTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2FjaGUucHJvcHMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FjaGUucHJvcHMuZm9yRWFjaChmdW5jdGlvbihtYW5nbGVkX25hbWUpIHtcbiAgICAgICAgICAgICAgICBtYW5nbGVkX25hbWVzLmFkZChtYW5nbGVkX25hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlLCBkZXNjZW5kKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhYmVsZWRTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGxuYW1lIGlzIGluY3JlbWVudGVkIHdoZW4gd2UgZ2V0IHRvIHRoZSBBU1RfTGFiZWxcbiAgICAgICAgICAgIHZhciBzYXZlX25lc3RpbmcgPSBsbmFtZTtcbiAgICAgICAgICAgIGRlc2NlbmQoKTtcbiAgICAgICAgICAgIGxuYW1lID0gc2F2ZV9uZXN0aW5nO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7ICAgICAgICAvLyBkb24ndCBkZXNjZW5kIGFnYWluIGluIFRyZWVXYWxrZXJcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgbm9kZS52YXJpYWJsZXMuZm9yRWFjaChjb2xsZWN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5pc19ibG9ja19zY29wZSgpKSB7XG4gICAgICAgICAgICBub2RlLmJsb2NrX3Njb3BlLnZhcmlhYmxlcy5mb3JFYWNoKGNvbGxlY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGZ1bmN0aW9uX2RlZnNcbiAgICAgICAgICAgICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyRGVmXG4gICAgICAgICAgICAmJiBub2RlLnZhbHVlIGluc3RhbmNlb2YgQVNUX0xhbWJkYVxuICAgICAgICAgICAgJiYgIW5vZGUudmFsdWUubmFtZVxuICAgICAgICAgICAgJiYga2VlcF9uYW1lKG9wdGlvbnMua2VlcF9mbmFtZXMsIG5vZGUubmFtZS5uYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uX2RlZnMuYWRkKG5vZGUubmFtZS5kZWZpbml0aW9uKCkuaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xhYmVsKSB7XG4gICAgICAgICAgICBsZXQgbmFtZTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gYmFzZTU0KCsrbG5hbWUpO1xuICAgICAgICAgICAgfSB3aGlsZSAoUkVTRVJWRURfV09SRFMuaGFzKG5hbWUpKTtcbiAgICAgICAgICAgIG5vZGUubWFuZ2xlZF9uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG9wdGlvbnMuaWU4IHx8IG9wdGlvbnMuc2FmYXJpMTApICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2F0Y2gpIHtcbiAgICAgICAgICAgIHRvX21hbmdsZS5wdXNoKG5vZGUuZGVmaW5pdGlvbigpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy53YWxrKHR3KTtcblxuICAgIGlmIChvcHRpb25zLmtlZXBfZm5hbWVzIHx8IG9wdGlvbnMua2VlcF9jbGFzc25hbWVzKSB7XG4gICAgICAgIHVubWFuZ2xlYWJsZV9uYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gQ29sbGVjdCBhIHNldCBvZiBzaG9ydCBuYW1lcyB3aGljaCBhcmUgdW5tYW5nbGVhYmxlLFxuICAgICAgICAvLyBmb3IgdXNlIGluIGF2b2lkaW5nIGNvbGxpc2lvbnMgaW4gbmV4dF9tYW5nbGVkLlxuICAgICAgICB0b19tYW5nbGUuZm9yRWFjaChkZWYgPT4ge1xuICAgICAgICAgICAgaWYgKGRlZi5uYW1lLmxlbmd0aCA8IDYgJiYgZGVmLnVubWFuZ2xlYWJsZShvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHVubWFuZ2xlYWJsZV9uYW1lcy5hZGQoZGVmLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0b19tYW5nbGUuZm9yRWFjaChkZWYgPT4geyBkZWYubWFuZ2xlKG9wdGlvbnMpOyB9KTtcblxuICAgIGZ1bmN0aW9uX2RlZnMgPSBudWxsO1xuICAgIHVubWFuZ2xlYWJsZV9uYW1lcyA9IG51bGw7XG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0KHN5bWJvbCkge1xuICAgICAgICBjb25zdCBzaG91bGRfbWFuZ2xlID0gIW9wdGlvbnMucmVzZXJ2ZWQuaGFzKHN5bWJvbC5uYW1lKVxuICAgICAgICAgICAgJiYgIShzeW1ib2wuZXhwb3J0ICYgTUFTS19FWFBPUlRfRE9OVF9NQU5HTEUpO1xuICAgICAgICBpZiAoc2hvdWxkX21hbmdsZSkge1xuICAgICAgICAgICAgdG9fbWFuZ2xlLnB1c2goc3ltYm9sKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5BU1RfVG9wbGV2ZWwuREVGTUVUSE9EKFwiZmluZF9jb2xsaWRpbmdfbmFtZXNcIiwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGNvbnN0IGNhY2hlID0gb3B0aW9ucy5jYWNoZSAmJiBvcHRpb25zLmNhY2hlLnByb3BzO1xuICAgIGNvbnN0IGF2b2lkID0gbmV3IFNldCgpO1xuICAgIG9wdGlvbnMucmVzZXJ2ZWQuZm9yRWFjaCh0b19hdm9pZCk7XG4gICAgdGhpcy5nbG9iYWxzLmZvckVhY2goYWRkX2RlZik7XG4gICAgdGhpcy53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIG5vZGUudmFyaWFibGVzLmZvckVhY2goYWRkX2RlZik7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbENhdGNoKSBhZGRfZGVmKG5vZGUuZGVmaW5pdGlvbigpKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIGF2b2lkO1xuXG4gICAgZnVuY3Rpb24gdG9fYXZvaWQobmFtZSkge1xuICAgICAgICBhdm9pZC5hZGQobmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkX2RlZihkZWYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBkZWYubmFtZTtcbiAgICAgICAgaWYgKGRlZi5nbG9iYWwgJiYgY2FjaGUgJiYgY2FjaGUuaGFzKG5hbWUpKSBuYW1lID0gY2FjaGUuZ2V0KG5hbWUpO1xuICAgICAgICBlbHNlIGlmICghZGVmLnVubWFuZ2xlYWJsZShvcHRpb25zKSkgcmV0dXJuO1xuICAgICAgICB0b19hdm9pZChuYW1lKTtcbiAgICB9XG59KTtcblxuQVNUX1RvcGxldmVsLkRFRk1FVEhPRChcImV4cGFuZF9uYW1lc1wiLCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgYmFzZTU0LnJlc2V0KCk7XG4gICAgYmFzZTU0LnNvcnQoKTtcbiAgICBvcHRpb25zID0gdGhpcy5fZGVmYXVsdF9tYW5nbGVyX29wdGlvbnMob3B0aW9ucyk7XG4gICAgdmFyIGF2b2lkID0gdGhpcy5maW5kX2NvbGxpZGluZ19uYW1lcyhvcHRpb25zKTtcbiAgICB2YXIgY25hbWUgPSAwO1xuICAgIHRoaXMuZ2xvYmFscy5mb3JFYWNoKHJlbmFtZSk7XG4gICAgdGhpcy53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIG5vZGUudmFyaWFibGVzLmZvckVhY2gocmVuYW1lKTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ2F0Y2gpIHJlbmFtZShub2RlLmRlZmluaXRpb24oKSk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gbmV4dF9uYW1lKCkge1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbmFtZSA9IGJhc2U1NChjbmFtZSsrKTtcbiAgICAgICAgfSB3aGlsZSAoYXZvaWQuaGFzKG5hbWUpIHx8IFJFU0VSVkVEX1dPUkRTLmhhcyhuYW1lKSk7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmFtZShkZWYpIHtcbiAgICAgICAgaWYgKGRlZi5nbG9iYWwgJiYgb3B0aW9ucy5jYWNoZSkgcmV0dXJuO1xuICAgICAgICBpZiAoZGVmLnVubWFuZ2xlYWJsZShvcHRpb25zKSkgcmV0dXJuO1xuICAgICAgICBpZiAob3B0aW9ucy5yZXNlcnZlZC5oYXMoZGVmLm5hbWUpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IHJlZGVmaW5pdGlvbiA9IHJlZGVmaW5lZF9jYXRjaF9kZWYoZGVmKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGRlZi5uYW1lID0gcmVkZWZpbml0aW9uID8gcmVkZWZpbml0aW9uLm5hbWUgOiBuZXh0X25hbWUoKTtcbiAgICAgICAgZGVmLm9yaWcuZm9yRWFjaChmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgIHN5bS5uYW1lID0gbmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZi5yZWZlcmVuY2VzLmZvckVhY2goZnVuY3Rpb24oc3ltKSB7XG4gICAgICAgICAgICBzeW0ubmFtZSA9IG5hbWU7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5BU1RfTm9kZS5ERUZNRVRIT0QoXCJ0YWlsX25vZGVcIiwgcmV0dXJuX3RoaXMpO1xuQVNUX1NlcXVlbmNlLkRFRk1FVEhPRChcInRhaWxfbm9kZVwiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uc1t0aGlzLmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdO1xufSk7XG5cbkFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJjb21wdXRlX2NoYXJfZnJlcXVlbmN5XCIsIGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdGhpcy5fZGVmYXVsdF9tYW5nbGVyX29wdGlvbnMob3B0aW9ucyk7XG4gICAgdHJ5IHtcbiAgICAgICAgQVNUX05vZGUucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24oc3RyZWFtLCBmb3JjZV9wYXJlbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaW50KHN0cmVhbSwgZm9yY2VfcGFyZW5zKTtcbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQVNUX1N5bWJvbCAmJiAhdGhpcy51bm1hbmdsZWFibGUob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBiYXNlNTQuY29uc2lkZXIodGhpcy5uYW1lLCAtMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQVNUX0RvdEhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKFwiI1wiICsgdGhpcy5wcm9wZXJ0eSwgLTEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcyBpbnN0YW5jZW9mIEFTVF9Eb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKHRoaXMucHJvcGVydHksIC0xKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBBU1RfU3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXBfc3RyaW5nKHRoaXMucHJvcGVydHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYmFzZTU0LmNvbnNpZGVyKHRoaXMucHJpbnRfdG9fc3RyaW5nKCksIDEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIEFTVF9Ob2RlLnByb3RvdHlwZS5wcmludCA9IEFTVF9Ob2RlLnByb3RvdHlwZS5fcHJpbnQ7XG4gICAgfVxuICAgIGJhc2U1NC5zb3J0KCk7XG5cbiAgICBmdW5jdGlvbiBza2lwX3N0cmluZyhub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N0cmluZykge1xuICAgICAgICAgICAgYmFzZTU0LmNvbnNpZGVyKG5vZGUudmFsdWUsIC0xKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICBza2lwX3N0cmluZyhub2RlLmNvbnNlcXVlbnQpO1xuICAgICAgICAgICAgc2tpcF9zdHJpbmcobm9kZS5hbHRlcm5hdGl2ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkge1xuICAgICAgICAgICAgc2tpcF9zdHJpbmcobm9kZS50YWlsX25vZGUoKSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29uc3QgYmFzZTU0ID0gKCgpID0+IHtcbiAgICBjb25zdCBsZWFkaW5nID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF9cIi5zcGxpdChcIlwiKTtcbiAgICBjb25zdCBkaWdpdHMgPSBcIjAxMjM0NTY3ODlcIi5zcGxpdChcIlwiKTtcbiAgICBsZXQgY2hhcnM7XG4gICAgbGV0IGZyZXF1ZW5jeTtcbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgZnJlcXVlbmN5ID0gbmV3IE1hcCgpO1xuICAgICAgICBsZWFkaW5nLmZvckVhY2goZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgICAgIGZyZXF1ZW5jeS5zZXQoY2gsIDApO1xuICAgICAgICB9KTtcbiAgICAgICAgZGlnaXRzLmZvckVhY2goZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgICAgIGZyZXF1ZW5jeS5zZXQoY2gsIDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmFzZTU0LmNvbnNpZGVyID0gZnVuY3Rpb24oc3RyLCBkZWx0YSkge1xuICAgICAgICBmb3IgKHZhciBpID0gc3RyLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICBmcmVxdWVuY3kuc2V0KHN0cltpXSwgZnJlcXVlbmN5LmdldChzdHJbaV0pICsgZGVsdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGZyZXF1ZW5jeS5nZXQoYikgLSBmcmVxdWVuY3kuZ2V0KGEpO1xuICAgIH1cbiAgICBiYXNlNTQuc29ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjaGFycyA9IG1lcmdlU29ydChsZWFkaW5nLCBjb21wYXJlKS5jb25jYXQobWVyZ2VTb3J0KGRpZ2l0cywgY29tcGFyZSkpO1xuICAgIH07XG4gICAgYmFzZTU0LnJlc2V0ID0gcmVzZXQ7XG4gICAgcmVzZXQoKTtcbiAgICBmdW5jdGlvbiBiYXNlNTQobnVtKSB7XG4gICAgICAgIHZhciByZXQgPSBcIlwiLCBiYXNlID0gNTQ7XG4gICAgICAgIG51bSsrO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBudW0tLTtcbiAgICAgICAgICAgIHJldCArPSBjaGFyc1tudW0gJSBiYXNlXTtcbiAgICAgICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gYmFzZSk7XG4gICAgICAgICAgICBiYXNlID0gNjQ7XG4gICAgICAgIH0gd2hpbGUgKG51bSA+IDApO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTU0O1xufSkoKTtcblxubGV0IG1hbmdsZV9vcHRpb25zID0gdW5kZWZpbmVkO1xuQVNUX05vZGUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoY29tcHJlc3Nvciwgc3RhY2spIHtcbiAgICBtYW5nbGVfb3B0aW9ucyA9IGNvbXByZXNzb3IgJiYgY29tcHJlc3Nvci5tYW5nbGVfb3B0aW9ucztcblxuICAgIGxldCBzaXplID0gMDtcbiAgICB3YWxrX3BhcmVudCh0aGlzLCAobm9kZSwgaW5mbykgPT4ge1xuICAgICAgICBzaXplICs9IG5vZGUuX3NpemUoaW5mbyk7XG5cbiAgICAgICAgLy8gQnJhY2VsZXNzIGFycm93IGZ1bmN0aW9ucyBoYXZlIGZha2UgXCJyZXR1cm5cIiBzdGF0ZW1lbnRzXG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Fycm93ICYmIG5vZGUuaXNfYnJhY2VsZXNzKCkpIHtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZS5ib2R5WzBdLnZhbHVlLl9zaXplKGluZm8pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCBzdGFjayB8fCAoY29tcHJlc3NvciAmJiBjb21wcmVzc29yLnN0YWNrKSk7XG5cbiAgICAvLyBqdXN0IHRvIHNhdmUgYSBiaXQgb2YgbWVtb3J5XG4gICAgbWFuZ2xlX29wdGlvbnMgPSB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gc2l6ZTtcbn07XG5cbkFTVF9Ob2RlLnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDA7XG5cbkFTVF9EZWJ1Z2dlci5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA4O1xuXG5BU1RfRGlyZWN0aXZlLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUT0RPIHN0cmluZyBlbmNvZGluZyBzdHVmZlxuICAgIHJldHVybiAyICsgdGhpcy52YWx1ZS5sZW5ndGg7XG59O1xuXG5jb25zdCBsaXN0X292ZXJoZWFkID0gKGFycmF5KSA9PiBhcnJheS5sZW5ndGggJiYgYXJyYXkubGVuZ3RoIC0gMTtcblxuQVNUX0Jsb2NrLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMiArIGxpc3Rfb3ZlcmhlYWQodGhpcy5ib2R5KTtcbn07XG5cbkFTVF9Ub3BsZXZlbC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbGlzdF9vdmVyaGVhZCh0aGlzLmJvZHkpO1xufTtcblxuQVNUX0VtcHR5U3RhdGVtZW50LnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDE7XG5cbkFTVF9MYWJlbGVkU3RhdGVtZW50LnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDI7ICAvLyB4OlxuXG5BU1RfRG8ucHJvdG90eXBlLl9zaXplID0gKCkgPT4gOTtcblxuQVNUX1doaWxlLnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDc7XG5cbkFTVF9Gb3IucHJvdG90eXBlLl9zaXplID0gKCkgPT4gODtcblxuQVNUX0ZvckluLnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDg7XG4vLyBBU1RfRm9yT2YgaW5oZXJpdHMgXlxuXG5BU1RfV2l0aC5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA2O1xuXG5BU1RfRXhwYW5zaW9uLnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDM7XG5cbmNvbnN0IGxhbWJkYV9tb2RpZmllcnMgPSBmdW5jID0+XG4gICAgKGZ1bmMuaXNfZ2VuZXJhdG9yID8gMSA6IDApICsgKGZ1bmMuYXN5bmMgPyA2IDogMCk7XG5cbkFTVF9BY2Nlc3Nvci5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxhbWJkYV9tb2RpZmllcnModGhpcykgKyA0ICsgbGlzdF9vdmVyaGVhZCh0aGlzLmFyZ25hbWVzKSArIGxpc3Rfb3ZlcmhlYWQodGhpcy5ib2R5KTtcbn07XG5cbkFTVF9GdW5jdGlvbi5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgIGNvbnN0IGZpcnN0ID0gISFmaXJzdF9pbl9zdGF0ZW1lbnQoaW5mbyk7XG4gICAgcmV0dXJuIChmaXJzdCAqIDIpICsgbGFtYmRhX21vZGlmaWVycyh0aGlzKSArIDEyICsgbGlzdF9vdmVyaGVhZCh0aGlzLmFyZ25hbWVzKSArIGxpc3Rfb3ZlcmhlYWQodGhpcy5ib2R5KTtcbn07XG5cbkFTVF9EZWZ1bi5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxhbWJkYV9tb2RpZmllcnModGhpcykgKyAxMyArIGxpc3Rfb3ZlcmhlYWQodGhpcy5hcmduYW1lcykgKyBsaXN0X292ZXJoZWFkKHRoaXMuYm9keSk7XG59O1xuXG5BU1RfQXJyb3cucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBhcmdzX2FuZF9hcnJvdyA9IDIgKyBsaXN0X292ZXJoZWFkKHRoaXMuYXJnbmFtZXMpO1xuXG4gICAgaWYgKFxuICAgICAgICAhKFxuICAgICAgICAgICAgdGhpcy5hcmduYW1lcy5sZW5ndGggPT09IDFcbiAgICAgICAgICAgICYmIHRoaXMuYXJnbmFtZXNbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sXG4gICAgICAgIClcbiAgICApIHtcbiAgICAgICAgYXJnc19hbmRfYXJyb3cgKz0gMjtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5X292ZXJoZWFkID0gdGhpcy5pc19icmFjZWxlc3MoKSA/IDAgOiBsaXN0X292ZXJoZWFkKHRoaXMuYm9keSkgKyAyO1xuXG4gICAgcmV0dXJuIGxhbWJkYV9tb2RpZmllcnModGhpcykgKyBhcmdzX2FuZF9hcnJvdyArIGJvZHlfb3ZlcmhlYWQ7XG59O1xuXG5BU1RfRGVzdHJ1Y3R1cmluZy5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiAyO1xuXG5BU1RfVGVtcGxhdGVTdHJpbmcucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAyICsgKE1hdGguZmxvb3IodGhpcy5zZWdtZW50cy5sZW5ndGggLyAyKSAqIDMpOyAgLyogXCIke31cIiAqL1xufTtcblxuQVNUX1RlbXBsYXRlU2VnbWVudC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUubGVuZ3RoO1xufTtcblxuQVNUX1JldHVybi5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPyA3IDogNjtcbn07XG5cbkFTVF9UaHJvdy5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA2O1xuXG5BU1RfQnJlYWsucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxhYmVsID8gNiA6IDU7XG59O1xuXG5BU1RfQ29udGludWUucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxhYmVsID8gOSA6IDg7XG59O1xuXG5BU1RfSWYucHJvdG90eXBlLl9zaXplID0gKCkgPT4gNDtcblxuQVNUX1N3aXRjaC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDggKyBsaXN0X292ZXJoZWFkKHRoaXMuYm9keSk7XG59O1xuXG5BU1RfQ2FzZS5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDUgKyBsaXN0X292ZXJoZWFkKHRoaXMuYm9keSk7XG59O1xuXG5BU1RfRGVmYXVsdC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDggKyBsaXN0X292ZXJoZWFkKHRoaXMuYm9keSk7XG59O1xuXG5BU1RfVHJ5LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMyArIGxpc3Rfb3ZlcmhlYWQodGhpcy5ib2R5KTtcbn07XG5cbkFTVF9DYXRjaC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHNpemUgPSA3ICsgbGlzdF9vdmVyaGVhZCh0aGlzLmJvZHkpO1xuICAgIGlmICh0aGlzLmFyZ25hbWUpIHtcbiAgICAgICAgc2l6ZSArPSAyO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn07XG5cbkFTVF9GaW5hbGx5LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gNyArIGxpc3Rfb3ZlcmhlYWQodGhpcy5ib2R5KTtcbn07XG5cbi8qI19fSU5MSU5FX18qL1xuY29uc3QgZGVmX3NpemUgPSAoc2l6ZSwgZGVmKSA9PiBzaXplICsgbGlzdF9vdmVyaGVhZChkZWYuZGVmaW5pdGlvbnMpO1xuXG5BU1RfVmFyLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGVmX3NpemUoNCwgdGhpcyk7XG59O1xuXG5BU1RfTGV0LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGVmX3NpemUoNCwgdGhpcyk7XG59O1xuXG5BU1RfQ29uc3QucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkZWZfc2l6ZSg2LCB0aGlzKTtcbn07XG5cbkFTVF9WYXJEZWYucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlID8gMSA6IDA7XG59O1xuXG5BU1RfTmFtZU1hcHBpbmcucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGZvcmVpZ24gbmFtZSBpc24ndCBtYW5nbGVkXG4gICAgcmV0dXJuIHRoaXMubmFtZSA/IDQgOiAwO1xufTtcblxuQVNUX0ltcG9ydC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gaW1wb3J0XG4gICAgbGV0IHNpemUgPSA2O1xuXG4gICAgaWYgKHRoaXMuaW1wb3J0ZWRfbmFtZSkgc2l6ZSArPSAxO1xuXG4gICAgLy8gZnJvbVxuICAgIGlmICh0aGlzLmltcG9ydGVkX25hbWUgfHwgdGhpcy5pbXBvcnRlZF9uYW1lcykgc2l6ZSArPSA1O1xuXG4gICAgLy8gYnJhY2VzLCBhbmQgdGhlIGNvbW1hc1xuICAgIGlmICh0aGlzLmltcG9ydGVkX25hbWVzKSB7XG4gICAgICAgIHNpemUgKz0gMiArIGxpc3Rfb3ZlcmhlYWQodGhpcy5pbXBvcnRlZF9uYW1lcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpemU7XG59O1xuXG5BU1RfSW1wb3J0TWV0YS5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiAxMTtcblxuQVNUX0V4cG9ydC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHNpemUgPSA3ICsgKHRoaXMuaXNfZGVmYXVsdCA/IDggOiAwKTtcblxuICAgIGlmICh0aGlzLmV4cG9ydGVkX3ZhbHVlKSB7XG4gICAgICAgIHNpemUgKz0gdGhpcy5leHBvcnRlZF92YWx1ZS5fc2l6ZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmV4cG9ydGVkX25hbWVzKSB7XG4gICAgICAgIC8vIEJyYWNlcyBhbmQgY29tbWFzXG4gICAgICAgIHNpemUgKz0gMiArIGxpc3Rfb3ZlcmhlYWQodGhpcy5leHBvcnRlZF9uYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubW9kdWxlX25hbWUpIHtcbiAgICAgICAgLy8gXCJmcm9tIFwiXG4gICAgICAgIHNpemUgKz0gNTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZTtcbn07XG5cbkFTVF9DYWxsLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gNCArIGxpc3Rfb3ZlcmhlYWQodGhpcy5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIDIgKyBsaXN0X292ZXJoZWFkKHRoaXMuYXJncyk7XG59O1xuXG5BU1RfTmV3LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gNiArIGxpc3Rfb3ZlcmhlYWQodGhpcy5hcmdzKTtcbn07XG5cbkFTVF9TZXF1ZW5jZS5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3Rfb3ZlcmhlYWQodGhpcy5leHByZXNzaW9ucyk7XG59O1xuXG5BU1RfRG90LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5sZW5ndGggKyAyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5sZW5ndGggKyAxO1xufTtcblxuQVNUX0RvdEhhc2gucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5Lmxlbmd0aCArIDM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb3BlcnR5Lmxlbmd0aCArIDI7XG59O1xuXG5BU1RfU3ViLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbCA/IDQgOiAyO1xufTtcblxuQVNUX1VuYXJ5LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gXCJ0eXBlb2ZcIikgcmV0dXJuIDc7XG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09IFwidm9pZFwiKSByZXR1cm4gNTtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRvci5sZW5ndGg7XG59O1xuXG5BU1RfQmluYXJ5LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgaWYgKHRoaXMub3BlcmF0b3IgPT09IFwiaW5cIikgcmV0dXJuIDQ7XG5cbiAgICBsZXQgc2l6ZSA9IHRoaXMub3BlcmF0b3IubGVuZ3RoO1xuXG4gICAgaWYgKFxuICAgICAgICAodGhpcy5vcGVyYXRvciA9PT0gXCIrXCIgfHwgdGhpcy5vcGVyYXRvciA9PT0gXCItXCIpXG4gICAgICAgICYmIHRoaXMucmlnaHQgaW5zdGFuY2VvZiBBU1RfVW5hcnkgJiYgdGhpcy5yaWdodC5vcGVyYXRvciA9PT0gdGhpcy5vcGVyYXRvclxuICAgICkge1xuICAgICAgICAvLyAxKyArYSA+IG5lZWRzIHNwYWNlIGJldHdlZW4gdGhlICtcbiAgICAgICAgc2l6ZSArPSAxO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZWRzX3BhcmVucyhpbmZvKSkge1xuICAgICAgICBzaXplICs9IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpemU7XG59O1xuXG5BU1RfQ29uZGl0aW9uYWwucHJvdG90eXBlLl9zaXplID0gKCkgPT4gMztcblxuQVNUX0FycmF5LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMiArIGxpc3Rfb3ZlcmhlYWQodGhpcy5lbGVtZW50cyk7XG59O1xuXG5BU1RfT2JqZWN0LnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgbGV0IGJhc2UgPSAyO1xuICAgIGlmIChmaXJzdF9pbl9zdGF0ZW1lbnQoaW5mbykpIHtcbiAgICAgICAgYmFzZSArPSAyOyAvLyBwYXJlbnNcbiAgICB9XG4gICAgcmV0dXJuIGJhc2UgKyBsaXN0X292ZXJoZWFkKHRoaXMucHJvcGVydGllcyk7XG59O1xuXG4vKiNfX0lOTElORV9fKi9cbmNvbnN0IGtleV9zaXplID0ga2V5ID0+XG4gICAgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiA/IGtleS5sZW5ndGggOiAwO1xuXG5BU1RfT2JqZWN0S2V5VmFsLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ga2V5X3NpemUodGhpcy5rZXkpICsgMTtcbn07XG5cbi8qI19fSU5MSU5FX18qL1xuY29uc3Qgc3RhdGljX3NpemUgPSBpc19zdGF0aWMgPT4gaXNfc3RhdGljID8gNyA6IDA7XG5cbkFTVF9PYmplY3RHZXR0ZXIucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiA1ICsgc3RhdGljX3NpemUodGhpcy5zdGF0aWMpICsga2V5X3NpemUodGhpcy5rZXkpO1xufTtcblxuQVNUX09iamVjdFNldHRlci5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDUgKyBzdGF0aWNfc2l6ZSh0aGlzLnN0YXRpYykgKyBrZXlfc2l6ZSh0aGlzLmtleSk7XG59O1xuXG5BU1RfQ29uY2lzZU1ldGhvZC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0YXRpY19zaXplKHRoaXMuc3RhdGljKSArIGtleV9zaXplKHRoaXMua2V5KSArIGxhbWJkYV9tb2RpZmllcnModGhpcyk7XG59O1xuXG5BU1RfUHJpdmF0ZU1ldGhvZC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEFTVF9Db25jaXNlTWV0aG9kLnByb3RvdHlwZS5fc2l6ZS5jYWxsKHRoaXMpICsgMTtcbn07XG5cbkFTVF9Qcml2YXRlR2V0dGVyLnByb3RvdHlwZS5fc2l6ZSA9IEFTVF9Qcml2YXRlU2V0dGVyLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQVNUX0NvbmNpc2VNZXRob2QucHJvdG90eXBlLl9zaXplLmNhbGwodGhpcykgKyA0O1xufTtcblxuQVNUX0NsYXNzLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAodGhpcy5uYW1lID8gOCA6IDcpXG4gICAgICAgICsgKHRoaXMuZXh0ZW5kcyA/IDggOiAwKVxuICAgICk7XG59O1xuXG5BU1RfQ2xhc3NQcm9wZXJ0eS5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgc3RhdGljX3NpemUodGhpcy5zdGF0aWMpXG4gICAgICAgICsgKHR5cGVvZiB0aGlzLmtleSA9PT0gXCJzdHJpbmdcIiA/IHRoaXMua2V5Lmxlbmd0aCArIDIgOiAwKVxuICAgICAgICArICh0aGlzLnZhbHVlID8gMSA6IDApXG4gICAgKTtcbn07XG5cbkFTVF9DbGFzc1ByaXZhdGVQcm9wZXJ0eS5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEFTVF9DbGFzc1Byb3BlcnR5LnByb3RvdHlwZS5fc2l6ZS5jYWxsKHRoaXMpICsgMTtcbn07XG5cbkFTVF9TeW1ib2wucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhbWFuZ2xlX29wdGlvbnMgfHwgdGhpcy5kZWZpbml0aW9uKCkudW5tYW5nbGVhYmxlKG1hbmdsZV9vcHRpb25zKVxuICAgICAgICA/IHRoaXMubmFtZS5sZW5ndGhcbiAgICAgICAgOiAxO1xufTtcblxuLy8gVE9ETyB0YWtlIHByb3BtYW5nbGUgaW50byBhY2NvdW50XG5BU1RfU3ltYm9sQ2xhc3NQcm9wZXJ0eS5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZS5sZW5ndGg7XG59O1xuXG5BU1RfU3ltYm9sUmVmLnByb3RvdHlwZS5fc2l6ZSA9IEFTVF9TeW1ib2xEZWNsYXJhdGlvbi5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgeyBuYW1lLCB0aGVkZWYgfSA9IHRoaXM7XG5cbiAgICBpZiAodGhlZGVmICYmIHRoZWRlZi5nbG9iYWwpIHJldHVybiBuYW1lLmxlbmd0aDtcblxuICAgIGlmIChuYW1lID09PSBcImFyZ3VtZW50c1wiKSByZXR1cm4gOTtcblxuICAgIHJldHVybiBBU1RfU3ltYm9sLnByb3RvdHlwZS5fc2l6ZS5jYWxsKHRoaXMpO1xufTtcblxuQVNUX05ld1RhcmdldC5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiAxMDtcblxuQVNUX1N5bWJvbEltcG9ydEZvcmVpZ24ucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWUubGVuZ3RoO1xufTtcblxuQVNUX1N5bWJvbEV4cG9ydEZvcmVpZ24ucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWUubGVuZ3RoO1xufTtcblxuQVNUX1RoaXMucHJvdG90eXBlLl9zaXplID0gKCkgPT4gNDtcblxuQVNUX1N1cGVyLnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDU7XG5cbkFTVF9TdHJpbmcucHJvdG90eXBlLl9zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlLmxlbmd0aCArIDI7XG59O1xuXG5BU1RfTnVtYmVyLnByb3RvdHlwZS5fc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzO1xuICAgIGlmICh2YWx1ZSA9PT0gMCkgcmV0dXJuIDE7XG4gICAgaWYgKHZhbHVlID4gMCAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5sb2cxMCh2YWx1ZSkgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkubGVuZ3RoO1xufTtcblxuQVNUX0JpZ0ludC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUubGVuZ3RoO1xufTtcblxuQVNUX1JlZ0V4cC5wcm90b3R5cGUuX3NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUudG9TdHJpbmcoKS5sZW5ndGg7XG59O1xuXG5BU1RfTnVsbC5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA0O1xuXG5BU1RfTmFOLnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDM7XG5cbkFTVF9VbmRlZmluZWQucHJvdG90eXBlLl9zaXplID0gKCkgPT4gNjsgLy8gXCJ2b2lkIDBcIlxuXG5BU1RfSG9sZS5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiAwOyAgLy8gY29tbWEgaXMgdGFrZW4gaW50byBhY2NvdW50XG5cbkFTVF9JbmZpbml0eS5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA4O1xuXG5BU1RfVHJ1ZS5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA0O1xuXG5BU1RfRmFsc2UucHJvdG90eXBlLl9zaXplID0gKCkgPT4gNTtcblxuQVNUX0F3YWl0LnByb3RvdHlwZS5fc2l6ZSA9ICgpID0+IDY7XG5cbkFTVF9ZaWVsZC5wcm90b3R5cGUuX3NpemUgPSAoKSA9PiA2O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICBBIEphdmFTY3JpcHQgdG9rZW5pemVyIC8gcGFyc2VyIC8gYmVhdXRpZmllciAvIGNvbXByZXNzb3IuXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyXG5cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKEMpIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBBdXRob3I6IE1paGFpIEJhem9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cbiAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL21paGFpLmJhem9uLm5ldC9ibG9nXG5cbiAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBsaWNlbnNlOlxuXG4gICAgQ29weXJpZ2h0IDIwMTIgKGMpIE1paGFpIEJhem9uIDxtaWhhaS5iYXpvbkBnbWFpbC5jb20+XG5cbiAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAgICBhcmUgbWV0OlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lci5cblxuICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAgICAgICAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICAgICAgICAgIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVIg4oCcQVMgSVPigJ0gQU5EIEFOWVxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gICAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gICAgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgQkVcbiAgICBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksXG4gICAgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAgICBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAgICBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUlxuICAgIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRlxuICAgIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRlxuICAgIFNVQ0ggREFNQUdFLlxuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmNvbnN0IFVOVVNFRCAgICA9IDBiMDAwMDAwMDE7XG5jb25zdCBUUlVUSFkgICAgPSAwYjAwMDAwMDEwO1xuY29uc3QgRkFMU1kgICAgID0gMGIwMDAwMDEwMDtcbmNvbnN0IFVOREVGSU5FRCA9IDBiMDAwMDEwMDA7XG5jb25zdCBJTkxJTkVEICAgPSAwYjAwMDEwMDAwO1xuLy8gTm9kZXMgdG8gd2hpY2ggdmFsdWVzIGFyZSBldmVyIHdyaXR0ZW4uIFVzZWQgd2hlbiBrZWVwX2Fzc2lnbiBpcyBwYXJ0IG9mIHRoZSB1bnVzZWQgb3B0aW9uIHN0cmluZy5cbmNvbnN0IFdSSVRFX09OTFk9IDBiMDAxMDAwMDA7XG5cbi8vIGluZm9ybWF0aW9uIHNwZWNpZmljIHRvIGEgc2luZ2xlIGNvbXByZXNzaW9uIHBhc3NcbmNvbnN0IFNRVUVFWkVEICA9IDBiMDAwMDAwMDEwMDAwMDAwMDtcbmNvbnN0IE9QVElNSVpFRCA9IDBiMDAwMDAwMTAwMDAwMDAwMDtcbmNvbnN0IFRPUCAgICAgICA9IDBiMDAwMDAxMDAwMDAwMDAwMDtcblxuY29uc3QgQ0xFQVJfQkVUV0VFTl9QQVNTRVMgPSBTUVVFRVpFRCB8IE9QVElNSVpFRCB8IFRPUDtcblxuY29uc3QgaGFzX2ZsYWcgPSAobm9kZSwgZmxhZykgPT4gbm9kZS5mbGFncyAmIGZsYWc7XG5jb25zdCBzZXRfZmxhZyA9IChub2RlLCBmbGFnKSA9PiB7IG5vZGUuZmxhZ3MgfD0gZmxhZzsgfTtcbmNvbnN0IGNsZWFyX2ZsYWcgPSAobm9kZSwgZmxhZykgPT4geyBub2RlLmZsYWdzICY9IH5mbGFnOyB9O1xuXG5jbGFzcyBDb21wcmVzc29yIGV4dGVuZHMgVHJlZVdhbGtlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgeyBmYWxzZV9ieV9kZWZhdWx0ID0gZmFsc2UsIG1hbmdsZV9vcHRpb25zID0gZmFsc2UgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cyAhPT0gdW5kZWZpbmVkICYmICFvcHRpb25zLmRlZmF1bHRzKSBmYWxzZV9ieV9kZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICAgICAgYXJndW1lbnRzICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgYXJyb3dzICAgICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgYm9vbGVhbnMgICAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgYm9vbGVhbnNfYXNfaW50ZWdlcnMgOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbGxhcHNlX3ZhcnMgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgICAgIGNvbXBhcmlzb25zICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgICAgIGNvbXB1dGVkX3Byb3BzOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgICAgIGNvbmRpdGlvbmFscyAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgICAgIGRlYWRfY29kZSAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgICAgIGRlZmF1bHRzICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGlyZWN0aXZlcyAgICA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgZHJvcF9jb25zb2xlICA6IGZhbHNlLFxuICAgICAgICAgICAgZHJvcF9kZWJ1Z2dlciA6ICFmYWxzZV9ieV9kZWZhdWx0LFxuICAgICAgICAgICAgZWNtYSAgICAgICAgICA6IDUsXG4gICAgICAgICAgICBldmFsdWF0ZSAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBleHByZXNzaW9uICAgIDogZmFsc2UsXG4gICAgICAgICAgICBnbG9iYWxfZGVmcyAgIDogZmFsc2UsXG4gICAgICAgICAgICBob2lzdF9mdW5zICAgIDogZmFsc2UsXG4gICAgICAgICAgICBob2lzdF9wcm9wcyAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBob2lzdF92YXJzICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpZTggICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpZl9yZXR1cm4gICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBpbmxpbmUgICAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBqb2luX3ZhcnMgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBrZWVwX2NsYXNzbmFtZXM6IGZhbHNlLFxuICAgICAgICAgICAga2VlcF9mYXJncyAgICA6IHRydWUsXG4gICAgICAgICAgICBrZWVwX2ZuYW1lcyAgIDogZmFsc2UsXG4gICAgICAgICAgICBrZWVwX2luZmluaXR5IDogZmFsc2UsXG4gICAgICAgICAgICBsb29wcyAgICAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBtb2R1bGUgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBuZWdhdGVfaWlmZSAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBwYXNzZXMgICAgICAgIDogMSxcbiAgICAgICAgICAgIHByb3BlcnRpZXMgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgICAgIHB1cmVfZ2V0dGVycyAgOiAhZmFsc2VfYnlfZGVmYXVsdCAmJiBcInN0cmljdFwiLFxuICAgICAgICAgICAgcHVyZV9mdW5jcyAgICA6IG51bGwsXG4gICAgICAgICAgICByZWR1Y2VfZnVuY3MgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICByZWR1Y2VfdmFycyAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBzZXF1ZW5jZXMgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBzaWRlX2VmZmVjdHMgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICBzd2l0Y2hlcyAgICAgIDogIWZhbHNlX2J5X2RlZmF1bHQsXG4gICAgICAgICAgICB0b3BfcmV0YWluICAgIDogbnVsbCxcbiAgICAgICAgICAgIHRvcGxldmVsICAgICAgOiAhIShvcHRpb25zICYmIG9wdGlvbnNbXCJ0b3BfcmV0YWluXCJdKSxcbiAgICAgICAgICAgIHR5cGVvZnMgICAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgICAgIHVuc2FmZSAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVuc2FmZV9hcnJvd3MgOiBmYWxzZSxcbiAgICAgICAgICAgIHVuc2FmZV9jb21wcyAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVuc2FmZV9GdW5jdGlvbjogZmFsc2UsXG4gICAgICAgICAgICB1bnNhZmVfbWF0aCAgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnNhZmVfc3ltYm9sczogZmFsc2UsXG4gICAgICAgICAgICB1bnNhZmVfbWV0aG9kczogZmFsc2UsXG4gICAgICAgICAgICB1bnNhZmVfcHJvdG8gIDogZmFsc2UsXG4gICAgICAgICAgICB1bnNhZmVfcmVnZXhwIDogZmFsc2UsXG4gICAgICAgICAgICB1bnNhZmVfdW5kZWZpbmVkOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZCAgICAgICAgOiAhZmFsc2VfYnlfZGVmYXVsdCxcbiAgICAgICAgICAgIHdhcm5pbmdzICAgICAgOiBmYWxzZSAgLy8gbGVnYWN5XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICB2YXIgZ2xvYmFsX2RlZnMgPSB0aGlzLm9wdGlvbnNbXCJnbG9iYWxfZGVmc1wiXTtcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxfZGVmcyA9PSBcIm9iamVjdFwiKSBmb3IgKHZhciBrZXkgaW4gZ2xvYmFsX2RlZnMpIHtcbiAgICAgICAgICAgIGlmIChrZXlbMF0gPT09IFwiQFwiICYmIEhPUChnbG9iYWxfZGVmcywga2V5KSkge1xuICAgICAgICAgICAgICAgIGdsb2JhbF9kZWZzW2tleS5zbGljZSgxKV0gPSBwYXJzZShnbG9iYWxfZGVmc1trZXldLCB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zW1wiaW5saW5lXCJdID09PSB0cnVlKSB0aGlzLm9wdGlvbnNbXCJpbmxpbmVcIl0gPSAzO1xuICAgICAgICB2YXIgcHVyZV9mdW5jcyA9IHRoaXMub3B0aW9uc1tcInB1cmVfZnVuY3NcIl07XG4gICAgICAgIGlmICh0eXBlb2YgcHVyZV9mdW5jcyA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMucHVyZV9mdW5jcyA9IHB1cmVfZnVuY3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnB1cmVfZnVuY3MgPSBwdXJlX2Z1bmNzID8gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhcHVyZV9mdW5jcy5pbmNsdWRlcyhub2RlLmV4cHJlc3Npb24ucHJpbnRfdG9fc3RyaW5nKCkpO1xuICAgICAgICAgICAgfSA6IHJldHVybl90cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b3BfcmV0YWluID0gdGhpcy5vcHRpb25zW1widG9wX3JldGFpblwiXTtcbiAgICAgICAgaWYgKHRvcF9yZXRhaW4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHRoaXMudG9wX3JldGFpbiA9IGZ1bmN0aW9uKGRlZikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b3BfcmV0YWluLnRlc3QoZGVmLm5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdG9wX3JldGFpbiA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMudG9wX3JldGFpbiA9IHRvcF9yZXRhaW47XG4gICAgICAgIH0gZWxzZSBpZiAodG9wX3JldGFpbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3BfcmV0YWluID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0b3BfcmV0YWluID0gdG9wX3JldGFpbi5zcGxpdCgvLC8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50b3BfcmV0YWluID0gZnVuY3Rpb24oZGVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvcF9yZXRhaW4uaW5jbHVkZXMoZGVmLm5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zW1wibW9kdWxlXCJdKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXNbXCJ1c2Ugc3RyaWN0XCJdID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tcInRvcGxldmVsXCJdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG9wbGV2ZWwgPSB0aGlzLm9wdGlvbnNbXCJ0b3BsZXZlbFwiXTtcbiAgICAgICAgdGhpcy50b3BsZXZlbCA9IHR5cGVvZiB0b3BsZXZlbCA9PSBcInN0cmluZ1wiID8ge1xuICAgICAgICAgICAgZnVuY3M6IC9mdW5jcy8udGVzdCh0b3BsZXZlbCksXG4gICAgICAgICAgICB2YXJzOiAvdmFycy8udGVzdCh0b3BsZXZlbClcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGZ1bmNzOiB0b3BsZXZlbCxcbiAgICAgICAgICAgIHZhcnM6IHRvcGxldmVsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZXF1ZW5jZXMgPSB0aGlzLm9wdGlvbnNbXCJzZXF1ZW5jZXNcIl07XG4gICAgICAgIHRoaXMuc2VxdWVuY2VzX2xpbWl0ID0gc2VxdWVuY2VzID09IDEgPyA4MDAgOiBzZXF1ZW5jZXMgfCAwO1xuICAgICAgICB0aGlzLmV2YWx1YXRlZF9yZWdleHBzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl90b3BsZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tYW5nbGVfb3B0aW9ucyA9IG1hbmdsZV9vcHRpb25zO1xuICAgIH1cblxuICAgIG9wdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1trZXldO1xuICAgIH1cblxuICAgIGV4cG9zZWQoZGVmKSB7XG4gICAgICAgIGlmIChkZWYuZXhwb3J0KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGRlZi5nbG9iYWwpIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkZWYub3JpZy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy50b3BsZXZlbFtkZWYub3JpZ1tpXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWZ1biA/IFwiZnVuY3NcIiA6IFwidmFyc1wiXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGluX2Jvb2xlYW5fY29udGV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbihcImJvb2xlYW5zXCIpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcy5zZWxmKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwOyBwID0gdGhpcy5wYXJlbnQoaSk7IGkrKykge1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50XG4gICAgICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAmJiBwLmNvbmRpdGlvbiA9PT0gc2VsZlxuICAgICAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfRFdMb29wICYmIHAuY29uZGl0aW9uID09PSBzZWxmXG4gICAgICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9Gb3IgJiYgcC5jb25kaXRpb24gPT09IHNlbGZcbiAgICAgICAgICAgICAgICB8fCBwIGluc3RhbmNlb2YgQVNUX0lmICYmIHAuY29uZGl0aW9uID09PSBzZWxmXG4gICAgICAgICAgICAgICAgfHwgcCBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeCAmJiBwLm9wZXJhdG9yID09IFwiIVwiICYmIHAuZXhwcmVzc2lvbiA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHAub3BlcmF0b3IgPT0gXCImJlwiXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBwLm9wZXJhdG9yID09IFwifHxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgcC5vcGVyYXRvciA9PSBcIj8/XCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHx8IHAgaW5zdGFuY2VvZiBBU1RfQ29uZGl0aW9uYWxcbiAgICAgICAgICAgICAgICB8fCBwLnRhaWxfbm9kZSgpID09PSBzZWxmXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzZWxmID0gcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0X3RvcGxldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9wbGV2ZWw7XG4gICAgfVxuXG4gICAgY29tcHJlc3ModG9wbGV2ZWwpIHtcbiAgICAgICAgdG9wbGV2ZWwgPSB0b3BsZXZlbC5yZXNvbHZlX2RlZmluZXModGhpcyk7XG4gICAgICAgIHRoaXMuX3RvcGxldmVsID0gdG9wbGV2ZWw7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbihcImV4cHJlc3Npb25cIikpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvcGxldmVsLnByb2Nlc3NfZXhwcmVzc2lvbih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFzc2VzID0gK3RoaXMub3B0aW9ucy5wYXNzZXMgfHwgMTtcbiAgICAgICAgdmFyIG1pbl9jb3VudCA9IDEgLyAwO1xuICAgICAgICB2YXIgc3RvcHBpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIG1hbmdsZSA9IHsgaWU4OiB0aGlzLm9wdGlvbihcImllOFwiKSB9O1xuICAgICAgICBmb3IgKHZhciBwYXNzID0gMDsgcGFzcyA8IHBhc3NlczsgcGFzcysrKSB7XG4gICAgICAgICAgICB0aGlzLl90b3BsZXZlbC5maWd1cmVfb3V0X3Njb3BlKG1hbmdsZSk7XG4gICAgICAgICAgICBpZiAocGFzcyA9PT0gMCAmJiB0aGlzLm9wdGlvbihcImRyb3BfY29uc29sZVwiKSkge1xuICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgcnVuIGJlZm9yZSByZWR1Y2VfdmFycyBhbmQgY29tcHJlc3MgcGFzc1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvcGxldmVsID0gdGhpcy5fdG9wbGV2ZWwuZHJvcF9jb25zb2xlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFzcyA+IDAgfHwgdGhpcy5vcHRpb24oXCJyZWR1Y2VfdmFyc1wiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvcGxldmVsLnJlc2V0X29wdF9mbGFncyh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RvcGxldmVsID0gdGhpcy5fdG9wbGV2ZWwudHJhbnNmb3JtKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHBhc3NlcyA+IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHdhbGsodGhpcy5fdG9wbGV2ZWwsICgpID0+IHsgY291bnQrKzsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbl9jb3VudCA9IGNvdW50O1xuICAgICAgICAgICAgICAgICAgICBzdG9wcGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RvcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb24oXCJleHByZXNzaW9uXCIpKSB7XG4gICAgICAgICAgICB0aGlzLl90b3BsZXZlbC5wcm9jZXNzX2V4cHJlc3Npb24oZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRvcGxldmVsID0gdGhpcy5fdG9wbGV2ZWw7XG4gICAgICAgIHRoaXMuX3RvcGxldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdG9wbGV2ZWw7XG4gICAgfVxuXG4gICAgYmVmb3JlKG5vZGUsIGRlc2NlbmQpIHtcbiAgICAgICAgaWYgKGhhc19mbGFnKG5vZGUsIFNRVUVFWkVEKSkgcmV0dXJuIG5vZGU7XG4gICAgICAgIHZhciB3YXNfc2NvcGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmhvaXN0X3Byb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5ob2lzdF9kZWNsYXJhdGlvbnModGhpcyk7XG4gICAgICAgICAgICB3YXNfc2NvcGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJlZm9yZSBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9wdWxsLzE2MDIgQVNUX05vZGUub3B0aW1pemUoKVxuICAgICAgICAvLyB3b3VsZCBjYWxsIEFTVF9Ob2RlLnRyYW5zZm9ybSgpIGlmIGEgZGlmZmVyZW50IGluc3RhbmNlIG9mIEFTVF9Ob2RlIGlzXG4gICAgICAgIC8vIHByb2R1Y2VkIGFmdGVyIGRlZl9vcHRpbWl6ZSgpLlxuICAgICAgICAvLyBUaGlzIGNvcnJ1cHRzIFRyZWVXYWxrZXIuc3RhY2ssIHdoaWNoIGNhdXNlIEFTVCBsb29rLXVwcyB0byBtYWxmdW5jdGlvbi5cbiAgICAgICAgLy8gTWlncmF0ZSBhbmQgZGVmZXIgYWxsIGNoaWxkcmVuJ3MgQVNUX05vZGUudHJhbnNmb3JtKCkgdG8gYmVsb3csIHdoaWNoXG4gICAgICAgIC8vIHdpbGwgbm93IGhhcHBlbiBhZnRlciB0aGlzIHBhcmVudCBBU1RfTm9kZSBoYXMgYmVlbiBwcm9wZXJseSBzdWJzdGl0dXRlZFxuICAgICAgICAvLyB0aHVzIGdpdmVzIGEgY29uc2lzdGVudCBBU1Qgc25hcHNob3QuXG4gICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgIC8vIEV4aXN0aW5nIGNvZGUgcmVsaWVzIG9uIGhvdyBBU1RfTm9kZS5vcHRpbWl6ZSgpIHdvcmtlZCwgYW5kIG9taXR0aW5nIHRoZVxuICAgICAgICAvLyBmb2xsb3dpbmcgcmVwbGFjZW1lbnQgY2FsbCB3b3VsZCByZXN1bHQgaW4gZGVncmFkZWQgZWZmaWNpZW5jeSBvZiBib3RoXG4gICAgICAgIC8vIG91dHB1dCBhbmQgcGVyZm9ybWFuY2UuXG4gICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgIHZhciBvcHQgPSBub2RlLm9wdGltaXplKHRoaXMpO1xuICAgICAgICBpZiAod2FzX3Njb3BlICYmIG9wdCBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgb3B0LmRyb3BfdW51c2VkKHRoaXMpO1xuICAgICAgICAgICAgZGVzY2VuZChvcHQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHQgPT09IG5vZGUpIHNldF9mbGFnKG9wdCwgU1FVRUVaRUQpO1xuICAgICAgICByZXR1cm4gb3B0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmX29wdGltaXplKG5vZGUsIG9wdGltaXplcikge1xuICAgIG5vZGUuREVGTUVUSE9EKFwib3B0aW1pemVcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChoYXNfZmxhZyhzZWxmLCBPUFRJTUlaRUQpKSByZXR1cm4gc2VsZjtcbiAgICAgICAgaWYgKGNvbXByZXNzb3IuaGFzX2RpcmVjdGl2ZShcInVzZSBhc21cIikpIHJldHVybiBzZWxmO1xuICAgICAgICB2YXIgb3B0ID0gb3B0aW1pemVyKHNlbGYsIGNvbXByZXNzb3IpO1xuICAgICAgICBzZXRfZmxhZyhvcHQsIE9QVElNSVpFRCk7XG4gICAgICAgIHJldHVybiBvcHQ7XG4gICAgfSk7XG59XG5cbmRlZl9vcHRpbWl6ZShBU1RfTm9kZSwgZnVuY3Rpb24oc2VsZikge1xuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbkFTVF9Ub3BsZXZlbC5ERUZNRVRIT0QoXCJkcm9wX2NvbnNvbGVcIiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24oc2VsZikge1xuICAgICAgICBpZiAoc2VsZi5UWVBFID09IFwiQ2FsbFwiKSB7XG4gICAgICAgICAgICB2YXIgZXhwID0gc2VsZi5leHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKGV4cCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBleHAuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmFtZS5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc191bmRlY2xhcmVkX3JlZihuYW1lKSAmJiBuYW1lLm5hbWUgPT0gXCJjb25zb2xlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSk7XG59KTtcblxuQVNUX05vZGUuREVGTUVUSE9EKFwiZXF1aXZhbGVudF90b1wiLCBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIGVxdWl2YWxlbnRfdG8odGhpcywgbm9kZSk7XG59KTtcblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcInByb2Nlc3NfZXhwcmVzc2lvblwiLCBmdW5jdGlvbihpbnNlcnQsIGNvbXByZXNzb3IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR0ID0gbmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmIChpbnNlcnQgJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1JldHVybiwgbm9kZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBub2RlLmJvZHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5zZXJ0ICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfUmV0dXJuKSB7XG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvcikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUudmFsdWUgJiYgbm9kZS52YWx1ZS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3NvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogdmFsdWVcbiAgICAgICAgICAgICAgICB9KSA6IG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBub2RlLCB7XG4gICAgICAgICAgICAgICAgYm9keTogbm9kZS52YWx1ZSB8fCBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcInZvaWRcIixcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbWFrZV9ub2RlKEFTVF9OdW1iZXIsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NsYXNzIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhICYmIG5vZGUgIT09IHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Jsb2NrKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBub2RlLmJvZHkubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5ib2R5W2luZGV4XSA9IG5vZGUuYm9keVtpbmRleF0udHJhbnNmb3JtKHR0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0lmKSB7XG4gICAgICAgICAgICBub2RlLmJvZHkgPSBub2RlLmJvZHkudHJhbnNmb3JtKHR0KTtcbiAgICAgICAgICAgIGlmIChub2RlLmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hbHRlcm5hdGl2ZSA9IG5vZGUuYWx0ZXJuYXRpdmUudHJhbnNmb3JtKHR0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1dpdGgpIHtcbiAgICAgICAgICAgIG5vZGUuYm9keSA9IG5vZGUuYm9keS50cmFuc2Zvcm0odHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIHNlbGYudHJhbnNmb3JtKHR0KTtcbn0pO1xuXG5mdW5jdGlvbiByZWFkX3Byb3BlcnR5KG9iaiwga2V5KSB7XG4gICAga2V5ID0gZ2V0X3ZhbHVlKGtleSk7XG4gICAgaWYgKGtleSBpbnN0YW5jZW9mIEFTVF9Ob2RlKSByZXR1cm47XG5cbiAgICB2YXIgdmFsdWU7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFTVF9BcnJheSkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBvYmouZWxlbWVudHM7XG4gICAgICAgIGlmIChrZXkgPT0gXCJsZW5ndGhcIikgcmV0dXJuIG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGVsZW1lbnRzLmxlbmd0aCwgb2JqKTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gXCJudW1iZXJcIiAmJiBrZXkgaW4gZWxlbWVudHMpIHZhbHVlID0gZWxlbWVudHNba2V5XTtcbiAgICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIEFTVF9PYmplY3QpIHtcbiAgICAgICAga2V5ID0gXCJcIiArIGtleTtcbiAgICAgICAgdmFyIHByb3BzID0gb2JqLnByb3BlcnRpZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSBwcm9wcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgIGlmICghKHByb3AgaW5zdGFuY2VvZiBBU1RfT2JqZWN0S2V5VmFsKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSAmJiBwcm9wc1tpXS5rZXkgPT09IGtleSkgdmFsdWUgPSBwcm9wc1tpXS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgdmFsdWUuZml4ZWRfdmFsdWUoKSB8fCB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gaXNfbW9kaWZpZWQoY29tcHJlc3NvciwgdHcsIG5vZGUsIHZhbHVlLCBsZXZlbCwgaW1tdXRhYmxlKSB7XG4gICAgdmFyIHBhcmVudCA9IHR3LnBhcmVudChsZXZlbCk7XG4gICAgdmFyIGxocyA9IGlzX2xocyhub2RlLCBwYXJlbnQpO1xuICAgIGlmIChsaHMpIHJldHVybiBsaHM7XG4gICAgaWYgKCFpbW11dGFibGVcbiAgICAgICAgJiYgcGFyZW50IGluc3RhbmNlb2YgQVNUX0NhbGxcbiAgICAgICAgJiYgcGFyZW50LmV4cHJlc3Npb24gPT09IG5vZGVcbiAgICAgICAgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFTVF9BcnJvdylcbiAgICAgICAgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFTVF9DbGFzcylcbiAgICAgICAgJiYgIXBhcmVudC5pc19jYWxsZWVfcHVyZShjb21wcmVzc29yKVxuICAgICAgICAmJiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFTVF9GdW5jdGlvbilcbiAgICAgICAgICAgIHx8ICEocGFyZW50IGluc3RhbmNlb2YgQVNUX05ldykgJiYgdmFsdWUuY29udGFpbnNfdGhpcygpKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9BcnJheSkge1xuICAgICAgICByZXR1cm4gaXNfbW9kaWZpZWQoY29tcHJlc3NvciwgdHcsIHBhcmVudCwgcGFyZW50LCBsZXZlbCArIDEpO1xuICAgIH1cbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX09iamVjdEtleVZhbCAmJiBub2RlID09PSBwYXJlbnQudmFsdWUpIHtcbiAgICAgICAgdmFyIG9iaiA9IHR3LnBhcmVudChsZXZlbCArIDEpO1xuICAgICAgICByZXR1cm4gaXNfbW9kaWZpZWQoY29tcHJlc3NvciwgdHcsIG9iaiwgb2JqLCBsZXZlbCArIDIpO1xuICAgIH1cbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgcGFyZW50LmV4cHJlc3Npb24gPT09IG5vZGUpIHtcbiAgICAgICAgdmFyIHByb3AgPSByZWFkX3Byb3BlcnR5KHZhbHVlLCBwYXJlbnQucHJvcGVydHkpO1xuICAgICAgICByZXR1cm4gIWltbXV0YWJsZSAmJiBpc19tb2RpZmllZChjb21wcmVzc29yLCB0dywgcGFyZW50LCBwcm9wLCBsZXZlbCArIDEpO1xuICAgIH1cbn1cblxuKGZ1bmN0aW9uKGRlZl9yZWR1Y2VfdmFycykge1xuICAgIGRlZl9yZWR1Y2VfdmFycyhBU1RfTm9kZSwgbm9vcCk7XG5cbiAgICBmdW5jdGlvbiByZXNldF9kZWYoY29tcHJlc3NvciwgZGVmKSB7XG4gICAgICAgIGRlZi5hc3NpZ25tZW50cyA9IDA7XG4gICAgICAgIGRlZi5jaGFpbmVkID0gZmFsc2U7XG4gICAgICAgIGRlZi5kaXJlY3RfYWNjZXNzID0gZmFsc2U7XG4gICAgICAgIGRlZi5lc2NhcGVkID0gMDtcbiAgICAgICAgZGVmLnJlY3Vyc2l2ZV9yZWZzID0gMDtcbiAgICAgICAgZGVmLnJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgZGVmLnNpbmdsZV91c2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChkZWYuc2NvcGUucGlubmVkKCkpIHtcbiAgICAgICAgICAgIGRlZi5maXhlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGRlZi5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbENvbnN0IHx8ICFjb21wcmVzc29yLmV4cG9zZWQoZGVmKSkge1xuICAgICAgICAgICAgZGVmLmZpeGVkID0gZGVmLmluaXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWYuZml4ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2V0X3ZhcmlhYmxlcyh0dywgY29tcHJlc3Nvciwgbm9kZSkge1xuICAgICAgICBub2RlLnZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKGRlZikge1xuICAgICAgICAgICAgcmVzZXRfZGVmKGNvbXByZXNzb3IsIGRlZik7XG4gICAgICAgICAgICBpZiAoZGVmLmZpeGVkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHcuZGVmc190b19zYWZlX2lkcy5zZXQoZGVmLmlkLCB0dy5zYWZlX2lkcyk7XG4gICAgICAgICAgICAgICAgbWFyayh0dywgZGVmLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmLmZpeGVkKSB7XG4gICAgICAgICAgICAgICAgdHcubG9vcF9pZHMuc2V0KGRlZi5pZCwgdHcuaW5fbG9vcCk7XG4gICAgICAgICAgICAgICAgbWFyayh0dywgZGVmLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzZXRfYmxvY2tfdmFyaWFibGVzKGNvbXByZXNzb3IsIG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuYmxvY2tfc2NvcGUpIG5vZGUuYmxvY2tfc2NvcGUudmFyaWFibGVzLmZvckVhY2goKGRlZikgPT4ge1xuICAgICAgICAgICAgcmVzZXRfZGVmKGNvbXByZXNzb3IsIGRlZik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHB1c2godHcpIHtcbiAgICAgICAgdHcuc2FmZV9pZHMgPSBPYmplY3QuY3JlYXRlKHR3LnNhZmVfaWRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3AodHcpIHtcbiAgICAgICAgdHcuc2FmZV9pZHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodHcuc2FmZV9pZHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcmsodHcsIGRlZiwgc2FmZSkge1xuICAgICAgICB0dy5zYWZlX2lkc1tkZWYuaWRdID0gc2FmZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzYWZlX3RvX3JlYWQodHcsIGRlZikge1xuICAgICAgICBpZiAoZGVmLnNpbmdsZV91c2UgPT0gXCJtXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHR3LnNhZmVfaWRzW2RlZi5pZF0pIHtcbiAgICAgICAgICAgIGlmIChkZWYuZml4ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnID0gZGVmLm9yaWdbMF07XG4gICAgICAgICAgICAgICAgaWYgKG9yaWcgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRnVuYXJnIHx8IG9yaWcubmFtZSA9PSBcImFyZ3VtZW50c1wiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGVmLmZpeGVkID0gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIG9yaWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZi5maXhlZCBpbnN0YW5jZW9mIEFTVF9EZWZ1bjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzYWZlX3RvX2Fzc2lnbih0dywgZGVmLCBzY29wZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGRlZi5maXhlZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IGRlZl9zYWZlX2lkcztcbiAgICAgICAgaWYgKGRlZi5maXhlZCA9PT0gbnVsbFxuICAgICAgICAgICAgJiYgKGRlZl9zYWZlX2lkcyA9IHR3LmRlZnNfdG9fc2FmZV9pZHMuZ2V0KGRlZi5pZCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZGVmX3NhZmVfaWRzW2RlZi5pZF0gPSBmYWxzZTtcbiAgICAgICAgICAgIHR3LmRlZnNfdG9fc2FmZV9pZHMuZGVsZXRlKGRlZi5pZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUhPUCh0dy5zYWZlX2lkcywgZGVmLmlkKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXNhZmVfdG9fcmVhZCh0dywgZGVmKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGVmLmZpeGVkID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGVmLmZpeGVkICE9IG51bGwgJiYgKCF2YWx1ZSB8fCBkZWYucmVmZXJlbmNlcy5sZW5ndGggPiBkZWYuYXNzaWdubWVudHMpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkZWYuZml4ZWQgaW5zdGFuY2VvZiBBU1RfRGVmdW4pIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEFTVF9Ob2RlICYmIGRlZi5maXhlZC5wYXJlbnRfc2NvcGUgPT09IHNjb3BlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWYub3JpZy5ldmVyeSgoc3ltKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIShzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sQ29uc3RcbiAgICAgICAgICAgICAgICB8fCBzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVmdW5cbiAgICAgICAgICAgICAgICB8fCBzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sTGFtYmRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVmX29uY2UodHcsIGNvbXByZXNzb3IsIGRlZikge1xuICAgICAgICByZXR1cm4gY29tcHJlc3Nvci5vcHRpb24oXCJ1bnVzZWRcIilcbiAgICAgICAgICAgICYmICFkZWYuc2NvcGUucGlubmVkKClcbiAgICAgICAgICAgICYmIGRlZi5yZWZlcmVuY2VzLmxlbmd0aCAtIGRlZi5yZWN1cnNpdmVfcmVmcyA9PSAxXG4gICAgICAgICAgICAmJiB0dy5sb29wX2lkcy5nZXQoZGVmLmlkKSA9PT0gdHcuaW5fbG9vcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc19pbW11dGFibGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdmFsdWUuaXNfY29uc3RhbnQoKVxuICAgICAgICAgICAgfHwgdmFsdWUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhXG4gICAgICAgICAgICB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFTVF9UaGlzO1xuICAgIH1cblxuICAgIC8vIEEgZGVmaW5pdGlvbiBcImVzY2FwZXNcIiB3aGVuIGl0cyB2YWx1ZSBjYW4gbGVhdmUgdGhlIHBvaW50IG9mIHVzZS5cbiAgICAvLyBFeGFtcGxlOiBgYSA9IGIgfHwgY2BcbiAgICAvLyBJbiB0aGlzIGV4YW1wbGUsIFwiYlwiIGFuZCBcImNcIiBhcmUgZXNjYXBpbmcsIGJlY2F1c2UgdGhleSdyZSBnb2luZyBpbnRvIFwiYVwiXG4gICAgLy9cbiAgICAvLyBkZWYuZXNjYXBlZCBpcyAhPSAwIHdoZW4gaXQgZXNjYXBlcy5cbiAgICAvL1xuICAgIC8vIFdoZW4gZ3JlYXRlciB0aGFuIDEsIGl0IG1lYW5zIHRoYXQgTiBjaGFpbmVkIHByb3BlcnRpZXMgd2lsbCBiZSByZWFkIG9mZlxuICAgIC8vIG9mIHRoYXQgZGVmIGJlZm9yZSBhbiBlc2NhcGUgb2NjdXJzLiBUaGlzIGlzIHVzZWZ1bCBmb3IgZXZhbHVhdGluZ1xuICAgIC8vIHByb3BlcnR5IGFjY2Vzc2VzLCB3aGVyZSB5b3UgbmVlZCB0byBrbm93IHdoZW4gdG8gc3RvcC5cbiAgICBmdW5jdGlvbiBtYXJrX2VzY2FwZWQodHcsIGQsIHNjb3BlLCBub2RlLCB2YWx1ZSwgbGV2ZWwgPSAwLCBkZXB0aCA9IDEpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHR3LnBhcmVudChsZXZlbCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmlzX2NvbnN0YW50KCkpIHJldHVybjtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFTVF9DbGFzc0V4cHJlc3Npb24pIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24gJiYgKHBhcmVudC5vcGVyYXRvciA9PT0gXCI9XCIgfHwgcGFyZW50LmxvZ2ljYWwpICYmIG5vZGUgPT09IHBhcmVudC5yaWdodFxuICAgICAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX0NhbGwgJiYgKG5vZGUgIT09IHBhcmVudC5leHByZXNzaW9uIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9OZXcpXG4gICAgICAgICAgICB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfRXhpdCAmJiBub2RlID09PSBwYXJlbnQudmFsdWUgJiYgbm9kZS5zY29wZSAhPT0gZC5zY29wZVxuICAgICAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX1ZhckRlZiAmJiBub2RlID09PSBwYXJlbnQudmFsdWVcbiAgICAgICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9ZaWVsZCAmJiBub2RlID09PSBwYXJlbnQudmFsdWUgJiYgbm9kZS5zY29wZSAhPT0gZC5zY29wZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChkZXB0aCA+IDEgJiYgISh2YWx1ZSAmJiB2YWx1ZS5pc19jb25zdGFudF9leHByZXNzaW9uKHNjb3BlKSkpIGRlcHRoID0gMTtcbiAgICAgICAgICAgIGlmICghZC5lc2NhcGVkIHx8IGQuZXNjYXBlZCA+IGRlcHRoKSBkLmVzY2FwZWQgPSBkZXB0aDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHBhcmVudCBpbnN0YW5jZW9mIEFTVF9BcnJheVxuICAgICAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX0F3YWl0XG4gICAgICAgICAgICB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIGxhenlfb3AuaGFzKHBhcmVudC5vcGVyYXRvcilcbiAgICAgICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCAmJiBub2RlICE9PSBwYXJlbnQuY29uZGl0aW9uXG4gICAgICAgICAgICB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uXG4gICAgICAgICAgICB8fCBwYXJlbnQgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2UgJiYgbm9kZSA9PT0gcGFyZW50LnRhaWxfbm9kZSgpXG4gICAgICAgICkge1xuICAgICAgICAgICAgbWFya19lc2NhcGVkKHR3LCBkLCBzY29wZSwgcGFyZW50LCBwYXJlbnQsIGxldmVsICsgMSwgZGVwdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9PYmplY3RLZXlWYWwgJiYgbm9kZSA9PT0gcGFyZW50LnZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gdHcucGFyZW50KGxldmVsICsgMSk7XG5cbiAgICAgICAgICAgIG1hcmtfZXNjYXBlZCh0dywgZCwgc2NvcGUsIG9iaiwgb2JqLCBsZXZlbCArIDIsIGRlcHRoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAmJiBub2RlID09PSBwYXJlbnQuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgdmFsdWUgPSByZWFkX3Byb3BlcnR5KHZhbHVlLCBwYXJlbnQucHJvcGVydHkpO1xuXG4gICAgICAgICAgICBtYXJrX2VzY2FwZWQodHcsIGQsIHNjb3BlLCBwYXJlbnQsIHZhbHVlLCBsZXZlbCArIDEsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXZlbCA+IDApIHJldHVybjtcbiAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSAmJiBub2RlICE9PSBwYXJlbnQudGFpbF9ub2RlKCkpIHJldHVybjtcbiAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQpIHJldHVybjtcblxuICAgICAgICBkLmRpcmVjdF9hY2Nlc3MgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN1cHByZXNzID0gbm9kZSA9PiB3YWxrKG5vZGUsIG5vZGUgPT4ge1xuICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbCkpIHJldHVybjtcbiAgICAgICAgdmFyIGQgPSBub2RlLmRlZmluaXRpb24oKTtcbiAgICAgICAgaWYgKCFkKSByZXR1cm47XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikgZC5yZWZlcmVuY2VzLnB1c2gobm9kZSk7XG4gICAgICAgIGQuZml4ZWQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBkZWZfcmVkdWNlX3ZhcnMoQVNUX0FjY2Vzc29yLCBmdW5jdGlvbih0dywgZGVzY2VuZCwgY29tcHJlc3Nvcikge1xuICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgcmVzZXRfdmFyaWFibGVzKHR3LCBjb21wcmVzc29yLCB0aGlzKTtcbiAgICAgICAgZGVzY2VuZCgpO1xuICAgICAgICBwb3AodHcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBkZWZfcmVkdWNlX3ZhcnMoQVNUX0Fzc2lnbiwgZnVuY3Rpb24odHcsIGRlc2NlbmQsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzO1xuICAgICAgICBpZiAobm9kZS5sZWZ0IGluc3RhbmNlb2YgQVNUX0Rlc3RydWN0dXJpbmcpIHtcbiAgICAgICAgICAgIHN1cHByZXNzKG5vZGUubGVmdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmaW5pc2hfd2FsayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLmxvZ2ljYWwpIHtcbiAgICAgICAgICAgICAgICBub2RlLmxlZnQud2Fsayh0dyk7XG5cbiAgICAgICAgICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgICAgICAgICBub2RlLnJpZ2h0LndhbGsodHcpO1xuICAgICAgICAgICAgICAgIHBvcCh0dyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3ltID0gbm9kZS5sZWZ0O1xuICAgICAgICBpZiAoIShzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSkgcmV0dXJuIGZpbmlzaF93YWxrKCk7XG5cbiAgICAgICAgdmFyIGRlZiA9IHN5bS5kZWZpbml0aW9uKCk7XG4gICAgICAgIHZhciBzYWZlID0gc2FmZV90b19hc3NpZ24odHcsIGRlZiwgc3ltLnNjb3BlLCBub2RlLnJpZ2h0KTtcbiAgICAgICAgZGVmLmFzc2lnbm1lbnRzKys7XG4gICAgICAgIGlmICghc2FmZSkgcmV0dXJuIGZpbmlzaF93YWxrKCk7XG5cbiAgICAgICAgdmFyIGZpeGVkID0gZGVmLmZpeGVkO1xuICAgICAgICBpZiAoIWZpeGVkICYmIG5vZGUub3BlcmF0b3IgIT0gXCI9XCIgJiYgIW5vZGUubG9naWNhbCkgcmV0dXJuIGZpbmlzaF93YWxrKCk7XG5cbiAgICAgICAgdmFyIGVxID0gbm9kZS5vcGVyYXRvciA9PSBcIj1cIjtcbiAgICAgICAgdmFyIHZhbHVlID0gZXEgPyBub2RlLnJpZ2h0IDogbm9kZTtcbiAgICAgICAgaWYgKGlzX21vZGlmaWVkKGNvbXByZXNzb3IsIHR3LCBub2RlLCB2YWx1ZSwgMCkpIHJldHVybiBmaW5pc2hfd2FsaygpO1xuXG4gICAgICAgIGRlZi5yZWZlcmVuY2VzLnB1c2goc3ltKTtcblxuICAgICAgICBpZiAoIW5vZGUubG9naWNhbCkge1xuICAgICAgICAgICAgaWYgKCFlcSkgZGVmLmNoYWluZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBkZWYuZml4ZWQgPSBlcSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogbm9kZS5vcGVyYXRvci5zbGljZSgwLCAtMSksXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZpeGVkIGluc3RhbmNlb2YgQVNUX05vZGUgPyBmaXhlZCA6IGZpeGVkKCksXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBub2RlLnJpZ2h0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUubG9naWNhbCkge1xuICAgICAgICAgICAgbWFyayh0dywgZGVmLCBmYWxzZSk7XG4gICAgICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgICAgIG5vZGUucmlnaHQud2Fsayh0dyk7XG4gICAgICAgICAgICBwb3AodHcpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrKHR3LCBkZWYsIGZhbHNlKTtcbiAgICAgICAgbm9kZS5yaWdodC53YWxrKHR3KTtcbiAgICAgICAgbWFyayh0dywgZGVmLCB0cnVlKTtcblxuICAgICAgICBtYXJrX2VzY2FwZWQodHcsIGRlZiwgc3ltLnNjb3BlLCBub2RlLCB2YWx1ZSwgMCwgMSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgZGVmX3JlZHVjZV92YXJzKEFTVF9CaW5hcnksIGZ1bmN0aW9uKHR3KSB7XG4gICAgICAgIGlmICghbGF6eV9vcC5oYXModGhpcy5vcGVyYXRvcikpIHJldHVybjtcbiAgICAgICAgdGhpcy5sZWZ0LndhbGsodHcpO1xuICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgdGhpcy5yaWdodC53YWxrKHR3KTtcbiAgICAgICAgcG9wKHR3KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgZGVmX3JlZHVjZV92YXJzKEFTVF9CbG9jaywgZnVuY3Rpb24odHcsIGRlc2NlbmQsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmVzZXRfYmxvY2tfdmFyaWFibGVzKGNvbXByZXNzb3IsIHRoaXMpO1xuICAgIH0pO1xuICAgIGRlZl9yZWR1Y2VfdmFycyhBU1RfQ2FzZSwgZnVuY3Rpb24odHcpIHtcbiAgICAgICAgcHVzaCh0dyk7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbi53YWxrKHR3KTtcbiAgICAgICAgcG9wKHR3KTtcbiAgICAgICAgcHVzaCh0dyk7XG4gICAgICAgIHdhbGtfYm9keSh0aGlzLCB0dyk7XG4gICAgICAgIHBvcCh0dyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGRlZl9yZWR1Y2VfdmFycyhBU1RfQ2xhc3MsIGZ1bmN0aW9uKHR3LCBkZXNjZW5kKSB7XG4gICAgICAgIGNsZWFyX2ZsYWcodGhpcywgSU5MSU5FRCk7XG4gICAgICAgIHB1c2godHcpO1xuICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgIHBvcCh0dyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGRlZl9yZWR1Y2VfdmFycyhBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKHR3KSB7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uLndhbGsodHcpO1xuICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgdGhpcy5jb25zZXF1ZW50LndhbGsodHcpO1xuICAgICAgICBwb3AodHcpO1xuICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgdGhpcy5hbHRlcm5hdGl2ZS53YWxrKHR3KTtcbiAgICAgICAgcG9wKHR3KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICBkZWZfcmVkdWNlX3ZhcnMoQVNUX0NoYWluLCBmdW5jdGlvbih0dywgZGVzY2VuZCkge1xuICAgICAgICAvLyBDaGFpbnMnIGNvbmRpdGlvbnMgYXBwbHkgbGVmdC10by1yaWdodCwgY3VtdWxhdGl2ZWx5LlxuICAgICAgICAvLyBJZiB3ZSB3YWxrIG5vcm1hbGx5IHdlIGRvbid0IGdvIGluIHRoYXQgb3JkZXIgYmVjYXVzZSB3ZSB3b3VsZCBwb3AgYmVmb3JlIHB1c2hpbmcgYWdhaW5cbiAgICAgICAgLy8gU29sdXRpb246IEFTVF9Qcm9wQWNjZXNzIGFuZCBBU1RfQ2FsbCBwdXNoIHdoZW4gdGhleSBhcmUgb3B0aW9uYWwsIGFuZCBuZXZlciBwb3AuXG4gICAgICAgIC8vIFRoZW4gd2UgcG9wIGV2ZXJ5dGhpbmcgd2hlbiB0aGV5IGFyZSBkb25lIGJlaW5nIHdhbGtlZC5cbiAgICAgICAgY29uc3Qgc2FmZV9pZHMgPSB0dy5zYWZlX2lkcztcblxuICAgICAgICBkZXNjZW5kKCk7XG5cbiAgICAgICAgLy8gVW5yb2xsIGJhY2sgdG8gc3RhcnRcbiAgICAgICAgdHcuc2FmZV9pZHMgPSBzYWZlX2lkcztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgZGVmX3JlZHVjZV92YXJzKEFTVF9DYWxsLCBmdW5jdGlvbiAodHcpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uLndhbGsodHcpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICAvLyBOZXZlciBwb3AgLS0gaXQncyBwb3BwZWQgYXQgQVNUX0NoYWluIGFib3ZlXG4gICAgICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgYXJnIG9mIHRoaXMuYXJncykgYXJnLndhbGsodHcpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGRlZl9yZWR1Y2VfdmFycyhBU1RfUHJvcEFjY2VzcywgZnVuY3Rpb24gKHR3KSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25hbCkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbi53YWxrKHR3KTtcblxuICAgICAgICAvLyBOZXZlciBwb3AgLS0gaXQncyBwb3BwZWQgYXQgQVNUX0NoYWluIGFib3ZlXG4gICAgICAgIHB1c2godHcpO1xuXG4gICAgICAgIGlmICh0aGlzLnByb3BlcnR5IGluc3RhbmNlb2YgQVNUX05vZGUpIHRoaXMucHJvcGVydHkud2Fsayh0dyk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgZGVmX3JlZHVjZV92YXJzKEFTVF9EZWZhdWx0LCBmdW5jdGlvbih0dywgZGVzY2VuZCkge1xuICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgZGVzY2VuZCgpO1xuICAgICAgICBwb3AodHcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBtYXJrX2xhbWJkYSh0dywgZGVzY2VuZCwgY29tcHJlc3Nvcikge1xuICAgICAgICBjbGVhcl9mbGFnKHRoaXMsIElOTElORUQpO1xuICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgcmVzZXRfdmFyaWFibGVzKHR3LCBjb21wcmVzc29yLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMudXNlc19hcmd1bWVudHMpIHtcbiAgICAgICAgICAgIGRlc2NlbmQoKTtcbiAgICAgICAgICAgIHBvcCh0dyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlpZmU7XG4gICAgICAgIGlmICghdGhpcy5uYW1lXG4gICAgICAgICAgICAmJiAoaWlmZSA9IHR3LnBhcmVudCgpKSBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICAgICAmJiBpaWZlLmV4cHJlc3Npb24gPT09IHRoaXNcbiAgICAgICAgICAgICYmICFpaWZlLmFyZ3Muc29tZShhcmcgPT4gYXJnIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbilcbiAgICAgICAgICAgICYmIHRoaXMuYXJnbmFtZXMuZXZlcnkoYXJnX25hbWUgPT4gYXJnX25hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFZpcnR1YWxseSB0dXJuIElJRkUgcGFyYW1ldGVycyBpbnRvIHZhcmlhYmxlIGRlZmluaXRpb25zOlxuICAgICAgICAgICAgLy8gICAoZnVuY3Rpb24oYSxiKSB7Li4ufSkoYyxkKSA9PiAoZnVuY3Rpb24oKSB7dmFyIGE9YyxiPWQ7IC4uLn0pKClcbiAgICAgICAgICAgIC8vIFNvIGV4aXN0aW5nIHRyYW5zZm9ybWF0aW9uIHJ1bGVzIGNhbiB3b3JrIG9uIHRoZW0uXG4gICAgICAgICAgICB0aGlzLmFyZ25hbWVzLmZvckVhY2goKGFyZywgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghYXJnLmRlZmluaXRpb24pIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGFyZy5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBmaXhlZCB3aGVuIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZSBvcmlnaW4gZm9yIGEgdmFyaWFibGUgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoZC5vcmlnLmxlbmd0aCA+IDEpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZC5maXhlZCA9PT0gdW5kZWZpbmVkICYmICghdGhpcy51c2VzX2FyZ3VtZW50cyB8fCB0dy5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZC5maXhlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpZmUuYXJnc1tpXSB8fCBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgaWlmZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHR3Lmxvb3BfaWRzLnNldChkLmlkLCB0dy5pbl9sb29wKTtcbiAgICAgICAgICAgICAgICAgICAgbWFyayh0dywgZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZC5maXhlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlc2NlbmQoKTtcbiAgICAgICAgcG9wKHR3KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZGVmX3JlZHVjZV92YXJzKEFTVF9MYW1iZGEsIG1hcmtfbGFtYmRhKTtcblxuICAgIGRlZl9yZWR1Y2VfdmFycyhBU1RfRG8sIGZ1bmN0aW9uKHR3LCBkZXNjZW5kLCBjb21wcmVzc29yKSB7XG4gICAgICAgIHJlc2V0X2Jsb2NrX3ZhcmlhYmxlcyhjb21wcmVzc29yLCB0aGlzKTtcbiAgICAgICAgY29uc3Qgc2F2ZWRfbG9vcCA9IHR3LmluX2xvb3A7XG4gICAgICAgIHR3LmluX2xvb3AgPSB0aGlzO1xuICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgdGhpcy5ib2R5LndhbGsodHcpO1xuICAgICAgICBpZiAoaGFzX2JyZWFrX29yX2NvbnRpbnVlKHRoaXMpKSB7XG4gICAgICAgICAgICBwb3AodHcpO1xuICAgICAgICAgICAgcHVzaCh0dyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25kaXRpb24ud2Fsayh0dyk7XG4gICAgICAgIHBvcCh0dyk7XG4gICAgICAgIHR3LmluX2xvb3AgPSBzYXZlZF9sb29wO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBkZWZfcmVkdWNlX3ZhcnMoQVNUX0ZvciwgZnVuY3Rpb24odHcsIGRlc2NlbmQsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmVzZXRfYmxvY2tfdmFyaWFibGVzKGNvbXByZXNzb3IsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5pbml0KSB0aGlzLmluaXQud2Fsayh0dyk7XG4gICAgICAgIGNvbnN0IHNhdmVkX2xvb3AgPSB0dy5pbl9sb29wO1xuICAgICAgICB0dy5pbl9sb29wID0gdGhpcztcbiAgICAgICAgcHVzaCh0dyk7XG4gICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbikgdGhpcy5jb25kaXRpb24ud2Fsayh0dyk7XG4gICAgICAgIHRoaXMuYm9keS53YWxrKHR3KTtcbiAgICAgICAgaWYgKHRoaXMuc3RlcCkge1xuICAgICAgICAgICAgaWYgKGhhc19icmVha19vcl9jb250aW51ZSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHBvcCh0dyk7XG4gICAgICAgICAgICAgICAgcHVzaCh0dyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0ZXAud2Fsayh0dyk7XG4gICAgICAgIH1cbiAgICAgICAgcG9wKHR3KTtcbiAgICAgICAgdHcuaW5fbG9vcCA9IHNhdmVkX2xvb3A7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGRlZl9yZWR1Y2VfdmFycyhBU1RfRm9ySW4sIGZ1bmN0aW9uKHR3LCBkZXNjZW5kLCBjb21wcmVzc29yKSB7XG4gICAgICAgIHJlc2V0X2Jsb2NrX3ZhcmlhYmxlcyhjb21wcmVzc29yLCB0aGlzKTtcbiAgICAgICAgc3VwcHJlc3ModGhpcy5pbml0KTtcbiAgICAgICAgdGhpcy5vYmplY3Qud2Fsayh0dyk7XG4gICAgICAgIGNvbnN0IHNhdmVkX2xvb3AgPSB0dy5pbl9sb29wO1xuICAgICAgICB0dy5pbl9sb29wID0gdGhpcztcbiAgICAgICAgcHVzaCh0dyk7XG4gICAgICAgIHRoaXMuYm9keS53YWxrKHR3KTtcbiAgICAgICAgcG9wKHR3KTtcbiAgICAgICAgdHcuaW5fbG9vcCA9IHNhdmVkX2xvb3A7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgZGVmX3JlZHVjZV92YXJzKEFTVF9JZiwgZnVuY3Rpb24odHcpIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb24ud2Fsayh0dyk7XG4gICAgICAgIHB1c2godHcpO1xuICAgICAgICB0aGlzLmJvZHkud2Fsayh0dyk7XG4gICAgICAgIHBvcCh0dyk7XG4gICAgICAgIGlmICh0aGlzLmFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICBwdXNoKHR3KTtcbiAgICAgICAgICAgIHRoaXMuYWx0ZXJuYXRpdmUud2Fsayh0dyk7XG4gICAgICAgICAgICBwb3AodHcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGRlZl9yZWR1Y2VfdmFycyhBU1RfTGFiZWxlZFN0YXRlbWVudCwgZnVuY3Rpb24odHcpIHtcbiAgICAgICAgcHVzaCh0dyk7XG4gICAgICAgIHRoaXMuYm9keS53YWxrKHR3KTtcbiAgICAgICAgcG9wKHR3KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgZGVmX3JlZHVjZV92YXJzKEFTVF9TeW1ib2xDYXRjaCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbigpLmZpeGVkID0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICBkZWZfcmVkdWNlX3ZhcnMoQVNUX1N5bWJvbFJlZiwgZnVuY3Rpb24odHcsIGRlc2NlbmQsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmRlZmluaXRpb24oKTtcbiAgICAgICAgZC5yZWZlcmVuY2VzLnB1c2godGhpcyk7XG4gICAgICAgIGlmIChkLnJlZmVyZW5jZXMubGVuZ3RoID09IDFcbiAgICAgICAgICAgICYmICFkLmZpeGVkXG4gICAgICAgICAgICAmJiBkLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVmdW4pIHtcbiAgICAgICAgICAgIHR3Lmxvb3BfaWRzLnNldChkLmlkLCB0dy5pbl9sb29wKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZml4ZWRfdmFsdWU7XG4gICAgICAgIGlmIChkLmZpeGVkID09PSB1bmRlZmluZWQgfHwgIXNhZmVfdG9fcmVhZCh0dywgZCkpIHtcbiAgICAgICAgICAgIGQuZml4ZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChkLmZpeGVkKSB7XG4gICAgICAgICAgICBmaXhlZF92YWx1ZSA9IHRoaXMuZml4ZWRfdmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBmaXhlZF92YWx1ZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGFcbiAgICAgICAgICAgICAgICAmJiByZWN1cnNpdmVfcmVmKHR3LCBkKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZC5yZWN1cnNpdmVfcmVmcysrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmaXhlZF92YWx1ZVxuICAgICAgICAgICAgICAgICYmICFjb21wcmVzc29yLmV4cG9zZWQoZClcbiAgICAgICAgICAgICAgICAmJiByZWZfb25jZSh0dywgY29tcHJlc3NvciwgZClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGQuc2luZ2xlX3VzZSA9XG4gICAgICAgICAgICAgICAgICAgIGZpeGVkX3ZhbHVlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSAmJiAhZml4ZWRfdmFsdWUucGlubmVkKClcbiAgICAgICAgICAgICAgICAgICAgfHwgZml4ZWRfdmFsdWUgaW5zdGFuY2VvZiBBU1RfQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgfHwgZC5zY29wZSA9PT0gdGhpcy5zY29wZSAmJiBmaXhlZF92YWx1ZS5pc19jb25zdGFudF9leHByZXNzaW9uKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGQuc2luZ2xlX3VzZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzX21vZGlmaWVkKGNvbXByZXNzb3IsIHR3LCB0aGlzLCBmaXhlZF92YWx1ZSwgMCwgaXNfaW1tdXRhYmxlKGZpeGVkX3ZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZC5zaW5nbGVfdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuc2luZ2xlX3VzZSA9IFwibVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQuZml4ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFya19lc2NhcGVkKHR3LCBkLCB0aGlzLnNjb3BlLCB0aGlzLCBmaXhlZF92YWx1ZSwgMCwgMSk7XG4gICAgfSk7XG4gICAgZGVmX3JlZHVjZV92YXJzKEFTVF9Ub3BsZXZlbCwgZnVuY3Rpb24odHcsIGRlc2NlbmQsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxzLmZvckVhY2goZnVuY3Rpb24oZGVmKSB7XG4gICAgICAgICAgICByZXNldF9kZWYoY29tcHJlc3NvciwgZGVmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc2V0X3ZhcmlhYmxlcyh0dywgY29tcHJlc3NvciwgdGhpcyk7XG4gICAgfSk7XG4gICAgZGVmX3JlZHVjZV92YXJzKEFTVF9UcnksIGZ1bmN0aW9uKHR3LCBkZXNjZW5kLCBjb21wcmVzc29yKSB7XG4gICAgICAgIHJlc2V0X2Jsb2NrX3ZhcmlhYmxlcyhjb21wcmVzc29yLCB0aGlzKTtcbiAgICAgICAgcHVzaCh0dyk7XG4gICAgICAgIHdhbGtfYm9keSh0aGlzLCB0dyk7XG4gICAgICAgIHBvcCh0dyk7XG4gICAgICAgIGlmICh0aGlzLmJjYXRjaCkge1xuICAgICAgICAgICAgcHVzaCh0dyk7XG4gICAgICAgICAgICB0aGlzLmJjYXRjaC53YWxrKHR3KTtcbiAgICAgICAgICAgIHBvcCh0dyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYmZpbmFsbHkpIHRoaXMuYmZpbmFsbHkud2Fsayh0dyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGRlZl9yZWR1Y2VfdmFycyhBU1RfVW5hcnksIGZ1bmN0aW9uKHR3KSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcztcbiAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiKytcIiAmJiBub2RlLm9wZXJhdG9yICE9PSBcIi0tXCIpIHJldHVybjtcbiAgICAgICAgdmFyIGV4cCA9IG5vZGUuZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKCEoZXhwIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikpIHJldHVybjtcbiAgICAgICAgdmFyIGRlZiA9IGV4cC5kZWZpbml0aW9uKCk7XG4gICAgICAgIHZhciBzYWZlID0gc2FmZV90b19hc3NpZ24odHcsIGRlZiwgZXhwLnNjb3BlLCB0cnVlKTtcbiAgICAgICAgZGVmLmFzc2lnbm1lbnRzKys7XG4gICAgICAgIGlmICghc2FmZSkgcmV0dXJuO1xuICAgICAgICB2YXIgZml4ZWQgPSBkZWYuZml4ZWQ7XG4gICAgICAgIGlmICghZml4ZWQpIHJldHVybjtcbiAgICAgICAgZGVmLnJlZmVyZW5jZXMucHVzaChleHApO1xuICAgICAgICBkZWYuY2hhaW5lZCA9IHRydWU7XG4gICAgICAgIGRlZi5maXhlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBub2RlLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IG5vZGUub3BlcmF0b3Iuc2xpY2UoMCwgLTEpLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBmaXhlZCBpbnN0YW5jZW9mIEFTVF9Ob2RlID8gZml4ZWQgOiBmaXhlZCgpXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IG1ha2Vfbm9kZShBU1RfTnVtYmVyLCBub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBtYXJrKHR3LCBkZWYsIHRydWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBkZWZfcmVkdWNlX3ZhcnMoQVNUX1ZhckRlZiwgZnVuY3Rpb24odHcsIGRlc2NlbmQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzO1xuICAgICAgICBpZiAobm9kZS5uYW1lIGluc3RhbmNlb2YgQVNUX0Rlc3RydWN0dXJpbmcpIHtcbiAgICAgICAgICAgIHN1cHByZXNzKG5vZGUubmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGQgPSBub2RlLm5hbWUuZGVmaW5pdGlvbigpO1xuICAgICAgICBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHNhZmVfdG9fYXNzaWduKHR3LCBkLCBub2RlLm5hbWUuc2NvcGUsIG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZC5maXhlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHR3Lmxvb3BfaWRzLnNldChkLmlkLCB0dy5pbl9sb29wKTtcbiAgICAgICAgICAgICAgICBtYXJrKHR3LCBkLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgZGVzY2VuZCgpO1xuICAgICAgICAgICAgICAgIG1hcmsodHcsIGQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkLmZpeGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZfcmVkdWNlX3ZhcnMoQVNUX1doaWxlLCBmdW5jdGlvbih0dywgZGVzY2VuZCwgY29tcHJlc3Nvcikge1xuICAgICAgICByZXNldF9ibG9ja192YXJpYWJsZXMoY29tcHJlc3NvciwgdGhpcyk7XG4gICAgICAgIGNvbnN0IHNhdmVkX2xvb3AgPSB0dy5pbl9sb29wO1xuICAgICAgICB0dy5pbl9sb29wID0gdGhpcztcbiAgICAgICAgcHVzaCh0dyk7XG4gICAgICAgIGRlc2NlbmQoKTtcbiAgICAgICAgcG9wKHR3KTtcbiAgICAgICAgdHcuaW5fbG9vcCA9IHNhdmVkX2xvb3A7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufSkoZnVuY3Rpb24obm9kZSwgZnVuYykge1xuICAgIG5vZGUuREVGTUVUSE9EKFwicmVkdWNlX3ZhcnNcIiwgZnVuYyk7XG59KTtcblxuQVNUX1RvcGxldmVsLkRFRk1FVEhPRChcInJlc2V0X29wdF9mbGFnc1wiLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgcmVkdWNlX3ZhcnMgPSBjb21wcmVzc29yLm9wdGlvbihcInJlZHVjZV92YXJzXCIpO1xuXG4gICAgY29uc3QgcHJlcGFyYXRpb24gPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlLCBkZXNjZW5kKSB7XG4gICAgICAgIGNsZWFyX2ZsYWcobm9kZSwgQ0xFQVJfQkVUV0VFTl9QQVNTRVMpO1xuICAgICAgICBpZiAocmVkdWNlX3ZhcnMpIHtcbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLnRvcF9yZXRhaW5cbiAgICAgICAgICAgICAgICAmJiBub2RlIGluc3RhbmNlb2YgQVNUX0RlZnVuICAvLyBPbmx5IGZ1bmN0aW9ucyBhcmUgcmV0YWluZWRcbiAgICAgICAgICAgICAgICAmJiBwcmVwYXJhdGlvbi5wYXJlbnQoKSA9PT0gc2VsZlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgc2V0X2ZsYWcobm9kZSwgVE9QKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlLnJlZHVjZV92YXJzKHByZXBhcmF0aW9uLCBkZXNjZW5kLCBjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFN0YWNrIG9mIGxvb2stdXAgdGFibGVzIHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBhIGBTeW1ib2xEZWZgIGhhcyBiZWVuXG4gICAgLy8gcHJvcGVybHkgYXNzaWduZWQgYmVmb3JlIHVzZTpcbiAgICAvLyAtIGBwdXNoKClgICYgYHBvcCgpYCB3aGVuIHZpc2l0aW5nIGNvbmRpdGlvbmFsIGJyYW5jaGVzXG4gICAgcHJlcGFyYXRpb24uc2FmZV9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHByZXBhcmF0aW9uLmluX2xvb3AgPSBudWxsO1xuICAgIHByZXBhcmF0aW9uLmxvb3BfaWRzID0gbmV3IE1hcCgpO1xuICAgIHByZXBhcmF0aW9uLmRlZnNfdG9fc2FmZV9pZHMgPSBuZXcgTWFwKCk7XG4gICAgc2VsZi53YWxrKHByZXBhcmF0aW9uKTtcbn0pO1xuXG5BU1RfU3ltYm9sLkRFRk1FVEhPRChcImZpeGVkX3ZhbHVlXCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBmaXhlZCA9IHRoaXMudGhlZGVmLmZpeGVkO1xuICAgIGlmICghZml4ZWQgfHwgZml4ZWQgaW5zdGFuY2VvZiBBU1RfTm9kZSkgcmV0dXJuIGZpeGVkO1xuICAgIHJldHVybiBmaXhlZCgpO1xufSk7XG5cbkFTVF9TeW1ib2xSZWYuREVGTUVUSE9EKFwiaXNfaW1tdXRhYmxlXCIsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnID0gdGhpcy5kZWZpbml0aW9uKCkub3JpZztcbiAgICByZXR1cm4gb3JpZy5sZW5ndGggPT0gMSAmJiBvcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbExhbWJkYTtcbn0pO1xuXG5mdW5jdGlvbiBpc19mdW5jX2V4cHIobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgQVNUX0Fycm93IHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb247XG59XG5cbmZ1bmN0aW9uIGlzX2xoc19yZWFkX29ubHkobGhzKSB7XG4gICAgaWYgKGxocyBpbnN0YW5jZW9mIEFTVF9UaGlzKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAobGhzIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikgcmV0dXJuIGxocy5kZWZpbml0aW9uKCkub3JpZ1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xMYW1iZGE7XG4gICAgaWYgKGxocyBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzKSB7XG4gICAgICAgIGxocyA9IGxocy5leHByZXNzaW9uO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikge1xuICAgICAgICAgICAgaWYgKGxocy5pc19pbW11dGFibGUoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGhzID0gbGhzLmZpeGVkX3ZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsaHMpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgQVNUX1JlZ0V4cCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgQVNUX0NvbnN0YW50KSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGlzX2xoc19yZWFkX29ubHkobGhzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc19yZWZfb2YocmVmLCB0eXBlKSB7XG4gICAgaWYgKCEocmVmIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgb3JpZyA9IHJlZi5kZWZpbml0aW9uKCkub3JpZztcbiAgICBmb3IgKHZhciBpID0gb3JpZy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICBpZiAob3JpZ1tpXSBpbnN0YW5jZW9mIHR5cGUpIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZmluZF9zY29wZSh0dykge1xuICAgIGZvciAobGV0IGkgPSAwOztpKyspIHtcbiAgICAgICAgY29uc3QgcCA9IHR3LnBhcmVudChpKTtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfVG9wbGV2ZWwpIHJldHVybiBwO1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpIHJldHVybiBwO1xuICAgICAgICBpZiAocC5ibG9ja19zY29wZSkgcmV0dXJuIHAuYmxvY2tfc2NvcGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaW5kX3ZhcmlhYmxlKGNvbXByZXNzb3IsIG5hbWUpIHtcbiAgICB2YXIgc2NvcGUsIGkgPSAwO1xuICAgIHdoaWxlIChzY29wZSA9IGNvbXByZXNzb3IucGFyZW50KGkrKykpIHtcbiAgICAgICAgaWYgKHNjb3BlIGluc3RhbmNlb2YgQVNUX1Njb3BlKSBicmVhaztcbiAgICAgICAgaWYgKHNjb3BlIGluc3RhbmNlb2YgQVNUX0NhdGNoICYmIHNjb3BlLmFyZ25hbWUpIHtcbiAgICAgICAgICAgIHNjb3BlID0gc2NvcGUuYXJnbmFtZS5kZWZpbml0aW9uKCkuc2NvcGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2NvcGUuZmluZF92YXJpYWJsZShuYW1lKTtcbn1cblxuZnVuY3Rpb24gbWFrZV9zZXF1ZW5jZShvcmlnLCBleHByZXNzaW9ucykge1xuICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT0gMSkgcmV0dXJuIGV4cHJlc3Npb25zWzBdO1xuICAgIGlmIChleHByZXNzaW9ucy5sZW5ndGggPT0gMCkgdGhyb3cgbmV3IEVycm9yKFwidHJ5aW5nIHRvIGNyZWF0ZSBhIHNlcXVlbmNlIHdpdGggbGVuZ3RoIHplcm8hXCIpO1xuICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1NlcXVlbmNlLCBvcmlnLCB7XG4gICAgICAgIGV4cHJlc3Npb25zOiBleHByZXNzaW9ucy5yZWR1Y2UobWVyZ2Vfc2VxdWVuY2UsIFtdKVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlX25vZGVfZnJvbV9jb25zdGFudCh2YWwsIG9yaWcpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBvcmlnLCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBpZiAoaXNOYU4odmFsKSkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfTmFOLCBvcmlnKTtcbiAgICAgICAgaWYgKGlzRmluaXRlKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC8gdmFsIDwgMCA/IG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIG9yaWcsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCItXCIsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogbWFrZV9ub2RlKEFTVF9OdW1iZXIsIG9yaWcsIHsgdmFsdWU6IC12YWwgfSlcbiAgICAgICAgICAgIH0pIDogbWFrZV9ub2RlKEFTVF9OdW1iZXIsIG9yaWcsIHsgdmFsdWU6IHZhbCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsIDwgMCA/IG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIG9yaWcsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcIi1cIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IG1ha2Vfbm9kZShBU1RfSW5maW5pdHksIG9yaWcpXG4gICAgICAgIH0pIDogbWFrZV9ub2RlKEFTVF9JbmZpbml0eSwgb3JpZyk7XG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKHZhbCA/IEFTVF9UcnVlIDogQVNUX0ZhbHNlLCBvcmlnKTtcbiAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBvcmlnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX051bGwsIG9yaWcsIHsgdmFsdWU6IG51bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfUmVnRXhwLCBvcmlnLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiByZWdleHBfc291cmNlX2ZpeCh2YWwuc291cmNlKSxcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IHZhbC5mbGFnc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihzdHJpbmdfdGVtcGxhdGUoXCJDYW4ndCBoYW5kbGUgY29uc3RhbnQgb2YgdHlwZToge3R5cGV9XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVvZiB2YWxcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cblxuLy8gd2Ugc2hvdWxkbid0IGNvbXByZXNzICgxLGZ1bmMpKHNvbWV0aGluZykgdG9cbi8vIGZ1bmMoc29tZXRoaW5nKSBiZWNhdXNlIHRoYXQgY2hhbmdlcyB0aGUgbWVhbmluZyBvZlxuLy8gdGhlIGZ1bmMgKGJlY29tZXMgbGV4aWNhbCBpbnN0ZWFkIG9mIGdsb2JhbCkuXG5mdW5jdGlvbiBtYWludGFpbl90aGlzX2JpbmRpbmcocGFyZW50LCBvcmlnLCB2YWwpIHtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4ICYmIHBhcmVudC5vcGVyYXRvciA9PSBcImRlbGV0ZVwiXG4gICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9DYWxsICYmIHBhcmVudC5leHByZXNzaW9uID09PSBvcmlnXG4gICAgICAgICAgICAmJiAodmFsIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgfHwgdmFsIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZiAmJiB2YWwubmFtZSA9PSBcImV2YWxcIikpIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uob3JpZywgWyBtYWtlX25vZGUoQVNUX051bWJlciwgb3JpZywgeyB2YWx1ZTogMCB9KSwgdmFsIF0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBtZXJnZV9zZXF1ZW5jZShhcnJheSwgbm9kZSkge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlKSB7XG4gICAgICAgIGFycmF5LnB1c2goLi4ubm9kZS5leHByZXNzaW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXkucHVzaChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBhc19zdGF0ZW1lbnRfYXJyYXkodGhpbmcpIHtcbiAgICBpZiAodGhpbmcgPT09IG51bGwpIHJldHVybiBbXTtcbiAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQpIHJldHVybiB0aGluZy5ib2R5O1xuICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudCkgcmV0dXJuIFtdO1xuICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIEFTVF9TdGF0ZW1lbnQpIHJldHVybiBbIHRoaW5nIF07XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29udmVydCB0aGluZyB0byBzdGF0ZW1lbnQgYXJyYXlcIik7XG59XG5cbmZ1bmN0aW9uIGlzX2VtcHR5KHRoaW5nKSB7XG4gICAgaWYgKHRoaW5nID09PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpbmcgaW5zdGFuY2VvZiBBU1RfRW1wdHlTdGF0ZW1lbnQpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkgcmV0dXJuIHRoaW5nLmJvZHkubGVuZ3RoID09IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjYW5fYmVfZXZpY3RlZF9mcm9tX2Jsb2NrKG5vZGUpIHtcbiAgICByZXR1cm4gIShcbiAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZDbGFzcyB8fFxuICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX0RlZnVuIHx8XG4gICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfTGV0IHx8XG4gICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfQ29uc3QgfHxcbiAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9FeHBvcnQgfHxcbiAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9JbXBvcnRcbiAgICApO1xufVxuXG5mdW5jdGlvbiBsb29wX2JvZHkoeCkge1xuICAgIGlmICh4IGluc3RhbmNlb2YgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4geC5ib2R5IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50ID8geC5ib2R5IDogeDtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIGlzX2lpZmVfY2FsbChub2RlKSB7XG4gICAgLy8gVXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgbm9kZSBjYW4gYmVuZWZpdCBmcm9tIG5lZ2F0aW9uLlxuICAgIC8vIE5vdCB0aGUgY2FzZSB3aXRoIGFycm93IGZ1bmN0aW9ucyAoeW91IG5lZWQgYW4gZXh0cmEgc2V0IG9mIHBhcmVucykuXG4gICAgaWYgKG5vZGUuVFlQRSAhPSBcIkNhbGxcIikgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBub2RlLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb24gfHwgaXNfaWlmZV9jYWxsKG5vZGUuZXhwcmVzc2lvbik7XG59XG5cbmZ1bmN0aW9uIGlzX3VuZGVjbGFyZWRfcmVmKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgbm9kZS5kZWZpbml0aW9uKCkudW5kZWNsYXJlZDtcbn1cblxudmFyIGdsb2JhbF9uYW1lcyA9IG1ha2VQcmVkaWNhdGUoXCJBcnJheSBCb29sZWFuIGNsZWFySW50ZXJ2YWwgY2xlYXJUaW1lb3V0IGNvbnNvbGUgRGF0ZSBkZWNvZGVVUkkgZGVjb2RlVVJJQ29tcG9uZW50IGVuY29kZVVSSSBlbmNvZGVVUklDb21wb25lbnQgRXJyb3IgZXNjYXBlIGV2YWwgRXZhbEVycm9yIEZ1bmN0aW9uIGlzRmluaXRlIGlzTmFOIEpTT04gTWF0aCBOdW1iZXIgcGFyc2VGbG9hdCBwYXJzZUludCBSYW5nZUVycm9yIFJlZmVyZW5jZUVycm9yIFJlZ0V4cCBPYmplY3Qgc2V0SW50ZXJ2YWwgc2V0VGltZW91dCBTdHJpbmcgU3ludGF4RXJyb3IgVHlwZUVycm9yIHVuZXNjYXBlIFVSSUVycm9yXCIpO1xuQVNUX1N5bWJvbFJlZi5ERUZNRVRIT0QoXCJpc19kZWNsYXJlZFwiLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgcmV0dXJuICF0aGlzLmRlZmluaXRpb24oKS51bmRlY2xhcmVkXG4gICAgICAgIHx8IGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpICYmIGdsb2JhbF9uYW1lcy5oYXModGhpcy5uYW1lKTtcbn0pO1xuXG52YXIgaWRlbnRpZmllcl9hdG9tID0gbWFrZVByZWRpY2F0ZShcIkluZmluaXR5IE5hTiB1bmRlZmluZWRcIik7XG5mdW5jdGlvbiBpc19pZGVudGlmaWVyX2F0b20obm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgQVNUX0luZmluaXR5XG4gICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfTmFOXG4gICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfVW5kZWZpbmVkO1xufVxuXG4vLyBUaWdodGVuIGEgYnVuY2ggb2Ygc3RhdGVtZW50cyB0b2dldGhlci4gVXNlZCB3aGVuZXZlciB0aGVyZSBpcyBhIGJsb2NrLlxuZnVuY3Rpb24gdGlnaHRlbl9ib2R5KHN0YXRlbWVudHMsIGNvbXByZXNzb3IpIHtcbiAgICB2YXIgaW5fbG9vcCwgaW5fdHJ5O1xuICAgIHZhciBzY29wZSA9IGNvbXByZXNzb3IuZmluZF9wYXJlbnQoQVNUX1Njb3BlKS5nZXRfZGVmdW5fc2NvcGUoKTtcbiAgICBmaW5kX2xvb3Bfc2NvcGVfdHJ5KCk7XG4gICAgdmFyIENIQU5HRUQsIG1heF9pdGVyID0gMTA7XG4gICAgZG8ge1xuICAgICAgICBDSEFOR0VEID0gZmFsc2U7XG4gICAgICAgIGVsaW1pbmF0ZV9zcHVyaW91c19ibG9ja3Moc3RhdGVtZW50cyk7XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSkge1xuICAgICAgICAgICAgZWxpbWluYXRlX2RlYWRfY29kZShzdGF0ZW1lbnRzLCBjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJpZl9yZXR1cm5cIikpIHtcbiAgICAgICAgICAgIGhhbmRsZV9pZl9yZXR1cm4oc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iuc2VxdWVuY2VzX2xpbWl0ID4gMCkge1xuICAgICAgICAgICAgc2VxdWVuY2VzaXplKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgc2VxdWVuY2VzaXplXzIoc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiam9pbl92YXJzXCIpKSB7XG4gICAgICAgICAgICBqb2luX2NvbnNlY3V0aXZlX3ZhcnMoc3RhdGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiY29sbGFwc2VfdmFyc1wiKSkge1xuICAgICAgICAgICAgY29sbGFwc2Uoc3RhdGVtZW50cywgY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChDSEFOR0VEICYmIG1heF9pdGVyLS0gPiAwKTtcblxuICAgIGZ1bmN0aW9uIGZpbmRfbG9vcF9zY29wZV90cnkoKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tcHJlc3Nvci5zZWxmKCksIGxldmVsID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2F0Y2ggfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9GaW5hbGx5KSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpbl9sb29wID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkge1xuICAgICAgICAgICAgICAgIHNjb3BlID0gbm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9UcnkpIHtcbiAgICAgICAgICAgICAgICBpbl90cnkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChub2RlID0gY29tcHJlc3Nvci5wYXJlbnQobGV2ZWwrKykpO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmcm9tIHJpZ2h0IHRvIGxlZnQgZm9yIGFzc2lnbm1lbnQtbGlrZSBleHByZXNzaW9uczpcbiAgICAvLyAtIGB2YXIgYSA9IHg7YFxuICAgIC8vIC0gYGEgPSB4O2BcbiAgICAvLyAtIGArK2FgXG4gICAgLy8gRm9yIGVhY2ggY2FuZGlkYXRlLCBzY2FuIGZyb20gbGVmdCB0byByaWdodCBmb3IgZmlyc3QgdXNhZ2UsIHRoZW4gdHJ5XG4gICAgLy8gdG8gZm9sZCBhc3NpZ25tZW50IGludG8gdGhlIHNpdGUgZm9yIGNvbXByZXNzaW9uLlxuICAgIC8vIFdpbGwgbm90IGF0dGVtcHQgdG8gY29sbGFwc2UgYXNzaWdubWVudHMgaW50byBvciBwYXN0IGNvZGUgYmxvY2tzXG4gICAgLy8gd2hpY2ggYXJlIG5vdCBzZXF1ZW50aWFsbHkgZXhlY3V0ZWQsIGUuZy4gbG9vcHMgYW5kIGNvbmRpdGlvbmFscy5cbiAgICBmdW5jdGlvbiBjb2xsYXBzZShzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgICAgIGlmIChzY29wZS5waW5uZWQoKSkgcmV0dXJuIHN0YXRlbWVudHM7XG4gICAgICAgIHZhciBhcmdzO1xuICAgICAgICB2YXIgY2FuZGlkYXRlcyA9IFtdO1xuICAgICAgICB2YXIgc3RhdF9pbmRleCA9IHN0YXRlbWVudHMubGVuZ3RoO1xuICAgICAgICB2YXIgc2Nhbm5lciA9IG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKGFib3J0KSByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIC8vIFNraXAgbm9kZXMgYmVmb3JlIGBjYW5kaWRhdGVgIGFzIHF1aWNrbHkgYXMgcG9zc2libGVcbiAgICAgICAgICAgIGlmICghaGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IGhpdF9zdGFja1toaXRfaW5kZXhdKSByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICBoaXRfaW5kZXgrKztcbiAgICAgICAgICAgICAgICBpZiAoaGl0X2luZGV4IDwgaGl0X3N0YWNrLmxlbmd0aCkgcmV0dXJuIGhhbmRsZV9jdXN0b21fc2Nhbl9vcmRlcihub2RlKTtcbiAgICAgICAgICAgICAgICBoaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0b3BfYWZ0ZXIgPSBmaW5kX3N0b3Aobm9kZSwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BfYWZ0ZXIgPT09IG5vZGUpIGFib3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0b3AgaW1tZWRpYXRlbHkgaWYgdGhlc2Ugbm9kZSB0eXBlcyBhcmUgZW5jb3VudGVyZWRcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBzY2FubmVyLnBhcmVudCgpO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICAgICAgICAgICAgICYmIChub2RlLmxvZ2ljYWwgfHwgbm9kZS5vcGVyYXRvciAhPSBcIj1cIiAmJiBsaHMuZXF1aXZhbGVudF90byhub2RlLmxlZnQpKVxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfQXdhaXRcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0NhbGwgJiYgbGhzIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgJiYgbGhzLmVxdWl2YWxlbnRfdG8obm9kZS5leHByZXNzaW9uKVxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVidWdnZXJcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0Rlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvblxuICAgICAgICAgICAgICAgICAgICAmJiBub2RlLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfU3ltYm9sXG4gICAgICAgICAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9UaGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBub2RlLmV4cHJlc3Npb24uZGVmaW5pdGlvbigpLnJlZmVyZW5jZXMubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQgJiYgIShub2RlIGluc3RhbmNlb2YgQVNUX0ZvcilcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0xvb3BDb250cm9sXG4gICAgICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9UcnlcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1dpdGhcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1lpZWxkXG4gICAgICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9FeHBvcnRcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0NsYXNzXG4gICAgICAgICAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX0ZvciAmJiBub2RlICE9PSBwYXJlbnQuaW5pdFxuICAgICAgICAgICAgICAgIHx8ICFyZXBsYWNlX2FsbFxuICAgICAgICAgICAgICAgICAgICAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgIW5vZGUuaXNfZGVjbGFyZWQoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICFwdXJlX3Byb3BfYWNjZXNzX2dsb2JhbHMuaGFzKG5vZGUpKVxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAgICAgICAgICYmIHBhcmVudCBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICAgICAgICAgICAgICYmIGhhc19hbm5vdGF0aW9uKHBhcmVudCwgX05PSU5MSU5FKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYWJvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcCBvbmx5IGlmIGNhbmRpZGF0ZSBpcyBmb3VuZCB3aXRoaW4gY29uZGl0aW9uYWwgYnJhbmNoZXNcbiAgICAgICAgICAgIGlmICghc3RvcF9pZl9oaXQgJiYgKCFsaHNfbG9jYWwgfHwgIXJlcGxhY2VfYWxsKVxuICAgICAgICAgICAgICAgICYmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIGxhenlfb3AuaGFzKHBhcmVudC5vcGVyYXRvcikgJiYgcGFyZW50LmxlZnQgIT09IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsICYmIHBhcmVudC5jb25kaXRpb24gIT09IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX0lmICYmIHBhcmVudC5jb25kaXRpb24gIT09IG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgc3RvcF9pZl9oaXQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHZhcmlhYmxlIHdpdGggYXNzaWdubWVudCB3aGVuIGZvdW5kXG4gICAgICAgICAgICBpZiAoY2FuX3JlcGxhY2VcbiAgICAgICAgICAgICAgICAmJiAhKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVjbGFyYXRpb24pXG4gICAgICAgICAgICAgICAgJiYgbGhzLmVxdWl2YWxlbnRfdG8obm9kZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9wX2lmX2hpdCkge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNfbGhzKG5vZGUsIHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlX2RlZikgcmVwbGFjZWQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZWQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlX2RlZiAmJiBjYW5kaWRhdGUgaW5zdGFuY2VvZiBBU1RfVmFyRGVmKSByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQ0hBTkdFRCA9IGFib3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlIGluc3RhbmNlb2YgQVNUX1VuYXJ5UG9zdGZpeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgY2FuZGlkYXRlLCBjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlIGluc3RhbmNlb2YgQVNUX1ZhckRlZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gY2FuZGlkYXRlLm5hbWUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjYW5kaWRhdGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWYucmVmZXJlbmNlcy5sZW5ndGggLSBkZWYucmVwbGFjZWQgPT0gMSAmJiAhY29tcHJlc3Nvci5leHBvc2VkKGRlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZi5yZXBsYWNlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmFyZyAmJiBpc19pZGVudGlmaWVyX2F0b20odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1haW50YWluX3RoaXNfYmluZGluZyhwYXJlbnQsIG5vZGUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9Bc3NpZ24sIGNhbmRpZGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiPVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9naWNhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBtYWtlX25vZGUoQVNUX1N5bWJvbFJlZiwgY2FuZGlkYXRlLm5hbWUsIGNhbmRpZGF0ZS5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYXJfZmxhZyhjYW5kaWRhdGUsIFdSSVRFX09OTFkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVzZSBub2RlIHR5cGVzIGhhdmUgY2hpbGQgbm9kZXMgdGhhdCBleGVjdXRlIHNlcXVlbnRpYWxseSxcbiAgICAgICAgICAgIC8vIGJ1dCBhcmUgb3RoZXJ3aXNlIG5vdCBzYWZlIHRvIHNjYW4gaW50byBvciBiZXlvbmQgdGhlbS5cbiAgICAgICAgICAgIHZhciBzeW07XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9FeGl0XG4gICAgICAgICAgICAgICAgICAgICYmIChzaWRlX2VmZmVjdHMgfHwgbGhzIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MgfHwgbWF5X21vZGlmeShsaHMpKVxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2Vzc1xuICAgICAgICAgICAgICAgICAgICAmJiAoc2lkZV9lZmZlY3RzIHx8IG5vZGUuZXhwcmVzc2lvbi5tYXlfdGhyb3dfb25fYWNjZXNzKGNvbXByZXNzb3IpKVxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAgICAgICAgICYmIChsdmFsdWVzLmdldChub2RlLm5hbWUpIHx8IHNpZGVfZWZmZWN0cyAmJiBtYXlfbW9kaWZ5KG5vZGUpKVxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyRGVmICYmIG5vZGUudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgJiYgKGx2YWx1ZXMuaGFzKG5vZGUubmFtZS5uYW1lKSB8fCBzaWRlX2VmZmVjdHMgJiYgbWF5X21vZGlmeShub2RlLm5hbWUpKVxuICAgICAgICAgICAgICAgIHx8IChzeW0gPSBpc19saHMobm9kZS5sZWZ0LCBub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgJiYgKHN5bSBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzIHx8IGx2YWx1ZXMuaGFzKHN5bS5uYW1lKSlcbiAgICAgICAgICAgICAgICB8fCBtYXlfdGhyb3dcbiAgICAgICAgICAgICAgICAgICAgJiYgKGluX3RyeSA/IG5vZGUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSA6IHNpZGVfZWZmZWN0c19leHRlcm5hbChub2RlKSkpIHtcbiAgICAgICAgICAgICAgICBzdG9wX2FmdGVyID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkgYWJvcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZV9jdXN0b21fc2Nhbl9vcmRlcihub2RlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKGFib3J0KSByZXR1cm47XG4gICAgICAgICAgICBpZiAoc3RvcF9hZnRlciA9PT0gbm9kZSkgYWJvcnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHN0b3BfaWZfaGl0ID09PSBub2RlKSBzdG9wX2lmX2hpdCA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBtdWx0aV9yZXBsYWNlciA9IG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKGFib3J0KSByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIC8vIFNraXAgbm9kZXMgYmVmb3JlIGBjYW5kaWRhdGVgIGFzIHF1aWNrbHkgYXMgcG9zc2libGVcbiAgICAgICAgICAgIGlmICghaGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IGhpdF9zdGFja1toaXRfaW5kZXhdKSByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICBoaXRfaW5kZXgrKztcbiAgICAgICAgICAgICAgICBpZiAoaGl0X2luZGV4IDwgaGl0X3N0YWNrLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHZhcmlhYmxlIHdoZW4gZm91bmRcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgICAgICYmIG5vZGUubmFtZSA9PSBkZWYubmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghLS1yZXBsYWNlZCkgYWJvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChpc19saHMobm9kZSwgbXVsdGlfcmVwbGFjZXIucGFyZW50KCkpKSByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgICAgICBkZWYucmVwbGFjZWQrKztcbiAgICAgICAgICAgICAgICB2YWx1ZV9kZWYucmVwbGFjZWQtLTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2tpcCAobm9uLWV4ZWN1dGVkKSBmdW5jdGlvbnMgYW5kIChsZWFkaW5nKSBkZWZhdWx0IGNhc2UgaW4gc3dpdGNoIHN0YXRlbWVudHNcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZmF1bHQgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdoaWxlICgtLXN0YXRfaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgLy8gVHJlYXQgcGFyYW1ldGVycyBhcyBjb2xsYXBzaWJsZSBpbiBJSUZFLCBpLmUuXG4gICAgICAgICAgICAvLyAgIGZ1bmN0aW9uKGEsIGIpeyAuLi4gfSh4KCkpO1xuICAgICAgICAgICAgLy8gd291bGQgYmUgdHJhbnNsYXRlZCBpbnRvIGVxdWl2YWxlbnQgYXNzaWdubWVudHM6XG4gICAgICAgICAgICAvLyAgIHZhciBhID0geCgpLCBiID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHN0YXRfaW5kZXggPT0gMCAmJiBjb21wcmVzc29yLm9wdGlvbihcInVudXNlZFwiKSkgZXh0cmFjdF9hcmdzKCk7XG4gICAgICAgICAgICAvLyBGaW5kIGNvbGxhcHNpYmxlIGFzc2lnbm1lbnRzXG4gICAgICAgICAgICB2YXIgaGl0X3N0YWNrID0gW107XG4gICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoc3RhdGVtZW50c1tzdGF0X2luZGV4XSk7XG4gICAgICAgICAgICB3aGlsZSAoY2FuZGlkYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaGl0X3N0YWNrID0gY2FuZGlkYXRlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB2YXIgaGl0X2luZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gaGl0X3N0YWNrW2hpdF9zdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVfZGVmID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcF9hZnRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3BfaWZfaGl0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgbGhzID0gZ2V0X2xocyhjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIGlmICghbGhzIHx8IGlzX2xoc19yZWFkX29ubHkobGhzKSB8fCBsaHMuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgLy8gTG9jYXRlIHN5bWJvbHMgd2hpY2ggbWF5IGV4ZWN1dGUgY29kZSBvdXRzaWRlIG9mIHNjYW5uaW5nIHJhbmdlXG4gICAgICAgICAgICAgICAgdmFyIGx2YWx1ZXMgPSBnZXRfbHZhbHVlcyhjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIHZhciBsaHNfbG9jYWwgPSBpc19saHNfbG9jYWwobGhzKTtcbiAgICAgICAgICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikgbHZhbHVlcy5zZXQobGhzLm5hbWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB2YXIgc2lkZV9lZmZlY3RzID0gdmFsdWVfaGFzX3NpZGVfZWZmZWN0cyhjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlX2FsbCA9IHJlcGxhY2VfYWxsX3N5bWJvbHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF5X3Rocm93ID0gY2FuZGlkYXRlLm1heV90aHJvdyhjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVuYXJnID0gY2FuZGlkYXRlLm5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRnVuYXJnO1xuICAgICAgICAgICAgICAgIHZhciBoaXQgPSBmdW5hcmc7XG4gICAgICAgICAgICAgICAgdmFyIGFib3J0ID0gZmFsc2UsIHJlcGxhY2VkID0gMCwgY2FuX3JlcGxhY2UgPSAhYXJncyB8fCAhaGl0O1xuICAgICAgICAgICAgICAgIGlmICghY2FuX3JlcGxhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGNvbXByZXNzb3Iuc2VsZigpLmFyZ25hbWVzLmxhc3RJbmRleE9mKGNhbmRpZGF0ZS5uYW1lKSArIDE7ICFhYm9ydCAmJiBqIDwgYXJncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tqXS50cmFuc2Zvcm0oc2Nhbm5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FuX3JlcGxhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhdF9pbmRleDsgIWFib3J0ICYmIGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHNbaV0udHJhbnNmb3JtKHNjYW5uZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVfZGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSBjYW5kaWRhdGUubmFtZS5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYm9ydCAmJiBkZWYucmVmZXJlbmNlcy5sZW5ndGggLSBkZWYucmVwbGFjZWQgPiByZXBsYWNlZCkgcmVwbGFjZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0X2luZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdCA9IGZ1bmFyZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGF0X2luZGV4OyAhYWJvcnQgJiYgaSA8IHN0YXRlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzW2ldLnRyYW5zZm9ybShtdWx0aV9yZXBsYWNlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZV9kZWYuc2luZ2xlX3VzZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlZCAmJiAhcmVtb3ZlX2NhbmRpZGF0ZShjYW5kaWRhdGUpKSBzdGF0ZW1lbnRzLnNwbGljZShzdGF0X2luZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZV9jdXN0b21fc2Nhbl9vcmRlcihub2RlKSB7XG4gICAgICAgICAgICAvLyBTa2lwIChub24tZXhlY3V0ZWQpIGZ1bmN0aW9uc1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHJldHVybiBub2RlO1xuXG4gICAgICAgICAgICAvLyBTY2FuIGNhc2UgZXhwcmVzc2lvbnMgZmlyc3QgaW4gYSBzd2l0Y2ggc3RhdGVtZW50XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpIHtcbiAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24gPSBub2RlLmV4cHJlc3Npb24udHJhbnNmb3JtKHNjYW5uZXIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBub2RlLmJvZHkubGVuZ3RoOyAhYWJvcnQgJiYgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBicmFuY2ggPSBub2RlLmJvZHlbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChicmFuY2ggaW5zdGFuY2VvZiBBU1RfQ2FzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnJhbmNoICE9PSBoaXRfc3RhY2tbaGl0X2luZGV4XSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0X2luZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmFuY2guZXhwcmVzc2lvbiA9IGJyYW5jaC5leHByZXNzaW9uLnRyYW5zZm9ybShzY2FubmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVwbGFjZV9hbGwpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFib3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlZGVmaW5lZF93aXRoaW5fc2NvcGUoZGVmLCBzY29wZSkge1xuICAgICAgICAgICAgaWYgKGRlZi5nbG9iYWwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBjdXJfc2NvcGUgPSBkZWYuc2NvcGU7XG4gICAgICAgICAgICB3aGlsZSAoY3VyX3Njb3BlICYmIGN1cl9zY29wZSAhPT0gc2NvcGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyX3Njb3BlLnZhcmlhYmxlcy5oYXMoZGVmLm5hbWUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdXJfc2NvcGUgPSBjdXJfc2NvcGUucGFyZW50X3Njb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaGFzX292ZXJsYXBwaW5nX3N5bWJvbChmbiwgYXJnLCBmbl9zdHJpY3QpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlLCBzY2FuX3RoaXMgPSAhKGZuIGluc3RhbmNlb2YgQVNUX0Fycm93KTtcbiAgICAgICAgICAgIGFyZy53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUsIGRlc2NlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZiAmJiAoZm4udmFyaWFibGVzLmhhcyhub2RlLm5hbWUpIHx8IHJlZGVmaW5lZF93aXRoaW5fc2NvcGUobm9kZS5kZWZpbml0aW9uKCksIGZuKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBub2RlLmRlZmluaXRpb24oKS5zY29wZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMgIT09IHNjb3BlKSB3aGlsZSAocyA9IHMucGFyZW50X3Njb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PT0gc2NvcGUpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoZm5fc3RyaWN0IHx8IHNjYW5fdGhpcykgJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9UaGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlICYmICEobm9kZSBpbnN0YW5jZW9mIEFTVF9BcnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXYgPSBzY2FuX3RoaXM7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5fdGhpcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBkZXNjZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHNjYW5fdGhpcyA9IHByZXY7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4dHJhY3RfYXJncygpIHtcbiAgICAgICAgICAgIHZhciBpaWZlLCBmbiA9IGNvbXByZXNzb3Iuc2VsZigpO1xuICAgICAgICAgICAgaWYgKGlzX2Z1bmNfZXhwcihmbilcbiAgICAgICAgICAgICAgICAmJiAhZm4ubmFtZVxuICAgICAgICAgICAgICAgICYmICFmbi51c2VzX2FyZ3VtZW50c1xuICAgICAgICAgICAgICAgICYmICFmbi5waW5uZWQoKVxuICAgICAgICAgICAgICAgICYmIChpaWZlID0gY29tcHJlc3Nvci5wYXJlbnQoKSkgaW5zdGFuY2VvZiBBU1RfQ2FsbFxuICAgICAgICAgICAgICAgICYmIGlpZmUuZXhwcmVzc2lvbiA9PT0gZm5cbiAgICAgICAgICAgICAgICAmJiBpaWZlLmFyZ3MuZXZlcnkoKGFyZykgPT4gIShhcmcgaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciBmbl9zdHJpY3QgPSBjb21wcmVzc29yLmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpO1xuICAgICAgICAgICAgICAgIGlmIChmbl9zdHJpY3QgJiYgIW1lbWJlcihmbl9zdHJpY3QsIGZuLmJvZHkpKSBmbl9zdHJpY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gZm4uYXJnbmFtZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBpaWZlLmFyZ3Muc2xpY2UobGVuKTtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxlbjsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSBmbi5hcmduYW1lc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZyA9IGlpZmUuYXJnc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB0d28gbGluZSBmaXggaXMgYSBkdXBsaWNhdGUgb2YgdGhlIGZpeCBhdFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGVyc2VyL3RlcnNlci9jb21taXQvMDExZDNlYjA4Y2VmZTY5MjJjN2QxYmRmYTExM2ZjNGFlYWNhMWI3NVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1pZ2h0IG1lYW4gdGhhdCB0aGVzZSB0d28gcGllY2VzIG9mIGNvZGUgKG9uZSBoZXJlIGluIGNvbGxhcHNlX3ZhcnMgYW5kIGFub3RoZXIgaW4gcmVkdWNlX3ZhcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gTWlnaHQgYmUgZG9pbmcgdGhlIGV4YWN0IHNhbWUgdGhpbmcuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZiA9IHN5bS5kZWZpbml0aW9uICYmIHN5bS5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzX3JlYXNzaWduZWQgPSBkZWYgJiYgZGVmLm9yaWcubGVuZ3RoID4gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzX3JlYXNzaWduZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQobWFrZV9ub2RlKEFTVF9WYXJEZWYsIHN5bSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3ltLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFyZ1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lcy5oYXMoc3ltLm5hbWUpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZXMuYWRkKHN5bS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN5bSBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGlpZmUuYXJncy5zbGljZShpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5ldmVyeSgoYXJnKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFoYXNfb3ZlcmxhcHBpbmdfc3ltYm9sKGZuLCBhcmcsIGZuX3N0cmljdClcbiAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnVuc2hpZnQoWyBtYWtlX25vZGUoQVNUX1ZhckRlZiwgc3ltLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHN5bS5leHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWFrZV9ub2RlKEFTVF9BcnJheSwgaWlmZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzeW0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgQVNUX0xhbWJkYSAmJiBhcmcucGlubmVkKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBoYXNfb3ZlcmxhcHBpbmdfc3ltYm9sKGZuLCBhcmcsIGZuX3N0cmljdClcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnKSBjYW5kaWRhdGVzLnVuc2hpZnQoWyBtYWtlX25vZGUoQVNUX1ZhckRlZiwgc3ltLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc3ltLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhcmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIpIHtcbiAgICAgICAgICAgIGhpdF9zdGFjay5wdXNoKGV4cHIpO1xuICAgICAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfQXNzaWduKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhZXhwci5sZWZ0Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAgICAgJiYgIShleHByLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0NoYWluKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goaGl0X3N0YWNrLnNsaWNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5yaWdodCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIubGVmdCk7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIucmlnaHQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0NhbGwgJiYgIWhhc19hbm5vdGF0aW9uKGV4cHIsIF9OT0lOTElORSkpIHtcbiAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBleHByLmFyZ3MuZm9yRWFjaChleHRyYWN0X2NhbmRpZGF0ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0Nhc2UpIHtcbiAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5leHByZXNzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCkge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RfY2FuZGlkYXRlcyhleHByLmNvbmRpdGlvbik7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIuY29uc2VxdWVudCk7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIuYWx0ZXJuYXRpdmUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGV4cHIuZGVmaW5pdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIGxpbWl0IG51bWJlciBvZiB0cmFpbGluZyB2YXJpYWJsZSBkZWZpbml0aW9ucyBmb3IgY29uc2lkZXJhdGlvblxuICAgICAgICAgICAgICAgIHZhciBpID0gbGVuIC0gMjAwO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCkgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5kZWZpbml0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0RXTG9vcCkge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RfY2FuZGlkYXRlcyhleHByLmNvbmRpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKCEoZXhwci5ib2R5IGluc3RhbmNlb2YgQVNUX0Jsb2NrKSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5ib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfRXhpdCkge1xuICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlKSBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfRm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIuaW5pdCkgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIuaW5pdCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIuY29uZGl0aW9uKSBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5jb25kaXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChleHByLnN0ZXApIGV4dHJhY3RfY2FuZGlkYXRlcyhleHByLnN0ZXApO1xuICAgICAgICAgICAgICAgIGlmICghKGV4cHIuYm9keSBpbnN0YW5jZW9mIEFTVF9CbG9jaykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIuYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0ZvckluKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIub2JqZWN0KTtcbiAgICAgICAgICAgICAgICBpZiAoIShleHByLmJvZHkgaW5zdGFuY2VvZiBBU1RfQmxvY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RfY2FuZGlkYXRlcyhleHByLmJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9JZikge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RfY2FuZGlkYXRlcyhleHByLmNvbmRpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKCEoZXhwci5ib2R5IGluc3RhbmNlb2YgQVNUX0Jsb2NrKSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5ib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cHIuYWx0ZXJuYXRpdmUgJiYgIShleHByLmFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX0Jsb2NrKSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYWN0X2NhbmRpZGF0ZXMoZXhwci5hbHRlcm5hdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChleHByIGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgZXhwci5leHByZXNzaW9ucy5mb3JFYWNoKGV4dHJhY3RfY2FuZGlkYXRlcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIuYm9keSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdF9jYW5kaWRhdGVzKGV4cHIuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgZXhwci5ib2R5LmZvckVhY2goZXh0cmFjdF9jYW5kaWRhdGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9VbmFyeSkge1xuICAgICAgICAgICAgICAgIGlmIChleHByLm9wZXJhdG9yID09IFwiKytcIiB8fCBleHByLm9wZXJhdG9yID09IFwiLS1cIikge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goaGl0X3N0YWNrLnNsaWNlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9WYXJEZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwci52YWx1ZSAmJiAhKGV4cHIudmFsdWUgaW5zdGFuY2VvZiBBU1RfQ2hhaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaChoaXRfc3RhY2suc2xpY2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RfY2FuZGlkYXRlcyhleHByLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoaXRfc3RhY2sucG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmaW5kX3N0b3Aobm9kZSwgbGV2ZWwsIHdyaXRlX29ubHkpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBzY2FubmVyLnBhcmVudChsZXZlbCk7XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX0Fzc2lnbikge1xuICAgICAgICAgICAgICAgIGlmICh3cml0ZV9vbmx5XG4gICAgICAgICAgICAgICAgICAgICYmICFwYXJlbnQubG9naWNhbFxuICAgICAgICAgICAgICAgICAgICAmJiAhKHBhcmVudC5sZWZ0IGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGx2YWx1ZXMuaGFzKHBhcmVudC5sZWZ0Lm5hbWUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZF9zdG9wKHBhcmVudCwgbGV2ZWwgKyAxLCB3cml0ZV9vbmx5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX0JpbmFyeSkge1xuICAgICAgICAgICAgICAgIGlmICh3cml0ZV9vbmx5ICYmICghbGF6eV9vcC5oYXMocGFyZW50Lm9wZXJhdG9yKSB8fCBwYXJlbnQubGVmdCA9PT0gbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRfc3RvcChwYXJlbnQsIGxldmVsICsgMSwgd3JpdGVfb25seSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9DYWxsKSByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQ2FzZSkgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdyaXRlX29ubHkgJiYgcGFyZW50LmNvbmRpdGlvbiA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZF9zdG9wKHBhcmVudCwgbGV2ZWwgKyAxLCB3cml0ZV9vbmx5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRfc3RvcChwYXJlbnQsIGxldmVsICsgMSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX0V4aXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JpdGVfb25seSA/IGZpbmRfc3RvcChwYXJlbnQsIGxldmVsICsgMSwgd3JpdGVfb25seSkgOiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9JZikge1xuICAgICAgICAgICAgICAgIGlmICh3cml0ZV9vbmx5ICYmIHBhcmVudC5jb25kaXRpb24gPT09IG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRfc3RvcChwYXJlbnQsIGxldmVsICsgMSwgd3JpdGVfb25seSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQpIHJldHVybiBub2RlO1xuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kX3N0b3AocGFyZW50LCBsZXZlbCArIDEsIHBhcmVudC50YWlsX25vZGUoKSAhPT0gbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kX3N0b3AocGFyZW50LCBsZXZlbCArIDEsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpIHJldHVybiBub2RlO1xuICAgICAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9WYXJEZWYpIHJldHVybiBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtYW5nbGVhYmxlX3Zhcih2YXJfZGVmKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YXJfZGVmLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHZhbHVlLm5hbWUgPT0gXCJhcmd1bWVudHNcIikgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGRlZiA9IHZhbHVlLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgIGlmIChkZWYudW5kZWNsYXJlZCkgcmV0dXJuO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlX2RlZiA9IGRlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldF9saHMoZXhwcikge1xuICAgICAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfQXNzaWduICYmIGV4cHIubG9naWNhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9WYXJEZWYgJiYgZXhwci5uYW1lIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZiA9IGV4cHIubmFtZS5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFtZW1iZXIoZXhwci5uYW1lLCBkZWYub3JpZykpIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgcmVmZXJlbmNlZCA9IGRlZi5yZWZlcmVuY2VzLmxlbmd0aCAtIGRlZi5yZXBsYWNlZDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZmVyZW5jZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgZGVjbGFyZWQgPSBkZWYub3JpZy5sZW5ndGggLSBkZWYuZWxpbWluYXRlZDtcbiAgICAgICAgICAgICAgICBpZiAoZGVjbGFyZWQgPiAxICYmICEoZXhwci5uYW1lIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZylcbiAgICAgICAgICAgICAgICAgICAgfHwgKHJlZmVyZW5jZWQgPiAxID8gbWFuZ2xlYWJsZV92YXIoZXhwcikgOiAhY29tcHJlc3Nvci5leHBvc2VkKGRlZikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1N5bWJvbFJlZiwgZXhwci5uYW1lLCBleHByLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGhzID0gZXhwciBpbnN0YW5jZW9mIEFTVF9Bc3NpZ25cbiAgICAgICAgICAgICAgICAgICAgPyBleHByLmxlZnRcbiAgICAgICAgICAgICAgICAgICAgOiBleHByLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgcmV0dXJuICFpc19yZWZfb2YobGhzLCBBU1RfU3ltYm9sQ29uc3QpXG4gICAgICAgICAgICAgICAgICAgICYmICFpc19yZWZfb2YobGhzLCBBU1RfU3ltYm9sTGV0KSAmJiBsaHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRfcnZhbHVlKGV4cHIpIHtcbiAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0Fzc2lnbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBleHByLnJpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwci52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldF9sdmFsdWVzKGV4cHIpIHtcbiAgICAgICAgICAgIHZhciBsdmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfVW5hcnkpIHJldHVybiBsdmFsdWVzO1xuICAgICAgICAgICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBzeW0gPSBub2RlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzeW0gaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2Vzcykgc3ltID0gc3ltLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgaWYgKHN5bSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgfHwgc3ltIGluc3RhbmNlb2YgQVNUX1RoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbHZhbHVlcy5zZXQoc3ltLm5hbWUsIGx2YWx1ZXMuZ2V0KHN5bS5uYW1lKSB8fCBpc19tb2RpZmllZChjb21wcmVzc29yLCB0dywgbm9kZSwgbm9kZSwgMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ2V0X3J2YWx1ZShleHByKS53YWxrKHR3KTtcbiAgICAgICAgICAgIHJldHVybiBsdmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlX2NhbmRpZGF0ZShleHByKSB7XG4gICAgICAgICAgICBpZiAoZXhwci5uYW1lIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZykge1xuICAgICAgICAgICAgICAgIHZhciBpaWZlID0gY29tcHJlc3Nvci5wYXJlbnQoKSwgYXJnbmFtZXMgPSBjb21wcmVzc29yLnNlbGYoKS5hcmduYW1lcztcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhcmduYW1lcy5pbmRleE9mKGV4cHIubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpaWZlLmFyZ3MubGVuZ3RoID0gTWF0aC5taW4oaWlmZS5hcmdzLmxlbmd0aCwgYXJnbmFtZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBpaWZlLmFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzW2luZGV4XSkgYXJnc1tpbmRleF0gPSBtYWtlX25vZGUoQVNUX051bWJlciwgYXJnc1tpbmRleF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHNbc3RhdF9pbmRleF0udHJhbnNmb3JtKG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24obm9kZSwgZGVzY2VuZCwgaW5fbGlzdCkge1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCkgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IGV4cHIgfHwgbm9kZS5ib2R5ID09PSBleHByKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyRGVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbm9kZS5uYW1lIGluc3RhbmNlb2YgQVNUX1N5bWJvbENvbnN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIG5vZGUudmFsdWUpICAvLyBgY29uc3RgIGFsd2F5cyBuZWVkcyB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluX2xpc3QgPyBNQVAuc2tpcCA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlKSBzd2l0Y2ggKG5vZGUuZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbm9kZS5leHByZXNzaW9uc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc19saHNfbG9jYWwobGhzKSB7XG4gICAgICAgICAgICB3aGlsZSAobGhzIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MpIGxocyA9IGxocy5leHByZXNzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIGxocyBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAmJiBsaHMuZGVmaW5pdGlvbigpLnNjb3BlID09PSBzY29wZVxuICAgICAgICAgICAgICAgICYmICEoaW5fbG9vcFxuICAgICAgICAgICAgICAgICAgICAmJiAobHZhbHVlcy5oYXMobGhzLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBjYW5kaWRhdGUgaW5zdGFuY2VvZiBBU1RfVW5hcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IChjYW5kaWRhdGUgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgIWNhbmRpZGF0ZS5sb2dpY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2FuZGlkYXRlLm9wZXJhdG9yICE9IFwiPVwiKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdmFsdWVfaGFzX3NpZGVfZWZmZWN0cyhleHByKSB7XG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9VbmFyeSkgcmV0dXJuIHVuYXJ5X3NpZGVfZWZmZWN0cy5oYXMoZXhwci5vcGVyYXRvcik7XG4gICAgICAgICAgICByZXR1cm4gZ2V0X3J2YWx1ZShleHByKS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZV9hbGxfc3ltYm9scygpIHtcbiAgICAgICAgICAgIGlmIChzaWRlX2VmZmVjdHMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZV9kZWYpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGxocyBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVmID0gbGhzLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVmLnJlZmVyZW5jZXMubGVuZ3RoIC0gZGVmLnJlcGxhY2VkID09IChjYW5kaWRhdGUgaW5zdGFuY2VvZiBBU1RfVmFyRGVmID8gMSA6IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG1heV9tb2RpZnkoc3ltKSB7XG4gICAgICAgICAgICBpZiAoIXN5bS5kZWZpbml0aW9uKSByZXR1cm4gdHJ1ZTsgLy8gQVNUX0Rlc3RydWN0dXJpbmdcbiAgICAgICAgICAgIHZhciBkZWYgPSBzeW0uZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgaWYgKGRlZi5vcmlnLmxlbmd0aCA9PSAxICYmIGRlZi5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlZnVuKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZGVmLnNjb3BlLmdldF9kZWZ1bl9zY29wZSgpICE9PSBzY29wZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gIWRlZi5yZWZlcmVuY2VzLmV2ZXJ5KChyZWYpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHJlZi5zY29wZS5nZXRfZGVmdW5fc2NvcGUoKTtcbiAgICAgICAgICAgICAgICAvLyBcImJsb2NrXCIgc2NvcGUgd2l0aGluIEFTVF9DYXRjaFxuICAgICAgICAgICAgICAgIGlmIChzLlRZUEUgPT0gXCJTY29wZVwiKSBzID0gcy5wYXJlbnRfc2NvcGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMgPT09IHNjb3BlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzaWRlX2VmZmVjdHNfZXh0ZXJuYWwobm9kZSwgbGhzKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Bc3NpZ24pIHJldHVybiBzaWRlX2VmZmVjdHNfZXh0ZXJuYWwobm9kZS5sZWZ0LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1VuYXJ5KSByZXR1cm4gc2lkZV9lZmZlY3RzX2V4dGVybmFsKG5vZGUuZXhwcmVzc2lvbiwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9WYXJEZWYpIHJldHVybiBub2RlLnZhbHVlICYmIHNpZGVfZWZmZWN0c19leHRlcm5hbChub2RlLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChsaHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Eb3QpIHJldHVybiBzaWRlX2VmZmVjdHNfZXh0ZXJuYWwobm9kZS5leHByZXNzaW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TdWIpIHJldHVybiBzaWRlX2VmZmVjdHNfZXh0ZXJuYWwobm9kZS5leHByZXNzaW9uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHJldHVybiBub2RlLmRlZmluaXRpb24oKS5zY29wZSAhPT0gc2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbGltaW5hdGVfc3B1cmlvdXNfYmxvY2tzKHN0YXRlbWVudHMpIHtcbiAgICAgICAgdmFyIHNlZW5fZGlycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoOykge1xuICAgICAgICAgICAgdmFyIHN0YXQgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQgJiYgc3RhdC5ib2R5LmV2ZXJ5KGNhbl9iZV9ldmljdGVkX2Zyb21fYmxvY2spKSB7XG4gICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZWxpbWluYXRlX3NwdXJpb3VzX2Jsb2NrcyhzdGF0LmJvZHkpO1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudHMuc3BsaWNlKGksIDEsIC4uLnN0YXQuYm9keSk7XG4gICAgICAgICAgICAgICAgaSArPSBzdGF0LmJvZHkubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW5fZGlycy5pbmRleE9mKHN0YXQudmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5fZGlycy5wdXNoKHN0YXQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlX2lmX3JldHVybihzdGF0ZW1lbnRzLCBjb21wcmVzc29yKSB7XG4gICAgICAgIHZhciBzZWxmID0gY29tcHJlc3Nvci5zZWxmKCk7XG4gICAgICAgIHZhciBtdWx0aXBsZV9pZl9yZXR1cm5zID0gaGFzX211bHRpcGxlX2lmX3JldHVybnMoc3RhdGVtZW50cyk7XG4gICAgICAgIHZhciBpbl9sYW1iZGEgPSBzZWxmIGluc3RhbmNlb2YgQVNUX0xhbWJkYTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXRlbWVudHMubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgIHZhciBzdGF0ID0gc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBqID0gbmV4dF9pbmRleChpKTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gc3RhdGVtZW50c1tqXTtcblxuICAgICAgICAgICAgaWYgKGluX2xhbWJkYSAmJiAhbmV4dCAmJiBzdGF0IGluc3RhbmNlb2YgQVNUX1JldHVybikge1xuICAgICAgICAgICAgICAgIGlmICghc3RhdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdC52YWx1ZSBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeCAmJiBzdGF0LnZhbHVlLm9wZXJhdG9yID09IFwidm9pZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzW2ldID0gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHN0YXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHN0YXQudmFsdWUuZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9JZikge1xuICAgICAgICAgICAgICAgIHZhciBhYiA9IGFib3J0cyhzdGF0LmJvZHkpO1xuICAgICAgICAgICAgICAgIGlmIChjYW5fbWVyZ2VfZmxvdyhhYikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFiLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoYWIubGFiZWwudGhlZGVmLnJlZmVyZW5jZXMsIGFiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdC5jb25kaXRpb24gPSBzdGF0LmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gYXNfc3RhdGVtZW50X2FycmF5X3dpdGhfcmV0dXJuKHN0YXQuYm9keSwgYWIpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBhc19zdGF0ZW1lbnRfYXJyYXkoc3RhdC5hbHRlcm5hdGl2ZSkuY29uY2F0KGV4dHJhY3RfZnVuY3Rpb25zKCkpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc3RhdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1tpXSA9IHN0YXQudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYWIgPSBhYm9ydHMoc3RhdC5hbHRlcm5hdGl2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbl9tZXJnZV9mbG93KGFiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWIubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShhYi5sYWJlbC50aGVkZWYucmVmZXJlbmNlcywgYWIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ID0gc3RhdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0LmJvZHkgPSBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzdGF0LmJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGFzX3N0YXRlbWVudF9hcnJheShzdGF0LmJvZHkpLmNvbmNhdChleHRyYWN0X2Z1bmN0aW9ucygpKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBhc19zdGF0ZW1lbnRfYXJyYXlfd2l0aF9yZXR1cm4oc3RhdC5hbHRlcm5hdGl2ZSwgYWIpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc3RhdC5hbHRlcm5hdGl2ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1tpXSA9IHN0YXQudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0lmICYmIHN0YXQuYm9keSBpbnN0YW5jZW9mIEFTVF9SZXR1cm4pIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdGF0LmJvZHkudmFsdWU7XG4gICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAvLyBwcmV0dHkgc2lsbHkgY2FzZSwgYnV0OlxuICAgICAgICAgICAgICAgIC8vIGlmIChmb28oKSkgcmV0dXJuOyByZXR1cm47ID09PiBmb28oKTsgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghdmFsdWUgJiYgIXN0YXQuYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgJiYgKGluX2xhbWJkYSAmJiAhbmV4dCB8fCBuZXh0IGluc3RhbmNlb2YgQVNUX1JldHVybiAmJiAhbmV4dC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHNbaV0gPSBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc3RhdC5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHN0YXQuY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8tLS1cbiAgICAgICAgICAgICAgICAvLyBpZiAoZm9vKCkpIHJldHVybiB4OyByZXR1cm4geTsgPT0+IHJldHVybiBmb28oKSA/IHggOiB5O1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhc3RhdC5hbHRlcm5hdGl2ZSAmJiBuZXh0IGluc3RhbmNlb2YgQVNUX1JldHVybiAmJiBuZXh0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ID0gc3RhdC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0LmFsdGVybmF0aXZlID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1tpXSA9IHN0YXQudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgICAgICAgLy8gaWYgKGZvbygpKSByZXR1cm4geDsgWyByZXR1cm4gOyBdID09PiByZXR1cm4gZm9vKCkgPyB4IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhc3RhdC5hbHRlcm5hdGl2ZVxuICAgICAgICAgICAgICAgICAgICAmJiAoIW5leHQgJiYgaW5fbGFtYmRhICYmIG11bHRpcGxlX2lmX3JldHVybnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IG5leHQgaW5zdGFuY2VvZiBBU1RfUmV0dXJuKSkge1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdC5hbHRlcm5hdGl2ZSA9IG5leHQgfHwgbWFrZV9ub2RlKEFTVF9SZXR1cm4sIHN0YXQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzW2ldID0gc3RhdC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KSBzdGF0ZW1lbnRzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgICAgICAgLy8gaWYgKGEpIHJldHVybiBiOyBpZiAoYykgcmV0dXJuIGQ7IGU7ID09PiByZXR1cm4gYSA/IGIgOiBjID8gZCA6IHZvaWQgZTtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGlmIHNlcXVlbmNlcyBpcyBub3QgZW5hYmxlZCwgdGhpcyBjYW4gbGVhZCB0byBhbiBlbmRsZXNzIGxvb3AgKGlzc3VlICM4NjYpLlxuICAgICAgICAgICAgICAgIC8vIGhvd2V2ZXIsIHdpdGggc2VxdWVuY2VzIG9uIHRoaXMgaGVscHMgcHJvZHVjaW5nIHNsaWdodGx5IGJldHRlciBvdXRwdXQgZm9yXG4gICAgICAgICAgICAgICAgLy8gdGhlIGV4YW1wbGUgY29kZS5cbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHN0YXRlbWVudHNbcHJldl9pbmRleChpKV07XG4gICAgICAgICAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwic2VxdWVuY2VzXCIpICYmIGluX2xhbWJkYSAmJiAhc3RhdC5hbHRlcm5hdGl2ZVxuICAgICAgICAgICAgICAgICAgICAmJiBwcmV2IGluc3RhbmNlb2YgQVNUX0lmICYmIHByZXYuYm9keSBpbnN0YW5jZW9mIEFTVF9SZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgJiYgbmV4dF9pbmRleChqKSA9PSBzdGF0ZW1lbnRzLmxlbmd0aCAmJiBuZXh0IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBDSEFOR0VEID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdCA9IHN0YXQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdC5hbHRlcm5hdGl2ZSA9IG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIG5leHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2Vfbm9kZShBU1RfUmV0dXJuLCBuZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHNbaV0gPSBzdGF0LnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50cy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGhhc19tdWx0aXBsZV9pZl9yZXR1cm5zKHN0YXRlbWVudHMpIHtcbiAgICAgICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGF0ZW1lbnRzLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXQgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0lmICYmIHN0YXQuYm9keSBpbnN0YW5jZW9mIEFTVF9SZXR1cm4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCsrbiA+IDEpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGlzX3JldHVybl92b2lkKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gIXZhbHVlIHx8IHZhbHVlIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4ICYmIHZhbHVlLm9wZXJhdG9yID09IFwidm9pZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2FuX21lcmdlX2Zsb3coYWIpIHtcbiAgICAgICAgICAgIGlmICghYWIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMSwgbGVuID0gc3RhdGVtZW50cy5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ID0gc3RhdGVtZW50c1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Db25zdCB8fCBzdGF0IGluc3RhbmNlb2YgQVNUX0xldCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxjdCA9IGFiIGluc3RhbmNlb2YgQVNUX0xvb3BDb250cm9sID8gY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQoYWIpIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhYiBpbnN0YW5jZW9mIEFTVF9SZXR1cm4gJiYgaW5fbGFtYmRhICYmIGlzX3JldHVybl92b2lkKGFiLnZhbHVlKVxuICAgICAgICAgICAgICAgIHx8IGFiIGluc3RhbmNlb2YgQVNUX0NvbnRpbnVlICYmIHNlbGYgPT09IGxvb3BfYm9keShsY3QpXG4gICAgICAgICAgICAgICAgfHwgYWIgaW5zdGFuY2VvZiBBU1RfQnJlYWsgJiYgbGN0IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50ICYmIHNlbGYgPT09IGxjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4dHJhY3RfZnVuY3Rpb25zKCkge1xuICAgICAgICAgICAgdmFyIHRhaWwgPSBzdGF0ZW1lbnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHN0YXRlbWVudHMubGVuZ3RoID0gaSArIDE7XG4gICAgICAgICAgICByZXR1cm4gdGFpbC5maWx0ZXIoZnVuY3Rpb24oc3RhdCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0RlZnVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChzdGF0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXNfc3RhdGVtZW50X2FycmF5X3dpdGhfcmV0dXJuKG5vZGUsIGFiKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGFzX3N0YXRlbWVudF9hcnJheShub2RlKS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICBpZiAoYWIudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBib2R5LnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIGFiLnZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IGFiLnZhbHVlLmV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG5leHRfaW5kZXgoaSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxLCBsZW4gPSBzdGF0ZW1lbnRzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXQgPSBzdGF0ZW1lbnRzW2pdO1xuICAgICAgICAgICAgICAgIGlmICghKHN0YXQgaW5zdGFuY2VvZiBBU1RfVmFyICYmIGRlY2xhcmF0aW9uc19vbmx5KHN0YXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gajtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByZXZfaW5kZXgoaSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGk7IC0taiA+PSAwOykge1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ID0gc3RhdGVtZW50c1tqXTtcbiAgICAgICAgICAgICAgICBpZiAoIShzdGF0IGluc3RhbmNlb2YgQVNUX1ZhciAmJiBkZWNsYXJhdGlvbnNfb25seShzdGF0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGo7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbGltaW5hdGVfZGVhZF9jb2RlKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgdmFyIGhhc19xdWl0O1xuICAgICAgICB2YXIgc2VsZiA9IGNvbXByZXNzb3Iuc2VsZigpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IDAsIGxlbiA9IHN0YXRlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGF0ID0gc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0xvb3BDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxjdCA9IGNvbXByZXNzb3IubG9vcGNvbnRyb2xfdGFyZ2V0KHN0YXQpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0JyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAhKGxjdCBpbnN0YW5jZW9mIEFTVF9JdGVyYXRpb25TdGF0ZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBsb29wX2JvZHkobGN0KSA9PT0gc2VsZlxuICAgICAgICAgICAgICAgICAgICB8fCBzdGF0IGluc3RhbmNlb2YgQVNUX0NvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBsb29wX2JvZHkobGN0KSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdC5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHN0YXQubGFiZWwudGhlZGVmLnJlZmVyZW5jZXMsIHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1tuKytdID0gc3RhdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlbWVudHNbbisrXSA9IHN0YXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnRzKHN0YXQpKSB7XG4gICAgICAgICAgICAgICAgaGFzX3F1aXQgPSBzdGF0ZW1lbnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZW1lbnRzLmxlbmd0aCA9IG47XG4gICAgICAgIENIQU5HRUQgPSBuICE9IGxlbjtcbiAgICAgICAgaWYgKGhhc19xdWl0KSBoYXNfcXVpdC5mb3JFYWNoKGZ1bmN0aW9uKHN0YXQpIHtcbiAgICAgICAgICAgIHRyaW1fdW5yZWFjaGFibGVfY29kZShjb21wcmVzc29yLCBzdGF0LCBzdGF0ZW1lbnRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjbGFyYXRpb25zX29ubHkobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5kZWZpbml0aW9ucy5ldmVyeSgodmFyX2RlZikgPT5cbiAgICAgICAgICAgICF2YXJfZGVmLnZhbHVlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VxdWVuY2VzaXplKHN0YXRlbWVudHMsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgaWYgKHN0YXRlbWVudHMubGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgICAgICB2YXIgc2VxID0gW10sIG4gPSAwO1xuICAgICAgICBmdW5jdGlvbiBwdXNoX3NlcSgpIHtcbiAgICAgICAgICAgIGlmICghc2VxLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBtYWtlX3NlcXVlbmNlKHNlcVswXSwgc2VxKTtcbiAgICAgICAgICAgIHN0YXRlbWVudHNbbisrXSA9IG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBib2R5LCB7IGJvZHk6IGJvZHkgfSk7XG4gICAgICAgICAgICBzZXEgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RhdGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXQgPSBzdGF0ZW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcS5sZW5ndGggPj0gY29tcHJlc3Nvci5zZXF1ZW5jZXNfbGltaXQpIHB1c2hfc2VxKCk7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBzdGF0LmJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcS5sZW5ndGggPiAwKSBib2R5ID0gYm9keS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgaWYgKGJvZHkpIG1lcmdlX3NlcXVlbmNlKHNlcSwgYm9keSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMgJiYgZGVjbGFyYXRpb25zX29ubHkoc3RhdClcbiAgICAgICAgICAgICAgICB8fCBzdGF0IGluc3RhbmNlb2YgQVNUX0RlZnVuKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50c1tuKytdID0gc3RhdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHVzaF9zZXEoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzW24rK10gPSBzdGF0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1c2hfc2VxKCk7XG4gICAgICAgIHN0YXRlbWVudHMubGVuZ3RoID0gbjtcbiAgICAgICAgaWYgKG4gIT0gbGVuKSBDSEFOR0VEID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b19zaW1wbGVfc3RhdGVtZW50KGJsb2NrLCBkZWNscykge1xuICAgICAgICBpZiAoIShibG9jayBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkpIHJldHVybiBibG9jaztcbiAgICAgICAgdmFyIHN0YXQgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYmxvY2suYm9keS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBibG9jay5ib2R5W2ldO1xuICAgICAgICAgICAgaWYgKGxpbmUgaW5zdGFuY2VvZiBBU1RfVmFyICYmIGRlY2xhcmF0aW9uc19vbmx5KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgZGVjbHMucHVzaChsaW5lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdCA9IGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VxdWVuY2VzaXplXzIoc3RhdGVtZW50cywgY29tcHJlc3Nvcikge1xuICAgICAgICBmdW5jdGlvbiBjb25zX3NlcShyaWdodCkge1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHByZXYuYm9keTtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKGxlZnQsIFsgbGVmdCwgcmlnaHQgXSkudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gMCwgcHJldjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhdCA9IHN0YXRlbWVudHNbaV07XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0V4aXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdC52YWx1ZSA9IGNvbnNfc2VxKHN0YXQudmFsdWUgfHwgbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHN0YXQpLnRyYW5zZm9ybShjb21wcmVzc29yKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0Zvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShzdGF0LmluaXQgaW5zdGFuY2VvZiBBU1RfRGVmaW5pdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhYm9ydCA9IHdhbGsocHJldi5ib2R5LCBub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBub2RlLm9wZXJhdG9yID09PSBcImluXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGtfYWJvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFib3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXQuaW5pdCkgc3RhdC5pbml0ID0gY29uc19zZXEoc3RhdC5pbml0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdC5pbml0ID0gcHJldi5ib2R5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Gb3JJbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShzdGF0LmluaXQgaW5zdGFuY2VvZiBBU1RfQ29uc3QpICYmICEoc3RhdC5pbml0IGluc3RhbmNlb2YgQVNUX0xldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXQub2JqZWN0ID0gY29uc19zZXEoc3RhdC5vYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0lmKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQuY29uZGl0aW9uID0gY29uc19zZXEoc3RhdC5jb25kaXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9Td2l0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdC5leHByZXNzaW9uID0gY29uc19zZXEoc3RhdC5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfV2l0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0LmV4cHJlc3Npb24gPSBjb25zX3NlcShzdGF0LmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImNvbmRpdGlvbmFsc1wiKSAmJiBzdGF0IGluc3RhbmNlb2YgQVNUX0lmKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlY2xzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB0b19zaW1wbGVfc3RhdGVtZW50KHN0YXQuYm9keSwgZGVjbHMpO1xuICAgICAgICAgICAgICAgIHZhciBhbHQgPSB0b19zaW1wbGVfc3RhdGVtZW50KHN0YXQuYWx0ZXJuYXRpdmUsIGRlY2xzKTtcbiAgICAgICAgICAgICAgICBpZiAoYm9keSAhPT0gZmFsc2UgJiYgYWx0ICE9PSBmYWxzZSAmJiBkZWNscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBkZWNscy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xzLnB1c2gobWFrZV9ub2RlKEFTVF9JZiwgc3RhdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uOiBzdGF0LmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHkgfHwgbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgc3RhdC5ib2R5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlOiBhbHRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBkZWNscy51bnNoaWZ0KG4sIDEpO1xuICAgICAgICAgICAgICAgICAgICBbXS5zcGxpY2UuYXBwbHkoc3RhdGVtZW50cywgZGVjbHMpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IGxlbjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBsZW4gKyAxO1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlbWVudHNbbisrXSA9IHN0YXQ7XG4gICAgICAgICAgICBwcmV2ID0gc3RhdCBpbnN0YW5jZW9mIEFTVF9TaW1wbGVTdGF0ZW1lbnQgPyBzdGF0IDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZW1lbnRzLmxlbmd0aCA9IG47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gam9pbl9vYmplY3RfYXNzaWdubWVudHMoZGVmbiwgYm9keSkge1xuICAgICAgICBpZiAoIShkZWZuIGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zKSkgcmV0dXJuO1xuICAgICAgICB2YXIgZGVmID0gZGVmbi5kZWZpbml0aW9uc1tkZWZuLmRlZmluaXRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIShkZWYudmFsdWUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0KSkgcmV0dXJuO1xuICAgICAgICB2YXIgZXhwcnM7XG4gICAgICAgIGlmIChib2R5IGluc3RhbmNlb2YgQVNUX0Fzc2lnbiAmJiAhYm9keS5sb2dpY2FsKSB7XG4gICAgICAgICAgICBleHBycyA9IFsgYm9keSBdO1xuICAgICAgICB9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2UpIHtcbiAgICAgICAgICAgIGV4cHJzID0gYm9keS5leHByZXNzaW9ucy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhwcnMpIHJldHVybjtcbiAgICAgICAgdmFyIHRyaW1tZWQgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBleHByc1swXTtcbiAgICAgICAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBBU1RfQXNzaWduKSkgYnJlYWs7XG4gICAgICAgICAgICBpZiAobm9kZS5vcGVyYXRvciAhPSBcIj1cIikgYnJlYWs7XG4gICAgICAgICAgICBpZiAoIShub2RlLmxlZnQgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcykpIGJyZWFrO1xuICAgICAgICAgICAgdmFyIHN5bSA9IG5vZGUubGVmdC5leHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKCEoc3ltIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZikpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKGRlZi5uYW1lLm5hbWUgIT0gc3ltLm5hbWUpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKCFub2RlLnJpZ2h0LmlzX2NvbnN0YW50X2V4cHJlc3Npb24oc2NvcGUpKSBicmVhaztcbiAgICAgICAgICAgIHZhciBwcm9wID0gbm9kZS5sZWZ0LnByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBBU1RfTm9kZSkge1xuICAgICAgICAgICAgICAgIHByb3AgPSBwcm9wLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBBU1RfTm9kZSkgYnJlYWs7XG4gICAgICAgICAgICBwcm9wID0gXCJcIiArIHByb3A7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGNvbXByZXNzb3Iub3B0aW9uKFwiZWNtYVwiKSA8IDIwMTVcbiAgICAgICAgICAgICAgICAmJiBjb21wcmVzc29yLmhhc19kaXJlY3RpdmUoXCJ1c2Ugc3RyaWN0XCIpID8gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmtleSAhPSBwcm9wICYmIChub2RlLmtleSAmJiBub2RlLmtleS5uYW1lICE9IHByb3ApO1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5rZXkgJiYgbm9kZS5rZXkubmFtZSAhPSBwcm9wO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghZGVmLnZhbHVlLnByb3BlcnRpZXMuZXZlcnkoZGlmZikpIGJyZWFrO1xuICAgICAgICAgICAgdmFyIHAgPSBkZWYudmFsdWUucHJvcGVydGllcy5maWx0ZXIoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAua2V5ID09PSBwcm9wOyB9KVswXTtcbiAgICAgICAgICAgIGlmICghcCkge1xuICAgICAgICAgICAgICAgIGRlZi52YWx1ZS5wcm9wZXJ0aWVzLnB1c2gobWFrZV9ub2RlKEFTVF9PYmplY3RLZXlWYWwsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBwcm9wLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbm9kZS5yaWdodFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcC52YWx1ZSA9IG5ldyBBU1RfU2VxdWVuY2Uoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogcC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IFtwLnZhbHVlLmNsb25lKCksIG5vZGUucmlnaHQuY2xvbmUoKV0sXG4gICAgICAgICAgICAgICAgICAgIGVuZDogcC5lbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cHJzLnNoaWZ0KCk7XG4gICAgICAgICAgICB0cmltbWVkID0gdHJ1ZTtcbiAgICAgICAgfSB3aGlsZSAoZXhwcnMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRyaW1tZWQgJiYgZXhwcnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gam9pbl9jb25zZWN1dGl2ZV92YXJzKHN0YXRlbWVudHMpIHtcbiAgICAgICAgdmFyIGRlZnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gLTEsIGxlbiA9IHN0YXRlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGF0ID0gc3RhdGVtZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gc3RhdGVtZW50c1tqXTtcbiAgICAgICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5UWVBFID09IHN0YXQuVFlQRSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2LmRlZmluaXRpb25zID0gcHJldi5kZWZpbml0aW9ucy5jb25jYXQoc3RhdC5kZWZpbml0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmcyAmJiBkZWZzLlRZUEUgPT0gc3RhdC5UWVBFICYmIGRlY2xhcmF0aW9uc19vbmx5KHN0YXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZnMuZGVmaW5pdGlvbnMgPSBkZWZzLmRlZmluaXRpb25zLmNvbmNhdChzdGF0LmRlZmluaXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1srK2pdID0gc3RhdDtcbiAgICAgICAgICAgICAgICAgICAgZGVmcyA9IHN0YXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX0V4aXQpIHtcbiAgICAgICAgICAgICAgICBzdGF0LnZhbHVlID0gZXh0cmFjdF9vYmplY3RfYXNzaWdubWVudHMoc3RhdC52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4cHJzID0gam9pbl9vYmplY3RfYXNzaWdubWVudHMocHJldiwgc3RhdC5pbml0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhwcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQuaW5pdCA9IGV4cHJzLmxlbmd0aCA/IG1ha2Vfc2VxdWVuY2Uoc3RhdC5pbml0LCBleHBycykgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzWysral0gPSBzdGF0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldiBpbnN0YW5jZW9mIEFTVF9WYXIgJiYgKCFzdGF0LmluaXQgfHwgc3RhdC5pbml0LlRZUEUgPT0gcHJldi5UWVBFKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdC5pbml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmRlZmluaXRpb25zID0gcHJldi5kZWZpbml0aW9ucy5jb25jYXQoc3RhdC5pbml0LmRlZmluaXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0LmluaXQgPSBwcmV2O1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzW2pdID0gc3RhdDtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZWZzICYmIHN0YXQuaW5pdCAmJiBkZWZzLlRZUEUgPT0gc3RhdC5pbml0LlRZUEUgJiYgZGVjbGFyYXRpb25zX29ubHkoc3RhdC5pbml0KSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZzLmRlZmluaXRpb25zID0gZGVmcy5kZWZpbml0aW9ucy5jb25jYXQoc3RhdC5pbml0LmRlZmluaXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdC5pbml0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1srK2pdID0gc3RhdDtcbiAgICAgICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50c1srK2pdID0gc3RhdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfRm9ySW4pIHtcbiAgICAgICAgICAgICAgICBzdGF0Lm9iamVjdCA9IGV4dHJhY3Rfb2JqZWN0X2Fzc2lnbm1lbnRzKHN0YXQub2JqZWN0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9JZikge1xuICAgICAgICAgICAgICAgIHN0YXQuY29uZGl0aW9uID0gZXh0cmFjdF9vYmplY3RfYXNzaWdubWVudHMoc3RhdC5jb25kaXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBleHBycyA9IGpvaW5fb2JqZWN0X2Fzc2lnbm1lbnRzKHByZXYsIHN0YXQuYm9keSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIENIQU5HRUQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4cHJzLmxlbmd0aCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YXQuYm9keSA9IG1ha2Vfc2VxdWVuY2Uoc3RhdC5ib2R5LCBleHBycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlbWVudHNbKytqXSA9IHN0YXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfU3dpdGNoKSB7XG4gICAgICAgICAgICAgICAgc3RhdC5leHByZXNzaW9uID0gZXh0cmFjdF9vYmplY3RfYXNzaWdubWVudHMoc3RhdC5leHByZXNzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdCBpbnN0YW5jZW9mIEFTVF9XaXRoKSB7XG4gICAgICAgICAgICAgICAgc3RhdC5leHByZXNzaW9uID0gZXh0cmFjdF9vYmplY3RfYXNzaWdubWVudHMoc3RhdC5leHByZXNzaW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGVtZW50c1srK2pdID0gc3RhdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZW1lbnRzLmxlbmd0aCA9IGogKyAxO1xuXG4gICAgICAgIGZ1bmN0aW9uIGV4dHJhY3Rfb2JqZWN0X2Fzc2lnbm1lbnRzKHZhbHVlKSB7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzWysral0gPSBzdGF0O1xuICAgICAgICAgICAgdmFyIGV4cHJzID0gam9pbl9vYmplY3RfYXNzaWdubWVudHMocHJldiwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGV4cHJzKSB7XG4gICAgICAgICAgICAgICAgQ0hBTkdFRCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGV4cHJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZSh2YWx1ZSwgZXhwcnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRhaWxfbm9kZSgpLmxlZnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0cmltX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc3RhdCwgdGFyZ2V0KSB7XG4gICAgd2FsayhzdGF0LCBub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZV9pbml0aWFsaXplcnMoKTtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1blxuICAgICAgICAgICAgJiYgKG5vZGUgPT09IHN0YXQgfHwgIWNvbXByZXNzb3IuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIikpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2gobm9kZSA9PT0gc3RhdCA/IG5vZGUgOiBtYWtlX25vZGUoQVNUX1Zhciwgbm9kZSwge1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIG1ha2Vfbm9kZShBU1RfVmFyRGVmLCBub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBtYWtlX25vZGUoQVNUX1N5bWJvbFZhciwgbm9kZS5uYW1lLCBub2RlLm5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9FeHBvcnQgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9JbXBvcnQpIHtcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldF92YWx1ZShrZXkpIHtcbiAgICBpZiAoa2V5IGluc3RhbmNlb2YgQVNUX0NvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiBrZXkuZ2V0VmFsdWUoKTtcbiAgICB9XG4gICAgaWYgKGtleSBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeFxuICAgICAgICAmJiBrZXkub3BlcmF0b3IgPT0gXCJ2b2lkXCJcbiAgICAgICAgJiYga2V5LmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiBpc191bmRlZmluZWQobm9kZSwgY29tcHJlc3Nvcikge1xuICAgIHJldHVybiAoXG4gICAgICAgIGhhc19mbGFnKG5vZGUsIFVOREVGSU5FRClcbiAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9VbmRlZmluZWRcbiAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeFxuICAgICAgICAgICAgJiYgbm9kZS5vcGVyYXRvciA9PSBcInZvaWRcIlxuICAgICAgICAgICAgJiYgIW5vZGUuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgKTtcbn1cblxuLy8gbWF5X3Rocm93X29uX2FjY2VzcygpXG4vLyByZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIG1heSBiZSBudWxsLCB1bmRlZmluZWQgb3IgY29udGFpbiBgQVNUX0FjY2Vzc29yYFxuKGZ1bmN0aW9uKGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKSB7XG4gICAgQVNUX05vZGUuREVGTUVUSE9EKFwibWF5X3Rocm93X29uX2FjY2Vzc1wiLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiAhY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX2dldHRlcnNcIilcbiAgICAgICAgICAgIHx8IHRoaXMuX2RvdF90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGlzX3N0cmljdChjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiAvc3RyaWN0Ly50ZXN0KGNvbXByZXNzb3Iub3B0aW9uKFwicHVyZV9nZXR0ZXJzXCIpKTtcbiAgICB9XG5cbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfTm9kZSwgaXNfc3RyaWN0KTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfTnVsbCwgcmV0dXJuX3RydWUpO1xuICAgIGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKEFTVF9VbmRlZmluZWQsIHJldHVybl90cnVlKTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfQ29uc3RhbnQsIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX21heV90aHJvd19vbl9hY2Nlc3MoQVNUX0FycmF5LCByZXR1cm5fZmFsc2UpO1xuICAgIGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKEFTVF9PYmplY3QsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgaWYgKCFpc19zdHJpY3QoY29tcHJlc3NvcikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucHJvcGVydGllcy5sZW5ndGg7IC0taSA+PTA7KVxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcGVydGllc1tpXS5fZG90X3Rocm93KGNvbXByZXNzb3IpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIC8vIERvIG5vdCBiZSBhcyBzdHJpY3Qgd2l0aCBjbGFzc2VzIGFzIHdlIGFyZSB3aXRoIG9iamVjdHMuXG4gICAgLy8gSG9wZWZ1bGx5IHRoZSBjb21tdW5pdHkgaXMgbm90IGdvaW5nIHRvIGFidXNlIHN0YXRpYyBnZXR0ZXJzIGFuZCBzZXR0ZXJzLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZXJzZXIvdGVyc2VyL2lzc3Vlcy83MjQjaXNzdWVjb21tZW50LTY0MzY1NTY1NlxuICAgIGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKEFTVF9DbGFzcywgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfT2JqZWN0UHJvcGVydHksIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX21heV90aHJvd19vbl9hY2Nlc3MoQVNUX09iamVjdEdldHRlciwgcmV0dXJuX3RydWUpO1xuICAgIGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKEFTVF9FeHBhbnNpb24sIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5fZG90X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKEFTVF9GdW5jdGlvbiwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfQXJyb3csIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX21heV90aHJvd19vbl9hY2Nlc3MoQVNUX1VuYXJ5UG9zdGZpeCwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvciA9PSBcInZvaWRcIjtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfQmluYXJ5LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5vcGVyYXRvciA9PSBcIiYmXCIgfHwgdGhpcy5vcGVyYXRvciA9PSBcInx8XCIgfHwgdGhpcy5vcGVyYXRvciA9PSBcIj8/XCIpXG4gICAgICAgICAgICAmJiAodGhpcy5sZWZ0Ll9kb3RfdGhyb3coY29tcHJlc3NvcikgfHwgdGhpcy5yaWdodC5fZG90X3Rocm93KGNvbXByZXNzb3IpKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfQXNzaWduLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLmxvZ2ljYWwpIHJldHVybiB0cnVlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yID09IFwiPVwiXG4gICAgICAgICAgICAmJiB0aGlzLnJpZ2h0Ll9kb3RfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvd19vbl9hY2Nlc3MoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnNlcXVlbnQuX2RvdF90aHJvdyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgdGhpcy5hbHRlcm5hdGl2ZS5fZG90X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3dfb25fYWNjZXNzKEFTVF9Eb3QsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgaWYgKCFpc19zdHJpY3QoY29tcHJlc3NvcikpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5wcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gIShcbiAgICAgICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb25cbiAgICAgICAgICAgICAgICB8fCB0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfQ2xhc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvd19vbl9hY2Nlc3MoQVNUX0NoYWluLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uX2RvdF90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfU2VxdWVuY2UsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFpbF9ub2RlKCkuX2RvdF90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93X29uX2FjY2VzcyhBU1RfU3ltYm9sUmVmLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgPT09IFwiYXJndW1lbnRzXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGhhc19mbGFnKHRoaXMsIFVOREVGSU5FRCkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIWlzX3N0cmljdChjb21wcmVzc29yKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoaXNfdW5kZWNsYXJlZF9yZWYodGhpcykgJiYgdGhpcy5pc19kZWNsYXJlZChjb21wcmVzc29yKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc19pbW11dGFibGUoKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZml4ZWQgPSB0aGlzLmZpeGVkX3ZhbHVlKCk7XG4gICAgICAgIHJldHVybiAhZml4ZWQgfHwgZml4ZWQuX2RvdF90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbn0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpIHtcbiAgICBub2RlLkRFRk1FVEhPRChcIl9kb3RfdGhyb3dcIiwgZnVuYyk7XG59KTtcblxuLyogLS0tLS1bIGJvb2xlYW4vbmVnYXRpb24gaGVscGVycyBdLS0tLS0gKi9cblxuLy8gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhbiBleHByZXNzaW9uIGhhcyBhIGJvb2xlYW4gcmVzdWx0IHR5cGVcbihmdW5jdGlvbihkZWZfaXNfYm9vbGVhbikge1xuICAgIGNvbnN0IHVuYXJ5X2Jvb2wgPSBtYWtlUHJlZGljYXRlKFwiISBkZWxldGVcIik7XG4gICAgY29uc3QgYmluYXJ5X2Jvb2wgPSBtYWtlUHJlZGljYXRlKFwiaW4gaW5zdGFuY2VvZiA9PSAhPSA9PT0gIT09IDwgPD0gPj0gPlwiKTtcbiAgICBkZWZfaXNfYm9vbGVhbihBU1RfTm9kZSwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfaXNfYm9vbGVhbihBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdW5hcnlfYm9vbC5oYXModGhpcy5vcGVyYXRvcik7XG4gICAgfSk7XG4gICAgZGVmX2lzX2Jvb2xlYW4oQVNUX0JpbmFyeSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBiaW5hcnlfYm9vbC5oYXModGhpcy5vcGVyYXRvcilcbiAgICAgICAgICAgIHx8IGxhenlfb3AuaGFzKHRoaXMub3BlcmF0b3IpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5sZWZ0LmlzX2Jvb2xlYW4oKVxuICAgICAgICAgICAgICAgICYmIHRoaXMucmlnaHQuaXNfYm9vbGVhbigpO1xuICAgIH0pO1xuICAgIGRlZl9pc19ib29sZWFuKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnNlcXVlbnQuaXNfYm9vbGVhbigpICYmIHRoaXMuYWx0ZXJuYXRpdmUuaXNfYm9vbGVhbigpO1xuICAgIH0pO1xuICAgIGRlZl9pc19ib29sZWFuKEFTVF9Bc3NpZ24sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvciA9PSBcIj1cIiAmJiB0aGlzLnJpZ2h0LmlzX2Jvb2xlYW4oKTtcbiAgICB9KTtcbiAgICBkZWZfaXNfYm9vbGVhbihBU1RfU2VxdWVuY2UsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWlsX25vZGUoKS5pc19ib29sZWFuKCk7XG4gICAgfSk7XG4gICAgZGVmX2lzX2Jvb2xlYW4oQVNUX1RydWUsIHJldHVybl90cnVlKTtcbiAgICBkZWZfaXNfYm9vbGVhbihBU1RfRmFsc2UsIHJldHVybl90cnVlKTtcbn0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpIHtcbiAgICBub2RlLkRFRk1FVEhPRChcImlzX2Jvb2xlYW5cIiwgZnVuYyk7XG59KTtcblxuLy8gbWV0aG9kcyB0byBkZXRlcm1pbmUgaWYgYW4gZXhwcmVzc2lvbiBoYXMgYSBudW1lcmljIHJlc3VsdCB0eXBlXG4oZnVuY3Rpb24oZGVmX2lzX251bWJlcikge1xuICAgIGRlZl9pc19udW1iZXIoQVNUX05vZGUsIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX2lzX251bWJlcihBU1RfTnVtYmVyLCByZXR1cm5fdHJ1ZSk7XG4gICAgdmFyIHVuYXJ5ID0gbWFrZVByZWRpY2F0ZShcIisgLSB+ICsrIC0tXCIpO1xuICAgIGRlZl9pc19udW1iZXIoQVNUX1VuYXJ5LCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVuYXJ5Lmhhcyh0aGlzLm9wZXJhdG9yKTtcbiAgICB9KTtcbiAgICB2YXIgYmluYXJ5ID0gbWFrZVByZWRpY2F0ZShcIi0gKiAvICUgJiB8IF4gPDwgPj4gPj4+XCIpO1xuICAgIGRlZl9pc19udW1iZXIoQVNUX0JpbmFyeSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gYmluYXJ5Lmhhcyh0aGlzLm9wZXJhdG9yKSB8fCB0aGlzLm9wZXJhdG9yID09IFwiK1wiXG4gICAgICAgICAgICAmJiB0aGlzLmxlZnQuaXNfbnVtYmVyKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAmJiB0aGlzLnJpZ2h0LmlzX251bWJlcihjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaXNfbnVtYmVyKEFTVF9Bc3NpZ24sIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGJpbmFyeS5oYXModGhpcy5vcGVyYXRvci5zbGljZSgwLCAtMSkpXG4gICAgICAgICAgICB8fCB0aGlzLm9wZXJhdG9yID09IFwiPVwiICYmIHRoaXMucmlnaHQuaXNfbnVtYmVyKGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9pc19udW1iZXIoQVNUX1NlcXVlbmNlLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhaWxfbm9kZSgpLmlzX251bWJlcihjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaXNfbnVtYmVyKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zZXF1ZW50LmlzX251bWJlcihjb21wcmVzc29yKSAmJiB0aGlzLmFsdGVybmF0aXZlLmlzX251bWJlcihjb21wcmVzc29yKTtcbiAgICB9KTtcbn0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpIHtcbiAgICBub2RlLkRFRk1FVEhPRChcImlzX251bWJlclwiLCBmdW5jKTtcbn0pO1xuXG4vLyBtZXRob2RzIHRvIGRldGVybWluZSBpZiBhbiBleHByZXNzaW9uIGhhcyBhIHN0cmluZyByZXN1bHQgdHlwZVxuKGZ1bmN0aW9uKGRlZl9pc19zdHJpbmcpIHtcbiAgICBkZWZfaXNfc3RyaW5nKEFTVF9Ob2RlLCByZXR1cm5fZmFsc2UpO1xuICAgIGRlZl9pc19zdHJpbmcoQVNUX1N0cmluZywgcmV0dXJuX3RydWUpO1xuICAgIGRlZl9pc19zdHJpbmcoQVNUX1RlbXBsYXRlU3RyaW5nLCByZXR1cm5fdHJ1ZSk7XG4gICAgZGVmX2lzX3N0cmluZyhBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvciA9PSBcInR5cGVvZlwiO1xuICAgIH0pO1xuICAgIGRlZl9pc19zdHJpbmcoQVNUX0JpbmFyeSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvciA9PSBcIitcIiAmJlxuICAgICAgICAgICAgKHRoaXMubGVmdC5pc19zdHJpbmcoY29tcHJlc3NvcikgfHwgdGhpcy5yaWdodC5pc19zdHJpbmcoY29tcHJlc3NvcikpO1xuICAgIH0pO1xuICAgIGRlZl9pc19zdHJpbmcoQVNUX0Fzc2lnbiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gKHRoaXMub3BlcmF0b3IgPT0gXCI9XCIgfHwgdGhpcy5vcGVyYXRvciA9PSBcIis9XCIpICYmIHRoaXMucmlnaHQuaXNfc3RyaW5nKGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9pc19zdHJpbmcoQVNUX1NlcXVlbmNlLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhaWxfbm9kZSgpLmlzX3N0cmluZyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaXNfc3RyaW5nKEFTVF9Db25kaXRpb25hbCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zZXF1ZW50LmlzX3N0cmluZyhjb21wcmVzc29yKSAmJiB0aGlzLmFsdGVybmF0aXZlLmlzX3N0cmluZyhjb21wcmVzc29yKTtcbiAgICB9KTtcbn0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpIHtcbiAgICBub2RlLkRFRk1FVEhPRChcImlzX3N0cmluZ1wiLCBmdW5jKTtcbn0pO1xuXG52YXIgbGF6eV9vcCA9IG1ha2VQcmVkaWNhdGUoXCImJiB8fCA/P1wiKTtcbnZhciB1bmFyeV9zaWRlX2VmZmVjdHMgPSBtYWtlUHJlZGljYXRlKFwiZGVsZXRlICsrIC0tXCIpO1xuXG5mdW5jdGlvbiBpc19saHMobm9kZSwgcGFyZW50KSB7XG4gICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9VbmFyeSAmJiB1bmFyeV9zaWRlX2VmZmVjdHMuaGFzKHBhcmVudC5vcGVyYXRvcikpIHJldHVybiBwYXJlbnQuZXhwcmVzc2lvbjtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX0Fzc2lnbiAmJiBwYXJlbnQubGVmdCA9PT0gbm9kZSkgcmV0dXJuIG5vZGU7XG59XG5cbihmdW5jdGlvbihkZWZfZmluZF9kZWZzKSB7XG4gICAgZnVuY3Rpb24gdG9fbm9kZSh2YWx1ZSwgb3JpZykge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBU1RfTm9kZSkgcmV0dXJuIG1ha2Vfbm9kZSh2YWx1ZS5DVE9SLCBvcmlnLCB2YWx1ZSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQXJyYXksIG9yaWcsIHtcbiAgICAgICAgICAgIGVsZW1lbnRzOiB2YWx1ZS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9fbm9kZSh2YWx1ZSwgb3JpZyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgaWYgKEhPUCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHByb3BzLnB1c2gobWFrZV9ub2RlKEFTVF9PYmplY3RLZXlWYWwsIG9yaWcsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0b19ub2RlKHZhbHVlW2tleV0sIG9yaWcpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfT2JqZWN0LCBvcmlnLCB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogcHJvcHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlX25vZGVfZnJvbV9jb25zdGFudCh2YWx1ZSwgb3JpZyk7XG4gICAgfVxuXG4gICAgQVNUX1RvcGxldmVsLkRFRk1FVEhPRChcInJlc29sdmVfZGVmaW5lc1wiLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJnbG9iYWxfZGVmc1wiKSkgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMuZmlndXJlX291dF9zY29wZSh7IGllODogY29tcHJlc3Nvci5vcHRpb24oXCJpZThcIikgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShuZXcgVHJlZVRyYW5zZm9ybWVyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBub2RlLl9maW5kX2RlZnMoY29tcHJlc3NvciwgXCJcIik7XG4gICAgICAgICAgICBpZiAoIWRlZikgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGxldmVsID0gMCwgY2hpbGQgPSBub2RlLCBwYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50ID0gdGhpcy5wYXJlbnQobGV2ZWwrKykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcykpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuZXhwcmVzc2lvbiAhPT0gY2hpbGQpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNoaWxkID0gcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzX2xocyhjaGlsZCwgcGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWY7XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbiAgICBkZWZfZmluZF9kZWZzKEFTVF9Ob2RlLCBub29wKTtcbiAgICBkZWZfZmluZF9kZWZzKEFTVF9DaGFpbiwgZnVuY3Rpb24oY29tcHJlc3Nvciwgc3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uX2ZpbmRfZGVmcyhjb21wcmVzc29yLCBzdWZmaXgpO1xuICAgIH0pO1xuICAgIGRlZl9maW5kX2RlZnMoQVNUX0RvdCwgZnVuY3Rpb24oY29tcHJlc3Nvciwgc3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uX2ZpbmRfZGVmcyhjb21wcmVzc29yLCBcIi5cIiArIHRoaXMucHJvcGVydHkgKyBzdWZmaXgpO1xuICAgIH0pO1xuICAgIGRlZl9maW5kX2RlZnMoQVNUX1N5bWJvbERlY2xhcmF0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdsb2JhbCgpKSByZXR1cm47XG4gICAgfSk7XG4gICAgZGVmX2ZpbmRfZGVmcyhBU1RfU3ltYm9sUmVmLCBmdW5jdGlvbihjb21wcmVzc29yLCBzdWZmaXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdsb2JhbCgpKSByZXR1cm47XG4gICAgICAgIHZhciBkZWZpbmVzID0gY29tcHJlc3Nvci5vcHRpb24oXCJnbG9iYWxfZGVmc1wiKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUgKyBzdWZmaXg7XG4gICAgICAgIGlmIChIT1AoZGVmaW5lcywgbmFtZSkpIHJldHVybiB0b19ub2RlKGRlZmluZXNbbmFtZV0sIHRoaXMpO1xuICAgIH0pO1xufSkoZnVuY3Rpb24obm9kZSwgZnVuYykge1xuICAgIG5vZGUuREVGTUVUSE9EKFwiX2ZpbmRfZGVmc1wiLCBmdW5jKTtcbn0pO1xuXG5mdW5jdGlvbiBiZXN0X29mX2V4cHJlc3Npb24oYXN0MSwgYXN0Mikge1xuICAgIHJldHVybiBhc3QxLnNpemUoKSA+IGFzdDIuc2l6ZSgpID8gYXN0MiA6IGFzdDE7XG59XG5cbmZ1bmN0aW9uIGJlc3Rfb2Zfc3RhdGVtZW50KGFzdDEsIGFzdDIpIHtcbiAgICByZXR1cm4gYmVzdF9vZl9leHByZXNzaW9uKFxuICAgICAgICBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgYXN0MSwge1xuICAgICAgICAgICAgYm9keTogYXN0MVxuICAgICAgICB9KSxcbiAgICAgICAgbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIGFzdDIsIHtcbiAgICAgICAgICAgIGJvZHk6IGFzdDJcbiAgICAgICAgfSlcbiAgICApLmJvZHk7XG59XG5cbmZ1bmN0aW9uIGJlc3Rfb2YoY29tcHJlc3NvciwgYXN0MSwgYXN0Mikge1xuICAgIHJldHVybiAoZmlyc3RfaW5fc3RhdGVtZW50KGNvbXByZXNzb3IpID8gYmVzdF9vZl9zdGF0ZW1lbnQgOiBiZXN0X29mX2V4cHJlc3Npb24pKGFzdDEsIGFzdDIpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0X3RvX3ByZWRpY2F0ZShvYmopIHtcbiAgICBjb25zdCBvdXQgPSBuZXcgTWFwKCk7XG4gICAgZm9yICh2YXIga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgb3V0LnNldChrZXksIG1ha2VQcmVkaWNhdGUob2JqW2tleV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxudmFyIG9iamVjdF9mbnMgPSBbXG4gICAgXCJjb25zdHJ1Y3RvclwiLFxuICAgIFwidG9TdHJpbmdcIixcbiAgICBcInZhbHVlT2ZcIixcbl07XG52YXIgbmF0aXZlX2ZucyA9IGNvbnZlcnRfdG9fcHJlZGljYXRlKHtcbiAgICBBcnJheTogW1xuICAgICAgICBcImluZGV4T2ZcIixcbiAgICAgICAgXCJqb2luXCIsXG4gICAgICAgIFwibGFzdEluZGV4T2ZcIixcbiAgICAgICAgXCJzbGljZVwiLFxuICAgIF0uY29uY2F0KG9iamVjdF9mbnMpLFxuICAgIEJvb2xlYW46IG9iamVjdF9mbnMsXG4gICAgRnVuY3Rpb246IG9iamVjdF9mbnMsXG4gICAgTnVtYmVyOiBbXG4gICAgICAgIFwidG9FeHBvbmVudGlhbFwiLFxuICAgICAgICBcInRvRml4ZWRcIixcbiAgICAgICAgXCJ0b1ByZWNpc2lvblwiLFxuICAgIF0uY29uY2F0KG9iamVjdF9mbnMpLFxuICAgIE9iamVjdDogb2JqZWN0X2ZucyxcbiAgICBSZWdFeHA6IFtcbiAgICAgICAgXCJ0ZXN0XCIsXG4gICAgXS5jb25jYXQob2JqZWN0X2ZucyksXG4gICAgU3RyaW5nOiBbXG4gICAgICAgIFwiY2hhckF0XCIsXG4gICAgICAgIFwiY2hhckNvZGVBdFwiLFxuICAgICAgICBcImNvbmNhdFwiLFxuICAgICAgICBcImluZGV4T2ZcIixcbiAgICAgICAgXCJpdGFsaWNzXCIsXG4gICAgICAgIFwibGFzdEluZGV4T2ZcIixcbiAgICAgICAgXCJtYXRjaFwiLFxuICAgICAgICBcInJlcGxhY2VcIixcbiAgICAgICAgXCJzZWFyY2hcIixcbiAgICAgICAgXCJzbGljZVwiLFxuICAgICAgICBcInNwbGl0XCIsXG4gICAgICAgIFwic3Vic3RyXCIsXG4gICAgICAgIFwic3Vic3RyaW5nXCIsXG4gICAgICAgIFwidG9Mb3dlckNhc2VcIixcbiAgICAgICAgXCJ0b1VwcGVyQ2FzZVwiLFxuICAgICAgICBcInRyaW1cIixcbiAgICBdLmNvbmNhdChvYmplY3RfZm5zKSxcbn0pO1xudmFyIHN0YXRpY19mbnMgPSBjb252ZXJ0X3RvX3ByZWRpY2F0ZSh7XG4gICAgQXJyYXk6IFtcbiAgICAgICAgXCJpc0FycmF5XCIsXG4gICAgXSxcbiAgICBNYXRoOiBbXG4gICAgICAgIFwiYWJzXCIsXG4gICAgICAgIFwiYWNvc1wiLFxuICAgICAgICBcImFzaW5cIixcbiAgICAgICAgXCJhdGFuXCIsXG4gICAgICAgIFwiY2VpbFwiLFxuICAgICAgICBcImNvc1wiLFxuICAgICAgICBcImV4cFwiLFxuICAgICAgICBcImZsb29yXCIsXG4gICAgICAgIFwibG9nXCIsXG4gICAgICAgIFwicm91bmRcIixcbiAgICAgICAgXCJzaW5cIixcbiAgICAgICAgXCJzcXJ0XCIsXG4gICAgICAgIFwidGFuXCIsXG4gICAgICAgIFwiYXRhbjJcIixcbiAgICAgICAgXCJwb3dcIixcbiAgICAgICAgXCJtYXhcIixcbiAgICAgICAgXCJtaW5cIixcbiAgICBdLFxuICAgIE51bWJlcjogW1xuICAgICAgICBcImlzRmluaXRlXCIsXG4gICAgICAgIFwiaXNOYU5cIixcbiAgICBdLFxuICAgIE9iamVjdDogW1xuICAgICAgICBcImNyZWF0ZVwiLFxuICAgICAgICBcImdldE93blByb3BlcnR5RGVzY3JpcHRvclwiLFxuICAgICAgICBcImdldE93blByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgXCJnZXRQcm90b3R5cGVPZlwiLFxuICAgICAgICBcImlzRXh0ZW5zaWJsZVwiLFxuICAgICAgICBcImlzRnJvemVuXCIsXG4gICAgICAgIFwiaXNTZWFsZWRcIixcbiAgICAgICAgXCJrZXlzXCIsXG4gICAgXSxcbiAgICBTdHJpbmc6IFtcbiAgICAgICAgXCJmcm9tQ2hhckNvZGVcIixcbiAgICBdLFxufSk7XG5cbi8vIG1ldGhvZHMgdG8gZXZhbHVhdGUgYSBjb25zdGFudCBleHByZXNzaW9uXG4oZnVuY3Rpb24oZGVmX2V2YWwpIHtcbiAgICAvLyBJZiB0aGUgbm9kZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgcmVkdWNlZCB0byBhIGNvbnN0YW50LFxuICAgIC8vIHRoZW4gaXRzIHZhbHVlIGlzIHJldHVybmVkOyBvdGhlcndpc2UgdGhlIGVsZW1lbnQgaXRzZWxmXG4gICAgLy8gaXMgcmV0dXJuZWQuXG4gICAgLy8gVGhleSBjYW4gYmUgZGlzdGluZ3Vpc2hlZCBhcyBjb25zdGFudCB2YWx1ZSBpcyBuZXZlciBhXG4gICAgLy8gZGVzY2VuZGFudCBvZiBBU1RfTm9kZS5cbiAgICBBU1RfTm9kZS5ERUZNRVRIT0QoXCJldmFsdWF0ZVwiLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJldmFsdWF0ZVwiKSkgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLl9ldmFsKGNvbXByZXNzb3IsIDEpO1xuICAgICAgICBpZiAoIXZhbCB8fCB2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHJldHVybiB2YWw7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgdmFsID09IFwib2JqZWN0XCIpIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH0pO1xuICAgIHZhciB1bmFyeVByZWZpeCA9IG1ha2VQcmVkaWNhdGUoXCIhIH4gLSArIHZvaWRcIik7XG4gICAgQVNUX05vZGUuREVGTUVUSE9EKFwiaXNfY29uc3RhbnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEFjY29tb2RhdGUgd2hlbiBjb21wcmVzcyBvcHRpb24gZXZhbHVhdGU9ZmFsc2VcbiAgICAgICAgLy8gYXMgd2VsbCBhcyB0aGUgY29tbW9uIGNvbnN0YW50IGV4cHJlc3Npb25zICEwIGFuZCAtMVxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEFTVF9Db25zdGFudCkge1xuICAgICAgICAgICAgcmV0dXJuICEodGhpcyBpbnN0YW5jZW9mIEFTVF9SZWdFeHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAmJiB1bmFyeVByZWZpeC5oYXModGhpcy5vcGVyYXRvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZfZXZhbChBU1RfU3RhdGVtZW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cmluZ190ZW1wbGF0ZShcIkNhbm5vdCBldmFsdWF0ZSBhIHN0YXRlbWVudCBbe2ZpbGV9OntsaW5lfSx7Y29sfV1cIiwgdGhpcy5zdGFydCkpO1xuICAgIH0pO1xuICAgIGRlZl9ldmFsKEFTVF9MYW1iZGEsIHJldHVybl90aGlzKTtcbiAgICBkZWZfZXZhbChBU1RfQ2xhc3MsIHJldHVybl90aGlzKTtcbiAgICBkZWZfZXZhbChBU1RfTm9kZSwgcmV0dXJuX3RoaXMpO1xuICAgIGRlZl9ldmFsKEFTVF9Db25zdGFudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCk7XG4gICAgfSk7XG4gICAgZGVmX2V2YWwoQVNUX0JpZ0ludCwgcmV0dXJuX3RoaXMpO1xuICAgIGRlZl9ldmFsKEFTVF9SZWdFeHAsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgbGV0IGV2YWx1YXRlZCA9IGNvbXByZXNzb3IuZXZhbHVhdGVkX3JlZ2V4cHMuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAoZXZhbHVhdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZXZhbHVhdGVkID0gKDAsIGV2YWwpKHRoaXMucHJpbnRfdG9fc3RyaW5nKCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGV2YWx1YXRlZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wcmVzc29yLmV2YWx1YXRlZF9yZWdleHBzLnNldCh0aGlzLCBldmFsdWF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmFsdWF0ZWQgfHwgdGhpcztcbiAgICB9KTtcbiAgICBkZWZfZXZhbChBU1RfVGVtcGxhdGVTdHJpbmcsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zZWdtZW50cy5sZW5ndGggIT09IDEpIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50c1swXS52YWx1ZTtcbiAgICB9KTtcbiAgICBkZWZfZXZhbChBU1RfRnVuY3Rpb24sIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpKSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICAgICAgZm4ubm9kZSA9IHRoaXM7XG4gICAgICAgICAgICBmbi50b1N0cmluZyA9ICgpID0+IHRoaXMucHJpbnRfdG9fc3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgZGVmX2V2YWwoQVNUX0FycmF5LCBmdW5jdGlvbihjb21wcmVzc29yLCBkZXB0aCkge1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZWxlbWVudC5fZXZhbChjb21wcmVzc29yLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHZhbHVlKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBkZWZfZXZhbChBU1RfT2JqZWN0LCBmdW5jdGlvbihjb21wcmVzc29yLCBkZXB0aCkge1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBwcm9wLmtleTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgQVNUX1N5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXkubmFtZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSBpbnN0YW5jZW9mIEFTVF9Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS5fZXZhbChjb21wcmVzc29yLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IHByb3Aua2V5KSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QucHJvdG90eXBlW2tleV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3AudmFsdWUgaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb24pIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHZhbFtrZXldID0gcHJvcC52YWx1ZS5fZXZhbChjb21wcmVzc29yLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbFtrZXldID09PSBwcm9wLnZhbHVlKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgdmFyIG5vbl9jb252ZXJ0aW5nX3VuYXJ5ID0gbWFrZVByZWRpY2F0ZShcIiEgdHlwZW9mIHZvaWRcIik7XG4gICAgZGVmX2V2YWwoQVNUX1VuYXJ5UHJlZml4LCBmdW5jdGlvbihjb21wcmVzc29yLCBkZXB0aCkge1xuICAgICAgICB2YXIgZSA9IHRoaXMuZXhwcmVzc2lvbjtcbiAgICAgICAgLy8gRnVuY3Rpb24gd291bGQgYmUgZXZhbHVhdGVkIHRvIGFuIGFycmF5IGFuZCBzbyB0eXBlb2Ygd291bGRcbiAgICAgICAgLy8gaW5jb3JyZWN0bHkgcmV0dXJuICdvYmplY3QnLiBIZW5jZSBtYWtpbmcgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInR5cGVvZnNcIilcbiAgICAgICAgICAgICYmIHRoaXMub3BlcmF0b3IgPT0gXCJ0eXBlb2ZcIlxuICAgICAgICAgICAgJiYgKGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhXG4gICAgICAgICAgICAgICAgfHwgZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICAgICAgICAgJiYgZS5maXhlZF92YWx1ZSgpIGluc3RhbmNlb2YgQVNUX0xhbWJkYSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vbl9jb252ZXJ0aW5nX3VuYXJ5Lmhhcyh0aGlzLm9wZXJhdG9yKSkgZGVwdGgrKztcbiAgICAgICAgZSA9IGUuX2V2YWwoY29tcHJlc3NvciwgZGVwdGgpO1xuICAgICAgICBpZiAoZSA9PT0gdGhpcy5leHByZXNzaW9uKSByZXR1cm4gdGhpcztcbiAgICAgICAgc3dpdGNoICh0aGlzLm9wZXJhdG9yKSB7XG4gICAgICAgICAgY2FzZSBcIiFcIjogcmV0dXJuICFlO1xuICAgICAgICAgIGNhc2UgXCJ0eXBlb2ZcIjpcbiAgICAgICAgICAgIC8vIHR5cGVvZiA8UmVnRXhwPiByZXR1cm5zIFwib2JqZWN0XCIgb3IgXCJmdW5jdGlvblwiIG9uIGRpZmZlcmVudCBwbGF0Zm9ybXNcbiAgICAgICAgICAgIC8vIHNvIGNhbm5vdCBldmFsdWF0ZSByZWxpYWJseVxuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSZWdFeHApIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBlO1xuICAgICAgICAgIGNhc2UgXCJ2b2lkXCI6IHJldHVybiB2b2lkIGU7XG4gICAgICAgICAgY2FzZSBcIn5cIjogcmV0dXJuIH5lO1xuICAgICAgICAgIGNhc2UgXCItXCI6IHJldHVybiAtZTtcbiAgICAgICAgICBjYXNlIFwiK1wiOiByZXR1cm4gK2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgdmFyIG5vbl9jb252ZXJ0aW5nX2JpbmFyeSA9IG1ha2VQcmVkaWNhdGUoXCImJiB8fCA/PyA9PT0gIT09XCIpO1xuICAgIGNvbnN0IGlkZW50aXR5X2NvbXBhcmlzb24gPSBtYWtlUHJlZGljYXRlKFwiPT0gIT0gPT09ICE9PVwiKTtcbiAgICBjb25zdCBoYXNfaWRlbnRpdHkgPSB2YWx1ZSA9PlxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCJcbiAgICAgICAgfHwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgfHwgdHlwZW9mIHZhbHVlID09PSBcInN5bWJvbFwiO1xuXG4gICAgZGVmX2V2YWwoQVNUX0JpbmFyeSwgZnVuY3Rpb24oY29tcHJlc3NvciwgZGVwdGgpIHtcbiAgICAgICAgaWYgKCFub25fY29udmVydGluZ19iaW5hcnkuaGFzKHRoaXMub3BlcmF0b3IpKSBkZXB0aCsrO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5sZWZ0Ll9ldmFsKGNvbXByZXNzb3IsIGRlcHRoKTtcbiAgICAgICAgaWYgKGxlZnQgPT09IHRoaXMubGVmdCkgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmlnaHQuX2V2YWwoY29tcHJlc3NvciwgZGVwdGgpO1xuICAgICAgICBpZiAocmlnaHQgPT09IHRoaXMucmlnaHQpIHJldHVybiB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxlZnQgIT0gbnVsbFxuICAgICAgICAgICAgJiYgcmlnaHQgIT0gbnVsbFxuICAgICAgICAgICAgJiYgaWRlbnRpdHlfY29tcGFyaXNvbi5oYXModGhpcy5vcGVyYXRvcilcbiAgICAgICAgICAgICYmIGhhc19pZGVudGl0eShsZWZ0KVxuICAgICAgICAgICAgJiYgaGFzX2lkZW50aXR5KHJpZ2h0KVxuICAgICAgICAgICAgJiYgdHlwZW9mIGxlZnQgPT09IHR5cGVvZiByaWdodFxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCBjb21wYXJlIGJ5IHJlZmVyZW5jZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHRoaXMub3BlcmF0b3IpIHtcbiAgICAgICAgICBjYXNlIFwiJiZcIiAgOiByZXN1bHQgPSBsZWZ0ICYmICByaWdodDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInx8XCIgIDogcmVzdWx0ID0gbGVmdCB8fCAgcmlnaHQ7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCI/P1wiICA6IHJlc3VsdCA9IGxlZnQgIT0gbnVsbCA/IGxlZnQgOiByaWdodDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInxcIiAgIDogcmVzdWx0ID0gbGVmdCB8ICAgcmlnaHQ7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCImXCIgICA6IHJlc3VsdCA9IGxlZnQgJiAgIHJpZ2h0OyBicmVhaztcbiAgICAgICAgICBjYXNlIFwiXlwiICAgOiByZXN1bHQgPSBsZWZ0IF4gICByaWdodDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIitcIiAgIDogcmVzdWx0ID0gbGVmdCArICAgcmlnaHQ7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCIqXCIgICA6IHJlc3VsdCA9IGxlZnQgKiAgIHJpZ2h0OyBicmVhaztcbiAgICAgICAgICBjYXNlIFwiKipcIiAgOiByZXN1bHQgPSBNYXRoLnBvdyhsZWZ0LCByaWdodCk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCIvXCIgICA6IHJlc3VsdCA9IGxlZnQgLyAgIHJpZ2h0OyBicmVhaztcbiAgICAgICAgICBjYXNlIFwiJVwiICAgOiByZXN1bHQgPSBsZWZ0ICUgICByaWdodDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIi1cIiAgIDogcmVzdWx0ID0gbGVmdCAtICAgcmlnaHQ7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCI8PFwiICA6IHJlc3VsdCA9IGxlZnQgPDwgIHJpZ2h0OyBicmVhaztcbiAgICAgICAgICBjYXNlIFwiPj5cIiAgOiByZXN1bHQgPSBsZWZ0ID4+ICByaWdodDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIj4+PlwiIDogcmVzdWx0ID0gbGVmdCA+Pj4gcmlnaHQ7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCI9PVwiICA6IHJlc3VsdCA9IGxlZnQgPT0gIHJpZ2h0OyBicmVhaztcbiAgICAgICAgICBjYXNlIFwiPT09XCIgOiByZXN1bHQgPSBsZWZ0ID09PSByaWdodDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIiE9XCIgIDogcmVzdWx0ID0gbGVmdCAhPSAgcmlnaHQ7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCIhPT1cIiA6IHJlc3VsdCA9IGxlZnQgIT09IHJpZ2h0OyBicmVhaztcbiAgICAgICAgICBjYXNlIFwiPFwiICAgOiByZXN1bHQgPSBsZWZ0IDwgICByaWdodDsgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIjw9XCIgIDogcmVzdWx0ID0gbGVmdCA8PSAgcmlnaHQ7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCI+XCIgICA6IHJlc3VsdCA9IGxlZnQgPiAgIHJpZ2h0OyBicmVhaztcbiAgICAgICAgICBjYXNlIFwiPj1cIiAgOiByZXN1bHQgPSBsZWZ0ID49ICByaWdodDsgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKHJlc3VsdCkgJiYgY29tcHJlc3Nvci5maW5kX3BhcmVudChBU1RfV2l0aCkpIHtcbiAgICAgICAgICAgIC8vIGxlYXZlIG9yaWdpbmFsIGV4cHJlc3Npb24gYXMgaXNcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gICAgZGVmX2V2YWwoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihjb21wcmVzc29yLCBkZXB0aCkge1xuICAgICAgICB2YXIgY29uZGl0aW9uID0gdGhpcy5jb25kaXRpb24uX2V2YWwoY29tcHJlc3NvciwgZGVwdGgpO1xuICAgICAgICBpZiAoY29uZGl0aW9uID09PSB0aGlzLmNvbmRpdGlvbikgcmV0dXJuIHRoaXM7XG4gICAgICAgIHZhciBub2RlID0gY29uZGl0aW9uID8gdGhpcy5jb25zZXF1ZW50IDogdGhpcy5hbHRlcm5hdGl2ZTtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5fZXZhbChjb21wcmVzc29yLCBkZXB0aCk7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbm9kZSA/IHRoaXMgOiB2YWx1ZTtcbiAgICB9KTtcblxuICAgIC8vIFNldCBvZiBBU1RfU3ltYm9sUmVmIHdoaWNoIGFyZSBjdXJyZW50bHkgYmVpbmcgZXZhbHVhdGVkLlxuICAgIC8vIEF2b2lkcyBpbmZpbml0ZSByZWN1cnNpb24gb2YgLl9ldmFsKClcbiAgICBjb25zdCByZWVudHJhbnRfcmVmX2V2YWwgPSBuZXcgU2V0KCk7XG4gICAgZGVmX2V2YWwoQVNUX1N5bWJvbFJlZiwgZnVuY3Rpb24oY29tcHJlc3NvciwgZGVwdGgpIHtcbiAgICAgICAgaWYgKHJlZW50cmFudF9yZWZfZXZhbC5oYXModGhpcykpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHZhciBmaXhlZCA9IHRoaXMuZml4ZWRfdmFsdWUoKTtcbiAgICAgICAgaWYgKCFmaXhlZCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgcmVlbnRyYW50X3JlZl9ldmFsLmFkZCh0aGlzKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBmaXhlZC5fZXZhbChjb21wcmVzc29yLCBkZXB0aCk7XG4gICAgICAgIHJlZW50cmFudF9yZWZfZXZhbC5kZWxldGUodGhpcyk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBmaXhlZCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2YXIgZXNjYXBlZCA9IHRoaXMuZGVmaW5pdGlvbigpLmVzY2FwZWQ7XG4gICAgICAgICAgICBpZiAoZXNjYXBlZCAmJiBkZXB0aCA+IGVzY2FwZWQpIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgICB2YXIgZ2xvYmFsX29ianMgPSB7IEFycmF5LCBNYXRoLCBOdW1iZXIsIE9iamVjdCwgU3RyaW5nIH07XG4gICAgdmFyIHN0YXRpY192YWx1ZXMgPSBjb252ZXJ0X3RvX3ByZWRpY2F0ZSh7XG4gICAgICAgIE1hdGg6IFtcbiAgICAgICAgICAgIFwiRVwiLFxuICAgICAgICAgICAgXCJMTjEwXCIsXG4gICAgICAgICAgICBcIkxOMlwiLFxuICAgICAgICAgICAgXCJMT0cyRVwiLFxuICAgICAgICAgICAgXCJMT0cxMEVcIixcbiAgICAgICAgICAgIFwiUElcIixcbiAgICAgICAgICAgIFwiU1FSVDFfMlwiLFxuICAgICAgICAgICAgXCJTUVJUMlwiLFxuICAgICAgICBdLFxuICAgICAgICBOdW1iZXI6IFtcbiAgICAgICAgICAgIFwiTUFYX1ZBTFVFXCIsXG4gICAgICAgICAgICBcIk1JTl9WQUxVRVwiLFxuICAgICAgICAgICAgXCJOYU5cIixcbiAgICAgICAgICAgIFwiTkVHQVRJVkVfSU5GSU5JVFlcIixcbiAgICAgICAgICAgIFwiUE9TSVRJVkVfSU5GSU5JVFlcIixcbiAgICAgICAgXSxcbiAgICB9KTtcbiAgICBjb25zdCByZWdleHBfZmxhZ3MgPSBuZXcgU2V0KFtcbiAgICAgICAgXCJkb3RBbGxcIixcbiAgICAgICAgXCJnbG9iYWxcIixcbiAgICAgICAgXCJpZ25vcmVDYXNlXCIsXG4gICAgICAgIFwibXVsdGlsaW5lXCIsXG4gICAgICAgIFwic3RpY2t5XCIsXG4gICAgICAgIFwidW5pY29kZVwiLFxuICAgIF0pO1xuICAgIGRlZl9ldmFsKEFTVF9Qcm9wQWNjZXNzLCBmdW5jdGlvbihjb21wcmVzc29yLCBkZXB0aCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5leHByZXNzaW9uLl9ldmFsKGNvbXByZXNzb3IsIGRlcHRoKTtcbiAgICAgICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLnByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIEFTVF9Ob2RlKSB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5Ll9ldmFsKGNvbXByZXNzb3IsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSB0aGlzLnByb3BlcnR5KSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBleHAgPSB0aGlzLmV4cHJlc3Npb247XG4gICAgICAgICAgICB2YXIgdmFsO1xuICAgICAgICAgICAgaWYgKGlzX3VuZGVjbGFyZWRfcmVmKGV4cCkpIHtcblxuICAgICAgICAgICAgICAgIHZhciBhYTtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RfYXJnID0gZXhwLm5hbWUgPT09IFwiaGFzT3duUHJvcGVydHlcIlxuICAgICAgICAgICAgICAgICAgICAmJiBrZXkgPT09IFwiY2FsbFwiXG4gICAgICAgICAgICAgICAgICAgICYmIChhYSA9IGNvbXByZXNzb3IucGFyZW50KCkgJiYgY29tcHJlc3Nvci5wYXJlbnQoKS5hcmdzKVxuICAgICAgICAgICAgICAgICAgICAmJiAoYWEgJiYgYWFbMF1cbiAgICAgICAgICAgICAgICAgICAgJiYgYWFbMF0uZXZhbHVhdGUoY29tcHJlc3NvcikpO1xuXG4gICAgICAgICAgICAgICAgZmlyc3RfYXJnID0gZmlyc3RfYXJnIGluc3RhbmNlb2YgQVNUX0RvdCA/IGZpcnN0X2FyZy5leHByZXNzaW9uIDogZmlyc3RfYXJnO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0X2FyZyA9PSBudWxsIHx8IGZpcnN0X2FyZy50aGVkZWYgJiYgZmlyc3RfYXJnLnRoZWRlZi51bmRlY2xhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdGF0aWNfdmFsdWUgPSBzdGF0aWNfdmFsdWVzLmdldChleHAubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0aWNfdmFsdWUgfHwgIXN0YXRpY192YWx1ZS5oYXMoa2V5KSkgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgdmFsID0gZ2xvYmFsX29ianNbZXhwLm5hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBleHAuX2V2YWwoY29tcHJlc3NvciwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2V4cF9zb3VyY2VfZml4KHZhbC5zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PSBcImZsYWdzXCIgfHwgcmVnZXhwX2ZsYWdzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF2YWwgfHwgdmFsID09PSBleHAgfHwgIUhPUCh2YWwsIGtleSkpIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09IFwiZnVuY3Rpb25cIikgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwubm9kZS5uYW1lID8gdmFsLm5vZGUubmFtZS5uYW1lIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJsZW5ndGhcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5ub2RlLmxlbmd0aF9wcm9wZXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICAgIGRlZl9ldmFsKEFTVF9DaGFpbiwgZnVuY3Rpb24oY29tcHJlc3NvciwgZGVwdGgpIHtcbiAgICAgICAgY29uc3QgZXZhbHVhdGVkID0gdGhpcy5leHByZXNzaW9uLl9ldmFsKGNvbXByZXNzb3IsIGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlZCA9PT0gdGhpcy5leHByZXNzaW9uID8gdGhpcyA6IGV2YWx1YXRlZDtcbiAgICB9KTtcbiAgICBkZWZfZXZhbChBU1RfQ2FsbCwgZnVuY3Rpb24oY29tcHJlc3NvciwgZGVwdGgpIHtcbiAgICAgICAgdmFyIGV4cCA9IHRoaXMuZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxlZSA9IHRoaXMuZXhwcmVzc2lvbi5fZXZhbChjb21wcmVzc29yLCBkZXB0aCk7XG4gICAgICAgICAgICBpZiAoY2FsbGVlID09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpICYmIGV4cCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZXhwLnByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIEFTVF9Ob2RlKSB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5Ll9ldmFsKGNvbXByZXNzb3IsIGRlcHRoKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBleHAucHJvcGVydHkpIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbDtcbiAgICAgICAgICAgIHZhciBlID0gZXhwLmV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoaXNfdW5kZWNsYXJlZF9yZWYoZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RfYXJnID1cbiAgICAgICAgICAgICAgICAgICAgZS5uYW1lID09PSBcImhhc093blByb3BlcnR5XCIgJiZcbiAgICAgICAgICAgICAgICAgICAga2V5ID09PSBcImNhbGxcIiAmJlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5hcmdzWzBdICYmIHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjb21wcmVzc29yKSk7XG5cbiAgICAgICAgICAgICAgICBmaXJzdF9hcmcgPSBmaXJzdF9hcmcgaW5zdGFuY2VvZiBBU1RfRG90ID8gZmlyc3RfYXJnLmV4cHJlc3Npb24gOiBmaXJzdF9hcmc7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGZpcnN0X2FyZyA9PSBudWxsIHx8IGZpcnN0X2FyZy50aGVkZWYgJiYgZmlyc3RfYXJnLnRoZWRlZi51bmRlY2xhcmVkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc3RhdGljX2ZuID0gc3RhdGljX2Zucy5nZXQoZS5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRpY19mbiB8fCAhc3RhdGljX2ZuLmhhcyhrZXkpKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB2YWwgPSBnbG9iYWxfb2Jqc1tlLm5hbWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBlLl9ldmFsKGNvbXByZXNzb3IsIGRlcHRoICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gZSB8fCAhdmFsKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgbmF0aXZlX2ZuID0gbmF0aXZlX2Zucy5nZXQodmFsLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghbmF0aXZlX2ZuIHx8ICFuYXRpdmVfZm4uaGFzKGtleSkpIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gdGhpcy5hcmdzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFyZy5fZXZhbChjb21wcmVzc29yLCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZyA9PT0gdmFsdWUpIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBBU1RfTGFtYmRhKSByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsW2tleV0uYXBwbHkodmFsLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgcmVhbGx5IGNhcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgICBkZWZfZXZhbChBU1RfTmV3LCByZXR1cm5fdGhpcyk7XG59KShmdW5jdGlvbihub2RlLCBmdW5jKSB7XG4gICAgbm9kZS5ERUZNRVRIT0QoXCJfZXZhbFwiLCBmdW5jKTtcbn0pO1xuXG4vLyBtZXRob2QgdG8gbmVnYXRlIGFuIGV4cHJlc3Npb25cbihmdW5jdGlvbihkZWZfbmVnYXRlKSB7XG4gICAgZnVuY3Rpb24gYmFzaWNfbmVnYXRpb24oZXhwKSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBleHAsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcIiFcIixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmVzdChvcmlnLCBhbHQsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgICAgICB2YXIgbmVnYXRlZCA9IGJhc2ljX25lZ2F0aW9uKG9yaWcpO1xuICAgICAgICBpZiAoZmlyc3RfaW5fc3RhdGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgc3RhdCA9IG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBhbHQsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBhbHRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJlc3Rfb2ZfZXhwcmVzc2lvbihuZWdhdGVkLCBzdGF0KSA9PT0gc3RhdCA/IGFsdCA6IG5lZ2F0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3Rfb2ZfZXhwcmVzc2lvbihuZWdhdGVkLCBhbHQpO1xuICAgIH1cbiAgICBkZWZfbmVnYXRlKEFTVF9Ob2RlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGJhc2ljX25lZ2F0aW9uKHRoaXMpO1xuICAgIH0pO1xuICAgIGRlZl9uZWdhdGUoQVNUX1N0YXRlbWVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBuZWdhdGUgYSBzdGF0ZW1lbnRcIik7XG4gICAgfSk7XG4gICAgZGVmX25lZ2F0ZShBU1RfRnVuY3Rpb24sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmFzaWNfbmVnYXRpb24odGhpcyk7XG4gICAgfSk7XG4gICAgZGVmX25lZ2F0ZShBU1RfQXJyb3csIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmFzaWNfbmVnYXRpb24odGhpcyk7XG4gICAgfSk7XG4gICAgZGVmX25lZ2F0ZShBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcGVyYXRvciA9PSBcIiFcIilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb247XG4gICAgICAgIHJldHVybiBiYXNpY19uZWdhdGlvbih0aGlzKTtcbiAgICB9KTtcbiAgICBkZWZfbmVnYXRlKEFTVF9TZXF1ZW5jZSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSB0aGlzLmV4cHJlc3Npb25zLnNsaWNlKCk7XG4gICAgICAgIGV4cHJlc3Npb25zLnB1c2goZXhwcmVzc2lvbnMucG9wKCkubmVnYXRlKGNvbXByZXNzb3IpKTtcbiAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2UodGhpcywgZXhwcmVzc2lvbnMpO1xuICAgIH0pO1xuICAgIGRlZl9uZWdhdGUoQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHNlbGYuY29uc2VxdWVudCA9IHNlbGYuY29uc2VxdWVudC5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIHNlbGYuYWx0ZXJuYXRpdmUgPSBzZWxmLmFsdGVybmF0aXZlLm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgcmV0dXJuIGJlc3QodGhpcywgc2VsZiwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICB9KTtcbiAgICBkZWZfbmVnYXRlKEFTVF9CaW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXMuY2xvbmUoKSwgb3AgPSB0aGlzLm9wZXJhdG9yO1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVfY29tcHNcIikpIHtcbiAgICAgICAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgICAgICAgY2FzZSBcIjw9XCIgOiBzZWxmLm9wZXJhdG9yID0gXCI+XCIgIDsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICAgIGNhc2UgXCI8XCIgIDogc2VsZi5vcGVyYXRvciA9IFwiPj1cIiA7IHJldHVybiBzZWxmO1xuICAgICAgICAgICAgICBjYXNlIFwiPj1cIiA6IHNlbGYub3BlcmF0b3IgPSBcIjxcIiAgOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgICAgY2FzZSBcIj5cIiAgOiBzZWxmLm9wZXJhdG9yID0gXCI8PVwiIDsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICAgIGNhc2UgXCI9PVwiIDogc2VsZi5vcGVyYXRvciA9IFwiIT1cIjsgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgY2FzZSBcIiE9XCIgOiBzZWxmLm9wZXJhdG9yID0gXCI9PVwiOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICBjYXNlIFwiPT09XCI6IHNlbGYub3BlcmF0b3IgPSBcIiE9PVwiOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICBjYXNlIFwiIT09XCI6IHNlbGYub3BlcmF0b3IgPSBcIj09PVwiOyByZXR1cm4gc2VsZjtcbiAgICAgICAgICBjYXNlIFwiJiZcIjpcbiAgICAgICAgICAgIHNlbGYub3BlcmF0b3IgPSBcInx8XCI7XG4gICAgICAgICAgICBzZWxmLmxlZnQgPSBzZWxmLmxlZnQubmVnYXRlKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgICAgICAgICBzZWxmLnJpZ2h0ID0gc2VsZi5yaWdodC5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICByZXR1cm4gYmVzdCh0aGlzLCBzZWxmLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgICAgICAgIGNhc2UgXCJ8fFwiOlxuICAgICAgICAgICAgc2VsZi5vcGVyYXRvciA9IFwiJiZcIjtcbiAgICAgICAgICAgIHNlbGYubGVmdCA9IHNlbGYubGVmdC5uZWdhdGUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICAgICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0Lm5lZ2F0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIHJldHVybiBiZXN0KHRoaXMsIHNlbGYsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgICAgICAgY2FzZSBcIj8/XCI6XG4gICAgICAgICAgICBzZWxmLnJpZ2h0ID0gc2VsZi5yaWdodC5uZWdhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICByZXR1cm4gYmVzdCh0aGlzLCBzZWxmLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNpY19uZWdhdGlvbih0aGlzKTtcbiAgICB9KTtcbn0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpIHtcbiAgICBub2RlLkRFRk1FVEhPRChcIm5lZ2F0ZVwiLCBmdW5jdGlvbihjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgIH0pO1xufSk7XG5cbnZhciBnbG9iYWxfcHVyZV9mbnMgPSBtYWtlUHJlZGljYXRlKFwiQm9vbGVhbiBkZWNvZGVVUkkgZGVjb2RlVVJJQ29tcG9uZW50IERhdGUgZW5jb2RlVVJJIGVuY29kZVVSSUNvbXBvbmVudCBFcnJvciBlc2NhcGUgRXZhbEVycm9yIGlzRmluaXRlIGlzTmFOIE51bWJlciBPYmplY3QgcGFyc2VGbG9hdCBwYXJzZUludCBSYW5nZUVycm9yIFJlZmVyZW5jZUVycm9yIFN0cmluZyBTeW50YXhFcnJvciBUeXBlRXJyb3IgdW5lc2NhcGUgVVJJRXJyb3JcIik7XG5BU1RfQ2FsbC5ERUZNRVRIT0QoXCJpc19jYWxsZWVfcHVyZVwiLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpKSB7XG4gICAgICAgIHZhciBleHByID0gdGhpcy5leHByZXNzaW9uO1xuICAgICAgICB2YXIgZmlyc3RfYXJnID0gKHRoaXMuYXJncyAmJiB0aGlzLmFyZ3NbMF0gJiYgdGhpcy5hcmdzWzBdLmV2YWx1YXRlKGNvbXByZXNzb3IpKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXhwci5leHByZXNzaW9uICYmIGV4cHIuZXhwcmVzc2lvbi5uYW1lID09PSBcImhhc093blByb3BlcnR5XCIgJiZcbiAgICAgICAgICAgIChmaXJzdF9hcmcgPT0gbnVsbCB8fCBmaXJzdF9hcmcudGhlZGVmICYmIGZpcnN0X2FyZy50aGVkZWYudW5kZWNsYXJlZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3VuZGVjbGFyZWRfcmVmKGV4cHIpICYmIGdsb2JhbF9wdXJlX2Zucy5oYXMoZXhwci5uYW1lKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGxldCBzdGF0aWNfZm47XG4gICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0RvdFxuICAgICAgICAgICAgJiYgaXNfdW5kZWNsYXJlZF9yZWYoZXhwci5leHByZXNzaW9uKVxuICAgICAgICAgICAgJiYgKHN0YXRpY19mbiA9IHN0YXRpY19mbnMuZ2V0KGV4cHIuZXhwcmVzc2lvbi5uYW1lKSlcbiAgICAgICAgICAgICYmIHN0YXRpY19mbi5oYXMoZXhwci5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhIWhhc19hbm5vdGF0aW9uKHRoaXMsIF9QVVJFKSB8fCAhY29tcHJlc3Nvci5wdXJlX2Z1bmNzKHRoaXMpO1xufSk7XG5BU1RfTm9kZS5ERUZNRVRIT0QoXCJpc19jYWxsX3B1cmVcIiwgcmV0dXJuX2ZhbHNlKTtcbkFTVF9Eb3QuREVGTUVUSE9EKFwiaXNfY2FsbF9wdXJlXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpKSByZXR1cm47XG4gICAgY29uc3QgZXhwciA9IHRoaXMuZXhwcmVzc2lvbjtcbiAgICBsZXQgbWFwO1xuICAgIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0FycmF5KSB7XG4gICAgICAgIG1hcCA9IG5hdGl2ZV9mbnMuZ2V0KFwiQXJyYXlcIik7XG4gICAgfSBlbHNlIGlmIChleHByLmlzX2Jvb2xlYW4oKSkge1xuICAgICAgICBtYXAgPSBuYXRpdmVfZm5zLmdldChcIkJvb2xlYW5cIik7XG4gICAgfSBlbHNlIGlmIChleHByLmlzX251bWJlcihjb21wcmVzc29yKSkge1xuICAgICAgICBtYXAgPSBuYXRpdmVfZm5zLmdldChcIk51bWJlclwiKTtcbiAgICB9IGVsc2UgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfUmVnRXhwKSB7XG4gICAgICAgIG1hcCA9IG5hdGl2ZV9mbnMuZ2V0KFwiUmVnRXhwXCIpO1xuICAgIH0gZWxzZSBpZiAoZXhwci5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgbWFwID0gbmF0aXZlX2Zucy5nZXQoXCJTdHJpbmdcIik7XG4gICAgfSBlbHNlIGlmICghdGhpcy5tYXlfdGhyb3dfb25fYWNjZXNzKGNvbXByZXNzb3IpKSB7XG4gICAgICAgIG1hcCA9IG5hdGl2ZV9mbnMuZ2V0KFwiT2JqZWN0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwICYmIG1hcC5oYXModGhpcy5wcm9wZXJ0eSk7XG59KTtcblxuY29uc3QgcHVyZV9wcm9wX2FjY2Vzc19nbG9iYWxzID0gbmV3IFNldChbXG4gICAgXCJOdW1iZXJcIixcbiAgICBcIlN0cmluZ1wiLFxuICAgIFwiQXJyYXlcIixcbiAgICBcIk9iamVjdFwiLFxuICAgIFwiRnVuY3Rpb25cIixcbiAgICBcIlByb21pc2VcIixcbl0pO1xuLy8gZGV0ZXJtaW5lIGlmIGV4cHJlc3Npb24gaGFzIHNpZGUgZWZmZWN0c1xuKGZ1bmN0aW9uKGRlZl9oYXNfc2lkZV9lZmZlY3RzKSB7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX05vZGUsIHJldHVybl90cnVlKTtcblxuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9FbXB0eVN0YXRlbWVudCwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfQ29uc3RhbnQsIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1RoaXMsIHJldHVybl9mYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBhbnkobGlzdCwgY29tcHJlc3Nvcikge1xuICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGg7IC0taSA+PSAwOylcbiAgICAgICAgICAgIGlmIChsaXN0W2ldLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfQmxvY2ssIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLmJvZHksIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9DYWxsLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICF0aGlzLmlzX2NhbGxlZV9wdXJlKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAmJiAoIXRoaXMuZXhwcmVzc2lvbi5pc19jYWxsX3B1cmUoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICB8fCB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW55KHRoaXMuYXJncywgY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1N3aXRjaCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IGFueSh0aGlzLmJvZHksIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9DYXNlLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgYW55KHRoaXMuYm9keSwgY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1RyeSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gYW55KHRoaXMuYm9keSwgY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuYmNhdGNoICYmIHRoaXMuYmNhdGNoLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuYmZpbmFsbHkgJiYgdGhpcy5iZmluYWxseS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9JZiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgdGhpcy5ib2R5ICYmIHRoaXMuYm9keS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCB0aGlzLmFsdGVybmF0aXZlICYmIHRoaXMuYWx0ZXJuYXRpdmUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfTGFiZWxlZFN0YXRlbWVudCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1NpbXBsZVN0YXRlbWVudCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX0xhbWJkYSwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfQ2xhc3MsIGZ1bmN0aW9uIChjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLmV4dGVuZHMgJiYgdGhpcy5leHRlbmRzLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5wcm9wZXJ0aWVzLCBjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfQmluYXJ5LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgdGhpcy5yaWdodC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9Bc3NpZ24sIHJldHVybl90cnVlKTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuY29uc2VxdWVudC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCB0aGlzLmFsdGVybmF0aXZlLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1VuYXJ5LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB1bmFyeV9zaWRlX2VmZmVjdHMuaGFzKHRoaXMub3BlcmF0b3IpXG4gICAgICAgICAgICB8fCB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfU3ltYm9sUmVmLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc19kZWNsYXJlZChjb21wcmVzc29yKSAmJiAhcHVyZV9wcm9wX2FjY2Vzc19nbG9iYWxzLmhhcyh0aGlzLm5hbWUpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9TeW1ib2xDbGFzc1Byb3BlcnR5LCByZXR1cm5fZmFsc2UpO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9TeW1ib2xEZWNsYXJhdGlvbiwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfT2JqZWN0LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5wcm9wZXJ0aWVzLCBjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfT2JqZWN0UHJvcGVydHksIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRfa2V5KCkgJiYgdGhpcy5rZXkuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgdGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfQ2xhc3NQcm9wZXJ0eSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5jb21wdXRlZF9rZXkoKSAmJiB0aGlzLmtleS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCB0aGlzLnN0YXRpYyAmJiB0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICApO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9Db25jaXNlTWV0aG9kLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkX2tleSgpICYmIHRoaXMua2V5Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX09iamVjdEdldHRlciwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZF9rZXkoKSAmJiB0aGlzLmtleS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9oYXNfc2lkZV9lZmZlY3RzKEFTVF9PYmplY3RTZXR0ZXIsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWRfa2V5KCkgJiYgdGhpcy5rZXkuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfQXJyYXksIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLmVsZW1lbnRzLCBjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfRG90LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5vcHRpb25hbCAmJiB0aGlzLmV4cHJlc3Npb24ubWF5X3Rocm93X29uX2FjY2Vzcyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgdGhpcy5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1N1YiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbCAmJiBpc19udWxsaXNoKHRoaXMuZXhwcmVzc2lvbiwgY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhdGhpcy5vcHRpb25hbCAmJiB0aGlzLmV4cHJlc3Npb24ubWF5X3Rocm93X29uX2FjY2Vzcyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgdGhpcy5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMucHJvcGVydHkuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfQ2hhaW4sIGZ1bmN0aW9uIChjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfU2VxdWVuY2UsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLmV4cHJlc3Npb25zLCBjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfRGVmaW5pdGlvbnMsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLmRlZmluaXRpb25zLCBjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfVmFyRGVmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfSk7XG4gICAgZGVmX2hhc19zaWRlX2VmZmVjdHMoQVNUX1RlbXBsYXRlU2VnbWVudCwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfaGFzX3NpZGVfZWZmZWN0cyhBU1RfVGVtcGxhdGVTdHJpbmcsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLnNlZ21lbnRzLCBjb21wcmVzc29yKTtcbiAgICB9KTtcbn0pKGZ1bmN0aW9uKG5vZGUsIGZ1bmMpIHtcbiAgICBub2RlLkRFRk1FVEhPRChcImhhc19zaWRlX2VmZmVjdHNcIiwgZnVuYyk7XG59KTtcblxuLy8gZGV0ZXJtaW5lIGlmIGV4cHJlc3Npb24gbWF5IHRocm93XG4oZnVuY3Rpb24oZGVmX21heV90aHJvdykge1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX05vZGUsIHJldHVybl90cnVlKTtcblxuICAgIGRlZl9tYXlfdGhyb3coQVNUX0NvbnN0YW50LCByZXR1cm5fZmFsc2UpO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX0VtcHR5U3RhdGVtZW50LCByZXR1cm5fZmFsc2UpO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX0xhbWJkYSwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9TeW1ib2xEZWNsYXJhdGlvbiwgcmV0dXJuX2ZhbHNlKTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9UaGlzLCByZXR1cm5fZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gYW55KGxpc3QsIGNvbXByZXNzb3IpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoOyAtLWkgPj0gMDspXG4gICAgICAgICAgICBpZiAobGlzdFtpXS5tYXlfdGhyb3coY29tcHJlc3NvcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkZWZfbWF5X3Rocm93KEFTVF9DbGFzcywgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAodGhpcy5leHRlbmRzICYmIHRoaXMuZXh0ZW5kcy5tYXlfdGhyb3coY29tcHJlc3NvcikpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gYW55KHRoaXMucHJvcGVydGllcywgY29tcHJlc3Nvcik7XG4gICAgfSk7XG5cbiAgICBkZWZfbWF5X3Rocm93KEFTVF9BcnJheSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gYW55KHRoaXMuZWxlbWVudHMsIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX0Fzc2lnbiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAodGhpcy5yaWdodC5tYXlfdGhyb3coY29tcHJlc3NvcikpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIWNvbXByZXNzb3IuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIilcbiAgICAgICAgICAgICYmIHRoaXMub3BlcmF0b3IgPT0gXCI9XCJcbiAgICAgICAgICAgICYmIHRoaXMubGVmdCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Lm1heV90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9CaW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMucmlnaHQubWF5X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX0Jsb2NrLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5ib2R5LCBjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9DYWxsLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsICYmIGlzX251bGxpc2godGhpcy5leHByZXNzaW9uLCBjb21wcmVzc29yKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYW55KHRoaXMuYXJncywgY29tcHJlc3NvcikpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pc19jYWxsZWVfcHVyZShjb21wcmVzc29yKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uLm1heV90aHJvdyhjb21wcmVzc29yKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiAhKHRoaXMuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpXG4gICAgICAgICAgICB8fCBhbnkodGhpcy5leHByZXNzaW9uLmJvZHksIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX0Nhc2UsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IGFueSh0aGlzLmJvZHksIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX0NvbmRpdGlvbmFsLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbi5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuY29uc2VxdWVudC5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuYWx0ZXJuYXRpdmUubWF5X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX0RlZmluaXRpb25zLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiBhbnkodGhpcy5kZWZpbml0aW9ucywgY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfSWYsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uLm1heV90aHJvdyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgdGhpcy5ib2R5ICYmIHRoaXMuYm9keS5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuYWx0ZXJuYXRpdmUgJiYgdGhpcy5hbHRlcm5hdGl2ZS5tYXlfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfTGFiZWxlZFN0YXRlbWVudCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm1heV90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9PYmplY3QsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIGFueSh0aGlzLnByb3BlcnRpZXMsIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX09iamVjdFByb3BlcnR5LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIC8vIFRPRE8ga2V5IG1heSB0aHJvdyB0b29cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLm1heV90aHJvdyhjb21wcmVzc29yKSA6IGZhbHNlO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX0NsYXNzUHJvcGVydHksIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZWRfa2V5KCkgJiYgdGhpcy5rZXkubWF5X3Rocm93KGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCB0aGlzLnN0YXRpYyAmJiB0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUubWF5X3Rocm93KGNvbXByZXNzb3IpXG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfQ29uY2lzZU1ldGhvZCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZF9rZXkoKSAmJiB0aGlzLmtleS5tYXlfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfT2JqZWN0R2V0dGVyLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkX2tleSgpICYmIHRoaXMua2V5Lm1heV90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9PYmplY3RTZXR0ZXIsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWRfa2V5KCkgJiYgdGhpcy5rZXkubWF5X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX1JldHVybiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLm1heV90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9TZXF1ZW5jZSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gYW55KHRoaXMuZXhwcmVzc2lvbnMsIGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX1NpbXBsZVN0YXRlbWVudCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm1heV90aHJvdyhjb21wcmVzc29yKTtcbiAgICB9KTtcbiAgICBkZWZfbWF5X3Rocm93KEFTVF9Eb3QsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLm9wdGlvbmFsICYmIHRoaXMuZXhwcmVzc2lvbi5tYXlfdGhyb3dfb25fYWNjZXNzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCB0aGlzLmV4cHJlc3Npb24ubWF5X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX1N1YiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbCAmJiBpc19udWxsaXNoKHRoaXMuZXhwcmVzc2lvbiwgY29tcHJlc3NvcikpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gIXRoaXMub3B0aW9uYWwgJiYgdGhpcy5leHByZXNzaW9uLm1heV90aHJvd19vbl9hY2Nlc3MoY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMuZXhwcmVzc2lvbi5tYXlfdGhyb3coY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHRoaXMucHJvcGVydHkubWF5X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX0NoYWluLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24ubWF5X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX1N3aXRjaCwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLm1heV90aHJvdyhjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgYW55KHRoaXMuYm9keSwgY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfU3ltYm9sUmVmLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc19kZWNsYXJlZChjb21wcmVzc29yKSAmJiAhcHVyZV9wcm9wX2FjY2Vzc19nbG9iYWxzLmhhcyh0aGlzLm5hbWUpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX1N5bWJvbENsYXNzUHJvcGVydHksIHJldHVybl9mYWxzZSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfVHJ5LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJjYXRjaCA/IHRoaXMuYmNhdGNoLm1heV90aHJvdyhjb21wcmVzc29yKSA6IGFueSh0aGlzLmJvZHksIGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCB0aGlzLmJmaW5hbGx5ICYmIHRoaXMuYmZpbmFsbHkubWF5X3Rocm93KGNvbXByZXNzb3IpO1xuICAgIH0pO1xuICAgIGRlZl9tYXlfdGhyb3coQVNUX1VuYXJ5LCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLm9wZXJhdG9yID09IFwidHlwZW9mXCIgJiYgdGhpcy5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5tYXlfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgfSk7XG4gICAgZGVmX21heV90aHJvdyhBU1RfVmFyRGVmLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5tYXlfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgfSk7XG59KShmdW5jdGlvbihub2RlLCBmdW5jKSB7XG4gICAgbm9kZS5ERUZNRVRIT0QoXCJtYXlfdGhyb3dcIiwgZnVuYyk7XG59KTtcblxuLy8gZGV0ZXJtaW5lIGlmIGV4cHJlc3Npb24gaXMgY29uc3RhbnRcbihmdW5jdGlvbihkZWZfaXNfY29uc3RhbnRfZXhwcmVzc2lvbikge1xuICAgIGZ1bmN0aW9uIGFsbF9yZWZzX2xvY2FsKHNjb3BlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgICAgICB3YWxrKHRoaXMsIG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc19mbGFnKHRoaXMsIElOTElORUQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2Fsa19hYm9ydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRlZiA9IG5vZGUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbWVtYmVyKGRlZiwgdGhpcy5lbmNsb3NlZClcbiAgICAgICAgICAgICAgICAgICAgJiYgIXRoaXMudmFyaWFibGVzLmhhcyhkZWYubmFtZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NvcGVfZGVmID0gc2NvcGUuZmluZF92YXJpYWJsZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWYudW5kZWNsYXJlZCA/ICFzY29wZV9kZWYgOiBzY29wZV9kZWYgPT09IGRlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFwiZlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2Fsa19hYm9ydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9UaGlzICYmIHRoaXMgaW5zdGFuY2VvZiBBU1RfQXJyb3cpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGNoZWNrIGFyZ3VtZW50cyB0b28hXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGtfYWJvcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGRlZl9pc19jb25zdGFudF9leHByZXNzaW9uKEFTVF9Ob2RlLCByZXR1cm5fZmFsc2UpO1xuICAgIGRlZl9pc19jb25zdGFudF9leHByZXNzaW9uKEFTVF9Db25zdGFudCwgcmV0dXJuX3RydWUpO1xuICAgIGRlZl9pc19jb25zdGFudF9leHByZXNzaW9uKEFTVF9DbGFzcywgZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZXh0ZW5kcyAmJiAhdGhpcy5leHRlbmRzLmlzX2NvbnN0YW50X2V4cHJlc3Npb24oc2NvcGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgdGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcC5jb21wdXRlZF9rZXkoKSAmJiAhcHJvcC5rZXkuaXNfY29uc3RhbnRfZXhwcmVzc2lvbihzY29wZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcC5zdGF0aWMgJiYgcHJvcC52YWx1ZSAmJiAhcHJvcC52YWx1ZS5pc19jb25zdGFudF9leHByZXNzaW9uKHNjb3BlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbGxfcmVmc19sb2NhbC5jYWxsKHRoaXMsIHNjb3BlKTtcbiAgICB9KTtcbiAgICBkZWZfaXNfY29uc3RhbnRfZXhwcmVzc2lvbihBU1RfTGFtYmRhLCBhbGxfcmVmc19sb2NhbCk7XG4gICAgZGVmX2lzX2NvbnN0YW50X2V4cHJlc3Npb24oQVNUX1VuYXJ5LCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5pc19jb25zdGFudF9leHByZXNzaW9uKCk7XG4gICAgfSk7XG4gICAgZGVmX2lzX2NvbnN0YW50X2V4cHJlc3Npb24oQVNUX0JpbmFyeSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuaXNfY29uc3RhbnRfZXhwcmVzc2lvbigpXG4gICAgICAgICAgICAmJiB0aGlzLnJpZ2h0LmlzX2NvbnN0YW50X2V4cHJlc3Npb24oKTtcbiAgICB9KTtcbiAgICBkZWZfaXNfY29uc3RhbnRfZXhwcmVzc2lvbihBU1RfQXJyYXksIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5ldmVyeSgobCkgPT4gbC5pc19jb25zdGFudF9leHByZXNzaW9uKCkpO1xuICAgIH0pO1xuICAgIGRlZl9pc19jb25zdGFudF9leHByZXNzaW9uKEFTVF9PYmplY3QsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmV2ZXJ5KChsKSA9PiBsLmlzX2NvbnN0YW50X2V4cHJlc3Npb24oKSk7XG4gICAgfSk7XG4gICAgZGVmX2lzX2NvbnN0YW50X2V4cHJlc3Npb24oQVNUX09iamVjdFByb3BlcnR5LCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhKCEodGhpcy5rZXkgaW5zdGFuY2VvZiBBU1RfTm9kZSkgJiYgdGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmlzX2NvbnN0YW50X2V4cHJlc3Npb24oKSk7XG4gICAgfSk7XG59KShmdW5jdGlvbihub2RlLCBmdW5jKSB7XG4gICAgbm9kZS5ERUZNRVRIT0QoXCJpc19jb25zdGFudF9leHByZXNzaW9uXCIsIGZ1bmMpO1xufSk7XG5cbi8vIHRlbGwgbWUgaWYgYSBzdGF0ZW1lbnQgYWJvcnRzXG5mdW5jdGlvbiBhYm9ydHModGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmcgJiYgdGhpbmcuYWJvcnRzKCk7XG59XG4oZnVuY3Rpb24oZGVmX2Fib3J0cykge1xuICAgIGRlZl9hYm9ydHMoQVNUX1N0YXRlbWVudCwgcmV0dXJuX251bGwpO1xuICAgIGRlZl9hYm9ydHMoQVNUX0p1bXAsIHJldHVybl90aGlzKTtcbiAgICBmdW5jdGlvbiBibG9ja19hYm9ydHMoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYWJvcnRzKHRoaXMuYm9keVtpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib2R5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZWZfYWJvcnRzKEFTVF9JbXBvcnQsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfSk7XG4gICAgZGVmX2Fib3J0cyhBU1RfQmxvY2tTdGF0ZW1lbnQsIGJsb2NrX2Fib3J0cyk7XG4gICAgZGVmX2Fib3J0cyhBU1RfU3dpdGNoQnJhbmNoLCBibG9ja19hYm9ydHMpO1xuICAgIGRlZl9hYm9ydHMoQVNUX0lmLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWx0ZXJuYXRpdmUgJiYgYWJvcnRzKHRoaXMuYm9keSkgJiYgYWJvcnRzKHRoaXMuYWx0ZXJuYXRpdmUpICYmIHRoaXM7XG4gICAgfSk7XG59KShmdW5jdGlvbihub2RlLCBmdW5jKSB7XG4gICAgbm9kZS5ERUZNRVRIT0QoXCJhYm9ydHNcIiwgZnVuYyk7XG59KTtcblxuLyogLS0tLS1bIG9wdGltaXplcnMgXS0tLS0tICovXG5cbnZhciBkaXJlY3RpdmVzID0gbmV3IFNldChbXCJ1c2UgYXNtXCIsIFwidXNlIHN0cmljdFwiXSk7XG5kZWZfb3B0aW1pemUoQVNUX0RpcmVjdGl2ZSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRpcmVjdGl2ZXNcIilcbiAgICAgICAgJiYgKCFkaXJlY3RpdmVzLmhhcyhzZWxmLnZhbHVlKSB8fCBjb21wcmVzc29yLmhhc19kaXJlY3RpdmUoc2VsZi52YWx1ZSkgIT09IHNlbGYpKSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9EZWJ1Z2dlciwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRyb3BfZGVidWdnZXJcIikpXG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX0xhYmVsZWRTdGF0ZW1lbnQsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX0JyZWFrXG4gICAgICAgICYmIGNvbXByZXNzb3IubG9vcGNvbnRyb2xfdGFyZ2V0KHNlbGYuYm9keSkgPT09IHNlbGYuYm9keSkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgc2VsZik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmLmxhYmVsLnJlZmVyZW5jZXMubGVuZ3RoID09IDAgPyBzZWxmLmJvZHkgOiBzZWxmO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfQmxvY2ssIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICB0aWdodGVuX2JvZHkoc2VsZi5ib2R5LCBjb21wcmVzc29yKTtcbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5mdW5jdGlvbiBjYW5fYmVfZXh0cmFjdGVkX2Zyb21faWZfYmxvY2sobm9kZSkge1xuICAgIHJldHVybiAhKFxuICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX0NvbnN0XG4gICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfTGV0XG4gICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3NcbiAgICApO1xufVxuXG5kZWZfb3B0aW1pemUoQVNUX0Jsb2NrU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgdGlnaHRlbl9ib2R5KHNlbGYuYm9keSwgY29tcHJlc3Nvcik7XG4gICAgc3dpdGNoIChzZWxmLmJvZHkubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmICghY29tcHJlc3Nvci5oYXNfZGlyZWN0aXZlKFwidXNlIHN0cmljdFwiKVxuICAgICAgICAgICAgJiYgY29tcHJlc3Nvci5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9JZlxuICAgICAgICAgICAgJiYgY2FuX2JlX2V4dHJhY3RlZF9mcm9tX2lmX2Jsb2NrKHNlbGYuYm9keVswXSlcbiAgICAgICAgICAgIHx8IGNhbl9iZV9ldmljdGVkX2Zyb21fYmxvY2soc2VsZi5ib2R5WzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuYm9keVswXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMDogcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIHNlbGYpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5mdW5jdGlvbiBvcHRfQVNUX0xhbWJkYShzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgdGlnaHRlbl9ib2R5KHNlbGYuYm9keSwgY29tcHJlc3Nvcik7XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwic2lkZV9lZmZlY3RzXCIpXG4gICAgICAgICYmIHNlbGYuYm9keS5sZW5ndGggPT0gMVxuICAgICAgICAmJiBzZWxmLmJvZHlbMF0gPT09IGNvbXByZXNzb3IuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIikpIHtcbiAgICAgICAgc2VsZi5ib2R5Lmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufVxuZGVmX29wdGltaXplKEFTVF9MYW1iZGEsIG9wdF9BU1RfTGFtYmRhKTtcblxuY29uc3Qgcl9rZWVwX2Fzc2lnbiA9IC9rZWVwX2Fzc2lnbi87XG5BU1RfU2NvcGUuREVGTUVUSE9EKFwiZHJvcF91bnVzZWRcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJ1bnVzZWRcIikpIHJldHVybjtcbiAgICBpZiAoY29tcHJlc3Nvci5oYXNfZGlyZWN0aXZlKFwidXNlIGFzbVwiKSkgcmV0dXJuO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5waW5uZWQoKSkgcmV0dXJuO1xuICAgIHZhciBkcm9wX2Z1bmNzID0gIShzZWxmIGluc3RhbmNlb2YgQVNUX1RvcGxldmVsKSB8fCBjb21wcmVzc29yLnRvcGxldmVsLmZ1bmNzO1xuICAgIHZhciBkcm9wX3ZhcnMgPSAhKHNlbGYgaW5zdGFuY2VvZiBBU1RfVG9wbGV2ZWwpIHx8IGNvbXByZXNzb3IudG9wbGV2ZWwudmFycztcbiAgICBjb25zdCBhc3NpZ25fYXNfdW51c2VkID0gcl9rZWVwX2Fzc2lnbi50ZXN0KGNvbXByZXNzb3Iub3B0aW9uKFwidW51c2VkXCIpKSA/IHJldHVybl9mYWxzZSA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICAgICAmJiAhbm9kZS5sb2dpY2FsXG4gICAgICAgICAgICAmJiAoaGFzX2ZsYWcobm9kZSwgV1JJVEVfT05MWSkgfHwgbm9kZS5vcGVyYXRvciA9PSBcIj1cIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1VuYXJ5ICYmIGhhc19mbGFnKG5vZGUsIFdSSVRFX09OTFkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgaW5fdXNlX2lkcyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgZml4ZWRfaWRzID0gbmV3IE1hcCgpO1xuICAgIGlmIChzZWxmIGluc3RhbmNlb2YgQVNUX1RvcGxldmVsICYmIGNvbXByZXNzb3IudG9wX3JldGFpbikge1xuICAgICAgICBzZWxmLnZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKGRlZikge1xuICAgICAgICAgICAgaWYgKGNvbXByZXNzb3IudG9wX3JldGFpbihkZWYpICYmICFpbl91c2VfaWRzLmhhcyhkZWYuaWQpKSB7XG4gICAgICAgICAgICAgICAgaW5fdXNlX2lkcy5zZXQoZGVmLmlkLCBkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHZhcl9kZWZzX2J5X2lkID0gbmV3IE1hcCgpO1xuICAgIHZhciBpbml0aWFsaXphdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgLy8gcGFzcyAxOiBmaW5kIG91dCB3aGljaCBzeW1ib2xzIGFyZSBkaXJlY3RseSB1c2VkIGluXG4gICAgLy8gdGhpcyBzY29wZSAobm90IGluIG5lc3RlZCBzY29wZXMpLlxuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSwgZGVzY2VuZCkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGEgJiYgbm9kZS51c2VzX2FyZ3VtZW50cyAmJiAhdHcuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIikpIHtcbiAgICAgICAgICAgIG5vZGUuYXJnbmFtZXMuZm9yRWFjaChmdW5jdGlvbihhcmduYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoYXJnbmFtZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWNsYXJhdGlvbikpIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgZGVmID0gYXJnbmFtZS5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpbl91c2VfaWRzLmhhcyhkZWYuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluX3VzZV9pZHMuc2V0KGRlZi5pZCwgZGVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gc2VsZikgcmV0dXJuO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1biB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0RlZkNsYXNzKSB7XG4gICAgICAgICAgICB2YXIgbm9kZV9kZWYgPSBub2RlLm5hbWUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgaW5fZXhwb3J0ID0gdHcucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfRXhwb3J0O1xuICAgICAgICAgICAgaWYgKGluX2V4cG9ydCB8fCAhZHJvcF9mdW5jcyAmJiBzY29wZSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlX2RlZi5nbG9iYWwgJiYgIWluX3VzZV9pZHMuaGFzKG5vZGVfZGVmLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBpbl91c2VfaWRzLnNldChub2RlX2RlZi5pZCwgbm9kZV9kZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZkNsYXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBub2RlLmV4dGVuZHNcbiAgICAgICAgICAgICAgICAgICAgJiYgKG5vZGUuZXh0ZW5kcy5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgICAgIHx8IG5vZGUuZXh0ZW5kcy5tYXlfdGhyb3coY29tcHJlc3NvcikpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZXh0ZW5kcy53YWxrKHR3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIG5vZGUucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AubWF5X3Rocm93KGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcC53YWxrKHR3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcF9hZGQoaW5pdGlhbGl6YXRpb25zLCBub2RlX2RlZi5pZCwgbm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gZG9uJ3QgZ28gaW4gbmVzdGVkIHNjb3Blc1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZyAmJiBzY29wZSA9PT0gc2VsZikge1xuICAgICAgICAgICAgbWFwX2FkZCh2YXJfZGVmc19ieV9pZCwgbm9kZS5kZWZpbml0aW9uKCkuaWQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zICYmIHNjb3BlID09PSBzZWxmKSB7XG4gICAgICAgICAgICBjb25zdCBpbl9leHBvcnQgPSB0dy5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9FeHBvcnQ7XG4gICAgICAgICAgICBub2RlLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi5uYW1lIGluc3RhbmNlb2YgQVNUX1N5bWJvbFZhcikge1xuICAgICAgICAgICAgICAgICAgICBtYXBfYWRkKHZhcl9kZWZzX2J5X2lkLCBkZWYubmFtZS5kZWZpbml0aW9uKCkuaWQsIGRlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbl9leHBvcnQgfHwgIWRyb3BfdmFycykge1xuICAgICAgICAgICAgICAgICAgICB3YWxrKGRlZi5uYW1lLCBub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmID0gbm9kZS5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5fZXhwb3J0IHx8IGRlZi5nbG9iYWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICFpbl91c2VfaWRzLmhhcyhkZWYuaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluX3VzZV9pZHMuc2V0KGRlZi5pZCwgZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGVmLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWYubmFtZSBpbnN0YW5jZW9mIEFTVF9EZXN0cnVjdHVyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYud2Fsayh0dyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZV9kZWYgPSBkZWYubmFtZS5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBfYWRkKGluaXRpYWxpemF0aW9ucywgbm9kZV9kZWYuaWQsIGRlZi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVfZGVmLmNoYWluZWQgJiYgZGVmLm5hbWUuZml4ZWRfdmFsdWUoKSA9PT0gZGVmLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZml4ZWRfaWRzLnNldChub2RlX2RlZi5pZCwgZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnZhbHVlLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZi52YWx1ZS53YWxrKHR3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYW5fcmVmX3Njb3BlZChub2RlLCBkZXNjZW5kKTtcbiAgICB9KTtcbiAgICBzZWxmLndhbGsodHcpO1xuICAgIC8vIHBhc3MgMjogZm9yIGV2ZXJ5IHVzZWQgc3ltYm9sIHdlIG5lZWQgdG8gd2FsayBpdHNcbiAgICAvLyBpbml0aWFsaXphdGlvbiBjb2RlIHRvIGZpZ3VyZSBvdXQgaWYgaXQgdXNlcyBvdGhlclxuICAgIC8vIHN5bWJvbHMgKHRoYXQgbWF5IG5vdCBiZSBpbl91c2UpLlxuICAgIHR3ID0gbmV3IFRyZWVXYWxrZXIoc2Nhbl9yZWZfc2NvcGVkKTtcbiAgICBpbl91c2VfaWRzLmZvckVhY2goZnVuY3Rpb24gKGRlZikge1xuICAgICAgICB2YXIgaW5pdCA9IGluaXRpYWxpemF0aW9ucy5nZXQoZGVmLmlkKTtcbiAgICAgICAgaWYgKGluaXQpIGluaXQuZm9yRWFjaChmdW5jdGlvbihpbml0KSB7XG4gICAgICAgICAgICBpbml0LndhbGsodHcpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBwYXNzIDM6IHdlIHNob3VsZCBkcm9wIGRlY2xhcmF0aW9ucyBub3QgaW5fdXNlXG4gICAgdmFyIHR0ID0gbmV3IFRyZWVUcmFuc2Zvcm1lcihcbiAgICAgICAgZnVuY3Rpb24gYmVmb3JlKG5vZGUsIGRlc2NlbmQsIGluX2xpc3QpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0dC5wYXJlbnQoKTtcbiAgICAgICAgICAgIGlmIChkcm9wX3ZhcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW0gPSBhc3NpZ25fYXNfdW51c2VkKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChzeW0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSBzeW0uZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5fdXNlID0gaW5fdXNlX2lkcy5oYXMoZGVmLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQXNzaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluX3VzZSB8fCBmaXhlZF9pZHMuaGFzKGRlZi5pZCkgJiYgZml4ZWRfaWRzLmdldChkZWYuaWQpICE9PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1haW50YWluX3RoaXNfYmluZGluZyhwYXJlbnQsIG5vZGUsIG5vZGUucmlnaHQudHJhbnNmb3JtKHR0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluX3VzZSkgcmV0dXJuIGluX2xpc3QgPyBNQVAuc2tpcCA6IG1ha2Vfbm9kZShBU1RfTnVtYmVyLCBub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NvcGUgIT09IHNlbGYpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBkZWY7XG4gICAgICAgICAgICBpZiAobm9kZS5uYW1lXG4gICAgICAgICAgICAgICAgJiYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3NFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICYmICFrZWVwX25hbWUoY29tcHJlc3Nvci5vcHRpb24oXCJrZWVwX2NsYXNzbmFtZXNcIiksIChkZWYgPSBub2RlLm5hbWUuZGVmaW5pdGlvbigpKS5uYW1lKVxuICAgICAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgJiYgIWtlZXBfbmFtZShjb21wcmVzc29yLm9wdGlvbihcImtlZXBfZm5hbWVzXCIpLCAoZGVmID0gbm9kZS5uYW1lLmRlZmluaXRpb24oKSkubmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gYW55IGRlY2xhcmF0aW9ucyB3aXRoIHNhbWUgbmFtZSB3aWxsIG92ZXJzaGFkb3dcbiAgICAgICAgICAgICAgICAvLyBuYW1lIG9mIHRoaXMgYW5vbnltb3VzIGZ1bmN0aW9uIGFuZCBjYW4gdGhlcmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gbmV2ZXIgYmUgdXNlZCBhbnl3aGVyZVxuICAgICAgICAgICAgICAgIGlmICghaW5fdXNlX2lkcy5oYXMoZGVmLmlkKSB8fCBkZWYub3JpZy5sZW5ndGggPiAxKSBub2RlLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhICYmICEobm9kZSBpbnN0YW5jZW9mIEFTVF9BY2Nlc3NvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJpbSA9ICFjb21wcmVzc29yLm9wdGlvbihcImtlZXBfZmFyZ3NcIik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYSA9IG5vZGUuYXJnbmFtZXMsIGkgPSBhLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzeW0gPSBhW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ltIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ltID0gc3ltLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN5bSBpbnN0YW5jZW9mIEFTVF9EZWZhdWx0QXNzaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW0gPSBzeW0ubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgZHJvcCBkZXN0cnVjdHVyaW5nIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhleSBjb25zdGl0dXRlIGEgdHlwZSBhc3NlcnRpb24sIHNvIGRyb3BwaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW0gd291bGQgc3RvcCB0aGF0IFR5cGVFcnJvciB3aGljaCB3b3VsZCBoYXBwZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgc29tZW9uZSBjYWxsZWQgaXQgd2l0aCBhbiBpbmNvcnJlY3RseSBmb3JtYXR0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyYW1ldGVyLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShzeW0gaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZykgJiYgIWluX3VzZV9pZHMuaGFzKHN5bS5kZWZpbml0aW9uKCkuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRfZmxhZyhzeW0sIFVOVVNFRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJpbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmltID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGVmdW4gfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZDbGFzcykgJiYgbm9kZSAhPT0gc2VsZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZiA9IG5vZGUubmFtZS5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgbGV0IGtlZXAgPSBkZWYuZ2xvYmFsICYmICFkcm9wX2Z1bmNzIHx8IGluX3VzZV9pZHMuaGFzKGRlZi5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZi5lbGltaW5hdGVkKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZkNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGFzc2VzIG1pZ2h0IGhhdmUgZXh0ZW5kcyB3aXRoIHNpZGUgZWZmZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lkZV9lZmZlY3RzID0gbm9kZS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2lkZV9lZmZlY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHNpZGVfZWZmZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbl9saXN0ID8gTUFQLnNraXAgOiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZpbml0aW9ucyAmJiAhKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9Gb3JJbiAmJiBwYXJlbnQuaW5pdCA9PT0gbm9kZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJvcF9ibG9jayA9ICEocGFyZW50IGluc3RhbmNlb2YgQVNUX1RvcGxldmVsKSAmJiAhKG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyKTtcbiAgICAgICAgICAgICAgICAvLyBwbGFjZSB1bmluaXRpYWxpemVkIG5hbWVzIGF0IHRoZSBzdGFydFxuICAgICAgICAgICAgICAgIHZhciBib2R5ID0gW10sIGhlYWQgPSBbXSwgdGFpbCA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIGZvciB1bnVzZWQgbmFtZXMgd2hvc2UgaW5pdGlhbGl6YXRpb24gaGFzXG4gICAgICAgICAgICAgICAgLy8gc2lkZSBlZmZlY3RzLCB3ZSBjYW4gY2FzY2FkZSB0aGUgaW5pdC4gY29kZVxuICAgICAgICAgICAgICAgIC8vIGludG8gdGhlIG5leHQgb25lLCBvciBuZXh0IHN0YXRlbWVudC5cbiAgICAgICAgICAgICAgICB2YXIgc2lkZV9lZmZlY3RzID0gW107XG4gICAgICAgICAgICAgICAgbm9kZS5kZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGRlZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnZhbHVlKSBkZWYudmFsdWUgPSBkZWYudmFsdWUudHJhbnNmb3JtKHR0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzX2Rlc3RydWN0dXJlID0gZGVmLm5hbWUgaW5zdGFuY2VvZiBBU1RfRGVzdHJ1Y3R1cmluZztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN5bSA9IGlzX2Rlc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBTeW1ib2xEZWYobnVsbCwgeyBuYW1lOiBcIjxkZXN0cnVjdHVyZT5cIiB9KSAvKiBmYWtlIFN5bWJvbERlZiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBkZWYubmFtZS5kZWZpbml0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcm9wX2Jsb2NrICYmIHN5bS5nbG9iYWwpIHJldHVybiB0YWlsLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZHJvcF92YXJzIHx8IGRyb3BfYmxvY2spXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBpc19kZXN0cnVjdHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChkZWYubmFtZS5uYW1lcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgZGVmLm5hbWUuaXNfYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX2dldHRlcnNcIikgIT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGluX3VzZV9pZHMuaGFzKHN5bS5pZClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnZhbHVlICYmIGZpeGVkX2lkcy5oYXMoc3ltLmlkKSAmJiBmaXhlZF9pZHMuZ2V0KHN5bS5pZCkgIT09IGRlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZi52YWx1ZSA9IGRlZi52YWx1ZS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLm5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sVmFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhcl9kZWZzID0gdmFyX2RlZnNfYnlfaWQuZ2V0KHN5bS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcl9kZWZzLmxlbmd0aCA+IDEgJiYgKCFkZWYudmFsdWUgfHwgc3ltLm9yaWcuaW5kZXhPZihkZWYubmFtZSkgPiBzeW0uZWxpbWluYXRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IG1ha2Vfbm9kZShBU1RfU3ltYm9sUmVmLCBkZWYubmFtZSwgZGVmLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltLnJlZmVyZW5jZXMucHVzaChyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFzc2lnbiA9IG1ha2Vfbm9kZShBU1RfQXNzaWduLCBkZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCI9XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9naWNhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBkZWYudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpeGVkX2lkcy5nZXQoc3ltLmlkKSA9PT0gZGVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZml4ZWRfaWRzLnNldChzeW0uaWQsIGFzc2lnbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMucHVzaChhc3NpZ24udHJhbnNmb3JtKHR0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHZhcl9kZWZzLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW0uZWxpbWluYXRlZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaWRlX2VmZmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMucHVzaChkZWYudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnZhbHVlID0gbWFrZV9zZXF1ZW5jZShkZWYudmFsdWUsIHNpZGVfZWZmZWN0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBtYWtlX3NlcXVlbmNlKG5vZGUsIHNpZGVfZWZmZWN0cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFpbC5wdXNoKGRlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQucHVzaChkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN5bS5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbENhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkZWYudmFsdWUgJiYgZGVmLnZhbHVlLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkgc2lkZV9lZmZlY3RzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWQucHVzaChkZWYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGVmLnZhbHVlICYmIGRlZi52YWx1ZS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2VmZmVjdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzeW0uZWxpbWluYXRlZCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWQubGVuZ3RoID4gMCB8fCB0YWlsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kZWZpbml0aW9ucyA9IGhlYWQuY29uY2F0KHRhaWwpO1xuICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzaWRlX2VmZmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IG1ha2Vfc2VxdWVuY2Uobm9kZSwgc2lkZV9lZmZlY3RzKVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYm9keS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluX2xpc3QgPyBNQVAuc2tpcCA6IG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9keVswXTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbl9saXN0ID8gTUFQLnNwbGljZShib2R5KSA6IG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2VydGFpbiBjb21iaW5hdGlvbiBvZiB1bnVzZWQgbmFtZSArIHNpZGUgZWZmZWN0IGxlYWRzIHRvOlxuICAgICAgICAgICAgLy8gICAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzQ0XG4gICAgICAgICAgICAvLyAgICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvMTgzMFxuICAgICAgICAgICAgLy8gICAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzE4MzhcbiAgICAgICAgICAgIC8vIHRoYXQncyBhbiBpbnZhbGlkIEFTVC5cbiAgICAgICAgICAgIC8vIFdlIGZpeCBpdCBhdCB0aGlzIHN0YWdlIGJ5IG1vdmluZyB0aGUgYHZhcmAgb3V0c2lkZSB0aGUgYGZvcmAuXG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Gb3IpIHtcbiAgICAgICAgICAgICAgICBkZXNjZW5kKG5vZGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHZhciBibG9jaztcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5pbml0IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrID0gbm9kZS5pbml0O1xuICAgICAgICAgICAgICAgICAgICBub2RlLmluaXQgPSBibG9jay5ib2R5LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBibG9jay5ib2R5LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLmluaXQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaW5pdCA9IG5vZGUuaW5pdC5ib2R5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNfZW1wdHkobm9kZS5pbml0KSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmluaXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gIWJsb2NrID8gbm9kZSA6IGluX2xpc3QgPyBNQVAuc3BsaWNlKGJsb2NrLmJvZHkpIDogYmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9MYWJlbGVkU3RhdGVtZW50XG4gICAgICAgICAgICAgICAgJiYgbm9kZS5ib2R5IGluc3RhbmNlb2YgQVNUX0ZvclxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGVzY2VuZChub2RlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ib2R5IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9jayA9IG5vZGUuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5ib2R5ID0gYmxvY2suYm9keS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suYm9keS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5fbGlzdCA/IE1BUC5zcGxpY2UoYmxvY2suYm9keSkgOiBibG9jaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKGluX2xpc3QgJiYgbm9kZS5ib2R5LmV2ZXJ5KGNhbl9iZV9ldmljdGVkX2Zyb21fYmxvY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNQVAuc3BsaWNlKG5vZGUuYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzYXZlX3Njb3BlID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBzYXZlX3Njb3BlO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIHNlbGYudHJhbnNmb3JtKHR0KTtcblxuICAgIGZ1bmN0aW9uIHNjYW5fcmVmX3Njb3BlZChub2RlLCBkZXNjZW5kKSB7XG4gICAgICAgIHZhciBub2RlX2RlZjtcbiAgICAgICAgY29uc3Qgc3ltID0gYXNzaWduX2FzX3VudXNlZChub2RlKTtcbiAgICAgICAgaWYgKHN5bSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICYmICFpc19yZWZfb2Yobm9kZS5sZWZ0LCBBU1RfU3ltYm9sQmxvY2tEZWNsYXJhdGlvbilcbiAgICAgICAgICAgICYmIHNlbGYudmFyaWFibGVzLmdldChzeW0ubmFtZSkgPT09IChub2RlX2RlZiA9IHN5bS5kZWZpbml0aW9uKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQXNzaWduKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yaWdodC53YWxrKHR3KTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVfZGVmLmNoYWluZWQgJiYgbm9kZS5sZWZ0LmZpeGVkX3ZhbHVlKCkgPT09IG5vZGUucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZml4ZWRfaWRzLnNldChub2RlX2RlZi5pZCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICBub2RlX2RlZiA9IG5vZGUuZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgaWYgKCFpbl91c2VfaWRzLmhhcyhub2RlX2RlZi5pZCkpIHtcbiAgICAgICAgICAgICAgICBpbl91c2VfaWRzLnNldChub2RlX2RlZi5pZCwgbm9kZV9kZWYpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlX2RlZi5vcmlnWzBdIGluc3RhbmNlb2YgQVNUX1N5bWJvbENhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZGVmID0gbm9kZV9kZWYuc2NvcGUuaXNfYmxvY2tfc2NvcGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgbm9kZV9kZWYuc2NvcGUuZ2V0X2RlZnVuX3Njb3BlKCkudmFyaWFibGVzLmdldChub2RlX2RlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZGVmKSBpbl91c2VfaWRzLnNldChyZWRlZi5pZCwgcmVkZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlKSB7XG4gICAgICAgICAgICB2YXIgc2F2ZV9zY29wZSA9IHNjb3BlO1xuICAgICAgICAgICAgc2NvcGUgPSBub2RlO1xuICAgICAgICAgICAgZGVzY2VuZCgpO1xuICAgICAgICAgICAgc2NvcGUgPSBzYXZlX3Njb3BlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuQVNUX1Njb3BlLkRFRk1FVEhPRChcImhvaXN0X2RlY2xhcmF0aW9uc1wiLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChjb21wcmVzc29yLmhhc19kaXJlY3RpdmUoXCJ1c2UgYXNtXCIpKSByZXR1cm4gc2VsZjtcbiAgICAvLyBIb2lzdGluZyBtYWtlcyBubyBzZW5zZSBpbiBhbiBhcnJvdyBmdW5jXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNlbGYuYm9keSkpIHJldHVybiBzZWxmO1xuXG4gICAgdmFyIGhvaXN0X2Z1bnMgPSBjb21wcmVzc29yLm9wdGlvbihcImhvaXN0X2Z1bnNcIik7XG4gICAgdmFyIGhvaXN0X3ZhcnMgPSBjb21wcmVzc29yLm9wdGlvbihcImhvaXN0X3ZhcnNcIik7XG5cbiAgICBpZiAoaG9pc3RfZnVucyB8fCBob2lzdF92YXJzKSB7XG4gICAgICAgIHZhciBkaXJzID0gW107XG4gICAgICAgIHZhciBob2lzdGVkID0gW107XG4gICAgICAgIHZhciB2YXJzID0gbmV3IE1hcCgpLCB2YXJzX2ZvdW5kID0gMCwgdmFyX2RlY2wgPSAwO1xuICAgICAgICAvLyBsZXQncyBjb3VudCB2YXJfZGVjbCBmaXJzdCwgd2Ugc2VlbSB0byB3YXN0ZSBhIGxvdCBvZlxuICAgICAgICAvLyBzcGFjZSBpZiB3ZSBob2lzdCBgdmFyYCB3aGVuIHRoZXJlJ3Mgb25seSBvbmUuXG4gICAgICAgIHdhbGsoc2VsZiwgbm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSAmJiBub2RlICE9PSBzZWxmKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyKSB7XG4gICAgICAgICAgICAgICAgKyt2YXJfZGVjbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGhvaXN0X3ZhcnMgPSBob2lzdF92YXJzICYmIHZhcl9kZWNsID4gMTtcbiAgICAgICAgdmFyIHR0ID0gbmV3IFRyZWVUcmFuc2Zvcm1lcihcbiAgICAgICAgICAgIGZ1bmN0aW9uIGJlZm9yZShub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9FbXB0eVN0YXRlbWVudCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvaXN0X2Z1bnMgJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9EZWZ1blxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgISh0dC5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9FeHBvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiB0dC5wYXJlbnQoKSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9pc3RlZC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0X3ZhcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfVmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAhbm9kZS5kZWZpbml0aW9ucy5zb21lKGRlZiA9PiBkZWYubmFtZSBpbnN0YW5jZW9mIEFTVF9EZXN0cnVjdHVyaW5nKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbihkZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJzLnNldChkZWYubmFtZS5uYW1lLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrdmFyc19mb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcSA9IG5vZGUudG9fYXNzaWdubWVudHMoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHR0LnBhcmVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfRm9ySW4gJiYgcC5pbml0ID09PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSBub2RlLmRlZmluaXRpb25zWzBdLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1N5bWJvbFJlZiwgZGVmLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfRm9yICYmIHAuaW5pdCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlcSkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2VxXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlOyAvLyB0byBhdm9pZCBkZXNjZW5kaW5nIGluIG5lc3RlZCBzY29wZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHNlbGYgPSBzZWxmLnRyYW5zZm9ybSh0dCk7XG4gICAgICAgIGlmICh2YXJzX2ZvdW5kID4gMCkge1xuICAgICAgICAgICAgLy8gY29sbGVjdCBvbmx5IHZhcnMgd2hpY2ggZG9uJ3Qgc2hvdyB1cCBpbiBzZWxmJ3MgYXJndW1lbnRzIGxpc3RcbiAgICAgICAgICAgIHZhciBkZWZzID0gW107XG4gICAgICAgICAgICBjb25zdCBpc19sYW1iZGEgPSBzZWxmIGluc3RhbmNlb2YgQVNUX0xhbWJkYTtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3NfYXNfbmFtZXMgPSBpc19sYW1iZGEgPyBzZWxmLmFyZ3NfYXNfbmFtZXMoKSA6IG51bGw7XG4gICAgICAgICAgICB2YXJzLmZvckVhY2goKGRlZiwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc19sYW1iZGEgJiYgYXJnc19hc19uYW1lcy5zb21lKCh4KSA9PiB4Lm5hbWUgPT09IGRlZi5uYW1lLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcnMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZiA9IGRlZi5jbG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICBkZWYudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkZWZzLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgdmFycy5zZXQobmFtZSwgZGVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkZWZzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gbWVyZ2UgaW4gYXNzaWdubWVudHNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuYm9keS5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmJvZHlbaV0gaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwciA9IHNlbGYuYm9keVtpXS5ib2R5LCBzeW0sIGFzc2lnbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgQVNUX0Fzc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGV4cHIub3BlcmF0b3IgPT0gXCI9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoc3ltID0gZXhwci5sZWZ0KSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB2YXJzLmhhcyhzeW0ubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSB2YXJzLmdldChzeW0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnZhbHVlID0gZXhwci5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoZGVmcywgZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZzLnB1c2goZGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoYXNzaWduID0gZXhwci5leHByZXNzaW9uc1swXSkgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgYXNzaWduLm9wZXJhdG9yID09IFwiPVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKHN5bSA9IGFzc2lnbi5sZWZ0KSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiB2YXJzLmhhcyhzeW0ubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSB2YXJzLmdldChzeW0ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi52YWx1ZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnZhbHVlID0gYXNzaWduLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShkZWZzLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMucHVzaChkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYm9keVtpXS5ib2R5ID0gbWFrZV9zZXF1ZW5jZShleHByLCBleHByLmV4cHJlc3Npb25zLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5ib2R5W2ldIGluc3RhbmNlb2YgQVNUX0VtcHR5U3RhdGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuYm9keVtpXSBpbnN0YW5jZW9mIEFTVF9CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5LnNwbGljZShpLCAxLCAuLi5zZWxmLmJvZHlbaV0uYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmcyA9IG1ha2Vfbm9kZShBU1RfVmFyLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb25zOiBkZWZzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaG9pc3RlZC5wdXNoKGRlZnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuYm9keSA9IGRpcnMuY29uY2F0KGhvaXN0ZWQsIHNlbGYuYm9keSk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbkFTVF9TY29wZS5ERUZNRVRIT0QoXCJob2lzdF9wcm9wZXJ0aWVzXCIsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImhvaXN0X3Byb3BzXCIpIHx8IGNvbXByZXNzb3IuaGFzX2RpcmVjdGl2ZShcInVzZSBhc21cIikpIHJldHVybiBzZWxmO1xuICAgIHZhciB0b3BfcmV0YWluID0gc2VsZiBpbnN0YW5jZW9mIEFTVF9Ub3BsZXZlbCAmJiBjb21wcmVzc29yLnRvcF9yZXRhaW4gfHwgcmV0dXJuX2ZhbHNlO1xuICAgIHZhciBkZWZzX2J5X2lkID0gbmV3IE1hcCgpO1xuICAgIHZhciBob2lzdGVyID0gbmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbihub2RlLCBkZXNjZW5kKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RlZmluaXRpb25zXG4gICAgICAgICAgICAmJiBob2lzdGVyLnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX0V4cG9ydCkgcmV0dXJuIG5vZGU7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1ZhckRlZikge1xuICAgICAgICAgICAgY29uc3Qgc3ltID0gbm9kZS5uYW1lO1xuICAgICAgICAgICAgbGV0IGRlZjtcbiAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChzeW0uc2NvcGUgPT09IHNlbGZcbiAgICAgICAgICAgICAgICAmJiAoZGVmID0gc3ltLmRlZmluaXRpb24oKSkuZXNjYXBlZCAhPSAxXG4gICAgICAgICAgICAgICAgJiYgIWRlZi5hc3NpZ25tZW50c1xuICAgICAgICAgICAgICAgICYmICFkZWYuZGlyZWN0X2FjY2Vzc1xuICAgICAgICAgICAgICAgICYmICFkZWYuc2luZ2xlX3VzZVxuICAgICAgICAgICAgICAgICYmICFjb21wcmVzc29yLmV4cG9zZWQoZGVmKVxuICAgICAgICAgICAgICAgICYmICF0b3BfcmV0YWluKGRlZilcbiAgICAgICAgICAgICAgICAmJiAodmFsdWUgPSBzeW0uZml4ZWRfdmFsdWUoKSkgPT09IG5vZGUudmFsdWVcbiAgICAgICAgICAgICAgICAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFTVF9PYmplY3RcbiAgICAgICAgICAgICAgICAmJiAhdmFsdWUucHJvcGVydGllcy5zb21lKHByb3AgPT5cbiAgICAgICAgICAgICAgICAgICAgcHJvcCBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24gfHwgcHJvcC5jb21wdXRlZF9rZXkoKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRlc2NlbmQobm9kZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc3NpZ25tZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhbHVlLnByb3BlcnRpZXMuZm9yRWFjaCgoeyBrZXksIHZhbHVlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NvcGUgPSBmaW5kX3Njb3BlKGhvaXN0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2wgPSBzZWxmLmNyZWF0ZV9zeW1ib2woc3ltLkNUT1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc3ltLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdF9zY29wZXM6IG5ldyBTZXQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN5bS5kZWZpbml0aW9uKCkucmVmZXJlbmNlcy5tYXAocmVmID0+IHJlZi5zY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVudGF0aXZlX25hbWU6IHN5bS5uYW1lICsgXCJfXCIgKyBrZXlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmcy5zZXQoU3RyaW5nKGtleSksIHN5bWJvbC5kZWZpbml0aW9uKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRzLnB1c2gobWFrZV9ub2RlKEFTVF9WYXJEZWYsIG5vZGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWZzX2J5X2lkLnNldChkZWYuaWQsIGRlZnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBNQVAuc3BsaWNlKGFzc2lnbm1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3NcbiAgICAgICAgICAgICYmIG5vZGUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZzID0gZGVmc19ieV9pZC5nZXQobm9kZS5leHByZXNzaW9uLmRlZmluaXRpb24oKS5pZCk7XG4gICAgICAgICAgICBpZiAoZGVmcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZiA9IGRlZnMuZ2V0KFN0cmluZyhnZXRfdmFsdWUobm9kZS5wcm9wZXJ0eSkpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW0gPSBtYWtlX25vZGUoQVNUX1N5bWJvbFJlZiwgbm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBkZWYubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2NvcGU6IG5vZGUuZXhwcmVzc2lvbi5zY29wZSxcbiAgICAgICAgICAgICAgICAgICAgdGhlZGVmOiBkZWZcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzeW0ucmVmZXJlbmNlKHt9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ltO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGYudHJhbnNmb3JtKGhvaXN0ZXIpO1xufSk7XG5cbi8vIGRyb3Bfc2lkZV9lZmZlY3RfZnJlZSgpXG4vLyByZW1vdmUgc2lkZS1lZmZlY3QtZnJlZSBwYXJ0cyB3aGljaCBvbmx5IGFmZmVjdHMgcmV0dXJuIHZhbHVlXG4oZnVuY3Rpb24oZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZSkge1xuICAgIC8vIERyb3Agc2lkZS1lZmZlY3QtZnJlZSBlbGVtZW50cyBmcm9tIGFuIGFycmF5IG9mIGV4cHJlc3Npb25zLlxuICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgZXhwcmVzc2lvbnMgd2l0aCBzaWRlLWVmZmVjdHMgb3IgbnVsbFxuICAgIC8vIGlmIGFsbCBlbGVtZW50cyB3ZXJlIGRyb3BwZWQuIE5vdGU6IG9yaWdpbmFsIGFycmF5IG1heSBiZVxuICAgIC8vIHJldHVybmVkIGlmIG5vdGhpbmcgY2hhbmdlZC5cbiAgICBmdW5jdGlvbiB0cmltKG5vZGVzLCBjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgaWYgKCFsZW4pIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgcmV0ID0gW10sIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICAgICAgICAgIGNoYW5nZWQgfD0gbm9kZSAhPT0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGZpcnN0X2luX3N0YXRlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkID8gcmV0Lmxlbmd0aCA/IHJldCA6IG51bGwgOiBub2RlcztcbiAgICB9XG5cbiAgICBkZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9Ob2RlLCByZXR1cm5fdGhpcyk7XG4gICAgZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfQ29uc3RhbnQsIHJldHVybl9udWxsKTtcbiAgICBkZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9UaGlzLCByZXR1cm5fbnVsbCk7XG4gICAgZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfQ2FsbCwgZnVuY3Rpb24oY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsICYmIGlzX251bGxpc2godGhpcy5leHByZXNzaW9uLCBjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc19jYWxsZWVfcHVyZShjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhwcmVzc2lvbi5pc19jYWxsX3B1cmUoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwcnMgPSB0aGlzLmFyZ3Muc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBleHBycy51bnNoaWZ0KHRoaXMuZXhwcmVzc2lvbi5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBleHBycyA9IHRyaW0oZXhwcnMsIGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJzICYmIG1ha2Vfc2VxdWVuY2UodGhpcywgZXhwcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzX2Z1bmNfZXhwcih0aGlzLmV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgJiYgKCF0aGlzLmV4cHJlc3Npb24ubmFtZSB8fCAhdGhpcy5leHByZXNzaW9uLm5hbWUuZGVmaW5pdGlvbigpLnJlZmVyZW5jZXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbi5wcm9jZXNzX2V4cHJlc3Npb24oZmFsc2UsIGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ3MgPSB0cmltKHRoaXMuYXJncywgY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGFyZ3MgJiYgbWFrZV9zZXF1ZW5jZSh0aGlzLCBhcmdzKTtcbiAgICB9KTtcbiAgICBkZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9BY2Nlc3NvciwgcmV0dXJuX251bGwpO1xuICAgIGRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoQVNUX0Z1bmN0aW9uLCByZXR1cm5fbnVsbCk7XG4gICAgZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfQXJyb3csIHJldHVybl9udWxsKTtcbiAgICBkZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9DbGFzcywgZnVuY3Rpb24gKGNvbXByZXNzb3IpIHtcbiAgICAgICAgY29uc3Qgd2l0aF9lZmZlY3RzID0gW107XG4gICAgICAgIGNvbnN0IHRyaW1tZWRfZXh0ZW5kcyA9IHRoaXMuZXh0ZW5kcyAmJiB0aGlzLmV4dGVuZHMuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAodHJpbW1lZF9leHRlbmRzKSB3aXRoX2VmZmVjdHMucHVzaCh0cmltbWVkX2V4dGVuZHMpO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgdGhpcy5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBjb25zdCB0cmltbWVkX3Byb3AgPSBwcm9wLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIGlmICh0cmltbWVkX3Byb3ApIHdpdGhfZWZmZWN0cy5wdXNoKHRyaW1tZWRfcHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3aXRoX2VmZmVjdHMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2UodGhpcywgd2l0aF9lZmZlY3RzKTtcbiAgICB9KTtcbiAgICBkZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9CaW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJpZ2h0LmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKCFyaWdodCkgcmV0dXJuIHRoaXMubGVmdC5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICAgICAgaWYgKGxhenlfb3AuaGFzKHRoaXMub3BlcmF0b3IpKSB7XG4gICAgICAgICAgICBpZiAocmlnaHQgPT09IHRoaXMucmlnaHQpIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICBub2RlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5sZWZ0LmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFsZWZ0KSByZXR1cm4gdGhpcy5yaWdodC5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHRoaXMsIFsgbGVmdCwgcmlnaHQgXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9Bc3NpZ24sIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgaWYgKHRoaXMubG9naWNhbCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICAgIGlmIChsZWZ0Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IGNvbXByZXNzb3IuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIilcbiAgICAgICAgICAgICAgICAmJiBsZWZ0IGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3NcbiAgICAgICAgICAgICAgICAmJiBsZWZ0LmV4cHJlc3Npb24uaXNfY29uc3RhbnQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc2V0X2ZsYWcodGhpcywgV1JJVEVfT05MWSk7XG4gICAgICAgIHdoaWxlIChsZWZ0IGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MpIHtcbiAgICAgICAgICAgIGxlZnQgPSBsZWZ0LmV4cHJlc3Npb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQuaXNfY29uc3RhbnRfZXhwcmVzc2lvbihjb21wcmVzc29yLmZpbmRfcGFyZW50KEFTVF9TY29wZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSk7XG4gICAgZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgdmFyIGNvbnNlcXVlbnQgPSB0aGlzLmNvbnNlcXVlbnQuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IpO1xuICAgICAgICB2YXIgYWx0ZXJuYXRpdmUgPSB0aGlzLmFsdGVybmF0aXZlLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKGNvbnNlcXVlbnQgPT09IHRoaXMuY29uc2VxdWVudCAmJiBhbHRlcm5hdGl2ZSA9PT0gdGhpcy5hbHRlcm5hdGl2ZSkgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICghY29uc2VxdWVudCkgcmV0dXJuIGFsdGVybmF0aXZlID8gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHRoaXMsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcInx8XCIsXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLmNvbmRpdGlvbixcbiAgICAgICAgICAgIHJpZ2h0OiBhbHRlcm5hdGl2ZVxuICAgICAgICB9KSA6IHRoaXMuY29uZGl0aW9uLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKCFhbHRlcm5hdGl2ZSkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCB0aGlzLCB7XG4gICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgbGVmdDogdGhpcy5jb25kaXRpb24sXG4gICAgICAgICAgICByaWdodDogY29uc2VxdWVudFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIG5vZGUuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XG4gICAgICAgIG5vZGUuYWx0ZXJuYXRpdmUgPSBhbHRlcm5hdGl2ZTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfVW5hcnksIGZ1bmN0aW9uKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgICAgICBpZiAodW5hcnlfc2lkZV9lZmZlY3RzLmhhcyh0aGlzLm9wZXJhdG9yKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV4cHJlc3Npb24uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgIHNldF9mbGFnKHRoaXMsIFdSSVRFX09OTFkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhcl9mbGFnKHRoaXMsIFdSSVRFX09OTFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3BlcmF0b3IgPT0gXCJ0eXBlb2ZcIiAmJiB0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24uZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgICAgIGlmIChmaXJzdF9pbl9zdGF0ZW1lbnQgJiYgZXhwcmVzc2lvbiAmJiBpc19paWZlX2NhbGwoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uID09PSB0aGlzLmV4cHJlc3Npb24gJiYgdGhpcy5vcGVyYXRvciA9PSBcIiFcIikgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbi5uZWdhdGUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICB9KTtcbiAgICBkZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9TeW1ib2xSZWYsIGZ1bmN0aW9uKGNvbXByZXNzb3IpIHtcbiAgICAgICAgY29uc3Qgc2FmZV9hY2Nlc3MgPSB0aGlzLmlzX2RlY2xhcmVkKGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCBwdXJlX3Byb3BfYWNjZXNzX2dsb2JhbHMuaGFzKHRoaXMubmFtZSk7XG4gICAgICAgIHJldHVybiBzYWZlX2FjY2VzcyA/IG51bGwgOiB0aGlzO1xuICAgIH0pO1xuICAgIGRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoQVNUX09iamVjdCwgZnVuY3Rpb24oY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0cmltKHRoaXMucHJvcGVydGllcywgY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyAmJiBtYWtlX3NlcXVlbmNlKHRoaXMsIHZhbHVlcyk7XG4gICAgfSk7XG4gICAgZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfT2JqZWN0UHJvcGVydHksIGZ1bmN0aW9uKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgICAgICBjb25zdCBjb21wdXRlZF9rZXkgPSB0aGlzIGluc3RhbmNlb2YgQVNUX09iamVjdEtleVZhbCAmJiB0aGlzLmtleSBpbnN0YW5jZW9mIEFTVF9Ob2RlO1xuICAgICAgICBjb25zdCBrZXkgPSBjb21wdXRlZF9rZXkgJiYgdGhpcy5rZXkuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZSAmJiB0aGlzLnZhbHVlLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgICAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZSh0aGlzLCBba2V5LCB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXkgfHwgdmFsdWU7XG4gICAgfSk7XG4gICAgZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfQ2xhc3NQcm9wZXJ0eSwgZnVuY3Rpb24gKGNvbXByZXNzb3IpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5jb21wdXRlZF9rZXkoKSAmJiB0aGlzLmtleS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnN0YXRpYyAmJiB0aGlzLnZhbHVlXG4gICAgICAgICAgICAmJiB0aGlzLnZhbHVlLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcblxuICAgICAgICBpZiAoa2V5ICYmIHZhbHVlKSByZXR1cm4gbWFrZV9zZXF1ZW5jZSh0aGlzLCBba2V5LCB2YWx1ZV0pO1xuICAgICAgICByZXR1cm4ga2V5IHx8IHZhbHVlIHx8IG51bGw7XG4gICAgfSk7XG4gICAgZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfQ29uY2lzZU1ldGhvZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlZF9rZXkoKSA/IHRoaXMua2V5IDogbnVsbDtcbiAgICB9KTtcbiAgICBkZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9PYmplY3RHZXR0ZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZWRfa2V5KCkgPyB0aGlzLmtleSA6IG51bGw7XG4gICAgfSk7XG4gICAgZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfT2JqZWN0U2V0dGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVkX2tleSgpID8gdGhpcy5rZXkgOiBudWxsO1xuICAgIH0pO1xuICAgIGRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoQVNUX0FycmF5LCBmdW5jdGlvbihjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHRyaW0odGhpcy5lbGVtZW50cywgY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcyAmJiBtYWtlX3NlcXVlbmNlKHRoaXMsIHZhbHVlcyk7XG4gICAgfSk7XG4gICAgZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfRG90LCBmdW5jdGlvbihjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpc19udWxsaXNoKHRoaXMuZXhwcmVzc2lvbiwgY29tcHJlc3NvcikgPyBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgdGhpcykgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4cHJlc3Npb24ubWF5X3Rocm93X29uX2FjY2Vzcyhjb21wcmVzc29yKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICB9KTtcbiAgICBkZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9TdWIsIGZ1bmN0aW9uKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzX251bGxpc2godGhpcy5leHByZXNzaW9uLCBjb21wcmVzc29yKSA/IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCB0aGlzKTogdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uLm1heV90aHJvd19vbl9hY2Nlc3MoY29tcHJlc3NvcikpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgICAgICBpZiAoIWV4cHJlc3Npb24pIHJldHVybiB0aGlzLnByb3BlcnR5LmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnByb3BlcnR5LmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgaWYgKCFwcm9wZXJ0eSkgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHRoaXMsIFsgZXhwcmVzc2lvbiwgcHJvcGVydHkgXSk7XG4gICAgfSk7XG4gICAgZGVmX2Ryb3Bfc2lkZV9lZmZlY3RfZnJlZShBU1RfQ2hhaW4sIGZ1bmN0aW9uIChjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KTtcbiAgICB9KTtcbiAgICBkZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9TZXF1ZW5jZSwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgICAgICB2YXIgbGFzdCA9IHRoaXMudGFpbF9ub2RlKCk7XG4gICAgICAgIHZhciBleHByID0gbGFzdC5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChleHByID09PSBsYXN0KSByZXR1cm4gdGhpcztcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gdGhpcy5leHByZXNzaW9ucy5zbGljZSgwLCAtMSk7XG4gICAgICAgIGlmIChleHByKSBleHByZXNzaW9ucy5wdXNoKGV4cHIpO1xuICAgICAgICBpZiAoIWV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfTnVtYmVyLCB0aGlzLCB7IHZhbHVlOiAwIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHRoaXMsIGV4cHJlc3Npb25zKTtcbiAgICB9KTtcbiAgICBkZWZfZHJvcF9zaWRlX2VmZmVjdF9mcmVlKEFTVF9FeHBhbnNpb24sIGZ1bmN0aW9uKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yLCBmaXJzdF9pbl9zdGF0ZW1lbnQpO1xuICAgIH0pO1xuICAgIGRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoQVNUX1RlbXBsYXRlU2VnbWVudCwgcmV0dXJuX251bGwpO1xuICAgIGRlZl9kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoQVNUX1RlbXBsYXRlU3RyaW5nLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB0cmltKHRoaXMuc2VnbWVudHMsIGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudCk7XG4gICAgICAgIHJldHVybiB2YWx1ZXMgJiYgbWFrZV9zZXF1ZW5jZSh0aGlzLCB2YWx1ZXMpO1xuICAgIH0pO1xufSkoZnVuY3Rpb24obm9kZSwgZnVuYykge1xuICAgIG5vZGUuREVGTUVUSE9EKFwiZHJvcF9zaWRlX2VmZmVjdF9mcmVlXCIsIGZ1bmMpO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfU2ltcGxlU3RhdGVtZW50LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwic2lkZV9lZmZlY3RzXCIpKSB7XG4gICAgICAgIHZhciBib2R5ID0gc2VsZi5ib2R5O1xuICAgICAgICB2YXIgbm9kZSA9IGJvZHkuZHJvcF9zaWRlX2VmZmVjdF9mcmVlKGNvbXByZXNzb3IsIHRydWUpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSAhPT0gYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLCB7IGJvZHk6IG5vZGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9XaGlsZSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIHJldHVybiBjb21wcmVzc29yLm9wdGlvbihcImxvb3BzXCIpID8gbWFrZV9ub2RlKEFTVF9Gb3IsIHNlbGYsIHNlbGYpLm9wdGltaXplKGNvbXByZXNzb3IpIDogc2VsZjtcbn0pO1xuXG5mdW5jdGlvbiBoYXNfYnJlYWtfb3JfY29udGludWUobG9vcCwgcGFyZW50KSB7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgdmFyIHR3ID0gbmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoZm91bmQgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0xvb3BDb250cm9sICYmIHR3Lmxvb3Bjb250cm9sX3RhcmdldChub2RlKSA9PT0gbG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfTGFiZWxlZFN0YXRlbWVudCkgdHcucHVzaChwYXJlbnQpO1xuICAgIHR3LnB1c2gobG9vcCk7XG4gICAgbG9vcC5ib2R5LndhbGsodHcpO1xuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZGVmX29wdGltaXplKEFTVF9EbywgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJsb29wc1wiKSkgcmV0dXJuIHNlbGY7XG4gICAgdmFyIGNvbmQgPSBzZWxmLmNvbmRpdGlvbi50YWlsX25vZGUoKS5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICBpZiAoIShjb25kIGluc3RhbmNlb2YgQVNUX05vZGUpKSB7XG4gICAgICAgIGlmIChjb25kKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9Gb3IsIHNlbGYsIHtcbiAgICAgICAgICAgIGJvZHk6IG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYuYm9keSwge1xuICAgICAgICAgICAgICAgIGJvZHk6IFtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5ib2R5LFxuICAgICAgICAgICAgICAgICAgICBtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZi5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHNlbGYuY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmICghaGFzX2JyZWFrX29yX2NvbnRpbnVlKHNlbGYsIGNvbXByZXNzb3IucGFyZW50KCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZi5ib2R5LCB7XG4gICAgICAgICAgICAgICAgYm9keTogW1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJvZHksXG4gICAgICAgICAgICAgICAgICAgIG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2VsZi5jb25kaXRpb25cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5mdW5jdGlvbiBpZl9icmVha19pbl9sb29wKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICB2YXIgZmlyc3QgPSBzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfQmxvY2tTdGF0ZW1lbnQgPyBzZWxmLmJvZHkuYm9keVswXSA6IHNlbGYuYm9keTtcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJkZWFkX2NvZGVcIikgJiYgaXNfYnJlYWsoZmlyc3QpKSB7XG4gICAgICAgIHZhciBib2R5ID0gW107XG4gICAgICAgIGlmIChzZWxmLmluaXQgaW5zdGFuY2VvZiBBU1RfU3RhdGVtZW50KSB7XG4gICAgICAgICAgICBib2R5LnB1c2goc2VsZi5pbml0KTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmluaXQpIHtcbiAgICAgICAgICAgIGJvZHkucHVzaChtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZi5pbml0LCB7XG4gICAgICAgICAgICAgICAgYm9keTogc2VsZi5pbml0XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uKSB7XG4gICAgICAgICAgICBib2R5LnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYuY29uZGl0aW9uLCB7XG4gICAgICAgICAgICAgICAgYm9keTogc2VsZi5jb25kaXRpb25cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0cmltX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc2VsZi5ib2R5LCBib2R5KTtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgIGJvZHk6IGJvZHlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChmaXJzdCBpbnN0YW5jZW9mIEFTVF9JZikge1xuICAgICAgICBpZiAoaXNfYnJlYWsoZmlyc3QuYm9keSkpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYuY29uZGl0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogZmlyc3QuY29uZGl0aW9uLm5lZ2F0ZShjb21wcmVzc29yKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBmaXJzdC5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHJvcF9pdChmaXJzdC5hbHRlcm5hdGl2ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNfYnJlYWsoZmlyc3QuYWx0ZXJuYXRpdmUpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiJiZcIixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGZpcnN0LmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jb25kaXRpb24gPSBmaXJzdC5jb25kaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkcm9wX2l0KGZpcnN0LmJvZHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gaXNfYnJlYWsobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEFTVF9CcmVha1xuICAgICAgICAgICAgJiYgY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQobm9kZSkgPT09IGNvbXByZXNzb3Iuc2VsZigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyb3BfaXQocmVzdCkge1xuICAgICAgICByZXN0ID0gYXNfc3RhdGVtZW50X2FycmF5KHJlc3QpO1xuICAgICAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX0Jsb2NrU3RhdGVtZW50KSB7XG4gICAgICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmJvZHkuY2xvbmUoKTtcbiAgICAgICAgICAgIHNlbGYuYm9keS5ib2R5ID0gcmVzdC5jb25jYXQoc2VsZi5ib2R5LmJvZHkuc2xpY2UoMSkpO1xuICAgICAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5ib2R5LnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuYm9keSA9IG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYuYm9keSwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHJlc3RcbiAgICAgICAgICAgIH0pLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmID0gaWZfYnJlYWtfaW5fbG9vcChzZWxmLCBjb21wcmVzc29yKTtcbiAgICB9XG59XG5cbmRlZl9vcHRpbWl6ZShBU1RfRm9yLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImxvb3BzXCIpKSByZXR1cm4gc2VsZjtcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIikgJiYgc2VsZi5pbml0KSB7XG4gICAgICAgIHNlbGYuaW5pdCA9IHNlbGYuaW5pdC5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgfVxuICAgIGlmIChzZWxmLmNvbmRpdGlvbikge1xuICAgICAgICB2YXIgY29uZCA9IHNlbGYuY29uZGl0aW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAoIShjb25kIGluc3RhbmNlb2YgQVNUX05vZGUpKSB7XG4gICAgICAgICAgICBpZiAoY29uZCkgc2VsZi5jb25kaXRpb24gPSBudWxsO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWcgPSBzZWxmLmNvbmRpdGlvbjtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGNvbmQsIHNlbGYuY29uZGl0aW9uKTtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmRpdGlvbiA9IGJlc3Rfb2ZfZXhwcmVzc2lvbihzZWxmLmNvbmRpdGlvbi50cmFuc2Zvcm0oY29tcHJlc3NvciksIG9yaWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSkge1xuICAgICAgICAgICAgaWYgKGNvbmQgaW5zdGFuY2VvZiBBU1RfTm9kZSkgY29uZCA9IHNlbGYuY29uZGl0aW9uLnRhaWxfbm9kZSgpLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgaWYgKCFjb25kKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgICAgICAgICB0cmltX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc2VsZi5ib2R5LCBib2R5KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5pbml0IGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2goc2VsZi5pbml0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuaW5pdCkge1xuICAgICAgICAgICAgICAgICAgICBib2R5LnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYuaW5pdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2VsZi5pbml0XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm9keS5wdXNoKG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiBzZWxmLmNvbmRpdGlvblxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwgeyBib2R5OiBib2R5IH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZl9icmVha19pbl9sb29wKHNlbGYsIGNvbXByZXNzb3IpO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfSWYsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoaXNfZW1wdHkoc2VsZi5hbHRlcm5hdGl2ZSkpIHNlbGYuYWx0ZXJuYXRpdmUgPSBudWxsO1xuXG4gICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImNvbmRpdGlvbmFsc1wiKSkgcmV0dXJuIHNlbGY7XG4gICAgLy8gaWYgY29uZGl0aW9uIGNhbiBiZSBzdGF0aWNhbGx5IGRldGVybWluZWQsIGRyb3BcbiAgICAvLyBvbmUgb2YgdGhlIGJsb2Nrcy4gIG5vdGUsIHN0YXRpY2FsbHkgZGV0ZXJtaW5lZCBpbXBsaWVzXG4gICAgLy8g4oCcaGFzIG5vIHNpZGUgZWZmZWN0c+KAnTsgYWxzbyBpdCBkb2Vzbid0IHdvcmsgZm9yIGNhc2VzIGxpa2VcbiAgICAvLyBgeCAmJiB0cnVlYCwgdGhvdWdoIGl0IHByb2JhYmx5IHNob3VsZC5cbiAgICB2YXIgY29uZCA9IHNlbGYuY29uZGl0aW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJkZWFkX2NvZGVcIikgJiYgIShjb25kIGluc3RhbmNlb2YgQVNUX05vZGUpKSB7XG4gICAgICAgIHZhciBvcmlnID0gc2VsZi5jb25kaXRpb247XG4gICAgICAgIHNlbGYuY29uZGl0aW9uID0gbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoY29uZCwgb3JpZyk7XG4gICAgICAgIHNlbGYuY29uZGl0aW9uID0gYmVzdF9vZl9leHByZXNzaW9uKHNlbGYuY29uZGl0aW9uLnRyYW5zZm9ybShjb21wcmVzc29yKSwgb3JpZyk7XG4gICAgfVxuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSkge1xuICAgICAgICBpZiAoY29uZCBpbnN0YW5jZW9mIEFTVF9Ob2RlKSBjb25kID0gc2VsZi5jb25kaXRpb24udGFpbF9ub2RlKCkuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmICghY29uZCkge1xuICAgICAgICAgICAgdmFyIGJvZHkgPSBbXTtcbiAgICAgICAgICAgIHRyaW1fdW5yZWFjaGFibGVfY29kZShjb21wcmVzc29yLCBzZWxmLmJvZHksIGJvZHkpO1xuICAgICAgICAgICAgYm9keS5wdXNoKG1ha2Vfbm9kZShBU1RfU2ltcGxlU3RhdGVtZW50LCBzZWxmLmNvbmRpdGlvbiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHNlbGYuY29uZGl0aW9uXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSkgYm9keS5wdXNoKHNlbGYuYWx0ZXJuYXRpdmUpO1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYsIHsgYm9keTogYm9keSB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgfSBlbHNlIGlmICghKGNvbmQgaW5zdGFuY2VvZiBBU1RfTm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gW107XG4gICAgICAgICAgICBib2R5LnB1c2gobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYuY29uZGl0aW9uLCB7XG4gICAgICAgICAgICAgICAgYm9keTogc2VsZi5jb25kaXRpb25cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGJvZHkucHVzaChzZWxmLmJvZHkpO1xuICAgICAgICAgICAgaWYgKHNlbGYuYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICB0cmltX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3Nvciwgc2VsZi5hbHRlcm5hdGl2ZSwgYm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwgeyBib2R5OiBib2R5IH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBuZWdhdGVkID0gc2VsZi5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgIHZhciBzZWxmX2NvbmRpdGlvbl9sZW5ndGggPSBzZWxmLmNvbmRpdGlvbi5zaXplKCk7XG4gICAgdmFyIG5lZ2F0ZWRfbGVuZ3RoID0gbmVnYXRlZC5zaXplKCk7XG4gICAgdmFyIG5lZ2F0ZWRfaXNfYmVzdCA9IG5lZ2F0ZWRfbGVuZ3RoIDwgc2VsZl9jb25kaXRpb25fbGVuZ3RoO1xuICAgIGlmIChzZWxmLmFsdGVybmF0aXZlICYmIG5lZ2F0ZWRfaXNfYmVzdCkge1xuICAgICAgICBuZWdhdGVkX2lzX2Jlc3QgPSBmYWxzZTsgLy8gYmVjYXVzZSB3ZSBhbHJlYWR5IGRvIHRoZSBzd2l0Y2ggaGVyZS5cbiAgICAgICAgLy8gbm8gbmVlZCB0byBzd2FwIHZhbHVlcyBvZiBzZWxmX2NvbmRpdGlvbl9sZW5ndGggYW5kIG5lZ2F0ZWRfbGVuZ3RoXG4gICAgICAgIC8vIGhlcmUgYmVjYXVzZSB0aGV5IGFyZSBvbmx5IHVzZWQgaW4gYW4gZXF1YWxpdHkgY29tcGFyaXNvbiBsYXRlciBvbi5cbiAgICAgICAgc2VsZi5jb25kaXRpb24gPSBuZWdhdGVkO1xuICAgICAgICB2YXIgdG1wID0gc2VsZi5ib2R5O1xuICAgICAgICBzZWxmLmJvZHkgPSBzZWxmLmFsdGVybmF0aXZlIHx8IG1ha2Vfbm9kZShBU1RfRW1wdHlTdGF0ZW1lbnQsIHNlbGYpO1xuICAgICAgICBzZWxmLmFsdGVybmF0aXZlID0gdG1wO1xuICAgIH1cbiAgICBpZiAoaXNfZW1wdHkoc2VsZi5ib2R5KSAmJiBpc19lbXB0eShzZWxmLmFsdGVybmF0aXZlKSkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYuY29uZGl0aW9uLCB7XG4gICAgICAgICAgICBib2R5OiBzZWxmLmNvbmRpdGlvbi5jbG9uZSgpXG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudFxuICAgICAgICAmJiBzZWxmLmFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgIGJvZHk6IG1ha2Vfbm9kZShBU1RfQ29uZGl0aW9uYWwsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb24gICA6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQgIDogc2VsZi5ib2R5LmJvZHksXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmUgOiBzZWxmLmFsdGVybmF0aXZlLmJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICBpZiAoaXNfZW1wdHkoc2VsZi5hbHRlcm5hdGl2ZSkgJiYgc2VsZi5ib2R5IGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICBpZiAoc2VsZl9jb25kaXRpb25fbGVuZ3RoID09PSBuZWdhdGVkX2xlbmd0aCAmJiAhbmVnYXRlZF9pc19iZXN0XG4gICAgICAgICAgICAmJiBzZWxmLmNvbmRpdGlvbiBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgc2VsZi5jb25kaXRpb24ub3BlcmF0b3IgPT0gXCJ8fFwiKSB7XG4gICAgICAgICAgICAvLyBhbHRob3VnaCB0aGUgY29kZSBsZW5ndGggb2Ygc2VsZi5jb25kaXRpb24gYW5kIG5lZ2F0ZWQgYXJlIHRoZSBzYW1lLFxuICAgICAgICAgICAgLy8gbmVnYXRlZCBkb2VzIG5vdCByZXF1aXJlIGFkZGl0aW9uYWwgc3Vycm91bmRpbmcgcGFyZW50aGVzZXMuXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvaXNzdWVzLzk3OVxuICAgICAgICAgICAgbmVnYXRlZF9pc19iZXN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVnYXRlZF9pc19iZXN0KSByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgIGJvZHk6IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBcInx8XCIsXG4gICAgICAgICAgICAgICAgbGVmdCAgICAgOiBuZWdhdGVkLFxuICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogc2VsZi5ib2R5LmJvZHlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgIGJvZHk6IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBcIiYmXCIsXG4gICAgICAgICAgICAgICAgbGVmdCAgICAgOiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICByaWdodCAgICA6IHNlbGYuYm9keS5ib2R5XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuYm9keSBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudFxuICAgICAgICAmJiBzZWxmLmFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgIGJvZHk6IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBcInx8XCIsXG4gICAgICAgICAgICAgICAgbGVmdCAgICAgOiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICByaWdodCAgICA6IHNlbGYuYWx0ZXJuYXRpdmUuYm9keVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgfVxuICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfRXhpdFxuICAgICAgICAmJiBzZWxmLmFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX0V4aXRcbiAgICAgICAgJiYgc2VsZi5ib2R5LlRZUEUgPT0gc2VsZi5hbHRlcm5hdGl2ZS5UWVBFKSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoc2VsZi5ib2R5LkNUT1IsIHNlbGYsIHtcbiAgICAgICAgICAgIHZhbHVlOiBtYWtlX25vZGUoQVNUX0NvbmRpdGlvbmFsLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgY29uZGl0aW9uICAgOiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW50ICA6IHNlbGYuYm9keS52YWx1ZSB8fCBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZi5ib2R5KSxcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZSA6IHNlbGYuYWx0ZXJuYXRpdmUudmFsdWUgfHwgbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYuYWx0ZXJuYXRpdmUpXG4gICAgICAgICAgICB9KS50cmFuc2Zvcm0oY29tcHJlc3NvcilcbiAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgfVxuICAgIGlmIChzZWxmLmJvZHkgaW5zdGFuY2VvZiBBU1RfSWZcbiAgICAgICAgJiYgIXNlbGYuYm9keS5hbHRlcm5hdGl2ZVxuICAgICAgICAmJiAhc2VsZi5hbHRlcm5hdGl2ZSkge1xuICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9JZiwgc2VsZiwge1xuICAgICAgICAgICAgY29uZGl0aW9uOiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZi5jb25kaXRpb24sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLmJvZHkuY29uZGl0aW9uXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGJvZHk6IHNlbGYuYm9keS5ib2R5LFxuICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhYm9ydHMoc2VsZi5ib2R5KSkge1xuICAgICAgICBpZiAoc2VsZi5hbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgdmFyIGFsdCA9IHNlbGYuYWx0ZXJuYXRpdmU7XG4gICAgICAgICAgICBzZWxmLmFsdGVybmF0aXZlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgYm9keTogWyBzZWxmLCBhbHQgXVxuICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFib3J0cyhzZWxmLmFsdGVybmF0aXZlKSkge1xuICAgICAgICB2YXIgYm9keSA9IHNlbGYuYm9keTtcbiAgICAgICAgc2VsZi5ib2R5ID0gc2VsZi5hbHRlcm5hdGl2ZTtcbiAgICAgICAgc2VsZi5jb25kaXRpb24gPSBuZWdhdGVkX2lzX2Jlc3QgPyBuZWdhdGVkIDogc2VsZi5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpO1xuICAgICAgICBzZWxmLmFsdGVybmF0aXZlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIHNlbGYsIHtcbiAgICAgICAgICAgIGJvZHk6IFsgc2VsZiwgYm9keSBdXG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX1N3aXRjaCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJzd2l0Y2hlc1wiKSkgcmV0dXJuIHNlbGY7XG4gICAgdmFyIGJyYW5jaDtcbiAgICB2YXIgdmFsdWUgPSBzZWxmLmV4cHJlc3Npb24uZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBU1RfTm9kZSkpIHtcbiAgICAgICAgdmFyIG9yaWcgPSBzZWxmLmV4cHJlc3Npb247XG4gICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KHZhbHVlLCBvcmlnKTtcbiAgICAgICAgc2VsZi5leHByZXNzaW9uID0gYmVzdF9vZl9leHByZXNzaW9uKHNlbGYuZXhwcmVzc2lvbi50cmFuc2Zvcm0oY29tcHJlc3NvciksIG9yaWcpO1xuICAgIH1cbiAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpKSByZXR1cm4gc2VsZjtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBU1RfTm9kZSkge1xuICAgICAgICB2YWx1ZSA9IHNlbGYuZXhwcmVzc2lvbi50YWlsX25vZGUoKS5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICB9XG4gICAgdmFyIGRlY2wgPSBbXTtcbiAgICB2YXIgYm9keSA9IFtdO1xuICAgIHZhciBkZWZhdWx0X2JyYW5jaDtcbiAgICB2YXIgZXhhY3RfbWF0Y2g7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYuYm9keS5sZW5ndGg7IGkgPCBsZW4gJiYgIWV4YWN0X21hdGNoOyBpKyspIHtcbiAgICAgICAgYnJhbmNoID0gc2VsZi5ib2R5W2ldO1xuICAgICAgICBpZiAoYnJhbmNoIGluc3RhbmNlb2YgQVNUX0RlZmF1bHQpIHtcbiAgICAgICAgICAgIGlmICghZGVmYXVsdF9icmFuY2gpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0X2JyYW5jaCA9IGJyYW5jaDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxpbWluYXRlX2JyYW5jaChicmFuY2gsIGJvZHlbYm9keS5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFTVF9Ob2RlKSkge1xuICAgICAgICAgICAgdmFyIGV4cCA9IGJyYW5jaC5leHByZXNzaW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgaWYgKCEoZXhwIGluc3RhbmNlb2YgQVNUX05vZGUpICYmIGV4cCAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbGltaW5hdGVfYnJhbmNoKGJyYW5jaCwgYm9keVtib2R5Lmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHAgaW5zdGFuY2VvZiBBU1RfTm9kZSkgZXhwID0gYnJhbmNoLmV4cHJlc3Npb24udGFpbF9ub2RlKCkuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBpZiAoZXhwID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGV4YWN0X21hdGNoID0gYnJhbmNoO1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0X2JyYW5jaCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdF9pbmRleCA9IGJvZHkuaW5kZXhPZihkZWZhdWx0X2JyYW5jaCk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkuc3BsaWNlKGRlZmF1bHRfaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBlbGltaW5hdGVfYnJhbmNoKGRlZmF1bHRfYnJhbmNoLCBib2R5W2RlZmF1bHRfaW5kZXggLSAxXSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRfYnJhbmNoID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFib3J0cyhicmFuY2gpKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IGJvZHlbYm9keS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChhYm9ydHMocHJldikgJiYgcHJldi5ib2R5Lmxlbmd0aCA9PSBicmFuY2guYm9keS5sZW5ndGhcbiAgICAgICAgICAgICAgICAmJiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBwcmV2LCBwcmV2KS5lcXVpdmFsZW50X3RvKG1ha2Vfbm9kZShBU1RfQmxvY2tTdGF0ZW1lbnQsIGJyYW5jaCwgYnJhbmNoKSkpIHtcbiAgICAgICAgICAgICAgICBwcmV2LmJvZHkgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBib2R5LnB1c2goYnJhbmNoKTtcbiAgICB9XG4gICAgd2hpbGUgKGkgPCBsZW4pIGVsaW1pbmF0ZV9icmFuY2goc2VsZi5ib2R5W2krK10sIGJvZHlbYm9keS5sZW5ndGggLSAxXSk7XG4gICAgaWYgKGJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICBib2R5WzBdLmJvZHkgPSBkZWNsLmNvbmNhdChib2R5WzBdLmJvZHkpO1xuICAgIH1cbiAgICBzZWxmLmJvZHkgPSBib2R5O1xuICAgIHdoaWxlIChicmFuY2ggPSBib2R5W2JvZHkubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgdmFyIHN0YXQgPSBicmFuY2guYm9keVticmFuY2guYm9keS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfQnJlYWsgJiYgY29tcHJlc3Nvci5sb29wY29udHJvbF90YXJnZXQoc3RhdCkgPT09IHNlbGYpXG4gICAgICAgICAgICBicmFuY2guYm9keS5wb3AoKTtcbiAgICAgICAgaWYgKGJyYW5jaC5ib2R5Lmxlbmd0aCB8fCBicmFuY2ggaW5zdGFuY2VvZiBBU1RfQ2FzZVxuICAgICAgICAgICAgJiYgKGRlZmF1bHRfYnJhbmNoIHx8IGJyYW5jaC5leHByZXNzaW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpKSBicmVhaztcbiAgICAgICAgaWYgKGJvZHkucG9wKCkgPT09IGRlZmF1bHRfYnJhbmNoKSBkZWZhdWx0X2JyYW5jaCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChib2R5Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICBib2R5OiBkZWNsLmNvbmNhdChtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgc2VsZi5leHByZXNzaW9uLCB7XG4gICAgICAgICAgICAgICAgYm9keTogc2VsZi5leHByZXNzaW9uXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgfVxuICAgIGlmIChib2R5Lmxlbmd0aCA9PSAxICYmIChib2R5WzBdID09PSBleGFjdF9tYXRjaCB8fCBib2R5WzBdID09PSBkZWZhdWx0X2JyYW5jaCkpIHtcbiAgICAgICAgdmFyIGhhc19icmVhayA9IGZhbHNlO1xuICAgICAgICB2YXIgdHcgPSBuZXcgVHJlZVdhbGtlcihmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBpZiAoaGFzX2JyZWFrXG4gICAgICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9MYW1iZGFcbiAgICAgICAgICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudCkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9CcmVhayAmJiB0dy5sb29wY29udHJvbF90YXJnZXQobm9kZSkgPT09IHNlbGYpXG4gICAgICAgICAgICAgICAgaGFzX2JyZWFrID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbGYud2Fsayh0dyk7XG4gICAgICAgIGlmICghaGFzX2JyZWFrKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGVtZW50cyA9IGJvZHlbMF0uYm9keS5zbGljZSgpO1xuICAgICAgICAgICAgdmFyIGV4cCA9IGJvZHlbMF0uZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChleHApIHN0YXRlbWVudHMudW5zaGlmdChtYWtlX25vZGUoQVNUX1NpbXBsZVN0YXRlbWVudCwgZXhwLCB7XG4gICAgICAgICAgICAgICAgYm9keTogZXhwXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBzdGF0ZW1lbnRzLnVuc2hpZnQobWFrZV9ub2RlKEFTVF9TaW1wbGVTdGF0ZW1lbnQsIHNlbGYuZXhwcmVzc2lvbiwge1xuICAgICAgICAgICAgICAgIGJvZHk6c2VsZi5leHByZXNzaW9uXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CbG9ja1N0YXRlbWVudCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHN0YXRlbWVudHNcbiAgICAgICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gZWxpbWluYXRlX2JyYW5jaChicmFuY2gsIHByZXYpIHtcbiAgICAgICAgaWYgKHByZXYgJiYgIWFib3J0cyhwcmV2KSkge1xuICAgICAgICAgICAgcHJldi5ib2R5ID0gcHJldi5ib2R5LmNvbmNhdChicmFuY2guYm9keSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmltX3VucmVhY2hhYmxlX2NvZGUoY29tcHJlc3NvciwgYnJhbmNoLCBkZWNsKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX1RyeSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIHRpZ2h0ZW5fYm9keShzZWxmLmJvZHksIGNvbXByZXNzb3IpO1xuICAgIGlmIChzZWxmLmJjYXRjaCAmJiBzZWxmLmJmaW5hbGx5ICYmIHNlbGYuYmZpbmFsbHkuYm9keS5ldmVyeShpc19lbXB0eSkpIHNlbGYuYmZpbmFsbHkgPSBudWxsO1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImRlYWRfY29kZVwiKSAmJiBzZWxmLmJvZHkuZXZlcnkoaXNfZW1wdHkpKSB7XG4gICAgICAgIHZhciBib2R5ID0gW107XG4gICAgICAgIGlmIChzZWxmLmJjYXRjaCkge1xuICAgICAgICAgICAgdHJpbV91bnJlYWNoYWJsZV9jb2RlKGNvbXByZXNzb3IsIHNlbGYuYmNhdGNoLCBib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5iZmluYWxseSkgYm9keS5wdXNoKC4uLnNlbGYuYmZpbmFsbHkuYm9keSk7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0Jsb2NrU3RhdGVtZW50LCBzZWxmLCB7XG4gICAgICAgICAgICBib2R5OiBib2R5XG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5BU1RfRGVmaW5pdGlvbnMuREVGTUVUSE9EKFwicmVtb3ZlX2luaXRpYWxpemVyc1wiLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVjbHMgPSBbXTtcbiAgICB0aGlzLmRlZmluaXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVmKSB7XG4gICAgICAgIGlmIChkZWYubmFtZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgZGVmLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGRlY2xzLnB1c2goZGVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhbGsoZGVmLm5hbWUsIG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbERlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xzLnB1c2gobWFrZV9ub2RlKEFTVF9WYXJEZWYsIGRlZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZGVmaW5pdGlvbnMgPSBkZWNscztcbn0pO1xuXG5BU1RfRGVmaW5pdGlvbnMuREVGTUVUSE9EKFwidG9fYXNzaWdubWVudHNcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgIHZhciByZWR1Y2VfdmFycyA9IGNvbXByZXNzb3Iub3B0aW9uKFwicmVkdWNlX3ZhcnNcIik7XG4gICAgdmFyIGFzc2lnbm1lbnRzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGRlZiBvZiB0aGlzLmRlZmluaXRpb25zKSB7XG4gICAgICAgIGlmIChkZWYudmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbWFrZV9ub2RlKEFTVF9TeW1ib2xSZWYsIGRlZi5uYW1lLCBkZWYubmFtZSk7XG4gICAgICAgICAgICBhc3NpZ25tZW50cy5wdXNoKG1ha2Vfbm9kZShBU1RfQXNzaWduLCBkZWYsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvciA6IFwiPVwiLFxuICAgICAgICAgICAgICAgIGxvZ2ljYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxlZnQgICAgIDogbmFtZSxcbiAgICAgICAgICAgICAgICByaWdodCAgICA6IGRlZi52YWx1ZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKHJlZHVjZV92YXJzKSBuYW1lLmRlZmluaXRpb24oKS5maXhlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGRlZi52YWx1ZSkge1xuICAgICAgICAgICAgLy8gQmVjYXVzZSBpdCdzIGEgZGVzdHJ1Y3R1cmluZywgZG8gbm90IHR1cm4gaW50byBhbiBhc3NpZ25tZW50LlxuICAgICAgICAgICAgdmFyIHZhckRlZiA9IG1ha2Vfbm9kZShBU1RfVmFyRGVmLCBkZWYsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBkZWYubmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGVmLnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciB2YXJfID0gbWFrZV9ub2RlKEFTVF9WYXIsIGRlZiwge1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb25zOiBbIHZhckRlZiBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzc2lnbm1lbnRzLnB1c2godmFyXyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhlZGVmID0gZGVmLm5hbWUuZGVmaW5pdGlvbigpO1xuICAgICAgICB0aGVkZWYuZWxpbWluYXRlZCsrO1xuICAgICAgICB0aGVkZWYucmVwbGFjZWQtLTtcbiAgICB9XG5cbiAgICBpZiAoYXNzaWdubWVudHMubGVuZ3RoID09IDApIHJldHVybiBudWxsO1xuICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHRoaXMsIGFzc2lnbm1lbnRzKTtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX0RlZmluaXRpb25zLCBmdW5jdGlvbihzZWxmKSB7XG4gICAgaWYgKHNlbGYuZGVmaW5pdGlvbnMubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0VtcHR5U3RhdGVtZW50LCBzZWxmKTtcbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX1ZhckRlZiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmIChcbiAgICAgICAgc2VsZi5uYW1lIGluc3RhbmNlb2YgQVNUX1N5bWJvbExldFxuICAgICAgICAmJiBzZWxmLnZhbHVlICE9IG51bGxcbiAgICAgICAgJiYgaXNfdW5kZWZpbmVkKHNlbGYudmFsdWUsIGNvbXByZXNzb3IpXG4gICAgKSB7XG4gICAgICAgIHNlbGYudmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX0ltcG9ydCwgZnVuY3Rpb24oc2VsZikge1xuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbi8vIFRPRE8gdGhpcyBvbmx5IHdvcmtzIHdpdGggQVNUX0RlZnVuLCBzaG91bGRuJ3QgaXQgd29yayBmb3Igb3RoZXIgd2F5cyBvZiBkZWZpbmluZyBmdW5jdGlvbnM/XG5mdW5jdGlvbiByZXRhaW5fdG9wX2Z1bmMoZm4sIGNvbXByZXNzb3IpIHtcbiAgICByZXR1cm4gY29tcHJlc3Nvci50b3BfcmV0YWluXG4gICAgICAgICYmIGZuIGluc3RhbmNlb2YgQVNUX0RlZnVuXG4gICAgICAgICYmIGhhc19mbGFnKGZuLCBUT1ApXG4gICAgICAgICYmIGZuLm5hbWVcbiAgICAgICAgJiYgY29tcHJlc3Nvci50b3BfcmV0YWluKGZuLm5hbWUpO1xufVxuXG5kZWZfb3B0aW1pemUoQVNUX0NhbGwsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICB2YXIgZXhwID0gc2VsZi5leHByZXNzaW9uO1xuICAgIHZhciBmbiA9IGV4cDtcbiAgICBpbmxpbmVfYXJyYXlfbGlrZV9zcHJlYWQoc2VsZi5hcmdzKTtcbiAgICB2YXIgc2ltcGxlX2FyZ3MgPSBzZWxmLmFyZ3MuZXZlcnkoKGFyZykgPT5cbiAgICAgICAgIShhcmcgaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKVxuICAgICk7XG5cbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJyZWR1Y2VfdmFyc1wiKVxuICAgICAgICAmJiBmbiBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgJiYgIWhhc19hbm5vdGF0aW9uKHNlbGYsIF9OT0lOTElORSlcbiAgICApIHtcbiAgICAgICAgY29uc3QgZml4ZWQgPSBmbi5maXhlZF92YWx1ZSgpO1xuICAgICAgICBpZiAoIXJldGFpbl90b3BfZnVuYyhmaXhlZCwgY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIGZuID0gZml4ZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZi5vcHRpb25hbCAmJiBpc19udWxsaXNoKGZuLCBjb21wcmVzc29yKSkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYpO1xuICAgIH1cblxuICAgIHZhciBpc19mdW5jID0gZm4gaW5zdGFuY2VvZiBBU1RfTGFtYmRhO1xuXG4gICAgaWYgKGlzX2Z1bmMgJiYgZm4ucGlubmVkKCkpIHJldHVybiBzZWxmO1xuXG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwidW51c2VkXCIpXG4gICAgICAgICYmIHNpbXBsZV9hcmdzXG4gICAgICAgICYmIGlzX2Z1bmNcbiAgICAgICAgJiYgIWZuLnVzZXNfYXJndW1lbnRzKSB7XG4gICAgICAgIHZhciBwb3MgPSAwLCBsYXN0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYuYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGZuLmFyZ25hbWVzW2ldIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNfZmxhZyhmbi5hcmduYW1lc1tpXS5leHByZXNzaW9uLCBVTlVTRUQpKSB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHNlbGYuYXJnc1tpKytdLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYXJnc1twb3MrK10gPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXJnc1twb3MrK10gPSBzZWxmLmFyZ3NbaSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdCA9IHBvcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmltID0gaSA+PSBmbi5hcmduYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodHJpbSB8fCBoYXNfZmxhZyhmbi5hcmduYW1lc1tpXSwgVU5VU0VEKSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gc2VsZi5hcmdzW2ldLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFyZ3NbcG9zKytdID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0cmltKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXJnc1twb3MrK10gPSBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZi5hcmdzW2ldLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFyZ3NbcG9zKytdID0gc2VsZi5hcmdzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdCA9IHBvcztcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmFyZ3MubGVuZ3RoID0gbGFzdDtcbiAgICB9XG5cbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVcIikpIHtcbiAgICAgICAgaWYgKGlzX3VuZGVjbGFyZWRfcmVmKGV4cCkpIHN3aXRjaCAoZXhwLm5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9BcnJheSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogc2VsZi5hcmdzXG4gICAgICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuYXJnc1swXSBpbnN0YW5jZW9mIEFTVF9OdW1iZXIgJiYgc2VsZi5hcmdzWzBdLnZhbHVlIDw9IDExKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGYuYXJnc1swXS52YWx1ZTsgaSsrKSBlbGVtZW50cy5wdXNoKG5ldyBBU1RfSG9sZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBU1RfQXJyYXkoeyBlbGVtZW50cyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9PYmplY3QsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJTdHJpbmdcIjpcbiAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDApIHJldHVybiBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoIDw9IDEpIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYuYXJnc1swXSxcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCIsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLCB7IHZhbHVlOiBcIlwiIH0pXG4gICAgICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJOdW1iZXJcIjpcbiAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDApIHJldHVybiBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDEgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVfbWF0aFwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHNlbGYuYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiK1wiXG4gICAgICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiU3ltYm9sXCI6XG4gICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA9PSAxICYmIHNlbGYuYXJnc1swXSBpbnN0YW5jZW9mIEFTVF9TdHJpbmcgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVfc3ltYm9sc1wiKSlcbiAgICAgICAgICAgICAgICBzZWxmLmFyZ3MubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiQm9vbGVhblwiOlxuICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMCkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRmFsc2UsIHNlbGYpO1xuICAgICAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMSkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBtYWtlX25vZGUoQVNUX1VuYXJ5UHJlZml4LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHNlbGYuYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiXG4gICAgICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJSZWdFeHBcIjpcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID49IDFcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmFyZ3MubGVuZ3RoIDw9IDJcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmFyZ3MuZXZlcnkoKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcmcuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZyAhPT0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGxldCBbIHNvdXJjZSwgZmxhZ3MgXSA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSByZWdleHBfc291cmNlX2ZpeChuZXcgUmVnRXhwKHNvdXJjZSkuc291cmNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByeCA9IG1ha2Vfbm9kZShBU1RfUmVnRXhwLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IHNvdXJjZSwgZmxhZ3MgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyeC5fZXZhbChjb21wcmVzc29yKSAhPT0gcngpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGV4cCBpbnN0YW5jZW9mIEFTVF9Eb3QpIHN3aXRjaChleHAucHJvcGVydHkpIHtcbiAgICAgICAgICBjYXNlIFwidG9TdHJpbmdcIjpcbiAgICAgICAgICAgIGlmIChzZWxmLmFyZ3MubGVuZ3RoID09IDAgJiYgIWV4cC5leHByZXNzaW9uLm1heV90aHJvd19vbl9hY2Nlc3MoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHsgdmFsdWU6IFwiXCIgfSksXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGV4cC5leHByZXNzaW9uXG4gICAgICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiam9pblwiOlxuICAgICAgICAgICAgaWYgKGV4cC5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX0FycmF5KSBFWElUOiB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gc2VsZi5hcmdzWzBdLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSBzZWxmLmFyZ3NbMF0pIGJyZWFrIEVYSVQ7IC8vIG5vdCBhIGNvbnN0YW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBjb25zdHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwLmV4cHJlc3Npb24uZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gZXhwLmV4cHJlc3Npb24uZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pIGJyZWFrIEVYSVQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVsLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb25zdHMuam9pbihzZXBhcmF0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb25zdHMuam9pbihzZXBhcmF0b3IpXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PSAwKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHsgdmFsdWU6IFwiXCIgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c1swXS5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIGVsZW1lbnRzWzBdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvciA6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCAgICAgOiBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZiwgeyB2YWx1ZTogXCJcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ICAgIDogZWxlbWVudHNbMF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IgPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50c1swXS5pc19zdHJpbmcoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IGVsZW1lbnRzWzFdLmlzX3N0cmluZyhjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBlbGVtZW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZiwgeyB2YWx1ZTogXCJcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3IgOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ICAgICA6IHByZXYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgICAgOiBlbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZpcnN0KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0aGlzIGF3a3dhcmQgY2xvbmluZyB0byBub3QgYWZmZWN0IG9yaWdpbmFsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBiZXN0X29mIHdpbGwgZGVjaWRlIHdoaWNoIG9uZSB0byBnZXQgdGhyb3VnaC5cbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHNlbGYuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24gPSBub2RlLmV4cHJlc3Npb24uY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24uZXhwcmVzc2lvbiA9IG5vZGUuZXhwcmVzc2lvbi5leHByZXNzaW9uLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uLmV4cHJlc3Npb24uZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVzdF9vZihjb21wcmVzc29yLCBzZWxmLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjaGFyQXRcIjpcbiAgICAgICAgICAgIGlmIChleHAuZXhwcmVzc2lvbi5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gc2VsZi5hcmdzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFyZyA/IGFyZy5ldmFsdWF0ZShjb21wcmVzc29yKSA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU3ViLCBleHAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cC5leHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGluZGV4IHwgMCwgYXJnIHx8IGV4cClcbiAgICAgICAgICAgICAgICAgICAgfSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImFwcGx5XCI6XG4gICAgICAgICAgICBpZiAoc2VsZi5hcmdzLmxlbmd0aCA9PSAyICYmIHNlbGYuYXJnc1sxXSBpbnN0YW5jZW9mIEFTVF9BcnJheSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2VsZi5hcmdzWzFdLmVsZW1lbnRzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KHNlbGYuYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQ2FsbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBtYWtlX25vZGUoQVNUX0RvdCwgZXhwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHAuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBcImNhbGxcIlxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNhbGxcIjpcbiAgICAgICAgICAgIHZhciBmdW5jID0gZXhwLmV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoZnVuYyBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYpIHtcbiAgICAgICAgICAgICAgICBmdW5jID0gZnVuYy5maXhlZF92YWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZ1bmMgaW5zdGFuY2VvZiBBU1RfTGFtYmRhICYmICFmdW5jLmNvbnRhaW5zX3RoaXMoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoc2VsZi5hcmdzLmxlbmd0aCA/IG1ha2Vfc2VxdWVuY2UodGhpcywgW1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIG1ha2Vfbm9kZShBU1RfQ2FsbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwLmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBzZWxmLmFyZ3Muc2xpY2UoMSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBdKSA6IG1ha2Vfbm9kZShBU1RfQ2FsbCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHAuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW11cbiAgICAgICAgICAgICAgICB9KSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZV9GdW5jdGlvblwiKVxuICAgICAgICAmJiBpc191bmRlY2xhcmVkX3JlZihleHApXG4gICAgICAgICYmIGV4cC5uYW1lID09IFwiRnVuY3Rpb25cIikge1xuICAgICAgICAvLyBuZXcgRnVuY3Rpb24oKSA9PiBmdW5jdGlvbigpe31cbiAgICAgICAgaWYgKHNlbGYuYXJncy5sZW5ndGggPT0gMCkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfRnVuY3Rpb24sIHNlbGYsIHtcbiAgICAgICAgICAgIGFyZ25hbWVzOiBbXSxcbiAgICAgICAgICAgIGJvZHk6IFtdXG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAoc2VsZi5hcmdzLmV2ZXJ5KCh4KSA9PiB4IGluc3RhbmNlb2YgQVNUX1N0cmluZykpIHtcbiAgICAgICAgICAgIC8vIHF1aXRlIGEgY29ybmVyLWNhc2UsIGJ1dCB3ZSBjYW4gaGFuZGxlIGl0OlxuICAgICAgICAgICAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9pc3N1ZXMvMjAzXG4gICAgICAgICAgICAvLyBpZiB0aGUgY29kZSBhcmd1bWVudCBpcyBhIGNvbnN0YW50LCB0aGVuIHdlIGNhbiBtaW5pZnkgaXQuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gXCJuKGZ1bmN0aW9uKFwiICsgc2VsZi5hcmdzLnNsaWNlKDAsIC0xKS5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcudmFsdWU7XG4gICAgICAgICAgICAgICAgfSkuam9pbihcIixcIikgKyBcIil7XCIgKyBzZWxmLmFyZ3Nbc2VsZi5hcmdzLmxlbmd0aCAtIDFdLnZhbHVlICsgXCJ9KVwiO1xuICAgICAgICAgICAgICAgIHZhciBhc3QgPSBwYXJzZShjb2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgbWFuZ2xlID0geyBpZTg6IGNvbXByZXNzb3Iub3B0aW9uKFwiaWU4XCIpIH07XG4gICAgICAgICAgICAgICAgYXN0LmZpZ3VyZV9vdXRfc2NvcGUobWFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2YXIgY29tcCA9IG5ldyBDb21wcmVzc29yKGNvbXByZXNzb3Iub3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBtYW5nbGVfb3B0aW9uczogY29tcHJlc3Nvci5tYW5nbGVfb3B0aW9uc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzdCA9IGFzdC50cmFuc2Zvcm0oY29tcCk7XG4gICAgICAgICAgICAgICAgYXN0LmZpZ3VyZV9vdXRfc2NvcGUobWFuZ2xlKTtcbiAgICAgICAgICAgICAgICBiYXNlNTQucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBhc3QuY29tcHV0ZV9jaGFyX2ZyZXF1ZW5jeShtYW5nbGUpO1xuICAgICAgICAgICAgICAgIGFzdC5tYW5nbGVfbmFtZXMobWFuZ2xlKTtcbiAgICAgICAgICAgICAgICB2YXIgZnVuO1xuICAgICAgICAgICAgICAgIHdhbGsoYXN0LCBub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2Z1bmNfZXhwcihub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxrX2Fib3J0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBPdXRwdXRTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICBBU1RfQmxvY2tTdGF0ZW1lbnQucHJvdG90eXBlLl9jb2RlZ2VuLmNhbGwoZnVuLCBmdW4sIGNvZGUpO1xuICAgICAgICAgICAgICAgIHNlbGYuYXJncyA9IFtcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmdW4uYXJnbmFtZXMubWFwKGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcucHJpbnRfdG9fc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKFwiLFwiKVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYuYXJnc1tzZWxmLmFyZ3MubGVuZ3RoIC0gMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2RlLmdldCgpLnJlcGxhY2UoL157fH0kL2csIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZXggaW5zdGFuY2VvZiBKU19QYXJzZV9FcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCBjcmFzaGVzIGF0IHJ1bnRpbWUuIE9yIG1heWJlIGl0J3Mgbm9uc3RhbmRhcmQgc3ludGF4LlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0YXQgPSBpc19mdW5jICYmIGZuLmJvZHlbMF07XG4gICAgdmFyIGlzX3JlZ3VsYXJfZnVuYyA9IGlzX2Z1bmMgJiYgIWZuLmlzX2dlbmVyYXRvciAmJiAhZm4uYXN5bmM7XG4gICAgdmFyIGNhbl9pbmxpbmUgPSBpc19yZWd1bGFyX2Z1bmMgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJpbmxpbmVcIikgJiYgIXNlbGYuaXNfY2FsbGVlX3B1cmUoY29tcHJlc3Nvcik7XG4gICAgaWYgKGNhbl9pbmxpbmUgJiYgc3RhdCBpbnN0YW5jZW9mIEFTVF9SZXR1cm4pIHtcbiAgICAgICAgbGV0IHJldHVybmVkID0gc3RhdC52YWx1ZTtcbiAgICAgICAgaWYgKCFyZXR1cm5lZCB8fCByZXR1cm5lZC5pc19jb25zdGFudF9leHByZXNzaW9uKCkpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybmVkID0gcmV0dXJuZWQuY2xvbmUodHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybmVkID0gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJncyA9IHNlbGYuYXJncy5jb25jYXQocmV0dXJuZWQpO1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uoc2VsZiwgYXJncykub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvcHRpbWl6ZSBpZGVudGl0eSBmdW5jdGlvblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBmbi5hcmduYW1lcy5sZW5ndGggPT09IDFcbiAgICAgICAgICAgICYmIChmbi5hcmduYW1lc1swXSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xGdW5hcmcpXG4gICAgICAgICAgICAmJiBzZWxmLmFyZ3MubGVuZ3RoIDwgMlxuICAgICAgICAgICAgJiYgcmV0dXJuZWQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAmJiByZXR1cm5lZC5uYW1lID09PSBmbi5hcmduYW1lc1swXS5uYW1lXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPVxuICAgICAgICAgICAgICAgIChzZWxmLmFyZ3NbMF0gfHwgbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQpKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcblxuICAgICAgICAgICAgbGV0IHBhcmVudDtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzXG4gICAgICAgICAgICAgICAgJiYgKHBhcmVudCA9IGNvbXByZXNzb3IucGFyZW50KCkpIGluc3RhbmNlb2YgQVNUX0NhbGxcbiAgICAgICAgICAgICAgICAmJiBwYXJlbnQuZXhwcmVzc2lvbiA9PT0gc2VsZlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gaWRlbnRpdHkgZnVuY3Rpb24gd2FzIGJlaW5nIHVzZWQgdG8gcmVtb3ZlIGB0aGlzYCwgbGlrZSBpblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gaWQoYmFnLm5vX3RoaXMpKC4uLilcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2Ugd2l0aCBhIGxhcmdlciBidXQgbW9yZSBlZmZpc2ggKDAsIGJhZy5ub190aGlzKSB3cmFwcGVyLlxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uoc2VsZiwgW1xuICAgICAgICAgICAgICAgICAgICBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZiwgeyB2YWx1ZTogMCB9KSxcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgY2FsbCB3aXRoIGZpcnN0IGFyZ3VtZW50IG9yIHVuZGVmaW5lZCBpZiBub25lIHBhc3NlZFxuICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNhbl9pbmxpbmUpIHtcbiAgICAgICAgdmFyIHNjb3BlLCBpbl9sb29wLCBsZXZlbCA9IC0xO1xuICAgICAgICBsZXQgZGVmO1xuICAgICAgICBsZXQgcmV0dXJuZWRfdmFsdWU7XG4gICAgICAgIGxldCBuZWFyZXN0X3Njb3BlO1xuICAgICAgICBpZiAoc2ltcGxlX2FyZ3NcbiAgICAgICAgICAgICYmICFmbi51c2VzX2FyZ3VtZW50c1xuICAgICAgICAgICAgJiYgIShjb21wcmVzc29yLnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX0NsYXNzKVxuICAgICAgICAgICAgJiYgIShmbi5uYW1lICYmIGZuIGluc3RhbmNlb2YgQVNUX0Z1bmN0aW9uKVxuICAgICAgICAgICAgJiYgKHJldHVybmVkX3ZhbHVlID0gY2FuX2ZsYXR0ZW5fYm9keShzdGF0KSlcbiAgICAgICAgICAgICYmIChleHAgPT09IGZuXG4gICAgICAgICAgICAgICAgfHwgaGFzX2Fubm90YXRpb24oc2VsZiwgX0lOTElORSlcbiAgICAgICAgICAgICAgICB8fCBjb21wcmVzc29yLm9wdGlvbihcInVudXNlZFwiKVxuICAgICAgICAgICAgICAgICAgICAmJiAoZGVmID0gZXhwLmRlZmluaXRpb24oKSkucmVmZXJlbmNlcy5sZW5ndGggPT0gMVxuICAgICAgICAgICAgICAgICAgICAmJiAhcmVjdXJzaXZlX3JlZihjb21wcmVzc29yLCBkZWYpXG4gICAgICAgICAgICAgICAgICAgICYmIGZuLmlzX2NvbnN0YW50X2V4cHJlc3Npb24oZXhwLnNjb3BlKSlcbiAgICAgICAgICAgICYmICFoYXNfYW5ub3RhdGlvbihzZWxmLCBfUFVSRSB8IF9OT0lOTElORSlcbiAgICAgICAgICAgICYmICFmbi5jb250YWluc190aGlzKClcbiAgICAgICAgICAgICYmIGNhbl9pbmplY3Rfc3ltYm9scygpXG4gICAgICAgICAgICAmJiAobmVhcmVzdF9zY29wZSA9IGZpbmRfc2NvcGUoY29tcHJlc3NvcikpXG4gICAgICAgICAgICAmJiAhc2NvcGVfZW5jbG9zZXNfdmFyaWFibGVzX2luX3RoaXNfc2NvcGUobmVhcmVzdF9zY29wZSwgZm4pXG4gICAgICAgICAgICAmJiAhKGZ1bmN0aW9uIGluX2RlZmF1bHRfYXNzaWduKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEdWUgdG8gdGhlIGZhY3QgZnVuY3Rpb24gcGFyYW1ldGVycyBoYXZlIHRoZWlyIG93biBzY29wZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCBjYW4ndCB1c2UgYHZhciBzb21ldGhpbmdgIGluIHRoZSBmdW5jdGlvbiBib2R5IHdpdGhpbixcbiAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2ltcGx5IGRvbid0IGlubGluZSBpbnRvIERlZmF1bHRBc3NpZ24uXG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgocCA9IGNvbXByZXNzb3IucGFyZW50KGkrKykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIEFTVF9EZWZhdWx0QXNzaWduKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgQVNUX0Jsb2NrKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSkoKVxuICAgICAgICAgICAgJiYgIShzY29wZSBpbnN0YW5jZW9mIEFTVF9DbGFzcylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBzZXRfZmxhZyhmbiwgU1FVRUVaRUQpO1xuICAgICAgICAgICAgbmVhcmVzdF9zY29wZS5hZGRfY2hpbGRfc2NvcGUoZm4pO1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uoc2VsZiwgZmxhdHRlbl9mbihyZXR1cm5lZF92YWx1ZSkpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNhbl9pbmxpbmUgJiYgaGFzX2Fubm90YXRpb24oc2VsZiwgX0lOTElORSkpIHtcbiAgICAgICAgc2V0X2ZsYWcoZm4sIFNRVUVFWkVEKTtcbiAgICAgICAgZm4gPSBtYWtlX25vZGUoZm4uQ1RPUiA9PT0gQVNUX0RlZnVuID8gQVNUX0Z1bmN0aW9uIDogZm4uQ1RPUiwgZm4sIGZuKTtcbiAgICAgICAgZm4uZmlndXJlX291dF9zY29wZSh7fSwge1xuICAgICAgICAgICAgcGFyZW50X3Njb3BlOiBmaW5kX3Njb3BlKGNvbXByZXNzb3IpLFxuICAgICAgICAgICAgdG9wbGV2ZWw6IGNvbXByZXNzb3IuZ2V0X3RvcGxldmVsKClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQ2FsbCwgc2VsZiwge1xuICAgICAgICAgICAgZXhwcmVzc2lvbjogZm4sXG4gICAgICAgICAgICBhcmdzOiBzZWxmLmFyZ3MsXG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbl9kcm9wX3RoaXNfY2FsbCA9IGlzX3JlZ3VsYXJfZnVuYyAmJiBjb21wcmVzc29yLm9wdGlvbihcInNpZGVfZWZmZWN0c1wiKSAmJiBmbi5ib2R5LmV2ZXJ5KGlzX2VtcHR5KTtcbiAgICBpZiAoY2FuX2Ryb3BfdGhpc19jYWxsKSB7XG4gICAgICAgIHZhciBhcmdzID0gc2VsZi5hcmdzLmNvbmNhdChtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZikpO1xuICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShzZWxmLCBhcmdzKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG5cbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJuZWdhdGVfaWlmZVwiKVxuICAgICAgICAmJiBjb21wcmVzc29yLnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX1NpbXBsZVN0YXRlbWVudFxuICAgICAgICAmJiBpc19paWZlX2NhbGwoc2VsZikpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubmVnYXRlKGNvbXByZXNzb3IsIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBldiA9IHNlbGYuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgaWYgKGV2ICE9PSBzZWxmKSB7XG4gICAgICAgIGV2ID0gbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoZXYsIHNlbGYpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICByZXR1cm4gYmVzdF9vZihjb21wcmVzc29yLCBldiwgc2VsZik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG5cbiAgICBmdW5jdGlvbiByZXR1cm5fdmFsdWUoc3RhdCkge1xuICAgICAgICBpZiAoIXN0YXQpIHJldHVybiBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZik7XG4gICAgICAgIGlmIChzdGF0IGluc3RhbmNlb2YgQVNUX1JldHVybikge1xuICAgICAgICAgICAgaWYgKCFzdGF0LnZhbHVlKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXQudmFsdWUuY2xvbmUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXQgaW5zdGFuY2VvZiBBU1RfU2ltcGxlU3RhdGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgc3RhdCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcInZvaWRcIixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBzdGF0LmJvZHkuY2xvbmUodHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuX2ZsYXR0ZW5fYm9keShzdGF0KSB7XG4gICAgICAgIHZhciBib2R5ID0gZm4uYm9keTtcbiAgICAgICAgdmFyIGxlbiA9IGJvZHkubGVuZ3RoO1xuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJpbmxpbmVcIikgPCAzKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVuID09IDEgJiYgcmV0dXJuX3ZhbHVlKHN0YXQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXQgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGJvZHlbaV07XG4gICAgICAgICAgICBpZiAobGluZSBpbnN0YW5jZW9mIEFTVF9WYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdCAmJiAhbGluZS5kZWZpbml0aW9ucy5ldmVyeSgodmFyX2RlZikgPT5cbiAgICAgICAgICAgICAgICAgICAgIXZhcl9kZWYudmFsdWVcbiAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEobGluZSBpbnN0YW5jZW9mIEFTVF9FbXB0eVN0YXRlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ID0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuX3ZhbHVlKHN0YXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbl9pbmplY3RfYXJncyhibG9ja19zY29wZWQsIHNhZmVfdG9faW5qZWN0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5hcmduYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGFyZyA9IGZuLmFyZ25hbWVzW2ldO1xuICAgICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFTVF9EZWZhdWx0QXNzaWduKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc19mbGFnKGFyZy5sZWZ0LCBVTlVTRUQpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJnIGluc3RhbmNlb2YgQVNUX0Rlc3RydWN0dXJpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc19mbGFnKGFyZy5leHByZXNzaW9uLCBVTlVTRUQpKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzX2ZsYWcoYXJnLCBVTlVTRUQpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghc2FmZV90b19pbmplY3RcbiAgICAgICAgICAgICAgICB8fCBibG9ja19zY29wZWQuaGFzKGFyZy5uYW1lKVxuICAgICAgICAgICAgICAgIHx8IGlkZW50aWZpZXJfYXRvbS5oYXMoYXJnLm5hbWUpXG4gICAgICAgICAgICAgICAgfHwgc2NvcGUuY29uZmxpY3RpbmdfZGVmKGFyZy5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbl9sb29wKSBpbl9sb29wLnB1c2goYXJnLmRlZmluaXRpb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuX2luamVjdF92YXJzKGJsb2NrX3Njb3BlZCwgc2FmZV90b19pbmplY3QpIHtcbiAgICAgICAgdmFyIGxlbiA9IGZuLmJvZHkubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhdCA9IGZuLmJvZHlbaV07XG4gICAgICAgICAgICBpZiAoIShzdGF0IGluc3RhbmNlb2YgQVNUX1ZhcikpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFzYWZlX3RvX2luamVjdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXQuZGVmaW5pdGlvbnMubGVuZ3RoOyAtLWogPj0gMDspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHN0YXQuZGVmaW5pdGlvbnNbal0ubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSBpbnN0YW5jZW9mIEFTVF9EZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICAgICAgICAgIHx8IGJsb2NrX3Njb3BlZC5oYXMobmFtZS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICB8fCBpZGVudGlmaWVyX2F0b20uaGFzKG5hbWUubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgfHwgc2NvcGUuY29uZmxpY3RpbmdfZGVmKG5hbWUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5fbG9vcCkgaW5fbG9vcC5wdXNoKG5hbWUuZGVmaW5pdGlvbigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5faW5qZWN0X3N5bWJvbHMoKSB7XG4gICAgICAgIHZhciBibG9ja19zY29wZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHNjb3BlID0gY29tcHJlc3Nvci5wYXJlbnQoKytsZXZlbCk7XG4gICAgICAgICAgICBpZiAoc2NvcGUuaXNfYmxvY2tfc2NvcGUoKSAmJiBzY29wZS5ibG9ja19zY29wZSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGR1cmluZyBjb21wcmVzc2lvbi5cbiAgICAgICAgICAgICAgICAvLyBCdXQgaXQgc2hvdWxkIGFsd2F5cyBoYXZlIGEgdmFsdWUhXG4gICAgICAgICAgICAgICAgc2NvcGUuYmxvY2tfc2NvcGUudmFyaWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrX3Njb3BlZC5hZGQodmFyaWFibGUubmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NvcGUgaW5zdGFuY2VvZiBBU1RfQ2F0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGNhbiB3ZSBkZWxldGU/IEFTVF9DYXRjaCBpcyBhIGJsb2NrIHNjb3BlLlxuICAgICAgICAgICAgICAgIGlmIChzY29wZS5hcmduYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrX3Njb3BlZC5hZGQoc2NvcGUuYXJnbmFtZS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNjb3BlIGluc3RhbmNlb2YgQVNUX0l0ZXJhdGlvblN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIGluX2xvb3AgPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NvcGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLmZpeGVkX3ZhbHVlKCkgaW5zdGFuY2VvZiBBU1RfU2NvcGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoIShzY29wZSBpbnN0YW5jZW9mIEFTVF9TY29wZSkpO1xuXG4gICAgICAgIHZhciBzYWZlX3RvX2luamVjdCA9ICEoc2NvcGUgaW5zdGFuY2VvZiBBU1RfVG9wbGV2ZWwpIHx8IGNvbXByZXNzb3IudG9wbGV2ZWwudmFycztcbiAgICAgICAgdmFyIGlubGluZSA9IGNvbXByZXNzb3Iub3B0aW9uKFwiaW5saW5lXCIpO1xuICAgICAgICBpZiAoIWNhbl9pbmplY3RfdmFycyhibG9ja19zY29wZWQsIGlubGluZSA+PSAzICYmIHNhZmVfdG9faW5qZWN0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWNhbl9pbmplY3RfYXJncyhibG9ja19zY29wZWQsIGlubGluZSA+PSAyICYmIHNhZmVfdG9faW5qZWN0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gIWluX2xvb3AgfHwgaW5fbG9vcC5sZW5ndGggPT0gMCB8fCAhaXNfcmVhY2hhYmxlKGZuLCBpbl9sb29wKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBlbmRfdmFyKGRlY2xzLCBleHByZXNzaW9ucywgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRlZiA9IG5hbWUuZGVmaW5pdGlvbigpO1xuXG4gICAgICAgIC8vIE5hbWUgYWxyZWFkeSBleGlzdHMsIG9ubHkgd2hlbiBhIGZ1bmN0aW9uIGFyZ3VtZW50IGhhZCB0aGUgc2FtZSBuYW1lXG4gICAgICAgIGNvbnN0IGFscmVhZHlfYXBwZW5kZWQgPSBzY29wZS52YXJpYWJsZXMuaGFzKG5hbWUubmFtZSk7XG4gICAgICAgIGlmICghYWxyZWFkeV9hcHBlbmRlZCkge1xuICAgICAgICAgICAgc2NvcGUudmFyaWFibGVzLnNldChuYW1lLm5hbWUsIGRlZik7XG4gICAgICAgICAgICBzY29wZS5lbmNsb3NlZC5wdXNoKGRlZik7XG4gICAgICAgICAgICBkZWNscy5wdXNoKG1ha2Vfbm9kZShBU1RfVmFyRGVmLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN5bSA9IG1ha2Vfbm9kZShBU1RfU3ltYm9sUmVmLCBuYW1lLCBuYW1lKTtcbiAgICAgICAgZGVmLnJlZmVyZW5jZXMucHVzaChzeW0pO1xuICAgICAgICBpZiAodmFsdWUpIGV4cHJlc3Npb25zLnB1c2gobWFrZV9ub2RlKEFTVF9Bc3NpZ24sIHNlbGYsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgIGxvZ2ljYWw6IGZhbHNlLFxuICAgICAgICAgICAgbGVmdDogc3ltLFxuICAgICAgICAgICAgcmlnaHQ6IHZhbHVlLmNsb25lKClcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZsYXR0ZW5fYXJncyhkZWNscywgZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgdmFyIGxlbiA9IGZuLmFyZ25hbWVzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNlbGYuYXJncy5sZW5ndGg7IC0taSA+PSBsZW47KSB7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKHNlbGYuYXJnc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gbGVuOyAtLWkgPj0gMDspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gZm4uYXJnbmFtZXNbaV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmFyZ3NbaV07XG4gICAgICAgICAgICBpZiAoaGFzX2ZsYWcobmFtZSwgVU5VU0VEKSB8fCAhbmFtZS5uYW1lIHx8IHNjb3BlLmNvbmZsaWN0aW5nX2RlZihuYW1lLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSBleHByZXNzaW9ucy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN5bWJvbCA9IG1ha2Vfbm9kZShBU1RfU3ltYm9sVmFyLCBuYW1lLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBuYW1lLmRlZmluaXRpb24oKS5vcmlnLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbHVlICYmIGluX2xvb3ApIHZhbHVlID0gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYpO1xuICAgICAgICAgICAgICAgIGFwcGVuZF92YXIoZGVjbHMsIGV4cHJlc3Npb25zLCBzeW1ib2wsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWNscy5yZXZlcnNlKCk7XG4gICAgICAgIGV4cHJlc3Npb25zLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbGF0dGVuX3ZhcnMoZGVjbHMsIGV4cHJlc3Npb25zKSB7XG4gICAgICAgIHZhciBwb3MgPSBleHByZXNzaW9ucy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsaW5lcyA9IGZuLmJvZHkubGVuZ3RoOyBpIDwgbGluZXM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXQgPSBmbi5ib2R5W2ldO1xuICAgICAgICAgICAgaWYgKCEoc3RhdCBpbnN0YW5jZW9mIEFTVF9WYXIpKSBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBkZWZzID0gc3RhdC5kZWZpbml0aW9ucy5sZW5ndGg7IGogPCBkZWZzOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFyX2RlZiA9IHN0YXQuZGVmaW5pdGlvbnNbal07XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB2YXJfZGVmLm5hbWU7XG4gICAgICAgICAgICAgICAgYXBwZW5kX3ZhcihkZWNscywgZXhwcmVzc2lvbnMsIG5hbWUsIHZhcl9kZWYudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpbl9sb29wICYmIGZuLmFyZ25hbWVzLmV2ZXJ5KChhcmduYW1lKSA9PlxuICAgICAgICAgICAgICAgICAgICBhcmduYW1lLm5hbWUgIT0gbmFtZS5uYW1lXG4gICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gZm4udmFyaWFibGVzLmdldChuYW1lLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltID0gbWFrZV9ub2RlKEFTVF9TeW1ib2xSZWYsIG5hbWUsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBkZWYucmVmZXJlbmNlcy5wdXNoKHN5bSk7XG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zLnNwbGljZShwb3MrKywgMCwgbWFrZV9ub2RlKEFTVF9Bc3NpZ24sIHZhcl9kZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2ljYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc3ltLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBuYW1lKVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmxhdHRlbl9mbihyZXR1cm5lZF92YWx1ZSkge1xuICAgICAgICB2YXIgZGVjbHMgPSBbXTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gW107XG4gICAgICAgIGZsYXR0ZW5fYXJncyhkZWNscywgZXhwcmVzc2lvbnMpO1xuICAgICAgICBmbGF0dGVuX3ZhcnMoZGVjbHMsIGV4cHJlc3Npb25zKTtcbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaChyZXR1cm5lZF92YWx1ZSk7XG4gICAgICAgIGlmIChkZWNscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBzY29wZS5ib2R5LmluZGV4T2YoY29tcHJlc3Nvci5wYXJlbnQobGV2ZWwgLSAxKSkgKyAxO1xuICAgICAgICAgICAgc2NvcGUuYm9keS5zcGxpY2UoaSwgMCwgbWFrZV9ub2RlKEFTVF9WYXIsIGZuLCB7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbnM6IGRlY2xzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25zLm1hcChleHAgPT4gZXhwLmNsb25lKHRydWUpKTtcbiAgICB9XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9OZXcsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoXG4gICAgICAgIGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpICYmXG4gICAgICAgIGlzX3VuZGVjbGFyZWRfcmVmKHNlbGYuZXhwcmVzc2lvbikgJiZcbiAgICAgICAgW1wiT2JqZWN0XCIsIFwiUmVnRXhwXCIsIFwiRnVuY3Rpb25cIiwgXCJFcnJvclwiLCBcIkFycmF5XCJdLmluY2x1ZGVzKHNlbGYuZXhwcmVzc2lvbi5uYW1lKVxuICAgICkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQ2FsbCwgc2VsZiwgc2VsZikudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfU2VxdWVuY2UsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwic2lkZV9lZmZlY3RzXCIpKSByZXR1cm4gc2VsZjtcbiAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXTtcbiAgICBmaWx0ZXJfZm9yX3NpZGVfZWZmZWN0cygpO1xuICAgIHZhciBlbmQgPSBleHByZXNzaW9ucy5sZW5ndGggLSAxO1xuICAgIHRyaW1fcmlnaHRfZm9yX3VuZGVmaW5lZCgpO1xuICAgIGlmIChlbmQgPT0gMCkge1xuICAgICAgICBzZWxmID0gbWFpbnRhaW5fdGhpc19iaW5kaW5nKGNvbXByZXNzb3IucGFyZW50KCksIGNvbXByZXNzb3Iuc2VsZigpLCBleHByZXNzaW9uc1swXSk7XG4gICAgICAgIGlmICghKHNlbGYgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2UpKSBzZWxmID0gc2VsZi5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIHNlbGYuZXhwcmVzc2lvbnMgPSBleHByZXNzaW9ucztcbiAgICByZXR1cm4gc2VsZjtcblxuICAgIGZ1bmN0aW9uIGZpbHRlcl9mb3Jfc2lkZV9lZmZlY3RzKCkge1xuICAgICAgICB2YXIgZmlyc3QgPSBmaXJzdF9pbl9zdGF0ZW1lbnQoY29tcHJlc3Nvcik7XG4gICAgICAgIHZhciBsYXN0ID0gc2VsZi5leHByZXNzaW9ucy5sZW5ndGggLSAxO1xuICAgICAgICBzZWxmLmV4cHJlc3Npb25zLmZvckVhY2goZnVuY3Rpb24oZXhwciwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxhc3QpIGV4cHIgPSBleHByLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yLCBmaXJzdCk7XG4gICAgICAgICAgICBpZiAoZXhwcikge1xuICAgICAgICAgICAgICAgIG1lcmdlX3NlcXVlbmNlKGV4cHJlc3Npb25zLCBleHByKTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmltX3JpZ2h0X2Zvcl91bmRlZmluZWQoKSB7XG4gICAgICAgIHdoaWxlIChlbmQgPiAwICYmIGlzX3VuZGVmaW5lZChleHByZXNzaW9uc1tlbmRdLCBjb21wcmVzc29yKSkgZW5kLS07XG4gICAgICAgIGlmIChlbmQgPCBleHByZXNzaW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uc1tlbmRdID0gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yICAgOiBcInZvaWRcIixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uIDogZXhwcmVzc2lvbnNbZW5kXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHByZXNzaW9ucy5sZW5ndGggPSBlbmQgKyAxO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbkFTVF9VbmFyeS5ERUZNRVRIT0QoXCJsaWZ0X3NlcXVlbmNlc1wiLCBmdW5jdGlvbihjb21wcmVzc29yKSB7XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwic2VxdWVuY2VzXCIpKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2UpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5leHByZXNzaW9uLmV4cHJlc3Npb25zLnNsaWNlKCk7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIGUuZXhwcmVzc2lvbiA9IHgucG9wKCk7XG4gICAgICAgICAgICB4LnB1c2goZSk7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZSh0aGlzLCB4KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX1VuYXJ5UG9zdGZpeCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIHJldHVybiBzZWxmLmxpZnRfc2VxdWVuY2VzKGNvbXByZXNzb3IpO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfVW5hcnlQcmVmaXgsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICB2YXIgZSA9IHNlbGYuZXhwcmVzc2lvbjtcbiAgICBpZiAoc2VsZi5vcGVyYXRvciA9PSBcImRlbGV0ZVwiXG4gICAgICAgICYmICEoZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgIHx8IGUgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2Vzc1xuICAgICAgICAgICAgfHwgaXNfaWRlbnRpZmllcl9hdG9tKGUpKSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkge1xuICAgICAgICAgICAgY29uc3QgZXhwcnMgPSBlLmV4cHJlc3Npb25zLnNsaWNlKCk7XG4gICAgICAgICAgICBleHBycy5wdXNoKG1ha2Vfbm9kZShBU1RfVHJ1ZSwgc2VsZikpO1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uoc2VsZiwgZXhwcnMpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHNlbGYsIFsgZSwgbWFrZV9ub2RlKEFTVF9UcnVlLCBzZWxmKSBdKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG4gICAgdmFyIHNlcSA9IHNlbGYubGlmdF9zZXF1ZW5jZXMoY29tcHJlc3Nvcik7XG4gICAgaWYgKHNlcSAhPT0gc2VsZikge1xuICAgICAgICByZXR1cm4gc2VxO1xuICAgIH1cbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIikgJiYgc2VsZi5vcGVyYXRvciA9PSBcInZvaWRcIikge1xuICAgICAgICBlID0gZS5kcm9wX3NpZGVfZWZmZWN0X2ZyZWUoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBlO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmRlZmluZWQsIHNlbGYpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wcmVzc29yLmluX2Jvb2xlYW5fY29udGV4dCgpKSB7XG4gICAgICAgIHN3aXRjaCAoc2VsZi5vcGVyYXRvcikge1xuICAgICAgICAgIGNhc2UgXCIhXCI6XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeCAmJiBlLm9wZXJhdG9yID09IFwiIVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gISFmb28gPT0+IGZvbywgaWYgd2UncmUgaW4gYm9vbGVhbiBjb250ZXh0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQVNUX0JpbmFyeSkge1xuICAgICAgICAgICAgICAgIHNlbGYgPSBiZXN0X29mKGNvbXByZXNzb3IsIHNlbGYsIGUubmVnYXRlKGNvbXByZXNzb3IsIGZpcnN0X2luX3N0YXRlbWVudChjb21wcmVzc29yKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInR5cGVvZlwiOlxuICAgICAgICAgICAgLy8gdHlwZW9mIGFsd2F5cyByZXR1cm5zIGEgbm9uLWVtcHR5IHN0cmluZywgdGh1cyBpdCdzXG4gICAgICAgICAgICAvLyBhbHdheXMgdHJ1ZSBpbiBib29sZWFuc1xuICAgICAgICAgICAgLy8gQW5kIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgaWYgaXQncyB1bmRlY2xhcmVkLCBiZWNhdXNlIGluIHR5cGVvZiwgdGhhdCdzIE9LXG4gICAgICAgICAgICByZXR1cm4gKGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmID8gbWFrZV9ub2RlKEFTVF9UcnVlLCBzZWxmKSA6IG1ha2Vfc2VxdWVuY2Uoc2VsZiwgW1xuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgbWFrZV9ub2RlKEFTVF9UcnVlLCBzZWxmKVxuICAgICAgICAgICAgXSkpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxmLm9wZXJhdG9yID09IFwiLVwiICYmIGUgaW5zdGFuY2VvZiBBU1RfSW5maW5pdHkpIHtcbiAgICAgICAgZSA9IGUudHJhbnNmb3JtKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICBpZiAoZSBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgJiYgKHNlbGYub3BlcmF0b3IgPT0gXCIrXCIgfHwgc2VsZi5vcGVyYXRvciA9PSBcIi1cIilcbiAgICAgICAgJiYgKGUub3BlcmF0b3IgPT0gXCIqXCIgfHwgZS5vcGVyYXRvciA9PSBcIi9cIiB8fCBlLm9wZXJhdG9yID09IFwiJVwiKSkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBlLm9wZXJhdG9yLFxuICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgZS5sZWZ0LCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6IHNlbGYub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZS5sZWZ0XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJpZ2h0OiBlLnJpZ2h0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBhdm9pZHMgaW5maW5pdGUgcmVjdXJzaW9uIG9mIG51bWVyYWxzXG4gICAgaWYgKHNlbGYub3BlcmF0b3IgIT0gXCItXCJcbiAgICAgICAgfHwgIShlIGluc3RhbmNlb2YgQVNUX051bWJlciB8fCBlIGluc3RhbmNlb2YgQVNUX0luZmluaXR5IHx8IGUgaW5zdGFuY2VvZiBBU1RfQmlnSW50KSkge1xuICAgICAgICB2YXIgZXYgPSBzZWxmLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAoZXYgIT09IHNlbGYpIHtcbiAgICAgICAgICAgIGV2ID0gbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoZXYsIHNlbGYpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGJlc3Rfb2YoY29tcHJlc3NvciwgZXYsIHNlbGYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbkFTVF9CaW5hcnkuREVGTUVUSE9EKFwibGlmdF9zZXF1ZW5jZXNcIiwgZnVuY3Rpb24oY29tcHJlc3Nvcikge1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInNlcXVlbmNlc1wiKSkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0IGluc3RhbmNlb2YgQVNUX1NlcXVlbmNlKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMubGVmdC5leHByZXNzaW9ucy5zbGljZSgpO1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICBlLmxlZnQgPSB4LnBvcCgpO1xuICAgICAgICAgICAgeC5wdXNoKGUpO1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2UodGhpcywgeCkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmlnaHQgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2UgJiYgIXRoaXMubGVmdC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICB2YXIgYXNzaWduID0gdGhpcy5vcGVyYXRvciA9PSBcIj1cIiAmJiB0aGlzLmxlZnQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmO1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLnJpZ2h0LmV4cHJlc3Npb25zO1xuICAgICAgICAgICAgdmFyIGxhc3QgPSB4Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghYXNzaWduICYmIHhbaV0uaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKSkgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgeCA9IHguc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBlLnJpZ2h0ID0geC5wb3AoKTtcbiAgICAgICAgICAgICAgICB4LnB1c2goZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2UodGhpcywgeCkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgZS5yaWdodCA9IG1ha2Vfc2VxdWVuY2UodGhpcy5yaWdodCwgeC5zbGljZShpKSk7XG4gICAgICAgICAgICAgICAgeCA9IHguc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgeC5wdXNoKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHRoaXMsIHgpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufSk7XG5cbnZhciBjb21tdXRhdGl2ZU9wZXJhdG9ycyA9IG1ha2VQcmVkaWNhdGUoXCI9PSA9PT0gIT0gIT09ICogJiB8IF5cIik7XG5mdW5jdGlvbiBpc19vYmplY3Qobm9kZSkge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgQVNUX0FycmF5XG4gICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfTGFtYmRhXG4gICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0XG4gICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3M7XG59XG5cbmRlZl9vcHRpbWl6ZShBU1RfQmluYXJ5LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgZnVuY3Rpb24gcmV2ZXJzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubGVmdC5pc19jb25zdGFudCgpXG4gICAgICAgICAgICB8fCBzZWxmLnJpZ2h0LmlzX2NvbnN0YW50KClcbiAgICAgICAgICAgIHx8ICFzZWxmLmxlZnQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgICYmICFzZWxmLnJpZ2h0Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3Nvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldmVyc2Uob3ApIHtcbiAgICAgICAgaWYgKHJldmVyc2libGUoKSkge1xuICAgICAgICAgICAgaWYgKG9wKSBzZWxmLm9wZXJhdG9yID0gb3A7XG4gICAgICAgICAgICB2YXIgdG1wID0gc2VsZi5sZWZ0O1xuICAgICAgICAgICAgc2VsZi5sZWZ0ID0gc2VsZi5yaWdodDtcbiAgICAgICAgICAgIHNlbGYucmlnaHQgPSB0bXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbW11dGF0aXZlT3BlcmF0b3JzLmhhcyhzZWxmLm9wZXJhdG9yKSkge1xuICAgICAgICBpZiAoc2VsZi5yaWdodC5pc19jb25zdGFudCgpXG4gICAgICAgICAgICAmJiAhc2VsZi5sZWZ0LmlzX2NvbnN0YW50KCkpIHtcbiAgICAgICAgICAgIC8vIGlmIHJpZ2h0IGlzIGEgY29uc3RhbnQsIHdoYXRldmVyIHNpZGUgZWZmZWN0cyB0aGVcbiAgICAgICAgICAgIC8vIGxlZnQgc2lkZSBtaWdodCBoYXZlIGNvdWxkIG5vdCBpbmZsdWVuY2UgdGhlXG4gICAgICAgICAgICAvLyByZXN1bHQuICBoZW5jZSwgZm9yY2Ugc3dpdGNoLlxuXG4gICAgICAgICAgICBpZiAoIShzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAgICAgICAmJiBQUkVDRURFTkNFW3NlbGYubGVmdC5vcGVyYXRvcl0gPj0gUFJFQ0VERU5DRVtzZWxmLm9wZXJhdG9yXSkpIHtcbiAgICAgICAgICAgICAgICByZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZiA9IHNlbGYubGlmdF9zZXF1ZW5jZXMoY29tcHJlc3Nvcik7XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiY29tcGFyaXNvbnNcIikpIHN3aXRjaCAoc2VsZi5vcGVyYXRvcikge1xuICAgICAgY2FzZSBcIj09PVwiOlxuICAgICAgY2FzZSBcIiE9PVwiOlxuICAgICAgICB2YXIgaXNfc3RyaWN0X2NvbXBhcmlzb24gPSB0cnVlO1xuICAgICAgICBpZiAoKHNlbGYubGVmdC5pc19zdHJpbmcoY29tcHJlc3NvcikgJiYgc2VsZi5yaWdodC5pc19zdHJpbmcoY29tcHJlc3NvcikpIHx8XG4gICAgICAgICAgICAoc2VsZi5sZWZ0LmlzX251bWJlcihjb21wcmVzc29yKSAmJiBzZWxmLnJpZ2h0LmlzX251bWJlcihjb21wcmVzc29yKSkgfHxcbiAgICAgICAgICAgIChzZWxmLmxlZnQuaXNfYm9vbGVhbigpICYmIHNlbGYucmlnaHQuaXNfYm9vbGVhbigpKSB8fFxuICAgICAgICAgICAgc2VsZi5sZWZ0LmVxdWl2YWxlbnRfdG8oc2VsZi5yaWdodCkpIHtcbiAgICAgICAgICAgIHNlbGYub3BlcmF0b3IgPSBzZWxmLm9wZXJhdG9yLnN1YnN0cigwLCAyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBYWFg6IGludGVudGlvbmFsbHkgZmFsbGluZyBkb3duIHRvIHRoZSBuZXh0IGNhc2VcbiAgICAgIGNhc2UgXCI9PVwiOlxuICAgICAgY2FzZSBcIiE9XCI6XG4gICAgICAgIC8vIHZvaWQgMCA9PSB4ID0+IG51bGwgPT0geFxuICAgICAgICBpZiAoIWlzX3N0cmljdF9jb21wYXJpc29uICYmIGlzX3VuZGVmaW5lZChzZWxmLmxlZnQsIGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICBzZWxmLmxlZnQgPSBtYWtlX25vZGUoQVNUX051bGwsIHNlbGYubGVmdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ0eXBlb2ZzXCIpXG4gICAgICAgICAgICAvLyBcInVuZGVmaW5lZFwiID09IHR5cGVvZiB4ID0+IHVuZGVmaW5lZCA9PT0geFxuICAgICAgICAgICAgJiYgc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX1N0cmluZ1xuICAgICAgICAgICAgJiYgc2VsZi5sZWZ0LnZhbHVlID09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQub3BlcmF0b3IgPT0gXCJ0eXBlb2ZcIikge1xuICAgICAgICAgICAgdmFyIGV4cHIgPSBzZWxmLnJpZ2h0LmV4cHJlc3Npb247XG4gICAgICAgICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgPyBleHByLmlzX2RlY2xhcmVkKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgOiAhKGV4cHIgaW5zdGFuY2VvZiBBU1RfUHJvcEFjY2VzcyAmJiBjb21wcmVzc29yLm9wdGlvbihcImllOFwiKSkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJpZ2h0ID0gZXhwcjtcbiAgICAgICAgICAgICAgICBzZWxmLmxlZnQgPSBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZi5sZWZ0KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5vcGVyYXRvci5sZW5ndGggPT0gMikgc2VsZi5vcGVyYXRvciArPSBcIj1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAvLyBvYmogIT09IG9iaiA9PiBmYWxzZVxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgICAgICYmIHNlbGYubGVmdC5kZWZpbml0aW9uKCkgPT09IHNlbGYucmlnaHQuZGVmaW5pdGlvbigpXG4gICAgICAgICAgICAmJiBpc19vYmplY3Qoc2VsZi5sZWZ0LmZpeGVkX3ZhbHVlKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKHNlbGYub3BlcmF0b3JbMF0gPT0gXCI9XCIgPyBBU1RfVHJ1ZSA6IEFTVF9GYWxzZSwgc2VsZik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiJiZcIjpcbiAgICAgIGNhc2UgXCJ8fFwiOlxuICAgICAgICB2YXIgbGhzID0gc2VsZi5sZWZ0O1xuICAgICAgICBpZiAobGhzLm9wZXJhdG9yID09IHNlbGYub3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGxocyA9IGxocy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGhzIGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgJiYgbGhzLm9wZXJhdG9yID09IChzZWxmLm9wZXJhdG9yID09IFwiJiZcIiA/IFwiIT09XCIgOiBcIj09PVwiKVxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICYmIGxocy5vcGVyYXRvciA9PSBzZWxmLnJpZ2h0Lm9wZXJhdG9yXG4gICAgICAgICAgICAmJiAoaXNfdW5kZWZpbmVkKGxocy5sZWZ0LCBjb21wcmVzc29yKSAmJiBzZWxmLnJpZ2h0LmxlZnQgaW5zdGFuY2VvZiBBU1RfTnVsbFxuICAgICAgICAgICAgICAgIHx8IGxocy5sZWZ0IGluc3RhbmNlb2YgQVNUX051bGwgJiYgaXNfdW5kZWZpbmVkKHNlbGYucmlnaHQubGVmdCwgY29tcHJlc3NvcikpXG4gICAgICAgICAgICAmJiAhbGhzLnJpZ2h0Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgICAgICYmIGxocy5yaWdodC5lcXVpdmFsZW50X3RvKHNlbGYucmlnaHQucmlnaHQpKSB7XG4gICAgICAgICAgICB2YXIgY29tYmluZWQgPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBsaHMub3BlcmF0b3Iuc2xpY2UoMCwgLTEpLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG1ha2Vfbm9kZShBU1RfTnVsbCwgc2VsZiksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGxocy5yaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobGhzICE9PSBzZWxmLmxlZnQpIHtcbiAgICAgICAgICAgICAgICBjb21iaW5lZCA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBzZWxmLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmxlZnQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbWJpbmVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChzZWxmLm9wZXJhdG9yID09IFwiK1wiICYmIGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHtcbiAgICAgICAgdmFyIGxsID0gc2VsZi5sZWZ0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICB2YXIgcnIgPSBzZWxmLnJpZ2h0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAobGwgJiYgdHlwZW9mIGxsID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHNlbGYsIFtcbiAgICAgICAgICAgICAgICBzZWxmLnJpZ2h0LFxuICAgICAgICAgICAgICAgIG1ha2Vfbm9kZShBU1RfVHJ1ZSwgc2VsZilcbiAgICAgICAgICAgIF0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyciAmJiB0eXBlb2YgcnIgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uoc2VsZiwgW1xuICAgICAgICAgICAgICAgIHNlbGYubGVmdCxcbiAgICAgICAgICAgICAgICBtYWtlX25vZGUoQVNUX1RydWUsIHNlbGYpXG4gICAgICAgICAgICBdKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJjb21wYXJpc29uc1wiKSAmJiBzZWxmLmlzX2Jvb2xlYW4oKSkge1xuICAgICAgICBpZiAoIShjb21wcmVzc29yLnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX0JpbmFyeSlcbiAgICAgICAgICAgIHx8IGNvbXByZXNzb3IucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfQXNzaWduKSB7XG4gICAgICAgICAgICB2YXIgbmVnYXRlZCA9IG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIhXCIsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogc2VsZi5uZWdhdGUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KGNvbXByZXNzb3IpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmID0gYmVzdF9vZihjb21wcmVzc29yLCBzZWxmLCBuZWdhdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVfY29tcHNcIikpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5vcGVyYXRvcikge1xuICAgICAgICAgICAgICBjYXNlIFwiPFwiOiByZXZlcnNlKFwiPlwiKTsgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCI8PVwiOiByZXZlcnNlKFwiPj1cIik7IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxmLm9wZXJhdG9yID09IFwiK1wiKSB7XG4gICAgICAgIGlmIChzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1N0cmluZ1xuICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5nZXRWYWx1ZSgpID09IFwiXCJcbiAgICAgICAgICAgICYmIHNlbGYubGVmdC5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9TdHJpbmdcbiAgICAgICAgICAgICYmIHNlbGYubGVmdC5nZXRWYWx1ZSgpID09IFwiXCJcbiAgICAgICAgICAgICYmIHNlbGYucmlnaHQuaXNfc3RyaW5nKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgJiYgc2VsZi5sZWZ0Lm9wZXJhdG9yID09IFwiK1wiXG4gICAgICAgICAgICAmJiBzZWxmLmxlZnQubGVmdCBpbnN0YW5jZW9mIEFTVF9TdHJpbmdcbiAgICAgICAgICAgICYmIHNlbGYubGVmdC5sZWZ0LmdldFZhbHVlKCkgPT0gXCJcIlxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHNlbGYubGVmdCA9IHNlbGYubGVmdC5yaWdodDtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcImV2YWx1YXRlXCIpKSB7XG4gICAgICAgIHN3aXRjaCAoc2VsZi5vcGVyYXRvcikge1xuICAgICAgICAgIGNhc2UgXCImJlwiOlxuICAgICAgICAgICAgdmFyIGxsID0gaGFzX2ZsYWcoc2VsZi5sZWZ0LCBUUlVUSFkpXG4gICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgOiBoYXNfZmxhZyhzZWxmLmxlZnQsIEZBTFNZKVxuICAgICAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIDogc2VsZi5sZWZ0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgaWYgKCFsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWludGFpbl90aGlzX2JpbmRpbmcoY29tcHJlc3Nvci5wYXJlbnQoKSwgY29tcHJlc3Nvci5zZWxmKCksIHNlbGYubGVmdCkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEobGwgaW5zdGFuY2VvZiBBU1RfTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShzZWxmLCBbIHNlbGYubGVmdCwgc2VsZi5yaWdodCBdKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByciA9IHNlbGYucmlnaHQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBpZiAoIXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uoc2VsZiwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZV9ub2RlKEFTVF9GYWxzZSwgc2VsZilcbiAgICAgICAgICAgICAgICAgICAgXSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0X2ZsYWcoc2VsZiwgRkFMU1kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShyciBpbnN0YW5jZW9mIEFTVF9Ob2RlKSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBjb21wcmVzc29yLnBhcmVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQub3BlcmF0b3IgPT0gXCImJlwiICYmIHBhcmVudC5sZWZ0ID09PSBjb21wcmVzc29yLnNlbGYoKSB8fCBjb21wcmVzc29yLmluX2Jvb2xlYW5fY29udGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmxlZnQub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8geCB8fCBmYWxzZSAmJiB5IC0tLT4geCA/IHkgOiBmYWxzZVxuICAgICAgICAgICAgaWYgKHNlbGYubGVmdC5vcGVyYXRvciA9PSBcInx8XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbHIgPSBzZWxmLmxlZnQucmlnaHQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgaWYgKCFscikgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQ29uZGl0aW9uYWwsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uOiBzZWxmLmxlZnQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVudDogc2VsZi5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IHNlbGYubGVmdC5yaWdodFxuICAgICAgICAgICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInx8XCI6XG4gICAgICAgICAgICB2YXIgbGwgPSBoYXNfZmxhZyhzZWxmLmxlZnQsIFRSVVRIWSlcbiAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgIDogaGFzX2ZsYWcoc2VsZi5sZWZ0LCBGQUxTWSlcbiAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiBzZWxmLmxlZnQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICBpZiAoIWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uoc2VsZiwgWyBzZWxmLmxlZnQsIHNlbGYucmlnaHQgXSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEobGwgaW5zdGFuY2VvZiBBU1RfTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbnRhaW5fdGhpc19iaW5kaW5nKGNvbXByZXNzb3IucGFyZW50KCksIGNvbXByZXNzb3Iuc2VsZigpLCBzZWxmLmxlZnQpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJyID0gc2VsZi5yaWdodC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIGlmICghcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gY29tcHJlc3Nvci5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm9wZXJhdG9yID09IFwifHxcIiAmJiBwYXJlbnQubGVmdCA9PT0gY29tcHJlc3Nvci5zZWxmKCkgfHwgY29tcHJlc3Nvci5pbl9ib29sZWFuX2NvbnRleHQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5sZWZ0Lm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShyciBpbnN0YW5jZW9mIEFTVF9Ob2RlKSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wcmVzc29yLmluX2Jvb2xlYW5fY29udGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHNlbGYsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2Vfbm9kZShBU1RfVHJ1ZSwgc2VsZilcbiAgICAgICAgICAgICAgICAgICAgXSkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0X2ZsYWcoc2VsZiwgVFJVVEhZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5sZWZ0Lm9wZXJhdG9yID09IFwiJiZcIikge1xuICAgICAgICAgICAgICAgIHZhciBsciA9IHNlbGYubGVmdC5yaWdodC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAobHIgJiYgIShsciBpbnN0YW5jZW9mIEFTVF9Ob2RlKSkgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQ29uZGl0aW9uYWwsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uOiBzZWxmLmxlZnQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVudDogc2VsZi5sZWZ0LnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZTogc2VsZi5yaWdodFxuICAgICAgICAgICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIj8/XCI6XG4gICAgICAgICAgICBpZiAoaXNfbnVsbGlzaChzZWxmLmxlZnQsIGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucmlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsbCA9IHNlbGYubGVmdC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIGlmICghKGxsIGluc3RhbmNlb2YgQVNUX05vZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2Uga25vdyB0aGUgdmFsdWUgZm9yIHN1cmUgd2UgY2FuIHNpbXBseSBjb21wdXRlIHJpZ2h0IGF3YXkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxsID09IG51bGwgPyBzZWxmLnJpZ2h0IDogc2VsZi5sZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5pbl9ib29sZWFuX2NvbnRleHQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJyID0gc2VsZi5yaWdodC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAoIShyciBpbnN0YW5jZW9mIEFTVF9Ob2RlKSAmJiAhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFzc29jaWF0aXZlID0gdHJ1ZTtcbiAgICAgICAgc3dpdGNoIChzZWxmLm9wZXJhdG9yKSB7XG4gICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgIC8vICh4ICsgXCJmb29cIikgKyBcImJhclwiID0+IHggKyBcImZvb2JhclwiXG4gICAgICAgICAgICBpZiAoc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQub3BlcmF0b3IgPT0gXCIrXCJcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQuaXNfc3RyaW5nKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpbmFyeSA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5sZWZ0LnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogc2VsZi5yaWdodCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGJpbmFyeS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAoYmluYXJ5ICE9PSByKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5sZWZ0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAoeCArIFwiZm9vXCIpICsgKFwiYmFyXCIgKyB5KSA9PiAoeCArIFwiZm9vYmFyXCIpICsgeVxuICAgICAgICAgICAgaWYgKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQub3BlcmF0b3IgPT0gXCIrXCJcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQuaXNfc3RyaW5nKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0Lm9wZXJhdG9yID09IFwiK1wiXG4gICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5pc19zdHJpbmcoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmluYXJ5ID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IFwiK1wiLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmxlZnQucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLnJpZ2h0LmxlZnQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBiaW5hcnkub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmFyeSAhPT0gbSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmxlZnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCIrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5sZWZ0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IG1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYucmlnaHQucmlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYSArIC1iID0+IGEgLSBiXG4gICAgICAgICAgICBpZiAoc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9VbmFyeVByZWZpeFxuICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQub3BlcmF0b3IgPT0gXCItXCJcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQuaXNfbnVtYmVyKGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIi1cIixcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICByaWdodDogc2VsZi5yaWdodC5leHByZXNzaW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtYSArIGIgPT4gYiAtIGFcbiAgICAgICAgICAgIGlmIChzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQub3BlcmF0b3IgPT0gXCItXCJcbiAgICAgICAgICAgICAgICAmJiByZXZlcnNpYmxlKClcbiAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LmlzX251bWJlcihjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgIHNlbGYgPSBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCItXCIsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLmxlZnQuZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYGZvbyR7YmFyfWJhemAgKyAxID0+IGBmb28ke2Jhcn1iYXoxYFxuICAgICAgICAgICAgaWYgKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9UZW1wbGF0ZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBsID0gc2VsZi5sZWZ0O1xuICAgICAgICAgICAgICAgIHZhciByID0gc2VsZi5yaWdodC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAociAhPSBzZWxmLnJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGwuc2VnbWVudHNbbC5zZWdtZW50cy5sZW5ndGggLSAxXS52YWx1ZSArPSBTdHJpbmcocik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDEgKyBgZm9vJHtiYXJ9YmF6YCA9PiBgMWZvbyR7YmFyfWJhemBcbiAgICAgICAgICAgIGlmIChzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1RlbXBsYXRlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBzZWxmLnJpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBsID0gc2VsZi5sZWZ0LmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgICAgIGlmIChsICE9IHNlbGYubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICByLnNlZ21lbnRzWzBdLnZhbHVlID0gU3RyaW5nKGwpICsgci5zZWdtZW50c1swXS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYDEke2Jhcn0yYCArIGBmb28ke2Jhcn1iYXpgID0+IGAxJHtiYXJ9MmZvbyR7YmFyfWJhemBcbiAgICAgICAgICAgIGlmIChzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfVGVtcGxhdGVTdHJpbmdcbiAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX1RlbXBsYXRlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSBzZWxmLmxlZnQ7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gbC5zZWdtZW50cztcbiAgICAgICAgICAgICAgICB2YXIgciA9IHNlbGYucmlnaHQ7XG4gICAgICAgICAgICAgICAgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0udmFsdWUgKz0gci5zZWdtZW50c1swXS52YWx1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHIuc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChyLnNlZ21lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgIGFzc29jaWF0aXZlID0gY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVfbWF0aFwiKTtcbiAgICAgICAgICBjYXNlIFwiJlwiOlxuICAgICAgICAgIGNhc2UgXCJ8XCI6XG4gICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgIC8vIGEgKyArYiA9PiArYiArIGFcbiAgICAgICAgICAgIGlmIChzZWxmLmxlZnQuaXNfbnVtYmVyKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5pc19udW1iZXIoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAmJiByZXZlcnNpYmxlKClcbiAgICAgICAgICAgICAgICAmJiAhKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0Lm9wZXJhdG9yICE9IHNlbGYub3BlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgJiYgUFJFQ0VERU5DRVtzZWxmLmxlZnQub3BlcmF0b3JdID49IFBSRUNFREVOQ0Vbc2VsZi5vcGVyYXRvcl0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldmVyc2VkID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHNlbGYub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLmxlZnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICAgICAmJiAhKHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IGJlc3Rfb2YoY29tcHJlc3NvciwgcmV2ZXJzZWQsIHNlbGYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYgPSBiZXN0X29mKGNvbXByZXNzb3IsIHNlbGYsIHJldmVyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXNzb2NpYXRpdmUgJiYgc2VsZi5pc19udW1iZXIoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICAvLyBhICsgKGIgKyBjKSA9PiAoYSArIGIpICsgY1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0Lm9wZXJhdG9yID09IHNlbGYub3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogc2VsZi5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmxlZnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogc2VsZi5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYucmlnaHQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VsZi5sZWZ0LnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogc2VsZi5yaWdodC5sZWZ0LmVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogc2VsZi5yaWdodC5yaWdodFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gKG4gKyAyKSArIDMgPT4gNSArIG5cbiAgICAgICAgICAgICAgICAvLyAoMiAqIG4pICogMyA9PiA2ICsgblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5sZWZ0Lm9wZXJhdG9yID09IHNlbGYub3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYubGVmdC5sZWZ0IGluc3RhbmNlb2YgQVNUX0NvbnN0YW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogc2VsZi5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZi5sZWZ0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBzZWxmLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmxlZnQubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzZWxmLmxlZnQubGVmdC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWxmLnJpZ2h0LmVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLmxlZnQucmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYubGVmdC5yaWdodCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZiA9IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3I6IHNlbGYub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYubGVmdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogc2VsZi5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5sZWZ0LnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogc2VsZi5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlbGYubGVmdC5yaWdodC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWxmLnJpZ2h0LmVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBzZWxmLmxlZnQubGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gKGEgfCAxKSB8ICgyIHwgZCkgPT4gKDMgfCBhKSB8IGJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5sZWZ0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQub3BlcmF0b3IgPT0gc2VsZi5vcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLmxlZnQucmlnaHQgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodCBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5vcGVyYXRvciA9PSBzZWxmLm9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICYmIHNlbGYucmlnaHQubGVmdCBpbnN0YW5jZW9mIEFTVF9Db25zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBzZWxmLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYubGVmdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBzZWxmLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLmxlZnQubGVmdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogc2VsZi5vcGVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc2VsZi5sZWZ0LnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogc2VsZi5yaWdodC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VsZi5sZWZ0LnJpZ2h0LnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlbGYucmlnaHQubGVmdC5lbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogc2VsZi5sZWZ0LmxlZnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYucmlnaHQucmlnaHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHggJiYgKHkgJiYgeikgID09PiAgeCAmJiB5ICYmIHpcbiAgICAvLyB4IHx8ICh5IHx8IHopICA9PT4gIHggfHwgeSB8fCB6XG4gICAgLy8geCArIChcInlcIiArIHopICA9PT4gIHggKyBcInlcIiArIHpcbiAgICAvLyBcInhcIiArICh5ICsgXCJ6XCIpPT0+ICBcInhcIiArIHkgKyBcInpcIlxuICAgIGlmIChzZWxmLnJpZ2h0IGluc3RhbmNlb2YgQVNUX0JpbmFyeVxuICAgICAgICAmJiBzZWxmLnJpZ2h0Lm9wZXJhdG9yID09IHNlbGYub3BlcmF0b3JcbiAgICAgICAgJiYgKGxhenlfb3AuaGFzKHNlbGYub3BlcmF0b3IpXG4gICAgICAgICAgICB8fCAoc2VsZi5vcGVyYXRvciA9PSBcIitcIlxuICAgICAgICAgICAgICAgICYmIChzZWxmLnJpZ2h0LmxlZnQuaXNfc3RyaW5nKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgICAgIHx8IChzZWxmLmxlZnQuaXNfc3RyaW5nKGNvbXByZXNzb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LnJpZ2h0LmlzX3N0cmluZyhjb21wcmVzc29yKSkpKSlcbiAgICApIHtcbiAgICAgICAgc2VsZi5sZWZ0ID0gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYubGVmdCwge1xuICAgICAgICAgICAgb3BlcmF0b3IgOiBzZWxmLm9wZXJhdG9yLFxuICAgICAgICAgICAgbGVmdCAgICAgOiBzZWxmLmxlZnQudHJhbnNmb3JtKGNvbXByZXNzb3IpLFxuICAgICAgICAgICAgcmlnaHQgICAgOiBzZWxmLnJpZ2h0LmxlZnQudHJhbnNmb3JtKGNvbXByZXNzb3IpXG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLnJpZ2h0ID0gc2VsZi5yaWdodC5yaWdodC50cmFuc2Zvcm0oY29tcHJlc3Nvcik7XG4gICAgICAgIHJldHVybiBzZWxmLnRyYW5zZm9ybShjb21wcmVzc29yKTtcbiAgICB9XG4gICAgdmFyIGV2ID0gc2VsZi5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICBpZiAoZXYgIT09IHNlbGYpIHtcbiAgICAgICAgZXYgPSBtYWtlX25vZGVfZnJvbV9jb25zdGFudChldiwgc2VsZikub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIHJldHVybiBiZXN0X29mKGNvbXByZXNzb3IsIGV2LCBzZWxmKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9TeW1ib2xFeHBvcnQsIGZ1bmN0aW9uKHNlbGYpIHtcbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5mdW5jdGlvbiByZWN1cnNpdmVfcmVmKGNvbXByZXNzb3IsIGRlZikge1xuICAgIHZhciBub2RlO1xuICAgIGZvciAodmFyIGkgPSAwOyBub2RlID0gY29tcHJlc3Nvci5wYXJlbnQoaSk7IGkrKykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX0xhbWJkYVxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9DbGFzc1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS5kZWZpbml0aW9uKCkgPT09IGRlZikgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHdpdGhpbl9hcnJheV9vcl9vYmplY3RfbGl0ZXJhbChjb21wcmVzc29yKSB7XG4gICAgdmFyIG5vZGUsIGxldmVsID0gMDtcbiAgICB3aGlsZSAobm9kZSA9IGNvbXByZXNzb3IucGFyZW50KGxldmVsKyspKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N0YXRlbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9BcnJheVxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9PYmplY3RLZXlWYWxcbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmRlZl9vcHRpbWl6ZShBU1RfU3ltYm9sUmVmLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKFxuICAgICAgICAhY29tcHJlc3Nvci5vcHRpb24oXCJpZThcIilcbiAgICAgICAgJiYgaXNfdW5kZWNsYXJlZF9yZWYoc2VsZilcbiAgICAgICAgJiYgIWNvbXByZXNzb3IuZmluZF9wYXJlbnQoQVNUX1dpdGgpXG4gICAgKSB7XG4gICAgICAgIHN3aXRjaCAoc2VsZi5uYW1lKSB7XG4gICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICBjYXNlIFwiTmFOXCI6XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9OYU4sIHNlbGYpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgIGNhc2UgXCJJbmZpbml0eVwiOlxuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfSW5maW5pdHksIHNlbGYpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50ID0gY29tcHJlc3Nvci5wYXJlbnQoKTtcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJyZWR1Y2VfdmFyc1wiKSAmJiBpc19saHMoc2VsZiwgcGFyZW50KSAhPT0gc2VsZikge1xuICAgICAgICBjb25zdCBkZWYgPSBzZWxmLmRlZmluaXRpb24oKTtcbiAgICAgICAgY29uc3QgbmVhcmVzdF9zY29wZSA9IGZpbmRfc2NvcGUoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChjb21wcmVzc29yLnRvcF9yZXRhaW4gJiYgZGVmLmdsb2JhbCAmJiBjb21wcmVzc29yLnRvcF9yZXRhaW4oZGVmKSkge1xuICAgICAgICAgICAgZGVmLmZpeGVkID0gZmFsc2U7XG4gICAgICAgICAgICBkZWYuc2luZ2xlX3VzZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZml4ZWQgPSBzZWxmLmZpeGVkX3ZhbHVlKCk7XG4gICAgICAgIGxldCBzaW5nbGVfdXNlID0gZGVmLnNpbmdsZV91c2VcbiAgICAgICAgICAgICYmICEocGFyZW50IGluc3RhbmNlb2YgQVNUX0NhbGxcbiAgICAgICAgICAgICAgICAmJiAocGFyZW50LmlzX2NhbGxlZV9wdXJlKGNvbXByZXNzb3IpKVxuICAgICAgICAgICAgICAgICAgICB8fCBoYXNfYW5ub3RhdGlvbihwYXJlbnQsIF9OT0lOTElORSkpXG4gICAgICAgICAgICAmJiAhKHBhcmVudCBpbnN0YW5jZW9mIEFTVF9FeHBvcnRcbiAgICAgICAgICAgICAgICAmJiBmaXhlZCBpbnN0YW5jZW9mIEFTVF9MYW1iZGFcbiAgICAgICAgICAgICAgICAmJiBmaXhlZC5uYW1lKTtcblxuICAgICAgICBpZiAoc2luZ2xlX3VzZSAmJiBmaXhlZCBpbnN0YW5jZW9mIEFTVF9Ob2RlKSB7XG4gICAgICAgICAgICBzaW5nbGVfdXNlID1cbiAgICAgICAgICAgICAgICAhZml4ZWQuaGFzX3NpZGVfZWZmZWN0cyhjb21wcmVzc29yKVxuICAgICAgICAgICAgICAgICYmICFmaXhlZC5tYXlfdGhyb3coY29tcHJlc3Nvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2luZ2xlX3VzZSAmJiAoZml4ZWQgaW5zdGFuY2VvZiBBU1RfTGFtYmRhIHx8IGZpeGVkIGluc3RhbmNlb2YgQVNUX0NsYXNzKSkge1xuICAgICAgICAgICAgaWYgKHJldGFpbl90b3BfZnVuYyhmaXhlZCwgY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgICAgICBzaW5nbGVfdXNlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlZi5zY29wZSAhPT0gc2VsZi5zY29wZVxuICAgICAgICAgICAgICAgICYmIChkZWYuZXNjYXBlZCA9PSAxXG4gICAgICAgICAgICAgICAgICAgIHx8IGhhc19mbGFnKGZpeGVkLCBJTkxJTkVEKVxuICAgICAgICAgICAgICAgICAgICB8fCB3aXRoaW5fYXJyYXlfb3Jfb2JqZWN0X2xpdGVyYWwoY29tcHJlc3NvcilcbiAgICAgICAgICAgICAgICAgICAgfHwgIWNvbXByZXNzb3Iub3B0aW9uKFwicmVkdWNlX2Z1bmNzXCIpKSkge1xuICAgICAgICAgICAgICAgIHNpbmdsZV91c2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVjdXJzaXZlX3JlZihjb21wcmVzc29yLCBkZWYpKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlX3VzZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWYuc2NvcGUgIT09IHNlbGYuc2NvcGUgfHwgZGVmLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sRnVuYXJnKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlX3VzZSA9IGZpeGVkLmlzX2NvbnN0YW50X2V4cHJlc3Npb24oc2VsZi5zY29wZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZV91c2UgPT0gXCJmXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjb3BlID0gc2VsZi5zY29wZTtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlIGluc3RhbmNlb2YgQVNUX0RlZnVuIHx8IGlzX2Z1bmNfZXhwcihzY29wZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRfZmxhZyhzY29wZSwgSU5MSU5FRCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50X3Njb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2luZ2xlX3VzZSAmJiBmaXhlZCBpbnN0YW5jZW9mIEFTVF9MYW1iZGEpIHtcbiAgICAgICAgICAgIHNpbmdsZV91c2UgPVxuICAgICAgICAgICAgICAgIGRlZi5zY29wZSA9PT0gc2VsZi5zY29wZVxuICAgICAgICAgICAgICAgICAgICAmJiAhc2NvcGVfZW5jbG9zZXNfdmFyaWFibGVzX2luX3RoaXNfc2NvcGUobmVhcmVzdF9zY29wZSwgZml4ZWQpXG4gICAgICAgICAgICAgICAgfHwgcGFyZW50IGluc3RhbmNlb2YgQVNUX0NhbGxcbiAgICAgICAgICAgICAgICAgICAgJiYgcGFyZW50LmV4cHJlc3Npb24gPT09IHNlbGZcbiAgICAgICAgICAgICAgICAgICAgJiYgIXNjb3BlX2VuY2xvc2VzX3ZhcmlhYmxlc19pbl90aGlzX3Njb3BlKG5lYXJlc3Rfc2NvcGUsIGZpeGVkKVxuICAgICAgICAgICAgICAgICAgICAmJiAhKGZpeGVkLm5hbWUgJiYgZml4ZWQubmFtZS5kZWZpbml0aW9uKCkucmVjdXJzaXZlX3JlZnMgPiAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaW5nbGVfdXNlICYmIGZpeGVkKSB7XG4gICAgICAgICAgICBpZiAoZml4ZWQgaW5zdGFuY2VvZiBBU1RfRGVmQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBzZXRfZmxhZyhmaXhlZCwgU1FVRUVaRUQpO1xuICAgICAgICAgICAgICAgIGZpeGVkID0gbWFrZV9ub2RlKEFTVF9DbGFzc0V4cHJlc3Npb24sIGZpeGVkLCBmaXhlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZml4ZWQgaW5zdGFuY2VvZiBBU1RfRGVmdW4pIHtcbiAgICAgICAgICAgICAgICBzZXRfZmxhZyhmaXhlZCwgU1FVRUVaRUQpO1xuICAgICAgICAgICAgICAgIGZpeGVkID0gbWFrZV9ub2RlKEFTVF9GdW5jdGlvbiwgZml4ZWQsIGZpeGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWYucmVjdXJzaXZlX3JlZnMgPiAwICYmIGZpeGVkLm5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sRGVmdW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZ1bl9kZWYgPSBmaXhlZC5uYW1lLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgICAgICBsZXQgbGFtYmRhX2RlZiA9IGZpeGVkLnZhcmlhYmxlcy5nZXQoZml4ZWQubmFtZS5uYW1lKTtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGxhbWJkYV9kZWYgJiYgbGFtYmRhX2RlZi5vcmlnWzBdO1xuICAgICAgICAgICAgICAgIGlmICghKG5hbWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTGFtYmRhKSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbWFrZV9ub2RlKEFTVF9TeW1ib2xMYW1iZGEsIGZpeGVkLm5hbWUsIGZpeGVkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBuYW1lLnNjb3BlID0gZml4ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGZpeGVkLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICBsYW1iZGFfZGVmID0gZml4ZWQuZGVmX2Z1bmN0aW9uKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YWxrKGZpeGVkLCBub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmICYmIG5vZGUuZGVmaW5pdGlvbigpID09PSBkZWZ1bl9kZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudGhlZGVmID0gbGFtYmRhX2RlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbWJkYV9kZWYucmVmZXJlbmNlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGZpeGVkIGluc3RhbmNlb2YgQVNUX0xhbWJkYSB8fCBmaXhlZCBpbnN0YW5jZW9mIEFTVF9DbGFzcylcbiAgICAgICAgICAgICAgICAmJiBmaXhlZC5wYXJlbnRfc2NvcGUgIT09IG5lYXJlc3Rfc2NvcGVcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGZpeGVkID0gZml4ZWQuY2xvbmUodHJ1ZSwgY29tcHJlc3Nvci5nZXRfdG9wbGV2ZWwoKSk7XG5cbiAgICAgICAgICAgICAgICBuZWFyZXN0X3Njb3BlLmFkZF9jaGlsZF9zY29wZShmaXhlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZml4ZWQub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtdWx0aXBsZSB1c2VzXG4gICAgICAgIGlmIChmaXhlZCkge1xuICAgICAgICAgICAgbGV0IHJlcGxhY2U7XG5cbiAgICAgICAgICAgIGlmIChmaXhlZCBpbnN0YW5jZW9mIEFTVF9UaGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZGVmLm9yaWdbMF0gaW5zdGFuY2VvZiBBU1RfU3ltYm9sRnVuYXJnKVxuICAgICAgICAgICAgICAgICAgICAmJiBkZWYucmVmZXJlbmNlcy5ldmVyeSgocmVmKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmLnNjb3BlID09PSByZWYuc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlID0gZml4ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZXYgPSBmaXhlZC5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGV2ICE9PSBmaXhlZFxuICAgICAgICAgICAgICAgICAgICAmJiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVfcmVnZXhwXCIpIHx8ICEoZXYgaW5zdGFuY2VvZiBSZWdFeHApKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlID0gbWFrZV9ub2RlX2Zyb21fY29uc3RhbnQoZXYsIGZpeGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZV9sZW5ndGggPSBzZWxmLnNpemUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZV9zaXplID0gcmVwbGFjZS5zaXplKGNvbXByZXNzb3IpO1xuXG4gICAgICAgICAgICAgICAgbGV0IG92ZXJoZWFkID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnVzZWRcIikgJiYgIWNvbXByZXNzb3IuZXhwb3NlZChkZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJoZWFkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lX2xlbmd0aCArIDIgKyByZXBsYWNlX3NpemUpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgIChkZWYucmVmZXJlbmNlcy5sZW5ndGggLSBkZWYuYXNzaWdubWVudHMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlX3NpemUgPD0gbmFtZV9sZW5ndGggKyBvdmVyaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5mdW5jdGlvbiBzY29wZV9lbmNsb3Nlc192YXJpYWJsZXNfaW5fdGhpc19zY29wZShzY29wZSwgcHVsbGVkX3Njb3BlKSB7XG4gICAgZm9yIChjb25zdCBlbmNsb3NlZCBvZiBwdWxsZWRfc2NvcGUuZW5jbG9zZWQpIHtcbiAgICAgICAgaWYgKHB1bGxlZF9zY29wZS52YXJpYWJsZXMuaGFzKGVuY2xvc2VkLm5hbWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb29rZWRfdXAgPSBzY29wZS5maW5kX3ZhcmlhYmxlKGVuY2xvc2VkLm5hbWUpO1xuICAgICAgICBpZiAobG9va2VkX3VwKSB7XG4gICAgICAgICAgICBpZiAobG9va2VkX3VwID09PSBlbmNsb3NlZCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzX2F0b21pYyhsaHMsIHNlbGYpIHtcbiAgICByZXR1cm4gbGhzIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZiB8fCBsaHMuVFlQRSA9PT0gc2VsZi5UWVBFO1xufVxuXG5kZWZfb3B0aW1pemUoQVNUX1VuZGVmaW5lZCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZV91bmRlZmluZWRcIikpIHtcbiAgICAgICAgdmFyIHVuZGVmID0gZmluZF92YXJpYWJsZShjb21wcmVzc29yLCBcInVuZGVmaW5lZFwiKTtcbiAgICAgICAgaWYgKHVuZGVmKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gbWFrZV9ub2RlKEFTVF9TeW1ib2xSZWYsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBuYW1lICAgOiBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgICAgIHNjb3BlICA6IHVuZGVmLnNjb3BlLFxuICAgICAgICAgICAgICAgIHRoZWRlZiA6IHVuZGVmXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldF9mbGFnKHJlZiwgVU5ERUZJTkVEKTtcbiAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGxocyA9IGlzX2xocyhjb21wcmVzc29yLnNlbGYoKSwgY29tcHJlc3Nvci5wYXJlbnQoKSk7XG4gICAgaWYgKGxocyAmJiBpc19hdG9taWMobGhzLCBzZWxmKSkgcmV0dXJuIHNlbGY7XG4gICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5hcnlQcmVmaXgsIHNlbGYsIHtcbiAgICAgICAgb3BlcmF0b3I6IFwidm9pZFwiLFxuICAgICAgICBleHByZXNzaW9uOiBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZiwge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSlcbiAgICB9KTtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX0luZmluaXR5LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgdmFyIGxocyA9IGlzX2xocyhjb21wcmVzc29yLnNlbGYoKSwgY29tcHJlc3Nvci5wYXJlbnQoKSk7XG4gICAgaWYgKGxocyAmJiBpc19hdG9taWMobGhzLCBzZWxmKSkgcmV0dXJuIHNlbGY7XG4gICAgaWYgKFxuICAgICAgICBjb21wcmVzc29yLm9wdGlvbihcImtlZXBfaW5maW5pdHlcIilcbiAgICAgICAgJiYgIShsaHMgJiYgIWlzX2F0b21pYyhsaHMsIHNlbGYpKVxuICAgICAgICAmJiAhZmluZF92YXJpYWJsZShjb21wcmVzc29yLCBcIkluZmluaXR5XCIpXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgb3BlcmF0b3I6IFwiL1wiLFxuICAgICAgICBsZWZ0OiBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZiwge1xuICAgICAgICAgICAgdmFsdWU6IDFcbiAgICAgICAgfSksXG4gICAgICAgIHJpZ2h0OiBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZiwge1xuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSlcbiAgICB9KTtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX05hTiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIHZhciBsaHMgPSBpc19saHMoY29tcHJlc3Nvci5zZWxmKCksIGNvbXByZXNzb3IucGFyZW50KCkpO1xuICAgIGlmIChsaHMgJiYgIWlzX2F0b21pYyhsaHMsIHNlbGYpXG4gICAgICAgIHx8IGZpbmRfdmFyaWFibGUoY29tcHJlc3NvciwgXCJOYU5cIikpIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICBvcGVyYXRvcjogXCIvXCIsXG4gICAgICAgICAgICBsZWZ0OiBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJpZ2h0OiBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZnVuY3Rpb24gaXNfcmVhY2hhYmxlKHNlbGYsIGRlZnMpIHtcbiAgICBjb25zdCBmaW5kX3JlZiA9IG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWYgJiYgbWVtYmVyKG5vZGUuZGVmaW5pdGlvbigpLCBkZWZzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdhbGtfYWJvcnQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIHdhbGtfcGFyZW50KHNlbGYsIChub2RlLCBpbmZvKSA9PiB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1Njb3BlICYmIG5vZGUgIT09IHNlbGYpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBpbmZvLnBhcmVudCgpO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50IGluc3RhbmNlb2YgQVNUX0NhbGwgJiYgcGFyZW50LmV4cHJlc3Npb24gPT09IG5vZGUpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKHdhbGsobm9kZSwgZmluZF9yZWYpKSByZXR1cm4gd2Fsa19hYm9ydDtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuY29uc3QgQVNTSUdOX09QUyA9IG1ha2VQcmVkaWNhdGUoXCIrIC0gLyAqICUgPj4gPDwgPj4+IHwgXiAmXCIpO1xuY29uc3QgQVNTSUdOX09QU19DT01NVVRBVElWRSA9IG1ha2VQcmVkaWNhdGUoXCIqIHwgXiAmXCIpO1xuZGVmX29wdGltaXplKEFTVF9Bc3NpZ24sIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoc2VsZi5sb2dpY2FsKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmxpZnRfc2VxdWVuY2VzKGNvbXByZXNzb3IpO1xuICAgIH1cblxuICAgIHZhciBkZWY7XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiZGVhZF9jb2RlXCIpXG4gICAgICAgICYmIHNlbGYubGVmdCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgJiYgKGRlZiA9IHNlbGYubGVmdC5kZWZpbml0aW9uKCkpLnNjb3BlID09PSBjb21wcmVzc29yLmZpbmRfcGFyZW50KEFTVF9MYW1iZGEpKSB7XG4gICAgICAgIHZhciBsZXZlbCA9IDAsIG5vZGUsIHBhcmVudCA9IHNlbGY7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICBwYXJlbnQgPSBjb21wcmVzc29yLnBhcmVudChsZXZlbCsrKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfRXhpdCkge1xuICAgICAgICAgICAgICAgIGlmIChpbl90cnkobGV2ZWwsIHBhcmVudCkpIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpc19yZWFjaGFibGUoZGVmLnNjb3BlLCBbIGRlZiBdKSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYub3BlcmF0b3IgPT0gXCI9XCIpIHJldHVybiBzZWxmLnJpZ2h0O1xuICAgICAgICAgICAgICAgIGRlZi5maXhlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogc2VsZi5vcGVyYXRvci5zbGljZSgwLCAtMSksXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHNlbGYucmlnaHRcbiAgICAgICAgICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAocGFyZW50IGluc3RhbmNlb2YgQVNUX0JpbmFyeSAmJiBwYXJlbnQucmlnaHQgPT09IG5vZGVcbiAgICAgICAgICAgIHx8IHBhcmVudCBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSAmJiBwYXJlbnQudGFpbF9ub2RlKCkgPT09IG5vZGUpO1xuICAgIH1cbiAgICBzZWxmID0gc2VsZi5saWZ0X3NlcXVlbmNlcyhjb21wcmVzc29yKTtcbiAgICBpZiAoc2VsZi5vcGVyYXRvciA9PSBcIj1cIiAmJiBzZWxmLmxlZnQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmICYmIHNlbGYucmlnaHQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5KSB7XG4gICAgICAgIC8vIHggPSBleHByMSBPUCBleHByMlxuICAgICAgICBpZiAoc2VsZi5yaWdodC5sZWZ0IGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgJiYgc2VsZi5yaWdodC5sZWZ0Lm5hbWUgPT0gc2VsZi5sZWZ0Lm5hbWVcbiAgICAgICAgICAgICYmIEFTU0lHTl9PUFMuaGFzKHNlbGYucmlnaHQub3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAvLyB4ID0geCAtIDIgIC0tLT4gIHggLT0gMlxuICAgICAgICAgICAgc2VsZi5vcGVyYXRvciA9IHNlbGYucmlnaHQub3BlcmF0b3IgKyBcIj1cIjtcbiAgICAgICAgICAgIHNlbGYucmlnaHQgPSBzZWxmLnJpZ2h0LnJpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGYucmlnaHQucmlnaHQgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICAgICAmJiBzZWxmLnJpZ2h0LnJpZ2h0Lm5hbWUgPT0gc2VsZi5sZWZ0Lm5hbWVcbiAgICAgICAgICAgICYmIEFTU0lHTl9PUFNfQ09NTVVUQVRJVkUuaGFzKHNlbGYucmlnaHQub3BlcmF0b3IpXG4gICAgICAgICAgICAmJiAhc2VsZi5yaWdodC5sZWZ0Lmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIC8vIHggPSAyICYgeCAgLS0tPiAgeCAmPSAyXG4gICAgICAgICAgICBzZWxmLm9wZXJhdG9yID0gc2VsZi5yaWdodC5vcGVyYXRvciArIFwiPVwiO1xuICAgICAgICAgICAgc2VsZi5yaWdodCA9IHNlbGYucmlnaHQubGVmdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcblxuICAgIGZ1bmN0aW9uIGluX3RyeShsZXZlbCwgbm9kZSkge1xuICAgICAgICB2YXIgcmlnaHQgPSBzZWxmLnJpZ2h0O1xuICAgICAgICBzZWxmLnJpZ2h0ID0gbWFrZV9ub2RlKEFTVF9OdWxsLCByaWdodCk7XG4gICAgICAgIHZhciBtYXlfdGhyb3cgPSBub2RlLm1heV90aHJvdyhjb21wcmVzc29yKTtcbiAgICAgICAgc2VsZi5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB2YXIgc2NvcGUgPSBzZWxmLmxlZnQuZGVmaW5pdGlvbigpLnNjb3BlO1xuICAgICAgICB2YXIgcGFyZW50O1xuICAgICAgICB3aGlsZSAoKHBhcmVudCA9IGNvbXByZXNzb3IucGFyZW50KGxldmVsKyspKSAhPT0gc2NvcGUpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgaW5zdGFuY2VvZiBBU1RfVHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5iZmluYWxseSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKG1heV90aHJvdyAmJiBwYXJlbnQuYmNhdGNoKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX0RlZmF1bHRBc3NpZ24sIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwiZXZhbHVhdGVcIikpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIHZhciBldmFsdWF0ZVJpZ2h0ID0gc2VsZi5yaWdodC5ldmFsdWF0ZShjb21wcmVzc29yKTtcblxuICAgIC8vIGBbeCA9IHVuZGVmaW5lZF0gPSBmb29gIC0tLT4gYFt4XSA9IGZvb2BcbiAgICBpZiAoZXZhbHVhdGVSaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGYgPSBzZWxmLmxlZnQ7XG4gICAgfSBlbHNlIGlmIChldmFsdWF0ZVJpZ2h0ICE9PSBzZWxmLnJpZ2h0KSB7XG4gICAgICAgIGV2YWx1YXRlUmlnaHQgPSBtYWtlX25vZGVfZnJvbV9jb25zdGFudChldmFsdWF0ZVJpZ2h0LCBzZWxmLnJpZ2h0KTtcbiAgICAgICAgc2VsZi5yaWdodCA9IGJlc3Rfb2ZfZXhwcmVzc2lvbihldmFsdWF0ZVJpZ2h0LCBzZWxmLnJpZ2h0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5mdW5jdGlvbiBpc19udWxsaXNoKG5vZGUsIGNvbXByZXNzb3IpIHtcbiAgICBsZXQgZml4ZWQ7XG4gICAgcmV0dXJuIChcbiAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9OdWxsXG4gICAgICAgIHx8IGlzX3VuZGVmaW5lZChub2RlLCBjb21wcmVzc29yKVxuICAgICAgICB8fCAoXG4gICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbFJlZlxuICAgICAgICAgICAgJiYgKGZpeGVkID0gbm9kZS5kZWZpbml0aW9uKCkuZml4ZWQpIGluc3RhbmNlb2YgQVNUX05vZGVcbiAgICAgICAgICAgICYmIGlzX251bGxpc2goZml4ZWQsIGNvbXByZXNzb3IpXG4gICAgICAgIClcbiAgICAgICAgLy8gUmVjdXJzZSBpbnRvIHRob3NlIG9wdGlvbmFsIGNoYWlucyFcbiAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Qcm9wQWNjZXNzICYmIG5vZGUub3B0aW9uYWwgJiYgaXNfbnVsbGlzaChub2RlLmV4cHJlc3Npb24sIGNvbXByZXNzb3IpXG4gICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2FsbCAmJiBub2RlLm9wdGlvbmFsICYmIGlzX251bGxpc2gobm9kZS5leHByZXNzaW9uLCBjb21wcmVzc29yKVxuICAgICAgICB8fCBub2RlIGluc3RhbmNlb2YgQVNUX0NoYWluICYmIGlzX251bGxpc2gobm9kZS5leHByZXNzaW9uLCBjb21wcmVzc29yKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIGlzX251bGxpc2hfY2hlY2soY2hlY2ssIGNoZWNrX3N1YmplY3QsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoY2hlY2tfc3ViamVjdC5tYXlfdGhyb3coY29tcHJlc3NvcikpIHJldHVybiBmYWxzZTtcblxuICAgIGxldCBudWxsaXNoX3NpZGU7XG5cbiAgICAvLyBmb28gPT0gbnVsbFxuICAgIGlmIChcbiAgICAgICAgY2hlY2sgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICYmIGNoZWNrLm9wZXJhdG9yID09PSBcIj09XCJcbiAgICAgICAgLy8gd2hpY2ggc2lkZSBpcyBudWxsaXNoP1xuICAgICAgICAmJiAoXG4gICAgICAgICAgICAobnVsbGlzaF9zaWRlID0gaXNfbnVsbGlzaChjaGVjay5sZWZ0LCBjb21wcmVzc29yKSAmJiBjaGVjay5sZWZ0KVxuICAgICAgICAgICAgfHwgKG51bGxpc2hfc2lkZSA9IGlzX251bGxpc2goY2hlY2sucmlnaHQsIGNvbXByZXNzb3IpICYmIGNoZWNrLnJpZ2h0KVxuICAgICAgICApXG4gICAgICAgIC8vIGlzIHRoZSBvdGhlciBzaWRlIHRoZSBzYW1lIGFzIHRoZSBjaGVja19zdWJqZWN0XG4gICAgICAgICYmIChcbiAgICAgICAgICAgIG51bGxpc2hfc2lkZSA9PT0gY2hlY2subGVmdFxuICAgICAgICAgICAgICAgID8gY2hlY2sucmlnaHRcbiAgICAgICAgICAgICAgICA6IGNoZWNrLmxlZnRcbiAgICAgICAgKS5lcXVpdmFsZW50X3RvKGNoZWNrX3N1YmplY3QpXG4gICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZvbyA9PT0gbnVsbCB8fCBmb28gPT09IHVuZGVmaW5lZFxuICAgIGlmIChjaGVjayBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgY2hlY2sub3BlcmF0b3IgPT09IFwifHxcIikge1xuICAgICAgICBsZXQgbnVsbF9jbXA7XG4gICAgICAgIGxldCB1bmRlZmluZWRfY21wO1xuXG4gICAgICAgIGNvbnN0IGZpbmRfY29tcGFyaXNvbiA9IGNtcCA9PiB7XG4gICAgICAgICAgICBpZiAoIShcbiAgICAgICAgICAgICAgICBjbXAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICAgICAgICAgJiYgKGNtcC5vcGVyYXRvciA9PT0gXCI9PT1cIiB8fCBjbXAub3BlcmF0b3IgPT09IFwiPT1cIilcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBmb3VuZCA9IDA7XG4gICAgICAgICAgICBsZXQgZGVmaW5lZF9zaWRlO1xuXG4gICAgICAgICAgICBpZiAoY21wLmxlZnQgaW5zdGFuY2VvZiBBU1RfTnVsbCkge1xuICAgICAgICAgICAgICAgIGZvdW5kKys7XG4gICAgICAgICAgICAgICAgbnVsbF9jbXAgPSBjbXA7XG4gICAgICAgICAgICAgICAgZGVmaW5lZF9zaWRlID0gY21wLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNtcC5yaWdodCBpbnN0YW5jZW9mIEFTVF9OdWxsKSB7XG4gICAgICAgICAgICAgICAgZm91bmQrKztcbiAgICAgICAgICAgICAgICBudWxsX2NtcCA9IGNtcDtcbiAgICAgICAgICAgICAgICBkZWZpbmVkX3NpZGUgPSBjbXAubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc191bmRlZmluZWQoY21wLmxlZnQsIGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgZm91bmQrKztcbiAgICAgICAgICAgICAgICB1bmRlZmluZWRfY21wID0gY21wO1xuICAgICAgICAgICAgICAgIGRlZmluZWRfc2lkZSA9IGNtcC5yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc191bmRlZmluZWQoY21wLnJpZ2h0LCBjb21wcmVzc29yKSkge1xuICAgICAgICAgICAgICAgIGZvdW5kKys7XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkX2NtcCA9IGNtcDtcbiAgICAgICAgICAgICAgICBkZWZpbmVkX3NpZGUgPSBjbXAubGVmdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvdW5kICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWRlZmluZWRfc2lkZS5lcXVpdmFsZW50X3RvKGNoZWNrX3N1YmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWZpbmRfY29tcGFyaXNvbihjaGVjay5sZWZ0KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWZpbmRfY29tcGFyaXNvbihjaGVjay5yaWdodCkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAobnVsbF9jbXAgJiYgdW5kZWZpbmVkX2NtcCAmJiBudWxsX2NtcCAhPT0gdW5kZWZpbmVkX2NtcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmRlZl9vcHRpbWl6ZShBU1RfQ29uZGl0aW9uYWwsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoIWNvbXByZXNzb3Iub3B0aW9uKFwiY29uZGl0aW9uYWxzXCIpKSByZXR1cm4gc2VsZjtcbiAgICAvLyBUaGlzIGxvb2tzIGxpa2UgbGlmdF9zZXF1ZW5jZXMoKSwgc2hvdWxkIHByb2JhYmx5IGJlIHVuZGVyIFwic2VxdWVuY2VzXCJcbiAgICBpZiAoc2VsZi5jb25kaXRpb24gaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2UpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb25zID0gc2VsZi5jb25kaXRpb24uZXhwcmVzc2lvbnMuc2xpY2UoKTtcbiAgICAgICAgc2VsZi5jb25kaXRpb24gPSBleHByZXNzaW9ucy5wb3AoKTtcbiAgICAgICAgZXhwcmVzc2lvbnMucHVzaChzZWxmKTtcbiAgICAgICAgcmV0dXJuIG1ha2Vfc2VxdWVuY2Uoc2VsZiwgZXhwcmVzc2lvbnMpO1xuICAgIH1cbiAgICB2YXIgY29uZCA9IHNlbGYuY29uZGl0aW9uLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgIGlmIChjb25kICE9PSBzZWxmLmNvbmRpdGlvbikge1xuICAgICAgICBpZiAoY29uZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1haW50YWluX3RoaXNfYmluZGluZyhjb21wcmVzc29yLnBhcmVudCgpLCBjb21wcmVzc29yLnNlbGYoKSwgc2VsZi5jb25zZXF1ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYWludGFpbl90aGlzX2JpbmRpbmcoY29tcHJlc3Nvci5wYXJlbnQoKSwgY29tcHJlc3Nvci5zZWxmKCksIHNlbGYuYWx0ZXJuYXRpdmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBuZWdhdGVkID0gY29uZC5uZWdhdGUoY29tcHJlc3NvciwgZmlyc3RfaW5fc3RhdGVtZW50KGNvbXByZXNzb3IpKTtcbiAgICBpZiAoYmVzdF9vZihjb21wcmVzc29yLCBjb25kLCBuZWdhdGVkKSA9PT0gbmVnYXRlZCkge1xuICAgICAgICBzZWxmID0gbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgY29uZGl0aW9uOiBuZWdhdGVkLFxuICAgICAgICAgICAgY29uc2VxdWVudDogc2VsZi5hbHRlcm5hdGl2ZSxcbiAgICAgICAgICAgIGFsdGVybmF0aXZlOiBzZWxmLmNvbnNlcXVlbnRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBjb25kaXRpb24gPSBzZWxmLmNvbmRpdGlvbjtcbiAgICB2YXIgY29uc2VxdWVudCA9IHNlbGYuY29uc2VxdWVudDtcbiAgICB2YXIgYWx0ZXJuYXRpdmUgPSBzZWxmLmFsdGVybmF0aXZlO1xuICAgIC8vIHg/eDp5IC0tPiB4fHx5XG4gICAgaWYgKGNvbmRpdGlvbiBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgJiYgY29uc2VxdWVudCBpbnN0YW5jZW9mIEFTVF9TeW1ib2xSZWZcbiAgICAgICAgJiYgY29uZGl0aW9uLmRlZmluaXRpb24oKSA9PT0gY29uc2VxdWVudC5kZWZpbml0aW9uKCkpIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICBvcGVyYXRvcjogXCJ8fFwiLFxuICAgICAgICAgICAgbGVmdDogY29uZGl0aW9uLFxuICAgICAgICAgICAgcmlnaHQ6IGFsdGVybmF0aXZlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBpZiAoZm9vKSBleHAgPSBzb21ldGhpbmc7IGVsc2UgZXhwID0gc29tZXRoaW5nX2Vsc2U7XG4gICAgLy8gICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICAgICAgICAgICAgICAgIHZcbiAgICAvLyBleHAgPSBmb28gPyBzb21ldGhpbmcgOiBzb21ldGhpbmdfZWxzZTtcbiAgICBpZiAoXG4gICAgICAgIGNvbnNlcXVlbnQgaW5zdGFuY2VvZiBBU1RfQXNzaWduXG4gICAgICAgICYmIGFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX0Fzc2lnblxuICAgICAgICAmJiBjb25zZXF1ZW50Lm9wZXJhdG9yID09PSBhbHRlcm5hdGl2ZS5vcGVyYXRvclxuICAgICAgICAmJiBjb25zZXF1ZW50LmxvZ2ljYWwgPT09IGFsdGVybmF0aXZlLmxvZ2ljYWxcbiAgICAgICAgJiYgY29uc2VxdWVudC5sZWZ0LmVxdWl2YWxlbnRfdG8oYWx0ZXJuYXRpdmUubGVmdClcbiAgICAgICAgJiYgKCFzZWxmLmNvbmRpdGlvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICAgICB8fCBjb25zZXF1ZW50Lm9wZXJhdG9yID09IFwiPVwiXG4gICAgICAgICAgICAgICAgJiYgIWNvbnNlcXVlbnQubGVmdC5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKVxuICAgICkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9Bc3NpZ24sIHNlbGYsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBjb25zZXF1ZW50Lm9wZXJhdG9yLFxuICAgICAgICAgICAgbGVmdDogY29uc2VxdWVudC5sZWZ0LFxuICAgICAgICAgICAgbG9naWNhbDogY29uc2VxdWVudC5sb2dpY2FsLFxuICAgICAgICAgICAgcmlnaHQ6IG1ha2Vfbm9kZShBU1RfQ29uZGl0aW9uYWwsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb246IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnQucmlnaHQsXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IGFsdGVybmF0aXZlLnJpZ2h0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8geCA/IHkoYSkgOiB5KGIpIC0tPiB5KHggPyBhIDogYilcbiAgICB2YXIgYXJnX2luZGV4O1xuICAgIGlmIChjb25zZXF1ZW50IGluc3RhbmNlb2YgQVNUX0NhbGxcbiAgICAgICAgJiYgYWx0ZXJuYXRpdmUuVFlQRSA9PT0gY29uc2VxdWVudC5UWVBFXG4gICAgICAgICYmIGNvbnNlcXVlbnQuYXJncy5sZW5ndGggPiAwXG4gICAgICAgICYmIGNvbnNlcXVlbnQuYXJncy5sZW5ndGggPT0gYWx0ZXJuYXRpdmUuYXJncy5sZW5ndGhcbiAgICAgICAgJiYgY29uc2VxdWVudC5leHByZXNzaW9uLmVxdWl2YWxlbnRfdG8oYWx0ZXJuYXRpdmUuZXhwcmVzc2lvbilcbiAgICAgICAgJiYgIXNlbGYuY29uZGl0aW9uLmhhc19zaWRlX2VmZmVjdHMoY29tcHJlc3NvcilcbiAgICAgICAgJiYgIWNvbnNlcXVlbnQuZXhwcmVzc2lvbi5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpXG4gICAgICAgICYmIHR5cGVvZiAoYXJnX2luZGV4ID0gc2luZ2xlX2FyZ19kaWZmKCkpID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb25zZXF1ZW50LmNsb25lKCk7XG4gICAgICAgIG5vZGUuYXJnc1thcmdfaW5kZXhdID0gbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgY29uZGl0aW9uOiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgIGNvbnNlcXVlbnQ6IGNvbnNlcXVlbnQuYXJnc1thcmdfaW5kZXhdLFxuICAgICAgICAgICAgYWx0ZXJuYXRpdmU6IGFsdGVybmF0aXZlLmFyZ3NbYXJnX2luZGV4XVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8vIGEgPyBiIDogYyA/IGIgOiBkIC0tPiAoYSB8fCBjKSA/IGIgOiBkXG4gICAgaWYgKGFsdGVybmF0aXZlIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsXG4gICAgICAgICYmIGNvbnNlcXVlbnQuZXF1aXZhbGVudF90byhhbHRlcm5hdGl2ZS5jb25zZXF1ZW50KSkge1xuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9Db25kaXRpb25hbCwgc2VsZiwge1xuICAgICAgICAgICAgY29uZGl0aW9uOiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcInx8XCIsXG4gICAgICAgICAgICAgICAgbGVmdDogY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBhbHRlcm5hdGl2ZS5jb25kaXRpb25cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY29uc2VxdWVudDogY29uc2VxdWVudCxcbiAgICAgICAgICAgIGFsdGVybmF0aXZlOiBhbHRlcm5hdGl2ZS5hbHRlcm5hdGl2ZVxuICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG5cbiAgICAvLyBhID09IG51bGwgPyBiIDogYSAtPiBhID8/IGJcbiAgICBpZiAoXG4gICAgICAgIGNvbXByZXNzb3Iub3B0aW9uKFwiZWNtYVwiKSA+PSAyMDIwICYmXG4gICAgICAgIGlzX251bGxpc2hfY2hlY2soY29uZGl0aW9uLCBhbHRlcm5hdGl2ZSwgY29tcHJlc3NvcilcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICBvcGVyYXRvcjogXCI/P1wiLFxuICAgICAgICAgICAgbGVmdDogYWx0ZXJuYXRpdmUsXG4gICAgICAgICAgICByaWdodDogY29uc2VxdWVudFxuICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG5cbiAgICAvLyBhID8gYiA6IChjLCBiKSAtLT4gKGEgfHwgYyksIGJcbiAgICBpZiAoYWx0ZXJuYXRpdmUgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2VcbiAgICAgICAgJiYgY29uc2VxdWVudC5lcXVpdmFsZW50X3RvKGFsdGVybmF0aXZlLmV4cHJlc3Npb25zW2FsdGVybmF0aXZlLmV4cHJlc3Npb25zLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShzZWxmLCBbXG4gICAgICAgICAgICBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcInx8XCIsXG4gICAgICAgICAgICAgICAgbGVmdDogY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBtYWtlX3NlcXVlbmNlKHNlbGYsIGFsdGVybmF0aXZlLmV4cHJlc3Npb25zLnNsaWNlKDAsIC0xKSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY29uc2VxdWVudFxuICAgICAgICBdKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG4gICAgLy8gYSA/IGIgOiAoYyAmJiBiKSAtLT4gKGEgfHwgYykgJiYgYlxuICAgIGlmIChhbHRlcm5hdGl2ZSBpbnN0YW5jZW9mIEFTVF9CaW5hcnlcbiAgICAgICAgJiYgYWx0ZXJuYXRpdmUub3BlcmF0b3IgPT0gXCImJlwiXG4gICAgICAgICYmIGNvbnNlcXVlbnQuZXF1aXZhbGVudF90byhhbHRlcm5hdGl2ZS5yaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCJ8fFwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICByaWdodDogYWx0ZXJuYXRpdmUubGVmdFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByaWdodDogY29uc2VxdWVudFxuICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG4gICAgLy8geD95P3o6YTphIC0tPiB4JiZ5P3o6YVxuICAgIGlmIChjb25zZXF1ZW50IGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsXG4gICAgICAgICYmIGNvbnNlcXVlbnQuYWx0ZXJuYXRpdmUuZXF1aXZhbGVudF90byhhbHRlcm5hdGl2ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQ29uZGl0aW9uYWwsIHNlbGYsIHtcbiAgICAgICAgICAgIGNvbmRpdGlvbjogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBzZWxmLmNvbmRpdGlvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBjb25zZXF1ZW50LmNvbmRpdGlvblxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjb25zZXF1ZW50OiBjb25zZXF1ZW50LmNvbnNlcXVlbnQsXG4gICAgICAgICAgICBhbHRlcm5hdGl2ZTogYWx0ZXJuYXRpdmVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHggPyB5IDogeSAtLT4geCwgeVxuICAgIGlmIChjb25zZXF1ZW50LmVxdWl2YWxlbnRfdG8oYWx0ZXJuYXRpdmUpKSB7XG4gICAgICAgIHJldHVybiBtYWtlX3NlcXVlbmNlKHNlbGYsIFtcbiAgICAgICAgICAgIHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgY29uc2VxdWVudFxuICAgICAgICBdKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICB9XG4gICAgLy8geCA/IHkgfHwgeiA6IHogLS0+IHggJiYgeSB8fCB6XG4gICAgaWYgKGNvbnNlcXVlbnQgaW5zdGFuY2VvZiBBU1RfQmluYXJ5XG4gICAgICAgICYmIGNvbnNlcXVlbnQub3BlcmF0b3IgPT0gXCJ8fFwiXG4gICAgICAgICYmIGNvbnNlcXVlbnQucmlnaHQuZXF1aXZhbGVudF90byhhbHRlcm5hdGl2ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICBvcGVyYXRvcjogXCJ8fFwiLFxuICAgICAgICAgICAgbGVmdDogbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHNlbGYuY29uZGl0aW9uLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBjb25zZXF1ZW50LmxlZnRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmlnaHQ6IGFsdGVybmF0aXZlXG4gICAgICAgIH0pLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICB2YXIgaW5fYm9vbCA9IGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCk7XG4gICAgaWYgKGlzX3RydWUoc2VsZi5jb25zZXF1ZW50KSkge1xuICAgICAgICBpZiAoaXNfZmFsc2Uoc2VsZi5hbHRlcm5hdGl2ZSkpIHtcbiAgICAgICAgICAgIC8vIGMgPyB0cnVlIDogZmFsc2UgLS0tPiAhIWNcbiAgICAgICAgICAgIHJldHVybiBib29sZWFuaXplKHNlbGYuY29uZGl0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjID8gdHJ1ZSA6IHggLS0tPiAhIWMgfHwgeFxuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9CaW5hcnksIHNlbGYsIHtcbiAgICAgICAgICAgIG9wZXJhdG9yOiBcInx8XCIsXG4gICAgICAgICAgICBsZWZ0OiBib29sZWFuaXplKHNlbGYuY29uZGl0aW9uKSxcbiAgICAgICAgICAgIHJpZ2h0OiBzZWxmLmFsdGVybmF0aXZlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNfZmFsc2Uoc2VsZi5jb25zZXF1ZW50KSkge1xuICAgICAgICBpZiAoaXNfdHJ1ZShzZWxmLmFsdGVybmF0aXZlKSkge1xuICAgICAgICAgICAgLy8gYyA/IGZhbHNlIDogdHJ1ZSAtLS0+ICFjXG4gICAgICAgICAgICByZXR1cm4gYm9vbGVhbml6ZShzZWxmLmNvbmRpdGlvbi5uZWdhdGUoY29tcHJlc3NvcikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGMgPyBmYWxzZSA6IHggLS0tPiAhYyAmJiB4XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgb3BlcmF0b3I6IFwiJiZcIixcbiAgICAgICAgICAgIGxlZnQ6IGJvb2xlYW5pemUoc2VsZi5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpKSxcbiAgICAgICAgICAgIHJpZ2h0OiBzZWxmLmFsdGVybmF0aXZlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNfdHJ1ZShzZWxmLmFsdGVybmF0aXZlKSkge1xuICAgICAgICAvLyBjID8geCA6IHRydWUgLS0tPiAhYyB8fCB4XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgb3BlcmF0b3I6IFwifHxcIixcbiAgICAgICAgICAgIGxlZnQ6IGJvb2xlYW5pemUoc2VsZi5jb25kaXRpb24ubmVnYXRlKGNvbXByZXNzb3IpKSxcbiAgICAgICAgICAgIHJpZ2h0OiBzZWxmLmNvbnNlcXVlbnRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc19mYWxzZShzZWxmLmFsdGVybmF0aXZlKSkge1xuICAgICAgICAvLyBjID8geCA6IGZhbHNlIC0tLT4gISFjICYmIHhcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfQmluYXJ5LCBzZWxmLCB7XG4gICAgICAgICAgICBvcGVyYXRvcjogXCImJlwiLFxuICAgICAgICAgICAgbGVmdDogYm9vbGVhbml6ZShzZWxmLmNvbmRpdGlvbiksXG4gICAgICAgICAgICByaWdodDogc2VsZi5jb25zZXF1ZW50XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuXG4gICAgZnVuY3Rpb24gYm9vbGVhbml6ZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmlzX2Jvb2xlYW4oKSkgcmV0dXJuIG5vZGU7XG4gICAgICAgIC8vICEhZXhwcmVzc2lvblxuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgbm9kZSwge1xuICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogbm9kZS5uZWdhdGUoY29tcHJlc3NvcilcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQVNUX1RydWUgb3IgITBcbiAgICBmdW5jdGlvbiBpc190cnVlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBBU1RfVHJ1ZVxuICAgICAgICAgICAgfHwgaW5fYm9vbFxuICAgICAgICAgICAgICAgICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnRcbiAgICAgICAgICAgICAgICAmJiBub2RlLmdldFZhbHVlKClcbiAgICAgICAgICAgIHx8IChub2RlIGluc3RhbmNlb2YgQVNUX1VuYXJ5UHJlZml4XG4gICAgICAgICAgICAgICAgJiYgbm9kZS5vcGVyYXRvciA9PSBcIiFcIlxuICAgICAgICAgICAgICAgICYmIG5vZGUuZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICYmICFub2RlLmV4cHJlc3Npb24uZ2V0VmFsdWUoKSk7XG4gICAgfVxuICAgIC8vIEFTVF9GYWxzZSBvciAhMVxuICAgIGZ1bmN0aW9uIGlzX2ZhbHNlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBBU1RfRmFsc2VcbiAgICAgICAgICAgIHx8IGluX2Jvb2xcbiAgICAgICAgICAgICAgICAmJiBub2RlIGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgJiYgIW5vZGUuZ2V0VmFsdWUoKVxuICAgICAgICAgICAgfHwgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVW5hcnlQcmVmaXhcbiAgICAgICAgICAgICAgICAmJiBub2RlLm9wZXJhdG9yID09IFwiIVwiXG4gICAgICAgICAgICAgICAgJiYgbm9kZS5leHByZXNzaW9uIGluc3RhbmNlb2YgQVNUX0NvbnN0YW50XG4gICAgICAgICAgICAgICAgJiYgbm9kZS5leHByZXNzaW9uLmdldFZhbHVlKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNpbmdsZV9hcmdfZGlmZigpIHtcbiAgICAgICAgdmFyIGEgPSBjb25zZXF1ZW50LmFyZ3M7XG4gICAgICAgIHZhciBiID0gYWx0ZXJuYXRpdmUuYXJncztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhW2ldIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFhW2ldLmVxdWl2YWxlbnRfdG8oYltpXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYltpXSBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pIHJldHVybjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYVtqXSBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhW2pdLmVxdWl2YWxlbnRfdG8oYltqXSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9Cb29sZWFuLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKGNvbXByZXNzb3IuaW5fYm9vbGVhbl9jb250ZXh0KCkpIHJldHVybiBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZiwge1xuICAgICAgICB2YWx1ZTogK3NlbGYudmFsdWVcbiAgICB9KTtcbiAgICB2YXIgcCA9IGNvbXByZXNzb3IucGFyZW50KCk7XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiYm9vbGVhbnNfYXNfaW50ZWdlcnNcIikpIHtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIChwLm9wZXJhdG9yID09IFwiPT09XCIgfHwgcC5vcGVyYXRvciA9PSBcIiE9PVwiKSkge1xuICAgICAgICAgICAgcC5vcGVyYXRvciA9IHAub3BlcmF0b3IucmVwbGFjZSgvPSQvLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgIHZhbHVlOiArc2VsZi52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiYm9vbGVhbnNcIikpIHtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBBU1RfQmluYXJ5ICYmIChwLm9wZXJhdG9yID09IFwiPT1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHAub3BlcmF0b3IgPT0gXCIhPVwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfTnVtYmVyLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICtzZWxmLnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9VbmFyeVByZWZpeCwgc2VsZiwge1xuICAgICAgICAgICAgb3BlcmF0b3I6IFwiIVwiLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogbWFrZV9ub2RlKEFTVF9OdW1iZXIsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogMSAtIHNlbGYudmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5mdW5jdGlvbiBzYWZlX3RvX2ZsYXR0ZW4odmFsdWUsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuZml4ZWRfdmFsdWUoKTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFTVF9DbGFzcykpIHJldHVybiB0cnVlO1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgQVNUX0xhbWJkYSAmJiB2YWx1ZS5jb250YWluc190aGlzKCkpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gY29tcHJlc3Nvci5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9OZXc7XG59XG5cbkFTVF9Qcm9wQWNjZXNzLkRFRk1FVEhPRChcImZsYXR0ZW5fb2JqZWN0XCIsIGZ1bmN0aW9uKGtleSwgY29tcHJlc3Nvcikge1xuICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJwcm9wZXJ0aWVzXCIpKSByZXR1cm47XG4gICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikgcmV0dXJuO1xuXG4gICAgdmFyIGFycm93cyA9IGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlX2Fycm93c1wiKSAmJiBjb21wcmVzc29yLm9wdGlvbihcImVjbWFcIikgPj0gMjAxNTtcbiAgICB2YXIgZXhwciA9IHRoaXMuZXhwcmVzc2lvbjtcbiAgICBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9PYmplY3QpIHtcbiAgICAgICAgdmFyIHByb3BzID0gZXhwci5wcm9wZXJ0aWVzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBwcm9wcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcblxuICAgICAgICAgICAgaWYgKFwiXCIgKyAocHJvcCBpbnN0YW5jZW9mIEFTVF9Db25jaXNlTWV0aG9kID8gcHJvcC5rZXkubmFtZSA6IHByb3Aua2V5KSA9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxfcHJvcHNfZmxhdHRlbmFibGUgPSBwcm9wcy5ldmVyeSgocCkgPT5cbiAgICAgICAgICAgICAgICAgICAgKHAgaW5zdGFuY2VvZiBBU1RfT2JqZWN0S2V5VmFsXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBhcnJvd3MgJiYgcCBpbnN0YW5jZW9mIEFTVF9Db25jaXNlTWV0aG9kICYmICFwLmlzX2dlbmVyYXRvclxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICYmICFwLmNvbXB1dGVkX2tleSgpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmICghYWxsX3Byb3BzX2ZsYXR0ZW5hYmxlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKCFzYWZlX3RvX2ZsYXR0ZW4ocHJvcC52YWx1ZSwgY29tcHJlc3NvcikpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1N1YiwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBtYWtlX25vZGUoQVNUX0FycmF5LCBleHByLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogcHJvcHMubWFwKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHByb3AudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBBU1RfQWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IG1ha2Vfbm9kZShBU1RfRnVuY3Rpb24sIHYsIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gcHJvcC5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGsgaW5zdGFuY2VvZiBBU1RfTm9kZSAmJiAhKGsgaW5zdGFuY2VvZiBBU1RfU3ltYm9sTWV0aG9kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShwcm9wLCBbIGssIHYgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IG1ha2Vfbm9kZShBU1RfTnVtYmVyLCB0aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfU3ViLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgdmFyIGV4cHIgPSBzZWxmLmV4cHJlc3Npb247XG4gICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnR5O1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInByb3BlcnRpZXNcIikpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3AuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChrZXkgIT09IHByb3ApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnRvU3RyaW5nKCkgPT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3AgPSBzZWxmLnByb3BlcnR5ID0gYmVzdF9vZl9leHByZXNzaW9uKHByb3AsIG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGtleSwgcHJvcCkudHJhbnNmb3JtKGNvbXByZXNzb3IpKTtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IFwiXCIgKyBrZXk7XG4gICAgICAgICAgICBpZiAoaXNfYmFzaWNfaWRlbnRpZmllcl9zdHJpbmcocHJvcGVydHkpXG4gICAgICAgICAgICAgICAgJiYgcHJvcGVydHkubGVuZ3RoIDw9IHByb3Auc2l6ZSgpICsgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0RvdCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogc2VsZi5vcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxuICAgICAgICAgICAgICAgICAgICBxdW90ZTogcHJvcC5xdW90ZSxcbiAgICAgICAgICAgICAgICB9KS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZm47XG4gICAgT1BUX0FSR1VNRU5UUzogaWYgKGNvbXByZXNzb3Iub3B0aW9uKFwiYXJndW1lbnRzXCIpXG4gICAgICAgICYmIGV4cHIgaW5zdGFuY2VvZiBBU1RfU3ltYm9sUmVmXG4gICAgICAgICYmIGV4cHIubmFtZSA9PSBcImFyZ3VtZW50c1wiXG4gICAgICAgICYmIGV4cHIuZGVmaW5pdGlvbigpLm9yaWcubGVuZ3RoID09IDFcbiAgICAgICAgJiYgKGZuID0gZXhwci5zY29wZSkgaW5zdGFuY2VvZiBBU1RfTGFtYmRhXG4gICAgICAgICYmIGZuLnVzZXNfYXJndW1lbnRzXG4gICAgICAgICYmICEoZm4gaW5zdGFuY2VvZiBBU1RfQXJyb3cpXG4gICAgICAgICYmIHByb3AgaW5zdGFuY2VvZiBBU1RfTnVtYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHByb3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIGFyZ25hbWVzID0gZm4uYXJnbmFtZXM7XG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYXJnbmFtZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgIGlmICghKGFyZ25hbWVzW25dIGluc3RhbmNlb2YgQVNUX1N5bWJvbEZ1bmFyZykpIHtcbiAgICAgICAgICAgICAgICBicmVhayBPUFRfQVJHVU1FTlRTOyAvLyBkZXN0cnVjdHVyaW5nIHBhcmFtZXRlciAtIGJhaWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJhbSA9IGFyZ25hbWVzW25dLm5hbWU7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmhhcyhwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICBicmVhayBPUFRfQVJHVU1FTlRTOyAvLyBkdXBsaWNhdGUgcGFyYW1ldGVyIC0gYmFpbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1zLmFkZChwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyZ25hbWUgPSBmbi5hcmduYW1lc1tpbmRleF07XG4gICAgICAgIGlmIChhcmduYW1lICYmIGNvbXByZXNzb3IuaGFzX2RpcmVjdGl2ZShcInVzZSBzdHJpY3RcIikpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSBhcmduYW1lLmRlZmluaXRpb24oKTtcbiAgICAgICAgICAgIGlmICghY29tcHJlc3Nvci5vcHRpb24oXCJyZWR1Y2VfdmFyc1wiKSB8fCBkZWYuYXNzaWdubWVudHMgfHwgZGVmLm9yaWcubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGFyZ25hbWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFhcmduYW1lICYmICFjb21wcmVzc29yLm9wdGlvbihcImtlZXBfZmFyZ3NcIikgJiYgaW5kZXggPCBmbi5hcmduYW1lcy5sZW5ndGggKyA1KSB7XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPj0gZm4uYXJnbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXJnbmFtZSA9IGZuLmNyZWF0ZV9zeW1ib2woQVNUX1N5bWJvbEZ1bmFyZywge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGZuLFxuICAgICAgICAgICAgICAgICAgICBzY29wZTogZm4sXG4gICAgICAgICAgICAgICAgICAgIHRlbnRhdGl2ZV9uYW1lOiBcImFyZ3VtZW50X1wiICsgZm4uYXJnbmFtZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZuLmFyZ25hbWVzLnB1c2goYXJnbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ25hbWUpIHtcbiAgICAgICAgICAgIHZhciBzeW0gPSBtYWtlX25vZGUoQVNUX1N5bWJvbFJlZiwgc2VsZiwgYXJnbmFtZSk7XG4gICAgICAgICAgICBzeW0ucmVmZXJlbmNlKHt9KTtcbiAgICAgICAgICAgIGNsZWFyX2ZsYWcoYXJnbmFtZSwgVU5VU0VEKTtcbiAgICAgICAgICAgIHJldHVybiBzeW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzX2xocyhzZWxmLCBjb21wcmVzc29yLnBhcmVudCgpKSkgcmV0dXJuIHNlbGY7XG4gICAgaWYgKGtleSAhPT0gcHJvcCkge1xuICAgICAgICB2YXIgc3ViID0gc2VsZi5mbGF0dGVuX29iamVjdChwcm9wZXJ0eSwgY29tcHJlc3Nvcik7XG4gICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgIGV4cHIgPSBzZWxmLmV4cHJlc3Npb24gPSBzdWIuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIHByb3AgPSBzZWxmLnByb3BlcnR5ID0gc3ViLnByb3BlcnR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInByb3BlcnRpZXNcIikgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJzaWRlX2VmZmVjdHNcIilcbiAgICAgICAgJiYgcHJvcCBpbnN0YW5jZW9mIEFTVF9OdW1iZXIgJiYgZXhwciBpbnN0YW5jZW9mIEFTVF9BcnJheSkge1xuICAgICAgICB2YXIgaW5kZXggPSBwcm9wLmdldFZhbHVlKCk7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IGV4cHIuZWxlbWVudHM7XG4gICAgICAgIHZhciByZXRWYWx1ZSA9IGVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgRkxBVFRFTjogaWYgKHNhZmVfdG9fZmxhdHRlbihyZXRWYWx1ZSwgY29tcHJlc3NvcikpIHtcbiAgICAgICAgICAgIHZhciBmbGF0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBlbGVtZW50cy5sZW5ndGg7IC0taSA+IGluZGV4Oykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVsZW1lbnRzW2ldLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnVuc2hpZnQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhdHRlbiAmJiB2YWx1ZS5oYXNfc2lkZV9lZmZlY3RzKGNvbXByZXNzb3IpKSBmbGF0dGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldFZhbHVlIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikgYnJlYWsgRkxBVFRFTjtcbiAgICAgICAgICAgIHJldFZhbHVlID0gcmV0VmFsdWUgaW5zdGFuY2VvZiBBU1RfSG9sZSA/IG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCByZXRWYWx1ZSkgOiByZXRWYWx1ZTtcbiAgICAgICAgICAgIGlmICghZmxhdHRlbikgdmFsdWVzLnVuc2hpZnQocmV0VmFsdWUpO1xuICAgICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikgYnJlYWsgRkxBVFRFTjtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmRyb3Bfc2lkZV9lZmZlY3RfZnJlZShjb21wcmVzc29yKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHZhbHVlcy51bnNoaWZ0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGluZGV4LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhdHRlbikge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHJldFZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZV9zZXF1ZW5jZShzZWxmLCB2YWx1ZXMpLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHJldHVybiBtYWtlX25vZGUoQVNUX1N1Yiwgc2VsZiwge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IG1ha2Vfbm9kZShBU1RfQXJyYXksIGV4cHIsIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IHZhbHVlc1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5OiBtYWtlX25vZGUoQVNUX051bWJlciwgcHJvcCwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5kZXhcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGV2ID0gc2VsZi5ldmFsdWF0ZShjb21wcmVzc29yKTtcbiAgICBpZiAoZXYgIT09IHNlbGYpIHtcbiAgICAgICAgZXYgPSBtYWtlX25vZGVfZnJvbV9jb25zdGFudChldiwgc2VsZikub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgICAgIHJldHVybiBiZXN0X29mKGNvbXByZXNzb3IsIGV2LCBzZWxmKTtcbiAgICB9XG4gICAgaWYgKHNlbGYub3B0aW9uYWwgJiYgaXNfbnVsbGlzaChzZWxmLmV4cHJlc3Npb24sIGNvbXByZXNzb3IpKSB7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX1VuZGVmaW5lZCwgc2VsZik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfQ2hhaW4sIGZ1bmN0aW9uIChzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgc2VsZi5leHByZXNzaW9uID0gc2VsZi5leHByZXNzaW9uLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbkFTVF9MYW1iZGEuREVGTUVUSE9EKFwiY29udGFpbnNfdGhpc1wiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gd2Fsayh0aGlzLCBub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfVGhpcykgcmV0dXJuIHdhbGtfYWJvcnQ7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG5vZGUgIT09IHRoaXNcbiAgICAgICAgICAgICYmIG5vZGUgaW5zdGFuY2VvZiBBU1RfU2NvcGVcbiAgICAgICAgICAgICYmICEobm9kZSBpbnN0YW5jZW9mIEFTVF9BcnJvdylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfRG90LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgY29uc3QgcGFyZW50ID0gY29tcHJlc3Nvci5wYXJlbnQoKTtcbiAgICBpZiAoaXNfbGhzKHNlbGYsIHBhcmVudCkpIHJldHVybiBzZWxmO1xuICAgIGlmIChjb21wcmVzc29yLm9wdGlvbihcInVuc2FmZV9wcm90b1wiKVxuICAgICAgICAmJiBzZWxmLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBBU1RfRG90XG4gICAgICAgICYmIHNlbGYuZXhwcmVzc2lvbi5wcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICAgIHZhciBleHAgPSBzZWxmLmV4cHJlc3Npb24uZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKGlzX3VuZGVjbGFyZWRfcmVmKGV4cCkpIHN3aXRjaCAoZXhwLm5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IG1ha2Vfbm9kZShBU1RfQXJyYXksIHNlbGYuZXhwcmVzc2lvbiwge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IG1ha2Vfbm9kZShBU1RfRnVuY3Rpb24sIHNlbGYuZXhwcmVzc2lvbiwge1xuICAgICAgICAgICAgICAgIGFyZ25hbWVzOiBbXSxcbiAgICAgICAgICAgICAgICBib2R5OiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiTnVtYmVyXCI6XG4gICAgICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBtYWtlX25vZGUoQVNUX051bWJlciwgc2VsZi5leHByZXNzaW9uLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIk9iamVjdFwiOlxuICAgICAgICAgICAgc2VsZi5leHByZXNzaW9uID0gbWFrZV9ub2RlKEFTVF9PYmplY3QsIHNlbGYuZXhwcmVzc2lvbiwge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJSZWdFeHBcIjpcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IG1ha2Vfbm9kZShBU1RfUmVnRXhwLCBzZWxmLmV4cHJlc3Npb24sIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyBzb3VyY2U6IFwidFwiLCBmbGFnczogXCJcIiB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJTdHJpbmdcIjpcbiAgICAgICAgICAgIHNlbGYuZXhwcmVzc2lvbiA9IG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLmV4cHJlc3Npb24sIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIShwYXJlbnQgaW5zdGFuY2VvZiBBU1RfQ2FsbCkgfHwgIWhhc19hbm5vdGF0aW9uKHBhcmVudCwgX05PSU5MSU5FKSkge1xuICAgICAgICBjb25zdCBzdWIgPSBzZWxmLmZsYXR0ZW5fb2JqZWN0KHNlbGYucHJvcGVydHksIGNvbXByZXNzb3IpO1xuICAgICAgICBpZiAoc3ViKSByZXR1cm4gc3ViLm9wdGltaXplKGNvbXByZXNzb3IpO1xuICAgIH1cbiAgICBsZXQgZXYgPSBzZWxmLmV2YWx1YXRlKGNvbXByZXNzb3IpO1xuICAgIGlmIChldiAhPT0gc2VsZikge1xuICAgICAgICBldiA9IG1ha2Vfbm9kZV9mcm9tX2NvbnN0YW50KGV2LCBzZWxmKS5vcHRpbWl6ZShjb21wcmVzc29yKTtcbiAgICAgICAgcmV0dXJuIGJlc3Rfb2YoY29tcHJlc3NvciwgZXYsIHNlbGYpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5vcHRpb25hbCAmJiBpc19udWxsaXNoKHNlbGYuZXhwcmVzc2lvbiwgY29tcHJlc3NvcikpIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfVW5kZWZpbmVkLCBzZWxmKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZnVuY3Rpb24gbGl0ZXJhbHNfaW5fYm9vbGVhbl9jb250ZXh0KHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoY29tcHJlc3Nvci5pbl9ib29sZWFuX2NvbnRleHQoKSkge1xuICAgICAgICByZXR1cm4gYmVzdF9vZihjb21wcmVzc29yLCBzZWxmLCBtYWtlX3NlcXVlbmNlKHNlbGYsIFtcbiAgICAgICAgICAgIHNlbGYsXG4gICAgICAgICAgICBtYWtlX25vZGUoQVNUX1RydWUsIHNlbGYpXG4gICAgICAgIF0pLm9wdGltaXplKGNvbXByZXNzb3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIGlubGluZV9hcnJheV9saWtlX3NwcmVhZChlbGVtZW50cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsID0gZWxlbWVudHNbaV07XG4gICAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEFTVF9FeHBhbnNpb24pIHtcbiAgICAgICAgICAgIHZhciBleHByID0gZWwuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBleHByIGluc3RhbmNlb2YgQVNUX0FycmF5XG4gICAgICAgICAgICAgICAgJiYgIWV4cHIuZWxlbWVudHMuc29tZShlbG0gPT4gZWxtIGluc3RhbmNlb2YgQVNUX0hvbGUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5zcGxpY2UoaSwgMSwgLi4uZXhwci5lbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgLy8gU3RlcCBiYWNrIG9uZSwgYXMgdGhlIGVsZW1lbnQgYXQgaSBpcyBub3cgbmV3LlxuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluIGFycmF5LWxpa2Ugc3ByZWFkLCBzcHJlYWRpbmcgYSBub24taXRlcmFibGUgdmFsdWUgaXMgVHlwZUVycm9yLlxuICAgICAgICAgICAgLy8gV2UgdGhlcmVmb3JlIGNhbuKAmXQgb3B0aW1pemUgYW55dGhpbmcgZWxzZSwgdW5saWtlIHdpdGggb2JqZWN0IHNwcmVhZC5cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZGVmX29wdGltaXplKEFTVF9BcnJheSwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIHZhciBvcHRpbWl6ZWQgPSBsaXRlcmFsc19pbl9ib29sZWFuX2NvbnRleHQoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgaWYgKG9wdGltaXplZCAhPT0gc2VsZikge1xuICAgICAgICByZXR1cm4gb3B0aW1pemVkO1xuICAgIH1cbiAgICBpbmxpbmVfYXJyYXlfbGlrZV9zcHJlYWQoc2VsZi5lbGVtZW50cyk7XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZnVuY3Rpb24gaW5saW5lX29iamVjdF9wcm9wX3NwcmVhZChwcm9wcywgY29tcHJlc3Nvcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBBU1RfRXhwYW5zaW9uKSB7XG4gICAgICAgICAgICBjb25zdCBleHByID0gcHJvcC5leHByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGV4cHIgaW5zdGFuY2VvZiBBU1RfT2JqZWN0XG4gICAgICAgICAgICAgICAgJiYgZXhwci5wcm9wZXJ0aWVzLmV2ZXJ5KHByb3AgPT4gcHJvcCBpbnN0YW5jZW9mIEFTVF9PYmplY3RLZXlWYWwpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5zcGxpY2UoaSwgMSwgLi4uZXhwci5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICAvLyBTdGVwIGJhY2sgb25lLCBhcyB0aGUgcHJvcGVydHkgYXQgaSBpcyBub3cgbmV3LlxuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwciBpbnN0YW5jZW9mIEFTVF9Db25zdGFudFxuICAgICAgICAgICAgICAgICYmICEoZXhwciBpbnN0YW5jZW9mIEFTVF9TdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gVW5saWtlIGFycmF5LWxpa2Ugc3ByZWFkLCBpbiBvYmplY3Qgc3ByZWFkLCBzcHJlYWRpbmcgYVxuICAgICAgICAgICAgICAgIC8vIG5vbi1pdGVyYWJsZSB2YWx1ZSBzaWxlbnRseSBkb2VzIG5vdGhpbmc7IGl0IGlzIHRodXMgc2FmZVxuICAgICAgICAgICAgICAgIC8vIHRvIHJlbW92ZS4gQVNUX1N0cmluZyBpcyB0aGUgb25seSBpdGVyYWJsZSBBU1RfQ29uc3RhbnQuXG4gICAgICAgICAgICAgICAgcHJvcHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc19udWxsaXNoKGV4cHIsIGNvbXByZXNzb3IpKSB7XG4gICAgICAgICAgICAgICAgLy8gTGlrZXdpc2UsIG51bGwgYW5kIHVuZGVmaW5lZCBjYW4gYmUgc2lsZW50bHkgcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICBwcm9wcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmRlZl9vcHRpbWl6ZShBU1RfT2JqZWN0LCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgdmFyIG9wdGltaXplZCA9IGxpdGVyYWxzX2luX2Jvb2xlYW5fY29udGV4dChzZWxmLCBjb21wcmVzc29yKTtcbiAgICBpZiAob3B0aW1pemVkICE9PSBzZWxmKSB7XG4gICAgICAgIHJldHVybiBvcHRpbWl6ZWQ7XG4gICAgfVxuICAgIGlubGluZV9vYmplY3RfcHJvcF9zcHJlYWQoc2VsZi5wcm9wZXJ0aWVzLCBjb21wcmVzc29yKTtcbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX1JlZ0V4cCwgbGl0ZXJhbHNfaW5fYm9vbGVhbl9jb250ZXh0KTtcblxuZGVmX29wdGltaXplKEFTVF9SZXR1cm4sIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoc2VsZi52YWx1ZSAmJiBpc191bmRlZmluZWQoc2VsZi52YWx1ZSwgY29tcHJlc3NvcikpIHtcbiAgICAgICAgc2VsZi52YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfQXJyb3csIG9wdF9BU1RfTGFtYmRhKTtcblxuZGVmX29wdGltaXplKEFTVF9GdW5jdGlvbiwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIHNlbGYgPSBvcHRfQVNUX0xhbWJkYShzZWxmLCBjb21wcmVzc29yKTtcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVfYXJyb3dzXCIpXG4gICAgICAgICYmIGNvbXByZXNzb3Iub3B0aW9uKFwiZWNtYVwiKSA+PSAyMDE1XG4gICAgICAgICYmICFzZWxmLm5hbWVcbiAgICAgICAgJiYgIXNlbGYuaXNfZ2VuZXJhdG9yXG4gICAgICAgICYmICFzZWxmLnVzZXNfYXJndW1lbnRzXG4gICAgICAgICYmICFzZWxmLnBpbm5lZCgpKSB7XG4gICAgICAgIGNvbnN0IHVzZXNfdGhpcyA9IHdhbGsoc2VsZiwgbm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9UaGlzKSByZXR1cm4gd2Fsa19hYm9ydDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdXNlc190aGlzKSByZXR1cm4gbWFrZV9ub2RlKEFTVF9BcnJvdywgc2VsZiwgc2VsZikub3B0aW1pemUoY29tcHJlc3Nvcik7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfQ2xhc3MsIGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAvLyBIQUNLIHRvIGF2b2lkIGNvbXByZXNzIGZhaWx1cmUuXG4gICAgLy8gQVNUX0NsYXNzIGlzIG5vdCByZWFsbHkgYW4gQVNUX1Njb3BlL0FTVF9CbG9jayBhcyBpdCBsYWNrcyBhIGJvZHkuXG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9ZaWVsZCwgZnVuY3Rpb24oc2VsZiwgY29tcHJlc3Nvcikge1xuICAgIGlmIChzZWxmLmV4cHJlc3Npb24gJiYgIXNlbGYuaXNfc3RhciAmJiBpc191bmRlZmluZWQoc2VsZi5leHByZXNzaW9uLCBjb21wcmVzc29yKSkge1xuICAgICAgICBzZWxmLmV4cHJlc3Npb24gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX1RlbXBsYXRlU3RyaW5nLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKFxuICAgICAgICAhY29tcHJlc3Nvci5vcHRpb24oXCJldmFsdWF0ZVwiKVxuICAgICAgICB8fCBjb21wcmVzc29yLnBhcmVudCgpIGluc3RhbmNlb2YgQVNUX1ByZWZpeGVkVGVtcGxhdGVTdHJpbmdcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gc2VsZi5zZWdtZW50c1tpXTtcbiAgICAgICAgaWYgKHNlZ21lbnQgaW5zdGFuY2VvZiBBU1RfTm9kZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNlZ21lbnQuZXZhbHVhdGUoY29tcHJlc3Nvcik7XG4gICAgICAgICAgICAvLyBFdmFsdWF0ZSB0byBjb25zdGFudCB2YWx1ZVxuICAgICAgICAgICAgLy8gQ29uc3RhbnQgdmFsdWUgc2hvcnRlciB0aGFuICR7c2VnbWVudH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHNlZ21lbnQgJiYgKHJlc3VsdCArIFwiXCIpLmxlbmd0aCA8PSBzZWdtZW50LnNpemUoKSArIFwiJHt9XCIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgc2hvdWxkIGFsd2F5cyBiZSBhIHByZXZpb3VzIGFuZCBuZXh0IHNlZ21lbnQgaWYgc2VnbWVudCBpcyBhIG5vZGVcbiAgICAgICAgICAgICAgICBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS52YWx1ZSA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLnZhbHVlICsgcmVzdWx0ICsgc2VsZi5zZWdtZW50c1srK2ldLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYGJlZm9yZSAke2Bpbm5lckJlZm9yZSAke2FueX0gaW5uZXJBZnRlcmB9IGFmdGVyYCA9PiBgYmVmb3JlIGlubmVyQmVmb3JlICR7YW55fSBpbm5lckFmdGVyIGFmdGVyYFxuICAgICAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgICAgIC8vIGBiZWZvcmUgJHsndGVzdCcgKyBmb299IGFmdGVyYCA9PiBgYmVmb3JlIGlubmVyQmVmb3JlICR7YW55fSBpbm5lckFmdGVyIGFmdGVyYFxuICAgICAgICAgICAgLy8gYGJlZm9yZSAke2ZvbyArICd0ZXN0fSBhZnRlcmAgPT4gYGJlZm9yZSBpbm5lckJlZm9yZSAke2FueX0gaW5uZXJBZnRlciBhZnRlcmBcbiAgICAgICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgQVNUX1RlbXBsYXRlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVycyA9IHNlZ21lbnQuc2VnbWVudHM7XG4gICAgICAgICAgICAgICAgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0udmFsdWUgKz0gaW5uZXJzWzBdLnZhbHVlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgaW5uZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQgPSBpbm5lcnNbal07XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICAgIHNlbGYuc2VnbWVudHMgPSBzZWdtZW50cztcblxuICAgIC8vIGBmb29gID0+IFwiZm9vXCJcbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIG1ha2Vfbm9kZShBU1RfU3RyaW5nLCBzZWxmLCBzZWdtZW50c1swXSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICBzZWdtZW50cy5sZW5ndGggPT09IDNcbiAgICAgICAgJiYgc2VnbWVudHNbMV0gaW5zdGFuY2VvZiBBU1RfTm9kZVxuICAgICAgICAmJiAoXG4gICAgICAgICAgICBzZWdtZW50c1sxXS5pc19zdHJpbmcoY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IHNlZ21lbnRzWzFdLmlzX251bWJlcihjb21wcmVzc29yKVxuICAgICAgICAgICAgfHwgaXNfbnVsbGlzaChzZWdtZW50c1sxXSwgY29tcHJlc3NvcilcbiAgICAgICAgICAgIHx8IGNvbXByZXNzb3Iub3B0aW9uKFwidW5zYWZlXCIpXG4gICAgICAgIClcbiAgICApIHtcbiAgICAgICAgLy8gYGZvbyR7YmFyfWAgPT4gXCJmb29cIiArIGJhclxuICAgICAgICBpZiAoc2VnbWVudHNbMl0udmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBtYWtlX25vZGUoQVNUX1N0cmluZywgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2VnbWVudHNbMF0udmFsdWUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHNlZ21lbnRzWzFdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYCR7YmFyfWJhemAgPT4gYmFyICsgXCJiYXpcIlxuICAgICAgICBpZiAoc2VnbWVudHNbMF0udmFsdWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX0JpbmFyeSwgc2VsZiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBcIitcIixcbiAgICAgICAgICAgICAgICBsZWZ0OiBzZWdtZW50c1sxXSxcbiAgICAgICAgICAgICAgICByaWdodDogbWFrZV9ub2RlKEFTVF9TdHJpbmcsIHNlbGYsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNlZ21lbnRzWzJdLnZhbHVlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuZGVmX29wdGltaXplKEFTVF9QcmVmaXhlZFRlbXBsYXRlU3RyaW5nLCBmdW5jdGlvbihzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGY7XG59KTtcblxuLy8gW1wicFwiXToxIC0tLT4gcDoxXG4vLyBbNDJdOjEgLS0tPiA0MjoxXG5mdW5jdGlvbiBsaWZ0X2tleShzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgaWYgKCFjb21wcmVzc29yLm9wdGlvbihcImNvbXB1dGVkX3Byb3BzXCIpKSByZXR1cm4gc2VsZjtcbiAgICAvLyBzYXZlIGEgY29tcGFyaXNvbiBpbiB0aGUgdHlwaWNhbCBjYXNlXG4gICAgaWYgKCEoc2VsZi5rZXkgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnQpKSByZXR1cm4gc2VsZjtcbiAgICAvLyBhbGxvdyBjZXJ0YWluIGFjY2VwdGFibGUgcHJvcHMgYXMgbm90IGFsbCBBU1RfQ29uc3RhbnRzIGFyZSB0cnVlIGNvbnN0YW50c1xuICAgIGlmIChzZWxmLmtleSBpbnN0YW5jZW9mIEFTVF9TdHJpbmcgfHwgc2VsZi5rZXkgaW5zdGFuY2VvZiBBU1RfTnVtYmVyKSB7XG4gICAgICAgIGlmIChzZWxmLmtleS52YWx1ZSA9PT0gXCJfX3Byb3RvX19cIikgcmV0dXJuIHNlbGY7XG4gICAgICAgIGlmIChzZWxmLmtleS52YWx1ZSA9PSBcImNvbnN0cnVjdG9yXCJcbiAgICAgICAgICAgICYmIGNvbXByZXNzb3IucGFyZW50KCkgaW5zdGFuY2VvZiBBU1RfQ2xhc3MpIHJldHVybiBzZWxmO1xuICAgICAgICBpZiAoc2VsZiBpbnN0YW5jZW9mIEFTVF9PYmplY3RLZXlWYWwpIHtcbiAgICAgICAgICAgIHNlbGYua2V5ID0gc2VsZi5rZXkudmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZiBpbnN0YW5jZW9mIEFTVF9DbGFzc1Byb3BlcnR5KSB7XG4gICAgICAgICAgICBzZWxmLmtleSA9IG1ha2Vfbm9kZShBU1RfU3ltYm9sQ2xhc3NQcm9wZXJ0eSwgc2VsZi5rZXksIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBzZWxmLmtleS52YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmtleSA9IG1ha2Vfbm9kZShBU1RfU3ltYm9sTWV0aG9kLCBzZWxmLmtleSwge1xuICAgICAgICAgICAgICAgIG5hbWU6IHNlbGYua2V5LnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn1cblxuZGVmX29wdGltaXplKEFTVF9PYmplY3RQcm9wZXJ0eSwgbGlmdF9rZXkpO1xuXG5kZWZfb3B0aW1pemUoQVNUX0NvbmNpc2VNZXRob2QsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBsaWZ0X2tleShzZWxmLCBjb21wcmVzc29yKTtcbiAgICAvLyBwKCl7cmV0dXJuIHg7fSAtLS0+IHA6KCk9PnhcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJhcnJvd3NcIilcbiAgICAgICAgJiYgY29tcHJlc3Nvci5wYXJlbnQoKSBpbnN0YW5jZW9mIEFTVF9PYmplY3RcbiAgICAgICAgJiYgIXNlbGYuaXNfZ2VuZXJhdG9yXG4gICAgICAgICYmICFzZWxmLnZhbHVlLnVzZXNfYXJndW1lbnRzXG4gICAgICAgICYmICFzZWxmLnZhbHVlLnBpbm5lZCgpXG4gICAgICAgICYmIHNlbGYudmFsdWUuYm9keS5sZW5ndGggPT0gMVxuICAgICAgICAmJiBzZWxmLnZhbHVlLmJvZHlbMF0gaW5zdGFuY2VvZiBBU1RfUmV0dXJuXG4gICAgICAgICYmIHNlbGYudmFsdWUuYm9keVswXS52YWx1ZVxuICAgICAgICAmJiAhc2VsZi52YWx1ZS5jb250YWluc190aGlzKCkpIHtcbiAgICAgICAgdmFyIGFycm93ID0gbWFrZV9ub2RlKEFTVF9BcnJvdywgc2VsZi52YWx1ZSwgc2VsZi52YWx1ZSk7XG4gICAgICAgIGFycm93LmFzeW5jID0gc2VsZi5hc3luYztcbiAgICAgICAgYXJyb3cuaXNfZ2VuZXJhdG9yID0gc2VsZi5pc19nZW5lcmF0b3I7XG4gICAgICAgIHJldHVybiBtYWtlX25vZGUoQVNUX09iamVjdEtleVZhbCwgc2VsZiwge1xuICAgICAgICAgICAga2V5OiBzZWxmLmtleSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xNZXRob2QgPyBzZWxmLmtleS5uYW1lIDogc2VsZi5rZXksXG4gICAgICAgICAgICB2YWx1ZTogYXJyb3csXG4gICAgICAgICAgICBxdW90ZTogc2VsZi5xdW90ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xufSk7XG5cbmRlZl9vcHRpbWl6ZShBU1RfT2JqZWN0S2V5VmFsLCBmdW5jdGlvbihzZWxmLCBjb21wcmVzc29yKSB7XG4gICAgbGlmdF9rZXkoc2VsZiwgY29tcHJlc3Nvcik7XG4gICAgLy8gcDpmdW5jdGlvbigpe30gLS0tPiBwKCl7fVxuICAgIC8vIHA6ZnVuY3Rpb24qKCl7fSAtLS0+ICpwKCl7fVxuICAgIC8vIHA6YXN5bmMgZnVuY3Rpb24oKXt9IC0tLT4gYXN5bmMgcCgpe31cbiAgICAvLyBwOigpPT57fSAtLS0+IHAoKXt9XG4gICAgLy8gcDphc3luYygpPT57fSAtLS0+IGFzeW5jIHAoKXt9XG4gICAgdmFyIHVuc2FmZV9tZXRob2RzID0gY29tcHJlc3Nvci5vcHRpb24oXCJ1bnNhZmVfbWV0aG9kc1wiKTtcbiAgICBpZiAodW5zYWZlX21ldGhvZHNcbiAgICAgICAgJiYgY29tcHJlc3Nvci5vcHRpb24oXCJlY21hXCIpID49IDIwMTVcbiAgICAgICAgJiYgKCEodW5zYWZlX21ldGhvZHMgaW5zdGFuY2VvZiBSZWdFeHApIHx8IHVuc2FmZV9tZXRob2RzLnRlc3Qoc2VsZi5rZXkgKyBcIlwiKSkpIHtcbiAgICAgICAgdmFyIGtleSA9IHNlbGYua2V5O1xuICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLnZhbHVlO1xuICAgICAgICB2YXIgaXNfYXJyb3dfd2l0aF9ibG9jayA9IHZhbHVlIGluc3RhbmNlb2YgQVNUX0Fycm93XG4gICAgICAgICAgICAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmJvZHkpXG4gICAgICAgICAgICAmJiAhdmFsdWUuY29udGFpbnNfdGhpcygpO1xuICAgICAgICBpZiAoKGlzX2Fycm93X3dpdGhfYmxvY2sgfHwgdmFsdWUgaW5zdGFuY2VvZiBBU1RfRnVuY3Rpb24pICYmICF2YWx1ZS5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZV9ub2RlKEFTVF9Db25jaXNlTWV0aG9kLCBzZWxmLCB7XG4gICAgICAgICAgICAgICAgYXN5bmM6IHZhbHVlLmFzeW5jLFxuICAgICAgICAgICAgICAgIGlzX2dlbmVyYXRvcjogdmFsdWUuaXNfZ2VuZXJhdG9yLFxuICAgICAgICAgICAgICAgIGtleToga2V5IGluc3RhbmNlb2YgQVNUX05vZGUgPyBrZXkgOiBtYWtlX25vZGUoQVNUX1N5bWJvbE1ldGhvZCwgc2VsZiwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IG1ha2Vfbm9kZShBU1RfQWNjZXNzb3IsIHZhbHVlLCB2YWx1ZSksXG4gICAgICAgICAgICAgICAgcXVvdGU6IHNlbGYucXVvdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbn0pO1xuXG5kZWZfb3B0aW1pemUoQVNUX0Rlc3RydWN0dXJpbmcsIGZ1bmN0aW9uKHNlbGYsIGNvbXByZXNzb3IpIHtcbiAgICBpZiAoY29tcHJlc3Nvci5vcHRpb24oXCJwdXJlX2dldHRlcnNcIikgPT0gdHJ1ZVxuICAgICAgICAmJiBjb21wcmVzc29yLm9wdGlvbihcInVudXNlZFwiKVxuICAgICAgICAmJiAhc2VsZi5pc19hcnJheVxuICAgICAgICAmJiBBcnJheS5pc0FycmF5KHNlbGYubmFtZXMpXG4gICAgICAgICYmICFpc19kZXN0cnVjdHVyaW5nX2V4cG9ydF9kZWNsKGNvbXByZXNzb3IpXG4gICAgICAgICYmICEoc2VsZi5uYW1lc1tzZWxmLm5hbWVzLmxlbmd0aCAtIDFdIGluc3RhbmNlb2YgQVNUX0V4cGFuc2lvbikpIHtcbiAgICAgICAgdmFyIGtlZXAgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLm5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IHNlbGYubmFtZXNbaV07XG4gICAgICAgICAgICBpZiAoIShlbGVtIGluc3RhbmNlb2YgQVNUX09iamVjdEtleVZhbFxuICAgICAgICAgICAgICAgICYmIHR5cGVvZiBlbGVtLmtleSA9PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgJiYgZWxlbS52YWx1ZSBpbnN0YW5jZW9mIEFTVF9TeW1ib2xEZWNsYXJhdGlvblxuICAgICAgICAgICAgICAgICYmICFzaG91bGRfcmV0YWluKGNvbXByZXNzb3IsIGVsZW0udmFsdWUuZGVmaW5pdGlvbigpKSkpIHtcbiAgICAgICAgICAgICAgICBrZWVwLnB1c2goZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtlZXAubGVuZ3RoICE9IHNlbGYubmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLm5hbWVzID0ga2VlcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcblxuICAgIGZ1bmN0aW9uIGlzX2Rlc3RydWN0dXJpbmdfZXhwb3J0X2RlY2woY29tcHJlc3Nvcikge1xuICAgICAgICB2YXIgYW5jZXN0b3JzID0gWy9eVmFyRGVmJC8sIC9eKENvbnN0fExldHxWYXIpJC8sIC9eRXhwb3J0JC9dO1xuICAgICAgICBmb3IgKHZhciBhID0gMCwgcCA9IDAsIGxlbiA9IGFuY2VzdG9ycy5sZW5ndGg7IGEgPCBsZW47IHArKykge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGNvbXByZXNzb3IucGFyZW50KHApO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhID09PSAwICYmIHBhcmVudC5UWVBFID09IFwiRGVzdHJ1Y3R1cmluZ1wiKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghYW5jZXN0b3JzW2FdLnRlc3QocGFyZW50LlRZUEUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZF9yZXRhaW4oY29tcHJlc3NvciwgZGVmKSB7XG4gICAgICAgIGlmIChkZWYucmVmZXJlbmNlcy5sZW5ndGgpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoIWRlZi5nbG9iYWwpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGNvbXByZXNzb3IudG9wbGV2ZWwudmFycykge1xuICAgICAgICAgICAgIGlmIChjb21wcmVzc29yLnRvcF9yZXRhaW4pIHtcbiAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXByZXNzb3IudG9wX3JldGFpbihkZWYpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSk7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gYSBzbWFsbCB3cmFwcGVyIGFyb3VuZCBmaXR6Z2VuJ3Mgc291cmNlLW1hcCBsaWJyYXJ5XG5hc3luYyBmdW5jdGlvbiBTb3VyY2VNYXAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGZpbGUgOiBudWxsLFxuICAgICAgICByb290IDogbnVsbCxcbiAgICAgICAgb3JpZyA6IG51bGwsXG5cbiAgICAgICAgb3JpZ19saW5lX2RpZmYgOiAwLFxuICAgICAgICBkZXN0X2xpbmVfZGlmZiA6IDAsXG4gICAgfSk7XG5cbiAgICB2YXIgb3JpZ19tYXA7XG4gICAgdmFyIGdlbmVyYXRvciA9IG5ldyBNT1pfU291cmNlTWFwX19kZWZhdWx0WydkZWZhdWx0J10uU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgICAgZmlsZSAgICAgICA6IG9wdGlvbnMuZmlsZSxcbiAgICAgICAgc291cmNlUm9vdCA6IG9wdGlvbnMucm9vdFxuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMub3JpZykge1xuICAgICAgICBvcmlnX21hcCA9IGF3YWl0IG5ldyBNT1pfU291cmNlTWFwX19kZWZhdWx0WydkZWZhdWx0J10uU291cmNlTWFwQ29uc3VtZXIob3B0aW9ucy5vcmlnKTtcbiAgICAgICAgb3JpZ19tYXAuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZUNvbnRlbnQgPSBvcmlnX21hcC5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoc291cmNlQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZSwgc291cmNlQ29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZChzb3VyY2UsIGdlbl9saW5lLCBnZW5fY29sLCBvcmlnX2xpbmUsIG9yaWdfY29sLCBuYW1lKSB7XG4gICAgICAgIGlmIChvcmlnX21hcCkge1xuICAgICAgICAgICAgdmFyIGluZm8gPSBvcmlnX21hcC5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnX2xpbmUsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBvcmlnX2NvbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5mby5zb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2UgPSBpbmZvLnNvdXJjZTtcbiAgICAgICAgICAgIG9yaWdfbGluZSA9IGluZm8ubGluZTtcbiAgICAgICAgICAgIG9yaWdfY29sID0gaW5mby5jb2x1bW47XG4gICAgICAgICAgICBuYW1lID0gaW5mby5uYW1lIHx8IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgZ2VuZXJhdGVkIDogeyBsaW5lOiBnZW5fbGluZSArIG9wdGlvbnMuZGVzdF9saW5lX2RpZmYsIGNvbHVtbjogZ2VuX2NvbCB9LFxuICAgICAgICAgICAgb3JpZ2luYWwgIDogeyBsaW5lOiBvcmlnX2xpbmUgKyBvcHRpb25zLm9yaWdfbGluZV9kaWZmLCBjb2x1bW46IG9yaWdfY29sIH0sXG4gICAgICAgICAgICBzb3VyY2UgICAgOiBzb3VyY2UsXG4gICAgICAgICAgICBuYW1lICAgICAgOiBuYW1lXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZCAgICAgICAgOiBhZGQsXG4gICAgICAgIGdldCAgICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIGdlbmVyYXRvcjsgfSxcbiAgICAgICAgdG9TdHJpbmcgICA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2VuZXJhdG9yLnRvU3RyaW5nKCk7IH0sXG4gICAgICAgIGRlc3Ryb3kgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAob3JpZ19tYXAgJiYgb3JpZ19tYXAuZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIG9yaWdfbWFwLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbnZhciBkb21wcm9wcyA9IFtcbiAgICBcIiQmXCIsXG4gICAgXCIkJ1wiLFxuICAgIFwiJCpcIixcbiAgICBcIiQrXCIsXG4gICAgXCIkMVwiLFxuICAgIFwiJDJcIixcbiAgICBcIiQzXCIsXG4gICAgXCIkNFwiLFxuICAgIFwiJDVcIixcbiAgICBcIiQ2XCIsXG4gICAgXCIkN1wiLFxuICAgIFwiJDhcIixcbiAgICBcIiQ5XCIsXG4gICAgXCIkX1wiLFxuICAgIFwiJGBcIixcbiAgICBcIiRpbnB1dFwiLFxuICAgIFwiLW1vei1hbmltYXRpb25cIixcbiAgICBcIi1tb3otYW5pbWF0aW9uLWRlbGF5XCIsXG4gICAgXCItbW96LWFuaW1hdGlvbi1kaXJlY3Rpb25cIixcbiAgICBcIi1tb3otYW5pbWF0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItbW96LWFuaW1hdGlvbi1maWxsLW1vZGVcIixcbiAgICBcIi1tb3otYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiLFxuICAgIFwiLW1vei1hbmltYXRpb24tbmFtZVwiLFxuICAgIFwiLW1vei1hbmltYXRpb24tcGxheS1zdGF0ZVwiLFxuICAgIFwiLW1vei1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uXCIsXG4gICAgXCItbW96LWFwcGVhcmFuY2VcIixcbiAgICBcIi1tb3otYmFja2ZhY2UtdmlzaWJpbGl0eVwiLFxuICAgIFwiLW1vei1ib3JkZXItZW5kXCIsXG4gICAgXCItbW96LWJvcmRlci1lbmQtY29sb3JcIixcbiAgICBcIi1tb3otYm9yZGVyLWVuZC1zdHlsZVwiLFxuICAgIFwiLW1vei1ib3JkZXItZW5kLXdpZHRoXCIsXG4gICAgXCItbW96LWJvcmRlci1pbWFnZVwiLFxuICAgIFwiLW1vei1ib3JkZXItc3RhcnRcIixcbiAgICBcIi1tb3otYm9yZGVyLXN0YXJ0LWNvbG9yXCIsXG4gICAgXCItbW96LWJvcmRlci1zdGFydC1zdHlsZVwiLFxuICAgIFwiLW1vei1ib3JkZXItc3RhcnQtd2lkdGhcIixcbiAgICBcIi1tb3otYm94LWFsaWduXCIsXG4gICAgXCItbW96LWJveC1kaXJlY3Rpb25cIixcbiAgICBcIi1tb3otYm94LWZsZXhcIixcbiAgICBcIi1tb3otYm94LW9yZGluYWwtZ3JvdXBcIixcbiAgICBcIi1tb3otYm94LW9yaWVudFwiLFxuICAgIFwiLW1vei1ib3gtcGFja1wiLFxuICAgIFwiLW1vei1ib3gtc2l6aW5nXCIsXG4gICAgXCItbW96LWZsb2F0LWVkZ2VcIixcbiAgICBcIi1tb3otZm9udC1mZWF0dXJlLXNldHRpbmdzXCIsXG4gICAgXCItbW96LWZvbnQtbGFuZ3VhZ2Utb3ZlcnJpZGVcIixcbiAgICBcIi1tb3otZm9yY2UtYnJva2VuLWltYWdlLWljb25cIixcbiAgICBcIi1tb3otaHlwaGVuc1wiLFxuICAgIFwiLW1vei1pbWFnZS1yZWdpb25cIixcbiAgICBcIi1tb3otbWFyZ2luLWVuZFwiLFxuICAgIFwiLW1vei1tYXJnaW4tc3RhcnRcIixcbiAgICBcIi1tb3otb3JpZW50XCIsXG4gICAgXCItbW96LW9zeC1mb250LXNtb290aGluZ1wiLFxuICAgIFwiLW1vei1vdXRsaW5lLXJhZGl1c1wiLFxuICAgIFwiLW1vei1vdXRsaW5lLXJhZGl1cy1ib3R0b21sZWZ0XCIsXG4gICAgXCItbW96LW91dGxpbmUtcmFkaXVzLWJvdHRvbXJpZ2h0XCIsXG4gICAgXCItbW96LW91dGxpbmUtcmFkaXVzLXRvcGxlZnRcIixcbiAgICBcIi1tb3otb3V0bGluZS1yYWRpdXMtdG9wcmlnaHRcIixcbiAgICBcIi1tb3otcGFkZGluZy1lbmRcIixcbiAgICBcIi1tb3otcGFkZGluZy1zdGFydFwiLFxuICAgIFwiLW1vei1wZXJzcGVjdGl2ZVwiLFxuICAgIFwiLW1vei1wZXJzcGVjdGl2ZS1vcmlnaW5cIixcbiAgICBcIi1tb3otdGFiLXNpemVcIixcbiAgICBcIi1tb3otdGV4dC1zaXplLWFkanVzdFwiLFxuICAgIFwiLW1vei10cmFuc2Zvcm1cIixcbiAgICBcIi1tb3otdHJhbnNmb3JtLW9yaWdpblwiLFxuICAgIFwiLW1vei10cmFuc2Zvcm0tc3R5bGVcIixcbiAgICBcIi1tb3otdHJhbnNpdGlvblwiLFxuICAgIFwiLW1vei10cmFuc2l0aW9uLWRlbGF5XCIsXG4gICAgXCItbW96LXRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcIi1tb3otdHJhbnNpdGlvbi1wcm9wZXJ0eVwiLFxuICAgIFwiLW1vei10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblwiLFxuICAgIFwiLW1vei11c2VyLWZvY3VzXCIsXG4gICAgXCItbW96LXVzZXItaW5wdXRcIixcbiAgICBcIi1tb3otdXNlci1tb2RpZnlcIixcbiAgICBcIi1tb3otdXNlci1zZWxlY3RcIixcbiAgICBcIi1tb3otd2luZG93LWRyYWdnaW5nXCIsXG4gICAgXCItd2Via2l0LWFsaWduLWNvbnRlbnRcIixcbiAgICBcIi13ZWJraXQtYWxpZ24taXRlbXNcIixcbiAgICBcIi13ZWJraXQtYWxpZ24tc2VsZlwiLFxuICAgIFwiLXdlYmtpdC1hbmltYXRpb25cIixcbiAgICBcIi13ZWJraXQtYW5pbWF0aW9uLWRlbGF5XCIsXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1kaXJlY3Rpb25cIixcbiAgICBcIi13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGVcIixcbiAgICBcIi13ZWJraXQtYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiLFxuICAgIFwiLXdlYmtpdC1hbmltYXRpb24tbmFtZVwiLFxuICAgIFwiLXdlYmtpdC1hbmltYXRpb24tcGxheS1zdGF0ZVwiLFxuICAgIFwiLXdlYmtpdC1hbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uXCIsXG4gICAgXCItd2Via2l0LWFwcGVhcmFuY2VcIixcbiAgICBcIi13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eVwiLFxuICAgIFwiLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXBcIixcbiAgICBcIi13ZWJraXQtYmFja2dyb3VuZC1vcmlnaW5cIixcbiAgICBcIi13ZWJraXQtYmFja2dyb3VuZC1zaXplXCIsXG4gICAgXCItd2Via2l0LWJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIixcbiAgICBcIi13ZWJraXQtYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXNcIixcbiAgICBcIi13ZWJraXQtYm9yZGVyLWltYWdlXCIsXG4gICAgXCItd2Via2l0LWJvcmRlci1yYWRpdXNcIixcbiAgICBcIi13ZWJraXQtYm9yZGVyLXRvcC1sZWZ0LXJhZGl1c1wiLFxuICAgIFwiLXdlYmtpdC1ib3JkZXItdG9wLXJpZ2h0LXJhZGl1c1wiLFxuICAgIFwiLXdlYmtpdC1ib3gtYWxpZ25cIixcbiAgICBcIi13ZWJraXQtYm94LWRpcmVjdGlvblwiLFxuICAgIFwiLXdlYmtpdC1ib3gtZmxleFwiLFxuICAgIFwiLXdlYmtpdC1ib3gtb3JkaW5hbC1ncm91cFwiLFxuICAgIFwiLXdlYmtpdC1ib3gtb3JpZW50XCIsXG4gICAgXCItd2Via2l0LWJveC1wYWNrXCIsXG4gICAgXCItd2Via2l0LWJveC1zaGFkb3dcIixcbiAgICBcIi13ZWJraXQtYm94LXNpemluZ1wiLFxuICAgIFwiLXdlYmtpdC1maWx0ZXJcIixcbiAgICBcIi13ZWJraXQtZmxleFwiLFxuICAgIFwiLXdlYmtpdC1mbGV4LWJhc2lzXCIsXG4gICAgXCItd2Via2l0LWZsZXgtZGlyZWN0aW9uXCIsXG4gICAgXCItd2Via2l0LWZsZXgtZmxvd1wiLFxuICAgIFwiLXdlYmtpdC1mbGV4LWdyb3dcIixcbiAgICBcIi13ZWJraXQtZmxleC1zaHJpbmtcIixcbiAgICBcIi13ZWJraXQtZmxleC13cmFwXCIsXG4gICAgXCItd2Via2l0LWp1c3RpZnktY29udGVudFwiLFxuICAgIFwiLXdlYmtpdC1saW5lLWNsYW1wXCIsXG4gICAgXCItd2Via2l0LW1hc2tcIixcbiAgICBcIi13ZWJraXQtbWFzay1jbGlwXCIsXG4gICAgXCItd2Via2l0LW1hc2stY29tcG9zaXRlXCIsXG4gICAgXCItd2Via2l0LW1hc2staW1hZ2VcIixcbiAgICBcIi13ZWJraXQtbWFzay1vcmlnaW5cIixcbiAgICBcIi13ZWJraXQtbWFzay1wb3NpdGlvblwiLFxuICAgIFwiLXdlYmtpdC1tYXNrLXBvc2l0aW9uLXhcIixcbiAgICBcIi13ZWJraXQtbWFzay1wb3NpdGlvbi15XCIsXG4gICAgXCItd2Via2l0LW1hc2stcmVwZWF0XCIsXG4gICAgXCItd2Via2l0LW1hc2stc2l6ZVwiLFxuICAgIFwiLXdlYmtpdC1vcmRlclwiLFxuICAgIFwiLXdlYmtpdC1wZXJzcGVjdGl2ZVwiLFxuICAgIFwiLXdlYmtpdC1wZXJzcGVjdGl2ZS1vcmlnaW5cIixcbiAgICBcIi13ZWJraXQtdGV4dC1maWxsLWNvbG9yXCIsXG4gICAgXCItd2Via2l0LXRleHQtc2l6ZS1hZGp1c3RcIixcbiAgICBcIi13ZWJraXQtdGV4dC1zdHJva2VcIixcbiAgICBcIi13ZWJraXQtdGV4dC1zdHJva2UtY29sb3JcIixcbiAgICBcIi13ZWJraXQtdGV4dC1zdHJva2Utd2lkdGhcIixcbiAgICBcIi13ZWJraXQtdHJhbnNmb3JtXCIsXG4gICAgXCItd2Via2l0LXRyYW5zZm9ybS1vcmlnaW5cIixcbiAgICBcIi13ZWJraXQtdHJhbnNmb3JtLXN0eWxlXCIsXG4gICAgXCItd2Via2l0LXRyYW5zaXRpb25cIixcbiAgICBcIi13ZWJraXQtdHJhbnNpdGlvbi1kZWxheVwiLFxuICAgIFwiLXdlYmtpdC10cmFuc2l0aW9uLWR1cmF0aW9uXCIsXG4gICAgXCItd2Via2l0LXRyYW5zaXRpb24tcHJvcGVydHlcIixcbiAgICBcIi13ZWJraXQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cIixcbiAgICBcIi13ZWJraXQtdXNlci1zZWxlY3RcIixcbiAgICBcIjBcIixcbiAgICBcIjFcIixcbiAgICBcIjEwXCIsXG4gICAgXCIxMVwiLFxuICAgIFwiMTJcIixcbiAgICBcIjEzXCIsXG4gICAgXCIxNFwiLFxuICAgIFwiMTVcIixcbiAgICBcIjE2XCIsXG4gICAgXCIxN1wiLFxuICAgIFwiMThcIixcbiAgICBcIjE5XCIsXG4gICAgXCIyXCIsXG4gICAgXCIyMFwiLFxuICAgIFwiM1wiLFxuICAgIFwiNFwiLFxuICAgIFwiNVwiLFxuICAgIFwiNlwiLFxuICAgIFwiN1wiLFxuICAgIFwiOFwiLFxuICAgIFwiOVwiLFxuICAgIFwiQEBpdGVyYXRvclwiLFxuICAgIFwiQUJPUlRfRVJSXCIsXG4gICAgXCJBQ1RJVkVcIixcbiAgICBcIkFDVElWRV9BVFRSSUJVVEVTXCIsXG4gICAgXCJBQ1RJVkVfVEVYVFVSRVwiLFxuICAgIFwiQUNUSVZFX1VOSUZPUk1TXCIsXG4gICAgXCJBQ1RJVkVfVU5JRk9STV9CTE9DS1NcIixcbiAgICBcIkFERElUSU9OXCIsXG4gICAgXCJBTElBU0VEX0xJTkVfV0lEVEhfUkFOR0VcIixcbiAgICBcIkFMSUFTRURfUE9JTlRfU0laRV9SQU5HRVwiLFxuICAgIFwiQUxMT1dfS0VZQk9BUkRfSU5QVVRcIixcbiAgICBcIkFMTFBBU1NcIixcbiAgICBcIkFMUEhBXCIsXG4gICAgXCJBTFBIQV9CSVRTXCIsXG4gICAgXCJBTFJFQURZX1NJR05BTEVEXCIsXG4gICAgXCJBTFRfTUFTS1wiLFxuICAgIFwiQUxXQVlTXCIsXG4gICAgXCJBTllfU0FNUExFU19QQVNTRURcIixcbiAgICBcIkFOWV9TQU1QTEVTX1BBU1NFRF9DT05TRVJWQVRJVkVcIixcbiAgICBcIkFOWV9UWVBFXCIsXG4gICAgXCJBTllfVU5PUkRFUkVEX05PREVfVFlQRVwiLFxuICAgIFwiQVJSQVlfQlVGRkVSXCIsXG4gICAgXCJBUlJBWV9CVUZGRVJfQklORElOR1wiLFxuICAgIFwiQVRUQUNIRURfU0hBREVSU1wiLFxuICAgIFwiQVRUUklCVVRFX05PREVcIixcbiAgICBcIkFUX1RBUkdFVFwiLFxuICAgIFwiQWJvcnRDb250cm9sbGVyXCIsXG4gICAgXCJBYm9ydFNpZ25hbFwiLFxuICAgIFwiQWJzb2x1dGVPcmllbnRhdGlvblNlbnNvclwiLFxuICAgIFwiQWJzdHJhY3RSYW5nZVwiLFxuICAgIFwiQWNjZWxlcm9tZXRlclwiLFxuICAgIFwiQWRkU2VhcmNoUHJvdmlkZXJcIixcbiAgICBcIkFnZ3JlZ2F0ZUVycm9yXCIsXG4gICAgXCJBbmFseXNlck5vZGVcIixcbiAgICBcIkFuaW1hdGlvblwiLFxuICAgIFwiQW5pbWF0aW9uRWZmZWN0XCIsXG4gICAgXCJBbmltYXRpb25FdmVudFwiLFxuICAgIFwiQW5pbWF0aW9uUGxheWJhY2tFdmVudFwiLFxuICAgIFwiQW5pbWF0aW9uVGltZWxpbmVcIixcbiAgICBcIkFub25YTUxIdHRwUmVxdWVzdFwiLFxuICAgIFwiQW55XCIsXG4gICAgXCJBcHBsaWNhdGlvbkNhY2hlXCIsXG4gICAgXCJBcHBsaWNhdGlvbkNhY2hlRXJyb3JFdmVudFwiLFxuICAgIFwiQXJyYXlcIixcbiAgICBcIkFycmF5QnVmZmVyXCIsXG4gICAgXCJBcnJheVR5cGVcIixcbiAgICBcIkF0b21pY3NcIixcbiAgICBcIkF0dHJcIixcbiAgICBcIkF1ZGlvXCIsXG4gICAgXCJBdWRpb0J1ZmZlclwiLFxuICAgIFwiQXVkaW9CdWZmZXJTb3VyY2VOb2RlXCIsXG4gICAgXCJBdWRpb0NvbnRleHRcIixcbiAgICBcIkF1ZGlvRGVzdGluYXRpb25Ob2RlXCIsXG4gICAgXCJBdWRpb0xpc3RlbmVyXCIsXG4gICAgXCJBdWRpb05vZGVcIixcbiAgICBcIkF1ZGlvUGFyYW1cIixcbiAgICBcIkF1ZGlvUGFyYW1NYXBcIixcbiAgICBcIkF1ZGlvUHJvY2Vzc2luZ0V2ZW50XCIsXG4gICAgXCJBdWRpb1NjaGVkdWxlZFNvdXJjZU5vZGVcIixcbiAgICBcIkF1ZGlvU3RyZWFtVHJhY2tcIixcbiAgICBcIkF1ZGlvV29ya2xldFwiLFxuICAgIFwiQXVkaW9Xb3JrbGV0Tm9kZVwiLFxuICAgIFwiQXV0aGVudGljYXRvckFzc2VydGlvblJlc3BvbnNlXCIsXG4gICAgXCJBdXRoZW50aWNhdG9yQXR0ZXN0YXRpb25SZXNwb25zZVwiLFxuICAgIFwiQXV0aGVudGljYXRvclJlc3BvbnNlXCIsXG4gICAgXCJBdXRvY29tcGxldGVFcnJvckV2ZW50XCIsXG4gICAgXCJCQUNLXCIsXG4gICAgXCJCQURfQk9VTkRBUllQT0lOVFNfRVJSXCIsXG4gICAgXCJCQURfUkVRVUVTVFwiLFxuICAgIFwiQkFORFBBU1NcIixcbiAgICBcIkJMRU5EXCIsXG4gICAgXCJCTEVORF9DT0xPUlwiLFxuICAgIFwiQkxFTkRfRFNUX0FMUEhBXCIsXG4gICAgXCJCTEVORF9EU1RfUkdCXCIsXG4gICAgXCJCTEVORF9FUVVBVElPTlwiLFxuICAgIFwiQkxFTkRfRVFVQVRJT05fQUxQSEFcIixcbiAgICBcIkJMRU5EX0VRVUFUSU9OX1JHQlwiLFxuICAgIFwiQkxFTkRfU1JDX0FMUEhBXCIsXG4gICAgXCJCTEVORF9TUkNfUkdCXCIsXG4gICAgXCJCTFVFX0JJVFNcIixcbiAgICBcIkJMVVJcIixcbiAgICBcIkJPT0xcIixcbiAgICBcIkJPT0xFQU5fVFlQRVwiLFxuICAgIFwiQk9PTF9WRUMyXCIsXG4gICAgXCJCT09MX1ZFQzNcIixcbiAgICBcIkJPT0xfVkVDNFwiLFxuICAgIFwiQk9USFwiLFxuICAgIFwiQlJPV1NFUl9ERUZBVUxUX1dFQkdMXCIsXG4gICAgXCJCVUJCTElOR19QSEFTRVwiLFxuICAgIFwiQlVGRkVSX1NJWkVcIixcbiAgICBcIkJVRkZFUl9VU0FHRVwiLFxuICAgIFwiQllURVwiLFxuICAgIFwiQllURVNfUEVSX0VMRU1FTlRcIixcbiAgICBcIkJhY2tncm91bmRGZXRjaE1hbmFnZXJcIixcbiAgICBcIkJhY2tncm91bmRGZXRjaFJlY29yZFwiLFxuICAgIFwiQmFja2dyb3VuZEZldGNoUmVnaXN0cmF0aW9uXCIsXG4gICAgXCJCYXJQcm9wXCIsXG4gICAgXCJCYXJjb2RlRGV0ZWN0b3JcIixcbiAgICBcIkJhc2VBdWRpb0NvbnRleHRcIixcbiAgICBcIkJhc2VIcmVmXCIsXG4gICAgXCJCYXR0ZXJ5TWFuYWdlclwiLFxuICAgIFwiQmVmb3JlSW5zdGFsbFByb21wdEV2ZW50XCIsXG4gICAgXCJCZWZvcmVMb2FkRXZlbnRcIixcbiAgICBcIkJlZm9yZVVubG9hZEV2ZW50XCIsXG4gICAgXCJCaWdJbnRcIixcbiAgICBcIkJpZ0ludDY0QXJyYXlcIixcbiAgICBcIkJpZ1VpbnQ2NEFycmF5XCIsXG4gICAgXCJCaXF1YWRGaWx0ZXJOb2RlXCIsXG4gICAgXCJCbG9iXCIsXG4gICAgXCJCbG9iRXZlbnRcIixcbiAgICBcIkJsdWV0b290aFwiLFxuICAgIFwiQmx1ZXRvb3RoQ2hhcmFjdGVyaXN0aWNQcm9wZXJ0aWVzXCIsXG4gICAgXCJCbHVldG9vdGhEZXZpY2VcIixcbiAgICBcIkJsdWV0b290aFJlbW90ZUdBVFRDaGFyYWN0ZXJpc3RpY1wiLFxuICAgIFwiQmx1ZXRvb3RoUmVtb3RlR0FUVERlc2NyaXB0b3JcIixcbiAgICBcIkJsdWV0b290aFJlbW90ZUdBVFRTZXJ2ZXJcIixcbiAgICBcIkJsdWV0b290aFJlbW90ZUdBVFRTZXJ2aWNlXCIsXG4gICAgXCJCbHVldG9vdGhVVUlEXCIsXG4gICAgXCJCb29sZWFuXCIsXG4gICAgXCJCcm9hZGNhc3RDaGFubmVsXCIsXG4gICAgXCJCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5XCIsXG4gICAgXCJDQVBUVVJJTkdfUEhBU0VcIixcbiAgICBcIkNDV1wiLFxuICAgIFwiQ0RBVEFTZWN0aW9uXCIsXG4gICAgXCJDREFUQV9TRUNUSU9OX05PREVcIixcbiAgICBcIkNIQU5HRVwiLFxuICAgIFwiQ0hBUlNFVF9SVUxFXCIsXG4gICAgXCJDSEVDS0lOR1wiLFxuICAgIFwiQ0xBTVBfVE9fRURHRVwiLFxuICAgIFwiQ0xJQ0tcIixcbiAgICBcIkNMT1NFRFwiLFxuICAgIFwiQ0xPU0lOR1wiLFxuICAgIFwiQ09MT1JcIixcbiAgICBcIkNPTE9SX0FUVEFDSE1FTlQwXCIsXG4gICAgXCJDT0xPUl9BVFRBQ0hNRU5UMVwiLFxuICAgIFwiQ09MT1JfQVRUQUNITUVOVDEwXCIsXG4gICAgXCJDT0xPUl9BVFRBQ0hNRU5UMTFcIixcbiAgICBcIkNPTE9SX0FUVEFDSE1FTlQxMlwiLFxuICAgIFwiQ09MT1JfQVRUQUNITUVOVDEzXCIsXG4gICAgXCJDT0xPUl9BVFRBQ0hNRU5UMTRcIixcbiAgICBcIkNPTE9SX0FUVEFDSE1FTlQxNVwiLFxuICAgIFwiQ09MT1JfQVRUQUNITUVOVDJcIixcbiAgICBcIkNPTE9SX0FUVEFDSE1FTlQzXCIsXG4gICAgXCJDT0xPUl9BVFRBQ0hNRU5UNFwiLFxuICAgIFwiQ09MT1JfQVRUQUNITUVOVDVcIixcbiAgICBcIkNPTE9SX0FUVEFDSE1FTlQ2XCIsXG4gICAgXCJDT0xPUl9BVFRBQ0hNRU5UN1wiLFxuICAgIFwiQ09MT1JfQVRUQUNITUVOVDhcIixcbiAgICBcIkNPTE9SX0FUVEFDSE1FTlQ5XCIsXG4gICAgXCJDT0xPUl9CVUZGRVJfQklUXCIsXG4gICAgXCJDT0xPUl9DTEVBUl9WQUxVRVwiLFxuICAgIFwiQ09MT1JfV1JJVEVNQVNLXCIsXG4gICAgXCJDT01NRU5UX05PREVcIixcbiAgICBcIkNPTVBBUkVfUkVGX1RPX1RFWFRVUkVcIixcbiAgICBcIkNPTVBJTEVfU1RBVFVTXCIsXG4gICAgXCJDT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVFwiLFxuICAgIFwiQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFRcIixcbiAgICBcIkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUXCIsXG4gICAgXCJDT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUXCIsXG4gICAgXCJDT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUU1wiLFxuICAgIFwiQ09ORElUSU9OX1NBVElTRklFRFwiLFxuICAgIFwiQ09ORklHVVJBVElPTl9VTlNVUFBPUlRFRFwiLFxuICAgIFwiQ09OTkVDVElOR1wiLFxuICAgIFwiQ09OU1RBTlRfQUxQSEFcIixcbiAgICBcIkNPTlNUQU5UX0NPTE9SXCIsXG4gICAgXCJDT05TVFJBSU5UX0VSUlwiLFxuICAgIFwiQ09OVEVYVF9MT1NUX1dFQkdMXCIsXG4gICAgXCJDT05UUk9MX01BU0tcIixcbiAgICBcIkNPUFlfUkVBRF9CVUZGRVJcIixcbiAgICBcIkNPUFlfUkVBRF9CVUZGRVJfQklORElOR1wiLFxuICAgIFwiQ09QWV9XUklURV9CVUZGRVJcIixcbiAgICBcIkNPUFlfV1JJVEVfQlVGRkVSX0JJTkRJTkdcIixcbiAgICBcIkNPVU5URVJfU1RZTEVfUlVMRVwiLFxuICAgIFwiQ1NTXCIsXG4gICAgXCJDU1MyUHJvcGVydGllc1wiLFxuICAgIFwiQ1NTQW5pbWF0aW9uXCIsXG4gICAgXCJDU1NDaGFyc2V0UnVsZVwiLFxuICAgIFwiQ1NTQ29uZGl0aW9uUnVsZVwiLFxuICAgIFwiQ1NTQ291bnRlclN0eWxlUnVsZVwiLFxuICAgIFwiQ1NTRm9udEZhY2VSdWxlXCIsXG4gICAgXCJDU1NGb250RmVhdHVyZVZhbHVlc1J1bGVcIixcbiAgICBcIkNTU0dyb3VwaW5nUnVsZVwiLFxuICAgIFwiQ1NTSW1hZ2VWYWx1ZVwiLFxuICAgIFwiQ1NTSW1wb3J0UnVsZVwiLFxuICAgIFwiQ1NTS2V5ZnJhbWVSdWxlXCIsXG4gICAgXCJDU1NLZXlmcmFtZXNSdWxlXCIsXG4gICAgXCJDU1NLZXl3b3JkVmFsdWVcIixcbiAgICBcIkNTU01hdGhJbnZlcnRcIixcbiAgICBcIkNTU01hdGhNYXhcIixcbiAgICBcIkNTU01hdGhNaW5cIixcbiAgICBcIkNTU01hdGhOZWdhdGVcIixcbiAgICBcIkNTU01hdGhQcm9kdWN0XCIsXG4gICAgXCJDU1NNYXRoU3VtXCIsXG4gICAgXCJDU1NNYXRoVmFsdWVcIixcbiAgICBcIkNTU01hdHJpeENvbXBvbmVudFwiLFxuICAgIFwiQ1NTTWVkaWFSdWxlXCIsXG4gICAgXCJDU1NNb3pEb2N1bWVudFJ1bGVcIixcbiAgICBcIkNTU05hbWVTcGFjZVJ1bGVcIixcbiAgICBcIkNTU05hbWVzcGFjZVJ1bGVcIixcbiAgICBcIkNTU051bWVyaWNBcnJheVwiLFxuICAgIFwiQ1NTTnVtZXJpY1ZhbHVlXCIsXG4gICAgXCJDU1NQYWdlUnVsZVwiLFxuICAgIFwiQ1NTUGVyc3BlY3RpdmVcIixcbiAgICBcIkNTU1Bvc2l0aW9uVmFsdWVcIixcbiAgICBcIkNTU1ByaW1pdGl2ZVZhbHVlXCIsXG4gICAgXCJDU1NSb3RhdGVcIixcbiAgICBcIkNTU1J1bGVcIixcbiAgICBcIkNTU1J1bGVMaXN0XCIsXG4gICAgXCJDU1NTY2FsZVwiLFxuICAgIFwiQ1NTU2tld1wiLFxuICAgIFwiQ1NTU2tld1hcIixcbiAgICBcIkNTU1NrZXdZXCIsXG4gICAgXCJDU1NTdHlsZURlY2xhcmF0aW9uXCIsXG4gICAgXCJDU1NTdHlsZVJ1bGVcIixcbiAgICBcIkNTU1N0eWxlU2hlZXRcIixcbiAgICBcIkNTU1N0eWxlVmFsdWVcIixcbiAgICBcIkNTU1N1cHBvcnRzUnVsZVwiLFxuICAgIFwiQ1NTVHJhbnNmb3JtQ29tcG9uZW50XCIsXG4gICAgXCJDU1NUcmFuc2Zvcm1WYWx1ZVwiLFxuICAgIFwiQ1NTVHJhbnNpdGlvblwiLFxuICAgIFwiQ1NTVHJhbnNsYXRlXCIsXG4gICAgXCJDU1NVbml0VmFsdWVcIixcbiAgICBcIkNTU1Vua25vd25SdWxlXCIsXG4gICAgXCJDU1NVbnBhcnNlZFZhbHVlXCIsXG4gICAgXCJDU1NWYWx1ZVwiLFxuICAgIFwiQ1NTVmFsdWVMaXN0XCIsXG4gICAgXCJDU1NWYXJpYWJsZVJlZmVyZW5jZVZhbHVlXCIsXG4gICAgXCJDU1NWYXJpYWJsZXNEZWNsYXJhdGlvblwiLFxuICAgIFwiQ1NTVmFyaWFibGVzUnVsZVwiLFxuICAgIFwiQ1NTVmlld3BvcnRSdWxlXCIsXG4gICAgXCJDU1NfQVRUUlwiLFxuICAgIFwiQ1NTX0NNXCIsXG4gICAgXCJDU1NfQ09VTlRFUlwiLFxuICAgIFwiQ1NTX0NVU1RPTVwiLFxuICAgIFwiQ1NTX0RFR1wiLFxuICAgIFwiQ1NTX0RJTUVOU0lPTlwiLFxuICAgIFwiQ1NTX0VNU1wiLFxuICAgIFwiQ1NTX0VYU1wiLFxuICAgIFwiQ1NTX0ZJTFRFUl9CTFVSXCIsXG4gICAgXCJDU1NfRklMVEVSX0JSSUdIVE5FU1NcIixcbiAgICBcIkNTU19GSUxURVJfQ09OVFJBU1RcIixcbiAgICBcIkNTU19GSUxURVJfQ1VTVE9NXCIsXG4gICAgXCJDU1NfRklMVEVSX0RST1BfU0hBRE9XXCIsXG4gICAgXCJDU1NfRklMVEVSX0dSQVlTQ0FMRVwiLFxuICAgIFwiQ1NTX0ZJTFRFUl9IVUVfUk9UQVRFXCIsXG4gICAgXCJDU1NfRklMVEVSX0lOVkVSVFwiLFxuICAgIFwiQ1NTX0ZJTFRFUl9PUEFDSVRZXCIsXG4gICAgXCJDU1NfRklMVEVSX1JFRkVSRU5DRVwiLFxuICAgIFwiQ1NTX0ZJTFRFUl9TQVRVUkFURVwiLFxuICAgIFwiQ1NTX0ZJTFRFUl9TRVBJQVwiLFxuICAgIFwiQ1NTX0dSQURcIixcbiAgICBcIkNTU19IWlwiLFxuICAgIFwiQ1NTX0lERU5UXCIsXG4gICAgXCJDU1NfSU5cIixcbiAgICBcIkNTU19JTkhFUklUXCIsXG4gICAgXCJDU1NfS0haXCIsXG4gICAgXCJDU1NfTUFUUklYXCIsXG4gICAgXCJDU1NfTUFUUklYM0RcIixcbiAgICBcIkNTU19NTVwiLFxuICAgIFwiQ1NTX01TXCIsXG4gICAgXCJDU1NfTlVNQkVSXCIsXG4gICAgXCJDU1NfUENcIixcbiAgICBcIkNTU19QRVJDRU5UQUdFXCIsXG4gICAgXCJDU1NfUEVSU1BFQ1RJVkVcIixcbiAgICBcIkNTU19QUklNSVRJVkVfVkFMVUVcIixcbiAgICBcIkNTU19QVFwiLFxuICAgIFwiQ1NTX1BYXCIsXG4gICAgXCJDU1NfUkFEXCIsXG4gICAgXCJDU1NfUkVDVFwiLFxuICAgIFwiQ1NTX1JHQkNPTE9SXCIsXG4gICAgXCJDU1NfUk9UQVRFXCIsXG4gICAgXCJDU1NfUk9UQVRFM0RcIixcbiAgICBcIkNTU19ST1RBVEVYXCIsXG4gICAgXCJDU1NfUk9UQVRFWVwiLFxuICAgIFwiQ1NTX1JPVEFURVpcIixcbiAgICBcIkNTU19TXCIsXG4gICAgXCJDU1NfU0NBTEVcIixcbiAgICBcIkNTU19TQ0FMRTNEXCIsXG4gICAgXCJDU1NfU0NBTEVYXCIsXG4gICAgXCJDU1NfU0NBTEVZXCIsXG4gICAgXCJDU1NfU0NBTEVaXCIsXG4gICAgXCJDU1NfU0tFV1wiLFxuICAgIFwiQ1NTX1NLRVdYXCIsXG4gICAgXCJDU1NfU0tFV1lcIixcbiAgICBcIkNTU19TVFJJTkdcIixcbiAgICBcIkNTU19UUkFOU0xBVEVcIixcbiAgICBcIkNTU19UUkFOU0xBVEUzRFwiLFxuICAgIFwiQ1NTX1RSQU5TTEFURVhcIixcbiAgICBcIkNTU19UUkFOU0xBVEVZXCIsXG4gICAgXCJDU1NfVFJBTlNMQVRFWlwiLFxuICAgIFwiQ1NTX1VOS05PV05cIixcbiAgICBcIkNTU19VUklcIixcbiAgICBcIkNTU19WQUxVRV9MSVNUXCIsXG4gICAgXCJDU1NfVkhcIixcbiAgICBcIkNTU19WTUFYXCIsXG4gICAgXCJDU1NfVk1JTlwiLFxuICAgIFwiQ1NTX1ZXXCIsXG4gICAgXCJDVUxMX0ZBQ0VcIixcbiAgICBcIkNVTExfRkFDRV9NT0RFXCIsXG4gICAgXCJDVVJSRU5UX1BST0dSQU1cIixcbiAgICBcIkNVUlJFTlRfUVVFUllcIixcbiAgICBcIkNVUlJFTlRfVkVSVEVYX0FUVFJJQlwiLFxuICAgIFwiQ1VTVE9NXCIsXG4gICAgXCJDV1wiLFxuICAgIFwiQ2FjaGVcIixcbiAgICBcIkNhY2hlU3RvcmFnZVwiLFxuICAgIFwiQ2FudmFzQ2FwdHVyZU1lZGlhU3RyZWFtXCIsXG4gICAgXCJDYW52YXNDYXB0dXJlTWVkaWFTdHJlYW1UcmFja1wiLFxuICAgIFwiQ2FudmFzR3JhZGllbnRcIixcbiAgICBcIkNhbnZhc1BhdHRlcm5cIixcbiAgICBcIkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFwiLFxuICAgIFwiQ2FyZXRQb3NpdGlvblwiLFxuICAgIFwiQ2hhbm5lbE1lcmdlck5vZGVcIixcbiAgICBcIkNoYW5uZWxTcGxpdHRlck5vZGVcIixcbiAgICBcIkNoYXJhY3RlckRhdGFcIixcbiAgICBcIkNsaWVudFJlY3RcIixcbiAgICBcIkNsaWVudFJlY3RMaXN0XCIsXG4gICAgXCJDbGlwYm9hcmRcIixcbiAgICBcIkNsaXBib2FyZEV2ZW50XCIsXG4gICAgXCJDbGlwYm9hcmRJdGVtXCIsXG4gICAgXCJDbG9zZUV2ZW50XCIsXG4gICAgXCJDb2xsYXRvclwiLFxuICAgIFwiQ29tbWFuZEV2ZW50XCIsXG4gICAgXCJDb21tZW50XCIsXG4gICAgXCJDb21waWxlRXJyb3JcIixcbiAgICBcIkNvbXBvc2l0aW9uRXZlbnRcIixcbiAgICBcIkNvbXByZXNzaW9uU3RyZWFtXCIsXG4gICAgXCJDb25zb2xlXCIsXG4gICAgXCJDb25zdGFudFNvdXJjZU5vZGVcIixcbiAgICBcIkNvbnRyb2xsZXJzXCIsXG4gICAgXCJDb252b2x2ZXJOb2RlXCIsXG4gICAgXCJDb3VudFF1ZXVpbmdTdHJhdGVneVwiLFxuICAgIFwiQ291bnRlclwiLFxuICAgIFwiQ3JlZGVudGlhbFwiLFxuICAgIFwiQ3JlZGVudGlhbHNDb250YWluZXJcIixcbiAgICBcIkNyeXB0b1wiLFxuICAgIFwiQ3J5cHRvS2V5XCIsXG4gICAgXCJDdXN0b21FbGVtZW50UmVnaXN0cnlcIixcbiAgICBcIkN1c3RvbUV2ZW50XCIsXG4gICAgXCJEQVRBQkFTRV9FUlJcIixcbiAgICBcIkRBVEFfQ0xPTkVfRVJSXCIsXG4gICAgXCJEQVRBX0VSUlwiLFxuICAgIFwiREJMQ0xJQ0tcIixcbiAgICBcIkRFQ1JcIixcbiAgICBcIkRFQ1JfV1JBUFwiLFxuICAgIFwiREVMRVRFX1NUQVRVU1wiLFxuICAgIFwiREVQVEhcIixcbiAgICBcIkRFUFRIMjRfU1RFTkNJTDhcIixcbiAgICBcIkRFUFRIMzJGX1NURU5DSUw4XCIsXG4gICAgXCJERVBUSF9BVFRBQ0hNRU5UXCIsXG4gICAgXCJERVBUSF9CSVRTXCIsXG4gICAgXCJERVBUSF9CVUZGRVJfQklUXCIsXG4gICAgXCJERVBUSF9DTEVBUl9WQUxVRVwiLFxuICAgIFwiREVQVEhfQ09NUE9ORU5UXCIsXG4gICAgXCJERVBUSF9DT01QT05FTlQxNlwiLFxuICAgIFwiREVQVEhfQ09NUE9ORU5UMjRcIixcbiAgICBcIkRFUFRIX0NPTVBPTkVOVDMyRlwiLFxuICAgIFwiREVQVEhfRlVOQ1wiLFxuICAgIFwiREVQVEhfUkFOR0VcIixcbiAgICBcIkRFUFRIX1NURU5DSUxcIixcbiAgICBcIkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVFwiLFxuICAgIFwiREVQVEhfVEVTVFwiLFxuICAgIFwiREVQVEhfV1JJVEVNQVNLXCIsXG4gICAgXCJERVZJQ0VfSU5FTElHSUJMRVwiLFxuICAgIFwiRElSRUNUSU9OX0RPV05cIixcbiAgICBcIkRJUkVDVElPTl9MRUZUXCIsXG4gICAgXCJESVJFQ1RJT05fUklHSFRcIixcbiAgICBcIkRJUkVDVElPTl9VUFwiLFxuICAgIFwiRElTQUJMRURcIixcbiAgICBcIkRJU1BBVENIX1JFUVVFU1RfRVJSXCIsXG4gICAgXCJESVRIRVJcIixcbiAgICBcIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREVcIixcbiAgICBcIkRPQ1VNRU5UX05PREVcIixcbiAgICBcIkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWVwiLFxuICAgIFwiRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTlNcIixcbiAgICBcIkRPQ1VNRU5UX1BPU0lUSU9OX0RJU0NPTk5FQ1RFRFwiLFxuICAgIFwiRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HXCIsXG4gICAgXCJET0NVTUVOVF9QT1NJVElPTl9JTVBMRU1FTlRBVElPTl9TUEVDSUZJQ1wiLFxuICAgIFwiRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HXCIsXG4gICAgXCJET0NVTUVOVF9UWVBFX05PREVcIixcbiAgICBcIkRPTUN1cnNvclwiLFxuICAgIFwiRE9NRXJyb3JcIixcbiAgICBcIkRPTUV4Y2VwdGlvblwiLFxuICAgIFwiRE9NSW1wbGVtZW50YXRpb25cIixcbiAgICBcIkRPTUltcGxlbWVudGF0aW9uTFNcIixcbiAgICBcIkRPTU1hdHJpeFwiLFxuICAgIFwiRE9NTWF0cml4UmVhZE9ubHlcIixcbiAgICBcIkRPTVBhcnNlclwiLFxuICAgIFwiRE9NUG9pbnRcIixcbiAgICBcIkRPTVBvaW50UmVhZE9ubHlcIixcbiAgICBcIkRPTVF1YWRcIixcbiAgICBcIkRPTVJlY3RcIixcbiAgICBcIkRPTVJlY3RMaXN0XCIsXG4gICAgXCJET01SZWN0UmVhZE9ubHlcIixcbiAgICBcIkRPTVJlcXVlc3RcIixcbiAgICBcIkRPTVNUUklOR19TSVpFX0VSUlwiLFxuICAgIFwiRE9NU2V0dGFibGVUb2tlbkxpc3RcIixcbiAgICBcIkRPTVN0cmluZ0xpc3RcIixcbiAgICBcIkRPTVN0cmluZ01hcFwiLFxuICAgIFwiRE9NVG9rZW5MaXN0XCIsXG4gICAgXCJET01UcmFuc2FjdGlvbkV2ZW50XCIsXG4gICAgXCJET01fREVMVEFfTElORVwiLFxuICAgIFwiRE9NX0RFTFRBX1BBR0VcIixcbiAgICBcIkRPTV9ERUxUQV9QSVhFTFwiLFxuICAgIFwiRE9NX0lOUFVUX01FVEhPRF9EUk9QXCIsXG4gICAgXCJET01fSU5QVVRfTUVUSE9EX0hBTkRXUklUSU5HXCIsXG4gICAgXCJET01fSU5QVVRfTUVUSE9EX0lNRVwiLFxuICAgIFwiRE9NX0lOUFVUX01FVEhPRF9LRVlCT0FSRFwiLFxuICAgIFwiRE9NX0lOUFVUX01FVEhPRF9NVUxUSU1PREFMXCIsXG4gICAgXCJET01fSU5QVVRfTUVUSE9EX09QVElPTlwiLFxuICAgIFwiRE9NX0lOUFVUX01FVEhPRF9QQVNURVwiLFxuICAgIFwiRE9NX0lOUFVUX01FVEhPRF9TQ1JJUFRcIixcbiAgICBcIkRPTV9JTlBVVF9NRVRIT0RfVU5LTk9XTlwiLFxuICAgIFwiRE9NX0lOUFVUX01FVEhPRF9WT0lDRVwiLFxuICAgIFwiRE9NX0tFWV9MT0NBVElPTl9KT1lTVElDS1wiLFxuICAgIFwiRE9NX0tFWV9MT0NBVElPTl9MRUZUXCIsXG4gICAgXCJET01fS0VZX0xPQ0FUSU9OX01PQklMRVwiLFxuICAgIFwiRE9NX0tFWV9MT0NBVElPTl9OVU1QQURcIixcbiAgICBcIkRPTV9LRVlfTE9DQVRJT05fUklHSFRcIixcbiAgICBcIkRPTV9LRVlfTE9DQVRJT05fU1RBTkRBUkRcIixcbiAgICBcIkRPTV9WS18wXCIsXG4gICAgXCJET01fVktfMVwiLFxuICAgIFwiRE9NX1ZLXzJcIixcbiAgICBcIkRPTV9WS18zXCIsXG4gICAgXCJET01fVktfNFwiLFxuICAgIFwiRE9NX1ZLXzVcIixcbiAgICBcIkRPTV9WS182XCIsXG4gICAgXCJET01fVktfN1wiLFxuICAgIFwiRE9NX1ZLXzhcIixcbiAgICBcIkRPTV9WS185XCIsXG4gICAgXCJET01fVktfQVwiLFxuICAgIFwiRE9NX1ZLX0FDQ0VQVFwiLFxuICAgIFwiRE9NX1ZLX0FERFwiLFxuICAgIFwiRE9NX1ZLX0FMVFwiLFxuICAgIFwiRE9NX1ZLX0FMVEdSXCIsXG4gICAgXCJET01fVktfQU1QRVJTQU5EXCIsXG4gICAgXCJET01fVktfQVNURVJJU0tcIixcbiAgICBcIkRPTV9WS19BVFwiLFxuICAgIFwiRE9NX1ZLX0FUVE5cIixcbiAgICBcIkRPTV9WS19CXCIsXG4gICAgXCJET01fVktfQkFDS1NQQUNFXCIsXG4gICAgXCJET01fVktfQkFDS19RVU9URVwiLFxuICAgIFwiRE9NX1ZLX0JBQ0tfU0xBU0hcIixcbiAgICBcIkRPTV9WS19CQUNLX1NQQUNFXCIsXG4gICAgXCJET01fVktfQ1wiLFxuICAgIFwiRE9NX1ZLX0NBTkNFTFwiLFxuICAgIFwiRE9NX1ZLX0NBUFNfTE9DS1wiLFxuICAgIFwiRE9NX1ZLX0NJUkNVTUZMRVhcIixcbiAgICBcIkRPTV9WS19DTEVBUlwiLFxuICAgIFwiRE9NX1ZLX0NMT1NFX0JSQUNLRVRcIixcbiAgICBcIkRPTV9WS19DTE9TRV9DVVJMWV9CUkFDS0VUXCIsXG4gICAgXCJET01fVktfQ0xPU0VfUEFSRU5cIixcbiAgICBcIkRPTV9WS19DT0xPTlwiLFxuICAgIFwiRE9NX1ZLX0NPTU1BXCIsXG4gICAgXCJET01fVktfQ09OVEVYVF9NRU5VXCIsXG4gICAgXCJET01fVktfQ09OVFJPTFwiLFxuICAgIFwiRE9NX1ZLX0NPTlZFUlRcIixcbiAgICBcIkRPTV9WS19DUlNFTFwiLFxuICAgIFwiRE9NX1ZLX0NUUkxcIixcbiAgICBcIkRPTV9WS19EXCIsXG4gICAgXCJET01fVktfREVDSU1BTFwiLFxuICAgIFwiRE9NX1ZLX0RFTEVURVwiLFxuICAgIFwiRE9NX1ZLX0RJVklERVwiLFxuICAgIFwiRE9NX1ZLX0RPTExBUlwiLFxuICAgIFwiRE9NX1ZLX0RPVUJMRV9RVU9URVwiLFxuICAgIFwiRE9NX1ZLX0RPV05cIixcbiAgICBcIkRPTV9WS19FXCIsXG4gICAgXCJET01fVktfRUlTVVwiLFxuICAgIFwiRE9NX1ZLX0VORFwiLFxuICAgIFwiRE9NX1ZLX0VOVEVSXCIsXG4gICAgXCJET01fVktfRVFVQUxTXCIsXG4gICAgXCJET01fVktfRVJFT0ZcIixcbiAgICBcIkRPTV9WS19FU0NBUEVcIixcbiAgICBcIkRPTV9WS19FWENMQU1BVElPTlwiLFxuICAgIFwiRE9NX1ZLX0VYRUNVVEVcIixcbiAgICBcIkRPTV9WS19FWFNFTFwiLFxuICAgIFwiRE9NX1ZLX0ZcIixcbiAgICBcIkRPTV9WS19GMVwiLFxuICAgIFwiRE9NX1ZLX0YxMFwiLFxuICAgIFwiRE9NX1ZLX0YxMVwiLFxuICAgIFwiRE9NX1ZLX0YxMlwiLFxuICAgIFwiRE9NX1ZLX0YxM1wiLFxuICAgIFwiRE9NX1ZLX0YxNFwiLFxuICAgIFwiRE9NX1ZLX0YxNVwiLFxuICAgIFwiRE9NX1ZLX0YxNlwiLFxuICAgIFwiRE9NX1ZLX0YxN1wiLFxuICAgIFwiRE9NX1ZLX0YxOFwiLFxuICAgIFwiRE9NX1ZLX0YxOVwiLFxuICAgIFwiRE9NX1ZLX0YyXCIsXG4gICAgXCJET01fVktfRjIwXCIsXG4gICAgXCJET01fVktfRjIxXCIsXG4gICAgXCJET01fVktfRjIyXCIsXG4gICAgXCJET01fVktfRjIzXCIsXG4gICAgXCJET01fVktfRjI0XCIsXG4gICAgXCJET01fVktfRjI1XCIsXG4gICAgXCJET01fVktfRjI2XCIsXG4gICAgXCJET01fVktfRjI3XCIsXG4gICAgXCJET01fVktfRjI4XCIsXG4gICAgXCJET01fVktfRjI5XCIsXG4gICAgXCJET01fVktfRjNcIixcbiAgICBcIkRPTV9WS19GMzBcIixcbiAgICBcIkRPTV9WS19GMzFcIixcbiAgICBcIkRPTV9WS19GMzJcIixcbiAgICBcIkRPTV9WS19GMzNcIixcbiAgICBcIkRPTV9WS19GMzRcIixcbiAgICBcIkRPTV9WS19GMzVcIixcbiAgICBcIkRPTV9WS19GMzZcIixcbiAgICBcIkRPTV9WS19GNFwiLFxuICAgIFwiRE9NX1ZLX0Y1XCIsXG4gICAgXCJET01fVktfRjZcIixcbiAgICBcIkRPTV9WS19GN1wiLFxuICAgIFwiRE9NX1ZLX0Y4XCIsXG4gICAgXCJET01fVktfRjlcIixcbiAgICBcIkRPTV9WS19GSU5BTFwiLFxuICAgIFwiRE9NX1ZLX0ZST05UXCIsXG4gICAgXCJET01fVktfR1wiLFxuICAgIFwiRE9NX1ZLX0dSRUFURVJfVEhBTlwiLFxuICAgIFwiRE9NX1ZLX0hcIixcbiAgICBcIkRPTV9WS19IQU5HVUxcIixcbiAgICBcIkRPTV9WS19IQU5KQVwiLFxuICAgIFwiRE9NX1ZLX0hBU0hcIixcbiAgICBcIkRPTV9WS19IRUxQXCIsXG4gICAgXCJET01fVktfSEtfVE9HR0xFXCIsXG4gICAgXCJET01fVktfSE9NRVwiLFxuICAgIFwiRE9NX1ZLX0hZUEhFTl9NSU5VU1wiLFxuICAgIFwiRE9NX1ZLX0lcIixcbiAgICBcIkRPTV9WS19JTlNFUlRcIixcbiAgICBcIkRPTV9WS19KXCIsXG4gICAgXCJET01fVktfSlVOSkFcIixcbiAgICBcIkRPTV9WS19LXCIsXG4gICAgXCJET01fVktfS0FOQVwiLFxuICAgIFwiRE9NX1ZLX0tBTkpJXCIsXG4gICAgXCJET01fVktfTFwiLFxuICAgIFwiRE9NX1ZLX0xFRlRcIixcbiAgICBcIkRPTV9WS19MRUZUX1RBQlwiLFxuICAgIFwiRE9NX1ZLX0xFU1NfVEhBTlwiLFxuICAgIFwiRE9NX1ZLX01cIixcbiAgICBcIkRPTV9WS19NRVRBXCIsXG4gICAgXCJET01fVktfTU9ERUNIQU5HRVwiLFxuICAgIFwiRE9NX1ZLX01VTFRJUExZXCIsXG4gICAgXCJET01fVktfTlwiLFxuICAgIFwiRE9NX1ZLX05PTkNPTlZFUlRcIixcbiAgICBcIkRPTV9WS19OVU1QQUQwXCIsXG4gICAgXCJET01fVktfTlVNUEFEMVwiLFxuICAgIFwiRE9NX1ZLX05VTVBBRDJcIixcbiAgICBcIkRPTV9WS19OVU1QQUQzXCIsXG4gICAgXCJET01fVktfTlVNUEFENFwiLFxuICAgIFwiRE9NX1ZLX05VTVBBRDVcIixcbiAgICBcIkRPTV9WS19OVU1QQUQ2XCIsXG4gICAgXCJET01fVktfTlVNUEFEN1wiLFxuICAgIFwiRE9NX1ZLX05VTVBBRDhcIixcbiAgICBcIkRPTV9WS19OVU1QQUQ5XCIsXG4gICAgXCJET01fVktfTlVNX0xPQ0tcIixcbiAgICBcIkRPTV9WS19PXCIsXG4gICAgXCJET01fVktfT0VNXzFcIixcbiAgICBcIkRPTV9WS19PRU1fMTAyXCIsXG4gICAgXCJET01fVktfT0VNXzJcIixcbiAgICBcIkRPTV9WS19PRU1fM1wiLFxuICAgIFwiRE9NX1ZLX09FTV80XCIsXG4gICAgXCJET01fVktfT0VNXzVcIixcbiAgICBcIkRPTV9WS19PRU1fNlwiLFxuICAgIFwiRE9NX1ZLX09FTV83XCIsXG4gICAgXCJET01fVktfT0VNXzhcIixcbiAgICBcIkRPTV9WS19PRU1fQ09NTUFcIixcbiAgICBcIkRPTV9WS19PRU1fTUlOVVNcIixcbiAgICBcIkRPTV9WS19PRU1fUEVSSU9EXCIsXG4gICAgXCJET01fVktfT0VNX1BMVVNcIixcbiAgICBcIkRPTV9WS19PUEVOX0JSQUNLRVRcIixcbiAgICBcIkRPTV9WS19PUEVOX0NVUkxZX0JSQUNLRVRcIixcbiAgICBcIkRPTV9WS19PUEVOX1BBUkVOXCIsXG4gICAgXCJET01fVktfUFwiLFxuICAgIFwiRE9NX1ZLX1BBMVwiLFxuICAgIFwiRE9NX1ZLX1BBR0VET1dOXCIsXG4gICAgXCJET01fVktfUEFHRVVQXCIsXG4gICAgXCJET01fVktfUEFHRV9ET1dOXCIsXG4gICAgXCJET01fVktfUEFHRV9VUFwiLFxuICAgIFwiRE9NX1ZLX1BBVVNFXCIsXG4gICAgXCJET01fVktfUEVSQ0VOVFwiLFxuICAgIFwiRE9NX1ZLX1BFUklPRFwiLFxuICAgIFwiRE9NX1ZLX1BJUEVcIixcbiAgICBcIkRPTV9WS19QTEFZXCIsXG4gICAgXCJET01fVktfUExVU1wiLFxuICAgIFwiRE9NX1ZLX1BSSU5UXCIsXG4gICAgXCJET01fVktfUFJJTlRTQ1JFRU5cIixcbiAgICBcIkRPTV9WS19QUk9DRVNTS0VZXCIsXG4gICAgXCJET01fVktfUFJPUEVSSVRFU1wiLFxuICAgIFwiRE9NX1ZLX1FcIixcbiAgICBcIkRPTV9WS19RVUVTVElPTl9NQVJLXCIsXG4gICAgXCJET01fVktfUVVPVEVcIixcbiAgICBcIkRPTV9WS19SXCIsXG4gICAgXCJET01fVktfUkVET1wiLFxuICAgIFwiRE9NX1ZLX1JFVFVSTlwiLFxuICAgIFwiRE9NX1ZLX1JJR0hUXCIsXG4gICAgXCJET01fVktfU1wiLFxuICAgIFwiRE9NX1ZLX1NDUk9MTF9MT0NLXCIsXG4gICAgXCJET01fVktfU0VMRUNUXCIsXG4gICAgXCJET01fVktfU0VNSUNPTE9OXCIsXG4gICAgXCJET01fVktfU0VQQVJBVE9SXCIsXG4gICAgXCJET01fVktfU0hJRlRcIixcbiAgICBcIkRPTV9WS19TTEFTSFwiLFxuICAgIFwiRE9NX1ZLX1NMRUVQXCIsXG4gICAgXCJET01fVktfU1BBQ0VcIixcbiAgICBcIkRPTV9WS19TVUJUUkFDVFwiLFxuICAgIFwiRE9NX1ZLX1RcIixcbiAgICBcIkRPTV9WS19UQUJcIixcbiAgICBcIkRPTV9WS19USUxERVwiLFxuICAgIFwiRE9NX1ZLX1VcIixcbiAgICBcIkRPTV9WS19VTkRFUlNDT1JFXCIsXG4gICAgXCJET01fVktfVU5ET1wiLFxuICAgIFwiRE9NX1ZLX1VOSUNPREVcIixcbiAgICBcIkRPTV9WS19VUFwiLFxuICAgIFwiRE9NX1ZLX1ZcIixcbiAgICBcIkRPTV9WS19WT0xVTUVfRE9XTlwiLFxuICAgIFwiRE9NX1ZLX1ZPTFVNRV9NVVRFXCIsXG4gICAgXCJET01fVktfVk9MVU1FX1VQXCIsXG4gICAgXCJET01fVktfV1wiLFxuICAgIFwiRE9NX1ZLX1dJTlwiLFxuICAgIFwiRE9NX1ZLX1dJTkRPV1wiLFxuICAgIFwiRE9NX1ZLX1dJTl9JQ09fMDBcIixcbiAgICBcIkRPTV9WS19XSU5fSUNPX0NMRUFSXCIsXG4gICAgXCJET01fVktfV0lOX0lDT19IRUxQXCIsXG4gICAgXCJET01fVktfV0lOX09FTV9BVFROXCIsXG4gICAgXCJET01fVktfV0lOX09FTV9BVVRPXCIsXG4gICAgXCJET01fVktfV0lOX09FTV9CQUNLVEFCXCIsXG4gICAgXCJET01fVktfV0lOX09FTV9DTEVBUlwiLFxuICAgIFwiRE9NX1ZLX1dJTl9PRU1fQ09QWVwiLFxuICAgIFwiRE9NX1ZLX1dJTl9PRU1fQ1VTRUxcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0VOTFdcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0ZJTklTSFwiLFxuICAgIFwiRE9NX1ZLX1dJTl9PRU1fRkpfSklTSE9cIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0ZKX0xPWUFcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0ZKX01BU1NIT1VcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0ZKX1JPWUFcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0ZKX1RPVVJPS1VcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX0pVTVBcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX1BBMVwiLFxuICAgIFwiRE9NX1ZLX1dJTl9PRU1fUEEyXCIsXG4gICAgXCJET01fVktfV0lOX09FTV9QQTNcIixcbiAgICBcIkRPTV9WS19XSU5fT0VNX1JFU0VUXCIsXG4gICAgXCJET01fVktfV0lOX09FTV9XU0NUUkxcIixcbiAgICBcIkRPTV9WS19YXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FERF9GQVZPUklURVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19BUFBMSUNBVElPTl9MRUZUXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FQUExJQ0FUSU9OX1JJR0hUXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX0NZQ0xFX1RSQUNLXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX0ZPUldBUkRcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQVVESU9fTE9XRVJfVk9MVU1FXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX01FRElBXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX01VVEVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQVVESU9fTkVYVFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19BVURJT19QQVVTRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19BVURJT19QTEFZXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX1BSRVZcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQVVESU9fUkFJU0VfVk9MVU1FXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX1JBTkRPTV9QTEFZXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX1JFQ09SRFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19BVURJT19SRVBFQVRcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQVVESU9fUkVXSU5EXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0FVRElPX1NUT1BcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQVdBWVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19CQUNLXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0JBQ0tfRk9SV0FSRFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19CQVRURVJZXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0JMVUVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQkxVRVRPT1RIXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0JPT0tcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQlJJR0hUTkVTU19BREpVU1RcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQ0FMQ1VMQVRPUlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19DQUxFTkRBUlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19DRFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19DTE9TRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19DT01NVU5JVFlcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQ09OVFJBU1RfQURKVVNUXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0NPUFlcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfQ1VUXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0NZQ0xFX0FOR0xFXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0RJU1BMQVlcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfRE9DVU1FTlRTXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0RPU1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19FSkVDVFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19FWENFTFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19FWFBMT1JFUlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19GQVZPUklURVNcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfRklOQU5DRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19GT1JXQVJEXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0ZSQU1FX0JBQ0tcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfRlJBTUVfRk9SV0FSRFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19HQU1FXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0dPXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0dSRUVOXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0hJQkVSTkFURVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19ISVNUT1JZXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0hPTUVfUEFHRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19IT1RfTElOS1NcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfSV9UT1VDSFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19LQkRfQlJJR0hUTkVTU19ET1dOXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0tCRF9CUklHSFRORVNTX1VQXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0tCRF9MSUdIVF9PTl9PRkZcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTEFVTkNIMFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0gxXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0xBVU5DSDJcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTEFVTkNIM1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0g0XCIsXG4gICAgXCJET01fVktfWEY4NlhLX0xBVU5DSDVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTEFVTkNINlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0g3XCIsXG4gICAgXCJET01fVktfWEY4NlhLX0xBVU5DSDhcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTEFVTkNIOVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0hfQVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0hfQlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0hfQ1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0hfRFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0hfRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MQVVOQ0hfRlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19MSUdIVF9CVUxCXCIsXG4gICAgXCJET01fVktfWEY4NlhLX0xPR19PRkZcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTUFJTFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19NQUlMX0ZPUldBUkRcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTUFSS0VUXCIsXG4gICAgXCJET01fVktfWEY4NlhLX01FRVRJTkdcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTUVNT1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19NRU5VX0tCXCIsXG4gICAgXCJET01fVktfWEY4NlhLX01FTlVfUEJcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTUVTU0VOR0VSXCIsXG4gICAgXCJET01fVktfWEY4NlhLX01PTl9CUklHSFRORVNTX0RPV05cIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTU9OX0JSSUdIVE5FU1NfVVBcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTVVTSUNcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTVlfQ09NUFVURVJcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTVlfU0lURVNcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfTkVXXCIsXG4gICAgXCJET01fVktfWEY4NlhLX05FV1NcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfT0ZGSUNFX0hPTUVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfT1BFTlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19PUEVOX1VSTFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19PUFRJT05cIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUEFTVEVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUEhPTkVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUElDVFVSRVNcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUE9XRVJfRE9XTlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19QT1dFUl9PRkZcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUkVEXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1JFRlJFU0hcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUkVMT0FEXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1JFUExZXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1JPQ0tFUl9ET1dOXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1JPQ0tFUl9FTlRFUlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19ST0NLRVJfVVBcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUk9UQVRFX1dJTkRPV1NcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUk9UQVRJT05fS0JcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfUk9UQVRJT05fUEJcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfU0FWRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19TQ1JFRU5fU0FWRVJcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfU0NST0xMX0NMSUNLXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1NDUk9MTF9ET1dOXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1NDUk9MTF9VUFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19TRUFSQ0hcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfU0VORFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19TSE9QXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1NQRUxMXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1NQTElUX1NDUkVFTlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19TVEFOREJZXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1NUQVJUXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1NUT1BcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfU1VCVElUTEVcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfU1VQUE9SVFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19TVVNQRU5EXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1RBU0tfUEFORVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19URVJNSU5BTFwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19USU1FXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1RPT0xTXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1RPUF9NRU5VXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1RPX0RPX0xJU1RcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfVFJBVkVMXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1VTRVIxS0JcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfVVNFUjJLQlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19VU0VSX1BCXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1VXQlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19WRU5ET1JfSE9NRVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19WSURFT1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19WSUVXXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1dBS0VfVVBcIixcbiAgICBcIkRPTV9WS19YRjg2WEtfV0VCX0NBTVwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19XSEVFTF9CVVRUT05cIixcbiAgICBcIkRPTV9WS19YRjg2WEtfV0xBTlwiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19XT1JEXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1dXV1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19YRkVSXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1lFTExPV1wiLFxuICAgIFwiRE9NX1ZLX1hGODZYS19aT09NX0lOXCIsXG4gICAgXCJET01fVktfWEY4NlhLX1pPT01fT1VUXCIsXG4gICAgXCJET01fVktfWVwiLFxuICAgIFwiRE9NX1ZLX1pcIixcbiAgICBcIkRPTV9WS19aT09NXCIsXG4gICAgXCJET05FXCIsXG4gICAgXCJET05UX0NBUkVcIixcbiAgICBcIkRPV05MT0FESU5HXCIsXG4gICAgXCJEUkFHRFJPUFwiLFxuICAgIFwiRFJBV19CVUZGRVIwXCIsXG4gICAgXCJEUkFXX0JVRkZFUjFcIixcbiAgICBcIkRSQVdfQlVGRkVSMTBcIixcbiAgICBcIkRSQVdfQlVGRkVSMTFcIixcbiAgICBcIkRSQVdfQlVGRkVSMTJcIixcbiAgICBcIkRSQVdfQlVGRkVSMTNcIixcbiAgICBcIkRSQVdfQlVGRkVSMTRcIixcbiAgICBcIkRSQVdfQlVGRkVSMTVcIixcbiAgICBcIkRSQVdfQlVGRkVSMlwiLFxuICAgIFwiRFJBV19CVUZGRVIzXCIsXG4gICAgXCJEUkFXX0JVRkZFUjRcIixcbiAgICBcIkRSQVdfQlVGRkVSNVwiLFxuICAgIFwiRFJBV19CVUZGRVI2XCIsXG4gICAgXCJEUkFXX0JVRkZFUjdcIixcbiAgICBcIkRSQVdfQlVGRkVSOFwiLFxuICAgIFwiRFJBV19CVUZGRVI5XCIsXG4gICAgXCJEUkFXX0ZSQU1FQlVGRkVSXCIsXG4gICAgXCJEUkFXX0ZSQU1FQlVGRkVSX0JJTkRJTkdcIixcbiAgICBcIkRTVF9BTFBIQVwiLFxuICAgIFwiRFNUX0NPTE9SXCIsXG4gICAgXCJEWU5BTUlDX0NPUFlcIixcbiAgICBcIkRZTkFNSUNfRFJBV1wiLFxuICAgIFwiRFlOQU1JQ19SRUFEXCIsXG4gICAgXCJEYXRhQ2hhbm5lbFwiLFxuICAgIFwiRGF0YVRyYW5zZmVyXCIsXG4gICAgXCJEYXRhVHJhbnNmZXJJdGVtXCIsXG4gICAgXCJEYXRhVHJhbnNmZXJJdGVtTGlzdFwiLFxuICAgIFwiRGF0YVZpZXdcIixcbiAgICBcIkRhdGVcIixcbiAgICBcIkRhdGVUaW1lRm9ybWF0XCIsXG4gICAgXCJEZWNvbXByZXNzaW9uU3RyZWFtXCIsXG4gICAgXCJEZWxheU5vZGVcIixcbiAgICBcIkRlcHJlY2F0aW9uUmVwb3J0Qm9keVwiLFxuICAgIFwiRGVza3RvcE5vdGlmaWNhdGlvblwiLFxuICAgIFwiRGVza3RvcE5vdGlmaWNhdGlvbkNlbnRlclwiLFxuICAgIFwiRGV2aWNlTGlnaHRFdmVudFwiLFxuICAgIFwiRGV2aWNlTW90aW9uRXZlbnRcIixcbiAgICBcIkRldmljZU1vdGlvbkV2ZW50QWNjZWxlcmF0aW9uXCIsXG4gICAgXCJEZXZpY2VNb3Rpb25FdmVudFJvdGF0aW9uUmF0ZVwiLFxuICAgIFwiRGV2aWNlT3JpZW50YXRpb25FdmVudFwiLFxuICAgIFwiRGV2aWNlUHJveGltaXR5RXZlbnRcIixcbiAgICBcIkRldmljZVN0b3JhZ2VcIixcbiAgICBcIkRldmljZVN0b3JhZ2VDaGFuZ2VFdmVudFwiLFxuICAgIFwiRGlyZWN0b3J5XCIsXG4gICAgXCJEaXNwbGF5TmFtZXNcIixcbiAgICBcIkRvY3VtZW50XCIsXG4gICAgXCJEb2N1bWVudEZyYWdtZW50XCIsXG4gICAgXCJEb2N1bWVudFRpbWVsaW5lXCIsXG4gICAgXCJEb2N1bWVudFR5cGVcIixcbiAgICBcIkRyYWdFdmVudFwiLFxuICAgIFwiRHluYW1pY3NDb21wcmVzc29yTm9kZVwiLFxuICAgIFwiRVwiLFxuICAgIFwiRUxFTUVOVF9BUlJBWV9CVUZGRVJcIixcbiAgICBcIkVMRU1FTlRfQVJSQVlfQlVGRkVSX0JJTkRJTkdcIixcbiAgICBcIkVMRU1FTlRfTk9ERVwiLFxuICAgIFwiRU1QVFlcIixcbiAgICBcIkVOQ09ESU5HX0VSUlwiLFxuICAgIFwiRU5ERURcIixcbiAgICBcIkVORF9UT19FTkRcIixcbiAgICBcIkVORF9UT19TVEFSVFwiLFxuICAgIFwiRU5USVRZX05PREVcIixcbiAgICBcIkVOVElUWV9SRUZFUkVOQ0VfTk9ERVwiLFxuICAgIFwiRVBTSUxPTlwiLFxuICAgIFwiRVFVQUxcIixcbiAgICBcIkVRVUFMUE9XRVJcIixcbiAgICBcIkVSUk9SXCIsXG4gICAgXCJFWFBPTkVOVElBTF9ESVNUQU5DRVwiLFxuICAgIFwiRWxlbWVudFwiLFxuICAgIFwiRWxlbWVudEludGVybmFsc1wiLFxuICAgIFwiRWxlbWVudFF1ZXJ5XCIsXG4gICAgXCJFbnRlclBpY3R1cmVJblBpY3R1cmVFdmVudFwiLFxuICAgIFwiRW50aXR5XCIsXG4gICAgXCJFbnRpdHlSZWZlcmVuY2VcIixcbiAgICBcIkVycm9yXCIsXG4gICAgXCJFcnJvckV2ZW50XCIsXG4gICAgXCJFdmFsRXJyb3JcIixcbiAgICBcIkV2ZW50XCIsXG4gICAgXCJFdmVudEV4Y2VwdGlvblwiLFxuICAgIFwiRXZlbnRTb3VyY2VcIixcbiAgICBcIkV2ZW50VGFyZ2V0XCIsXG4gICAgXCJFeHRlcm5hbFwiLFxuICAgIFwiRkFTVEVTVFwiLFxuICAgIFwiRklET1NES1wiLFxuICAgIFwiRklMVEVSX0FDQ0VQVFwiLFxuICAgIFwiRklMVEVSX0lOVEVSUlVQVFwiLFxuICAgIFwiRklMVEVSX1JFSkVDVFwiLFxuICAgIFwiRklMVEVSX1NLSVBcIixcbiAgICBcIkZJTklTSEVEX1NUQVRFXCIsXG4gICAgXCJGSVJTVF9PUkRFUkVEX05PREVfVFlQRVwiLFxuICAgIFwiRkxPQVRcIixcbiAgICBcIkZMT0FUXzMyX1VOU0lHTkVEX0lOVF8yNF84X1JFVlwiLFxuICAgIFwiRkxPQVRfTUFUMlwiLFxuICAgIFwiRkxPQVRfTUFUMngzXCIsXG4gICAgXCJGTE9BVF9NQVQyeDRcIixcbiAgICBcIkZMT0FUX01BVDNcIixcbiAgICBcIkZMT0FUX01BVDN4MlwiLFxuICAgIFwiRkxPQVRfTUFUM3g0XCIsXG4gICAgXCJGTE9BVF9NQVQ0XCIsXG4gICAgXCJGTE9BVF9NQVQ0eDJcIixcbiAgICBcIkZMT0FUX01BVDR4M1wiLFxuICAgIFwiRkxPQVRfVkVDMlwiLFxuICAgIFwiRkxPQVRfVkVDM1wiLFxuICAgIFwiRkxPQVRfVkVDNFwiLFxuICAgIFwiRk9DVVNcIixcbiAgICBcIkZPTlRfRkFDRV9SVUxFXCIsXG4gICAgXCJGT05UX0ZFQVRVUkVfVkFMVUVTX1JVTEVcIixcbiAgICBcIkZSQUdNRU5UX1NIQURFUlwiLFxuICAgIFwiRlJBR01FTlRfU0hBREVSX0RFUklWQVRJVkVfSElOVFwiLFxuICAgIFwiRlJBR01FTlRfU0hBREVSX0RFUklWQVRJVkVfSElOVF9PRVNcIixcbiAgICBcIkZSQU1FQlVGRkVSXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0FMUEhBX1NJWkVcIixcbiAgICBcIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfQkxVRV9TSVpFXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0NPTE9SX0VOQ09ESU5HXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0NPTVBPTkVOVF9UWVBFXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX0RFUFRIX1NJWkVcIixcbiAgICBcIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfR1JFRU5fU0laRVwiLFxuICAgIFwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfTkFNRVwiLFxuICAgIFwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9PQkpFQ1RfVFlQRVwiLFxuICAgIFwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9SRURfU0laRVwiLFxuICAgIFwiRlJBTUVCVUZGRVJfQVRUQUNITUVOVF9TVEVOQ0lMX1NJWkVcIixcbiAgICBcIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9DVUJFX01BUF9GQUNFXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9BVFRBQ0hNRU5UX1RFWFRVUkVfTEFZRVJcIixcbiAgICBcIkZSQU1FQlVGRkVSX0FUVEFDSE1FTlRfVEVYVFVSRV9MRVZFTFwiLFxuICAgIFwiRlJBTUVCVUZGRVJfQklORElOR1wiLFxuICAgIFwiRlJBTUVCVUZGRVJfQ09NUExFVEVcIixcbiAgICBcIkZSQU1FQlVGRkVSX0RFRkFVTFRcIixcbiAgICBcIkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVFwiLFxuICAgIFwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TXCIsXG4gICAgXCJGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVFwiLFxuICAgIFwiRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NVUxUSVNBTVBMRVwiLFxuICAgIFwiRlJBTUVCVUZGRVJfVU5TVVBQT1JURURcIixcbiAgICBcIkZST05UXCIsXG4gICAgXCJGUk9OVF9BTkRfQkFDS1wiLFxuICAgIFwiRlJPTlRfRkFDRVwiLFxuICAgIFwiRlVOQ19BRERcIixcbiAgICBcIkZVTkNfUkVWRVJTRV9TVUJUUkFDVFwiLFxuICAgIFwiRlVOQ19TVUJUUkFDVFwiLFxuICAgIFwiRmVhdHVyZVBvbGljeVwiLFxuICAgIFwiRmVhdHVyZVBvbGljeVZpb2xhdGlvblJlcG9ydEJvZHlcIixcbiAgICBcIkZlZGVyYXRlZENyZWRlbnRpYWxcIixcbiAgICBcIkZlZWRcIixcbiAgICBcIkZlZWRFbnRyeVwiLFxuICAgIFwiRmlsZVwiLFxuICAgIFwiRmlsZUVycm9yXCIsXG4gICAgXCJGaWxlTGlzdFwiLFxuICAgIFwiRmlsZVJlYWRlclwiLFxuICAgIFwiRmlsZVN5c3RlbVwiLFxuICAgIFwiRmlsZVN5c3RlbURpcmVjdG9yeUVudHJ5XCIsXG4gICAgXCJGaWxlU3lzdGVtRGlyZWN0b3J5UmVhZGVyXCIsXG4gICAgXCJGaWxlU3lzdGVtRW50cnlcIixcbiAgICBcIkZpbGVTeXN0ZW1GaWxlRW50cnlcIixcbiAgICBcIkZpbmFsaXphdGlvblJlZ2lzdHJ5XCIsXG4gICAgXCJGaW5kSW5QYWdlXCIsXG4gICAgXCJGbG9hdDMyQXJyYXlcIixcbiAgICBcIkZsb2F0NjRBcnJheVwiLFxuICAgIFwiRm9jdXNFdmVudFwiLFxuICAgIFwiRm9udEZhY2VcIixcbiAgICBcIkZvbnRGYWNlU2V0XCIsXG4gICAgXCJGb250RmFjZVNldExvYWRFdmVudFwiLFxuICAgIFwiRm9ybURhdGFcIixcbiAgICBcIkZvcm1EYXRhRXZlbnRcIixcbiAgICBcIkZyYWdtZW50RGlyZWN0aXZlXCIsXG4gICAgXCJGdW5jdGlvblwiLFxuICAgIFwiR0VORVJBVEVfTUlQTUFQX0hJTlRcIixcbiAgICBcIkdFUVVBTFwiLFxuICAgIFwiR1JFQVRFUlwiLFxuICAgIFwiR1JFRU5fQklUU1wiLFxuICAgIFwiR2Fpbk5vZGVcIixcbiAgICBcIkdhbWVwYWRcIixcbiAgICBcIkdhbWVwYWRBeGlzTW92ZUV2ZW50XCIsXG4gICAgXCJHYW1lcGFkQnV0dG9uXCIsXG4gICAgXCJHYW1lcGFkQnV0dG9uRXZlbnRcIixcbiAgICBcIkdhbWVwYWRFdmVudFwiLFxuICAgIFwiR2FtZXBhZEhhcHRpY0FjdHVhdG9yXCIsXG4gICAgXCJHYW1lcGFkUG9zZVwiLFxuICAgIFwiR2VvbG9jYXRpb25cIixcbiAgICBcIkdlb2xvY2F0aW9uQ29vcmRpbmF0ZXNcIixcbiAgICBcIkdlb2xvY2F0aW9uUG9zaXRpb25cIixcbiAgICBcIkdlb2xvY2F0aW9uUG9zaXRpb25FcnJvclwiLFxuICAgIFwiR2VzdHVyZUV2ZW50XCIsXG4gICAgXCJHbG9iYWxcIixcbiAgICBcIkd5cm9zY29wZVwiLFxuICAgIFwiSEFMRl9GTE9BVFwiLFxuICAgIFwiSEFWRV9DVVJSRU5UX0RBVEFcIixcbiAgICBcIkhBVkVfRU5PVUdIX0RBVEFcIixcbiAgICBcIkhBVkVfRlVUVVJFX0RBVEFcIixcbiAgICBcIkhBVkVfTUVUQURBVEFcIixcbiAgICBcIkhBVkVfTk9USElOR1wiLFxuICAgIFwiSEVBREVSU19SRUNFSVZFRFwiLFxuICAgIFwiSElEREVOXCIsXG4gICAgXCJISUVSQVJDSFlfUkVRVUVTVF9FUlJcIixcbiAgICBcIkhJR0hQQVNTXCIsXG4gICAgXCJISUdIU0hFTEZcIixcbiAgICBcIkhJR0hfRkxPQVRcIixcbiAgICBcIkhJR0hfSU5UXCIsXG4gICAgXCJIT1JJWk9OVEFMXCIsXG4gICAgXCJIT1JJWk9OVEFMX0FYSVNcIixcbiAgICBcIkhSVEZcIixcbiAgICBcIkhUTUxBbGxDb2xsZWN0aW9uXCIsXG4gICAgXCJIVE1MQW5jaG9yRWxlbWVudFwiLFxuICAgIFwiSFRNTEFwcGxldEVsZW1lbnRcIixcbiAgICBcIkhUTUxBcmVhRWxlbWVudFwiLFxuICAgIFwiSFRNTEF1ZGlvRWxlbWVudFwiLFxuICAgIFwiSFRNTEJSRWxlbWVudFwiLFxuICAgIFwiSFRNTEJhc2VFbGVtZW50XCIsXG4gICAgXCJIVE1MQmFzZUZvbnRFbGVtZW50XCIsXG4gICAgXCJIVE1MQmxvY2txdW90ZUVsZW1lbnRcIixcbiAgICBcIkhUTUxCb2R5RWxlbWVudFwiLFxuICAgIFwiSFRNTEJ1dHRvbkVsZW1lbnRcIixcbiAgICBcIkhUTUxDYW52YXNFbGVtZW50XCIsXG4gICAgXCJIVE1MQ29sbGVjdGlvblwiLFxuICAgIFwiSFRNTENvbW1hbmRFbGVtZW50XCIsXG4gICAgXCJIVE1MQ29udGVudEVsZW1lbnRcIixcbiAgICBcIkhUTUxETGlzdEVsZW1lbnRcIixcbiAgICBcIkhUTUxEYXRhRWxlbWVudFwiLFxuICAgIFwiSFRNTERhdGFMaXN0RWxlbWVudFwiLFxuICAgIFwiSFRNTERldGFpbHNFbGVtZW50XCIsXG4gICAgXCJIVE1MRGlhbG9nRWxlbWVudFwiLFxuICAgIFwiSFRNTERpcmVjdG9yeUVsZW1lbnRcIixcbiAgICBcIkhUTUxEaXZFbGVtZW50XCIsXG4gICAgXCJIVE1MRG9jdW1lbnRcIixcbiAgICBcIkhUTUxFbGVtZW50XCIsXG4gICAgXCJIVE1MRW1iZWRFbGVtZW50XCIsXG4gICAgXCJIVE1MRmllbGRTZXRFbGVtZW50XCIsXG4gICAgXCJIVE1MRm9udEVsZW1lbnRcIixcbiAgICBcIkhUTUxGb3JtQ29udHJvbHNDb2xsZWN0aW9uXCIsXG4gICAgXCJIVE1MRm9ybUVsZW1lbnRcIixcbiAgICBcIkhUTUxGcmFtZUVsZW1lbnRcIixcbiAgICBcIkhUTUxGcmFtZVNldEVsZW1lbnRcIixcbiAgICBcIkhUTUxIUkVsZW1lbnRcIixcbiAgICBcIkhUTUxIZWFkRWxlbWVudFwiLFxuICAgIFwiSFRNTEhlYWRpbmdFbGVtZW50XCIsXG4gICAgXCJIVE1MSHRtbEVsZW1lbnRcIixcbiAgICBcIkhUTUxJRnJhbWVFbGVtZW50XCIsXG4gICAgXCJIVE1MSW1hZ2VFbGVtZW50XCIsXG4gICAgXCJIVE1MSW5wdXRFbGVtZW50XCIsXG4gICAgXCJIVE1MSXNJbmRleEVsZW1lbnRcIixcbiAgICBcIkhUTUxLZXlnZW5FbGVtZW50XCIsXG4gICAgXCJIVE1MTElFbGVtZW50XCIsXG4gICAgXCJIVE1MTGFiZWxFbGVtZW50XCIsXG4gICAgXCJIVE1MTGVnZW5kRWxlbWVudFwiLFxuICAgIFwiSFRNTExpbmtFbGVtZW50XCIsXG4gICAgXCJIVE1MTWFwRWxlbWVudFwiLFxuICAgIFwiSFRNTE1hcnF1ZWVFbGVtZW50XCIsXG4gICAgXCJIVE1MTWVkaWFFbGVtZW50XCIsXG4gICAgXCJIVE1MTWVudUVsZW1lbnRcIixcbiAgICBcIkhUTUxNZW51SXRlbUVsZW1lbnRcIixcbiAgICBcIkhUTUxNZXRhRWxlbWVudFwiLFxuICAgIFwiSFRNTE1ldGVyRWxlbWVudFwiLFxuICAgIFwiSFRNTE1vZEVsZW1lbnRcIixcbiAgICBcIkhUTUxPTGlzdEVsZW1lbnRcIixcbiAgICBcIkhUTUxPYmplY3RFbGVtZW50XCIsXG4gICAgXCJIVE1MT3B0R3JvdXBFbGVtZW50XCIsXG4gICAgXCJIVE1MT3B0aW9uRWxlbWVudFwiLFxuICAgIFwiSFRNTE9wdGlvbnNDb2xsZWN0aW9uXCIsXG4gICAgXCJIVE1MT3V0cHV0RWxlbWVudFwiLFxuICAgIFwiSFRNTFBhcmFncmFwaEVsZW1lbnRcIixcbiAgICBcIkhUTUxQYXJhbUVsZW1lbnRcIixcbiAgICBcIkhUTUxQaWN0dXJlRWxlbWVudFwiLFxuICAgIFwiSFRNTFByZUVsZW1lbnRcIixcbiAgICBcIkhUTUxQcm9ncmVzc0VsZW1lbnRcIixcbiAgICBcIkhUTUxQcm9wZXJ0aWVzQ29sbGVjdGlvblwiLFxuICAgIFwiSFRNTFF1b3RlRWxlbWVudFwiLFxuICAgIFwiSFRNTFNjcmlwdEVsZW1lbnRcIixcbiAgICBcIkhUTUxTZWxlY3RFbGVtZW50XCIsXG4gICAgXCJIVE1MU2hhZG93RWxlbWVudFwiLFxuICAgIFwiSFRNTFNsb3RFbGVtZW50XCIsXG4gICAgXCJIVE1MU291cmNlRWxlbWVudFwiLFxuICAgIFwiSFRNTFNwYW5FbGVtZW50XCIsXG4gICAgXCJIVE1MU3R5bGVFbGVtZW50XCIsXG4gICAgXCJIVE1MVGFibGVDYXB0aW9uRWxlbWVudFwiLFxuICAgIFwiSFRNTFRhYmxlQ2VsbEVsZW1lbnRcIixcbiAgICBcIkhUTUxUYWJsZUNvbEVsZW1lbnRcIixcbiAgICBcIkhUTUxUYWJsZUVsZW1lbnRcIixcbiAgICBcIkhUTUxUYWJsZVJvd0VsZW1lbnRcIixcbiAgICBcIkhUTUxUYWJsZVNlY3Rpb25FbGVtZW50XCIsXG4gICAgXCJIVE1MVGVtcGxhdGVFbGVtZW50XCIsXG4gICAgXCJIVE1MVGV4dEFyZWFFbGVtZW50XCIsXG4gICAgXCJIVE1MVGltZUVsZW1lbnRcIixcbiAgICBcIkhUTUxUaXRsZUVsZW1lbnRcIixcbiAgICBcIkhUTUxUcmFja0VsZW1lbnRcIixcbiAgICBcIkhUTUxVTGlzdEVsZW1lbnRcIixcbiAgICBcIkhUTUxVbmtub3duRWxlbWVudFwiLFxuICAgIFwiSFRNTFZpZGVvRWxlbWVudFwiLFxuICAgIFwiSGFzaENoYW5nZUV2ZW50XCIsXG4gICAgXCJIZWFkZXJzXCIsXG4gICAgXCJIaXN0b3J5XCIsXG4gICAgXCJIelwiLFxuICAgIFwiSUNFX0NIRUNLSU5HXCIsXG4gICAgXCJJQ0VfQ0xPU0VEXCIsXG4gICAgXCJJQ0VfQ09NUExFVEVEXCIsXG4gICAgXCJJQ0VfQ09OTkVDVEVEXCIsXG4gICAgXCJJQ0VfRkFJTEVEXCIsXG4gICAgXCJJQ0VfR0FUSEVSSU5HXCIsXG4gICAgXCJJQ0VfV0FJVElOR1wiLFxuICAgIFwiSURCQ3Vyc29yXCIsXG4gICAgXCJJREJDdXJzb3JXaXRoVmFsdWVcIixcbiAgICBcIklEQkRhdGFiYXNlXCIsXG4gICAgXCJJREJEYXRhYmFzZUV4Y2VwdGlvblwiLFxuICAgIFwiSURCRmFjdG9yeVwiLFxuICAgIFwiSURCRmlsZUhhbmRsZVwiLFxuICAgIFwiSURCRmlsZVJlcXVlc3RcIixcbiAgICBcIklEQkluZGV4XCIsXG4gICAgXCJJREJLZXlSYW5nZVwiLFxuICAgIFwiSURCTXV0YWJsZUZpbGVcIixcbiAgICBcIklEQk9iamVjdFN0b3JlXCIsXG4gICAgXCJJREJPcGVuREJSZXF1ZXN0XCIsXG4gICAgXCJJREJSZXF1ZXN0XCIsXG4gICAgXCJJREJUcmFuc2FjdGlvblwiLFxuICAgIFwiSURCVmVyc2lvbkNoYW5nZUV2ZW50XCIsXG4gICAgXCJJRExFXCIsXG4gICAgXCJJSVJGaWx0ZXJOb2RlXCIsXG4gICAgXCJJTVBMRU1FTlRBVElPTl9DT0xPUl9SRUFEX0ZPUk1BVFwiLFxuICAgIFwiSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFXCIsXG4gICAgXCJJTVBPUlRfUlVMRVwiLFxuICAgIFwiSU5DUlwiLFxuICAgIFwiSU5DUl9XUkFQXCIsXG4gICAgXCJJTkRFWF9TSVpFX0VSUlwiLFxuICAgIFwiSU5UXCIsXG4gICAgXCJJTlRFUkxFQVZFRF9BVFRSSUJTXCIsXG4gICAgXCJJTlRfMl8xMF8xMF8xMF9SRVZcIixcbiAgICBcIklOVF9TQU1QTEVSXzJEXCIsXG4gICAgXCJJTlRfU0FNUExFUl8yRF9BUlJBWVwiLFxuICAgIFwiSU5UX1NBTVBMRVJfM0RcIixcbiAgICBcIklOVF9TQU1QTEVSX0NVQkVcIixcbiAgICBcIklOVF9WRUMyXCIsXG4gICAgXCJJTlRfVkVDM1wiLFxuICAgIFwiSU5UX1ZFQzRcIixcbiAgICBcIklOVVNFX0FUVFJJQlVURV9FUlJcIixcbiAgICBcIklOVkFMSURfQUNDRVNTX0VSUlwiLFxuICAgIFwiSU5WQUxJRF9DSEFSQUNURVJfRVJSXCIsXG4gICAgXCJJTlZBTElEX0VOVU1cIixcbiAgICBcIklOVkFMSURfRVhQUkVTU0lPTl9FUlJcIixcbiAgICBcIklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OXCIsXG4gICAgXCJJTlZBTElEX0lOREVYXCIsXG4gICAgXCJJTlZBTElEX01PRElGSUNBVElPTl9FUlJcIixcbiAgICBcIklOVkFMSURfTk9ERV9UWVBFX0VSUlwiLFxuICAgIFwiSU5WQUxJRF9PUEVSQVRJT05cIixcbiAgICBcIklOVkFMSURfU1RBVEVfRVJSXCIsXG4gICAgXCJJTlZBTElEX1ZBTFVFXCIsXG4gICAgXCJJTlZFUlNFX0RJU1RBTkNFXCIsXG4gICAgXCJJTlZFUlRcIixcbiAgICBcIkljZUNhbmRpZGF0ZVwiLFxuICAgIFwiSWRsZURlYWRsaW5lXCIsXG4gICAgXCJJbWFnZVwiLFxuICAgIFwiSW1hZ2VCaXRtYXBcIixcbiAgICBcIkltYWdlQml0bWFwUmVuZGVyaW5nQ29udGV4dFwiLFxuICAgIFwiSW1hZ2VDYXB0dXJlXCIsXG4gICAgXCJJbWFnZURhdGFcIixcbiAgICBcIkluZmluaXR5XCIsXG4gICAgXCJJbnB1dERldmljZUNhcGFiaWxpdGllc1wiLFxuICAgIFwiSW5wdXREZXZpY2VJbmZvXCIsXG4gICAgXCJJbnB1dEV2ZW50XCIsXG4gICAgXCJJbnB1dE1ldGhvZENvbnRleHRcIixcbiAgICBcIkluc3RhbGxUcmlnZ2VyXCIsXG4gICAgXCJJbnN0YWxsVHJpZ2dlckltcGxcIixcbiAgICBcIkluc3RhbmNlXCIsXG4gICAgXCJJbnQxNkFycmF5XCIsXG4gICAgXCJJbnQzMkFycmF5XCIsXG4gICAgXCJJbnQ4QXJyYXlcIixcbiAgICBcIkludGVudFwiLFxuICAgIFwiSW50ZXJuYWxFcnJvclwiLFxuICAgIFwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcIixcbiAgICBcIkludGVyc2VjdGlvbk9ic2VydmVyRW50cnlcIixcbiAgICBcIkludGxcIixcbiAgICBcIklzU2VhcmNoUHJvdmlkZXJJbnN0YWxsZWRcIixcbiAgICBcIkl0ZXJhdG9yXCIsXG4gICAgXCJKU09OXCIsXG4gICAgXCJLRUVQXCIsXG4gICAgXCJLRVlET1dOXCIsXG4gICAgXCJLRVlGUkFNRVNfUlVMRVwiLFxuICAgIFwiS0VZRlJBTUVfUlVMRVwiLFxuICAgIFwiS0VZUFJFU1NcIixcbiAgICBcIktFWVVQXCIsXG4gICAgXCJLZXlFdmVudFwiLFxuICAgIFwiS2V5Ym9hcmRcIixcbiAgICBcIktleWJvYXJkRXZlbnRcIixcbiAgICBcIktleWJvYXJkTGF5b3V0TWFwXCIsXG4gICAgXCJLZXlmcmFtZUVmZmVjdFwiLFxuICAgIFwiTEVOR1RIQURKVVNUX1NQQUNJTkdcIixcbiAgICBcIkxFTkdUSEFESlVTVF9TUEFDSU5HQU5ER0xZUEhTXCIsXG4gICAgXCJMRU5HVEhBREpVU1RfVU5LTk9XTlwiLFxuICAgIFwiTEVRVUFMXCIsXG4gICAgXCJMRVNTXCIsXG4gICAgXCJMSU5FQVJcIixcbiAgICBcIkxJTkVBUl9ESVNUQU5DRVwiLFxuICAgIFwiTElORUFSX01JUE1BUF9MSU5FQVJcIixcbiAgICBcIkxJTkVBUl9NSVBNQVBfTkVBUkVTVFwiLFxuICAgIFwiTElORVNcIixcbiAgICBcIkxJTkVfTE9PUFwiLFxuICAgIFwiTElORV9TVFJJUFwiLFxuICAgIFwiTElORV9XSURUSFwiLFxuICAgIFwiTElOS19TVEFUVVNcIixcbiAgICBcIkxJVkVcIixcbiAgICBcIkxOMTBcIixcbiAgICBcIkxOMlwiLFxuICAgIFwiTE9BREVEXCIsXG4gICAgXCJMT0FESU5HXCIsXG4gICAgXCJMT0cxMEVcIixcbiAgICBcIkxPRzJFXCIsXG4gICAgXCJMT1dQQVNTXCIsXG4gICAgXCJMT1dTSEVMRlwiLFxuICAgIFwiTE9XX0ZMT0FUXCIsXG4gICAgXCJMT1dfSU5UXCIsXG4gICAgXCJMU0V4Y2VwdGlvblwiLFxuICAgIFwiTFNQYXJzZXJGaWx0ZXJcIixcbiAgICBcIkxVTUlOQU5DRVwiLFxuICAgIFwiTFVNSU5BTkNFX0FMUEhBXCIsXG4gICAgXCJMYXJnZXN0Q29udGVudGZ1bFBhaW50XCIsXG4gICAgXCJMYXlvdXRTaGlmdFwiLFxuICAgIFwiTGF5b3V0U2hpZnRBdHRyaWJ1dGlvblwiLFxuICAgIFwiTGluZWFyQWNjZWxlcmF0aW9uU2Vuc29yXCIsXG4gICAgXCJMaW5rRXJyb3JcIixcbiAgICBcIkxpc3RGb3JtYXRcIixcbiAgICBcIkxvY2FsTWVkaWFTdHJlYW1cIixcbiAgICBcIkxvY2FsZVwiLFxuICAgIFwiTG9jYXRpb25cIixcbiAgICBcIkxvY2tcIixcbiAgICBcIkxvY2tNYW5hZ2VyXCIsXG4gICAgXCJNQVhcIixcbiAgICBcIk1BWF8zRF9URVhUVVJFX1NJWkVcIixcbiAgICBcIk1BWF9BUlJBWV9URVhUVVJFX0xBWUVSU1wiLFxuICAgIFwiTUFYX0NMSUVOVF9XQUlUX1RJTUVPVVRfV0VCR0xcIixcbiAgICBcIk1BWF9DT0xPUl9BVFRBQ0hNRU5UU1wiLFxuICAgIFwiTUFYX0NPTUJJTkVEX0ZSQUdNRU5UX1VOSUZPUk1fQ09NUE9ORU5UU1wiLFxuICAgIFwiTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFNcIixcbiAgICBcIk1BWF9DT01CSU5FRF9VTklGT1JNX0JMT0NLU1wiLFxuICAgIFwiTUFYX0NPTUJJTkVEX1ZFUlRFWF9VTklGT1JNX0NPTVBPTkVOVFNcIixcbiAgICBcIk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkVcIixcbiAgICBcIk1BWF9EUkFXX0JVRkZFUlNcIixcbiAgICBcIk1BWF9FTEVNRU5UU19JTkRJQ0VTXCIsXG4gICAgXCJNQVhfRUxFTUVOVFNfVkVSVElDRVNcIixcbiAgICBcIk1BWF9FTEVNRU5UX0lOREVYXCIsXG4gICAgXCJNQVhfRlJBR01FTlRfSU5QVVRfQ09NUE9ORU5UU1wiLFxuICAgIFwiTUFYX0ZSQUdNRU5UX1VOSUZPUk1fQkxPQ0tTXCIsXG4gICAgXCJNQVhfRlJBR01FTlRfVU5JRk9STV9DT01QT05FTlRTXCIsXG4gICAgXCJNQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTXCIsXG4gICAgXCJNQVhfUFJPR1JBTV9URVhFTF9PRkZTRVRcIixcbiAgICBcIk1BWF9SRU5ERVJCVUZGRVJfU0laRVwiLFxuICAgIFwiTUFYX1NBRkVfSU5URUdFUlwiLFxuICAgIFwiTUFYX1NBTVBMRVNcIixcbiAgICBcIk1BWF9TRVJWRVJfV0FJVF9USU1FT1VUXCIsXG4gICAgXCJNQVhfVEVYVFVSRV9JTUFHRV9VTklUU1wiLFxuICAgIFwiTUFYX1RFWFRVUkVfTE9EX0JJQVNcIixcbiAgICBcIk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVFwiLFxuICAgIFwiTUFYX1RFWFRVUkVfU0laRVwiLFxuICAgIFwiTUFYX1RSQU5TRk9STV9GRUVEQkFDS19JTlRFUkxFQVZFRF9DT01QT05FTlRTXCIsXG4gICAgXCJNQVhfVFJBTlNGT1JNX0ZFRURCQUNLX1NFUEFSQVRFX0FUVFJJQlNcIixcbiAgICBcIk1BWF9UUkFOU0ZPUk1fRkVFREJBQ0tfU0VQQVJBVEVfQ09NUE9ORU5UU1wiLFxuICAgIFwiTUFYX1VOSUZPUk1fQkxPQ0tfU0laRVwiLFxuICAgIFwiTUFYX1VOSUZPUk1fQlVGRkVSX0JJTkRJTkdTXCIsXG4gICAgXCJNQVhfVkFMVUVcIixcbiAgICBcIk1BWF9WQVJZSU5HX0NPTVBPTkVOVFNcIixcbiAgICBcIk1BWF9WQVJZSU5HX1ZFQ1RPUlNcIixcbiAgICBcIk1BWF9WRVJURVhfQVRUUklCU1wiLFxuICAgIFwiTUFYX1ZFUlRFWF9PVVRQVVRfQ09NUE9ORU5UU1wiLFxuICAgIFwiTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTXCIsXG4gICAgXCJNQVhfVkVSVEVYX1VOSUZPUk1fQkxPQ0tTXCIsXG4gICAgXCJNQVhfVkVSVEVYX1VOSUZPUk1fQ09NUE9ORU5UU1wiLFxuICAgIFwiTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlNcIixcbiAgICBcIk1BWF9WSUVXUE9SVF9ESU1TXCIsXG4gICAgXCJNRURJQV9FUlJfQUJPUlRFRFwiLFxuICAgIFwiTUVESUFfRVJSX0RFQ09ERVwiLFxuICAgIFwiTUVESUFfRVJSX0VOQ1JZUFRFRFwiLFxuICAgIFwiTUVESUFfRVJSX05FVFdPUktcIixcbiAgICBcIk1FRElBX0VSUl9TUkNfTk9UX1NVUFBPUlRFRFwiLFxuICAgIFwiTUVESUFfS0VZRVJSX0NMSUVOVFwiLFxuICAgIFwiTUVESUFfS0VZRVJSX0RPTUFJTlwiLFxuICAgIFwiTUVESUFfS0VZRVJSX0hBUkRXQVJFQ0hBTkdFXCIsXG4gICAgXCJNRURJQV9LRVlFUlJfT1VUUFVUXCIsXG4gICAgXCJNRURJQV9LRVlFUlJfU0VSVklDRVwiLFxuICAgIFwiTUVESUFfS0VZRVJSX1VOS05PV05cIixcbiAgICBcIk1FRElBX1JVTEVcIixcbiAgICBcIk1FRElVTV9GTE9BVFwiLFxuICAgIFwiTUVESVVNX0lOVFwiLFxuICAgIFwiTUVUQV9NQVNLXCIsXG4gICAgXCJNSURJQWNjZXNzXCIsXG4gICAgXCJNSURJQ29ubmVjdGlvbkV2ZW50XCIsXG4gICAgXCJNSURJSW5wdXRcIixcbiAgICBcIk1JRElJbnB1dE1hcFwiLFxuICAgIFwiTUlESU1lc3NhZ2VFdmVudFwiLFxuICAgIFwiTUlESU91dHB1dFwiLFxuICAgIFwiTUlESU91dHB1dE1hcFwiLFxuICAgIFwiTUlESVBvcnRcIixcbiAgICBcIk1JTlwiLFxuICAgIFwiTUlOX1BST0dSQU1fVEVYRUxfT0ZGU0VUXCIsXG4gICAgXCJNSU5fU0FGRV9JTlRFR0VSXCIsXG4gICAgXCJNSU5fVkFMVUVcIixcbiAgICBcIk1JUlJPUkVEX1JFUEVBVFwiLFxuICAgIFwiTU9ERV9BU1lOQ0hST05PVVNcIixcbiAgICBcIk1PREVfU1lOQ0hST05PVVNcIixcbiAgICBcIk1PRElGSUNBVElPTlwiLFxuICAgIFwiTU9VU0VET1dOXCIsXG4gICAgXCJNT1VTRURSQUdcIixcbiAgICBcIk1PVVNFTU9WRVwiLFxuICAgIFwiTU9VU0VPVVRcIixcbiAgICBcIk1PVVNFT1ZFUlwiLFxuICAgIFwiTU9VU0VVUFwiLFxuICAgIFwiTU9aX0tFWUZSQU1FU19SVUxFXCIsXG4gICAgXCJNT1pfS0VZRlJBTUVfUlVMRVwiLFxuICAgIFwiTU9aX1NPVVJDRV9DVVJTT1JcIixcbiAgICBcIk1PWl9TT1VSQ0VfRVJBU0VSXCIsXG4gICAgXCJNT1pfU09VUkNFX0tFWUJPQVJEXCIsXG4gICAgXCJNT1pfU09VUkNFX01PVVNFXCIsXG4gICAgXCJNT1pfU09VUkNFX1BFTlwiLFxuICAgIFwiTU9aX1NPVVJDRV9UT1VDSFwiLFxuICAgIFwiTU9aX1NPVVJDRV9VTktOT1dOXCIsXG4gICAgXCJNU0dFU1RVUkVfRkxBR19CRUdJTlwiLFxuICAgIFwiTVNHRVNUVVJFX0ZMQUdfQ0FOQ0VMXCIsXG4gICAgXCJNU0dFU1RVUkVfRkxBR19FTkRcIixcbiAgICBcIk1TR0VTVFVSRV9GTEFHX0lORVJUSUFcIixcbiAgICBcIk1TR0VTVFVSRV9GTEFHX05PTkVcIixcbiAgICBcIk1TUE9JTlRFUl9UWVBFX01PVVNFXCIsXG4gICAgXCJNU1BPSU5URVJfVFlQRV9QRU5cIixcbiAgICBcIk1TUE9JTlRFUl9UWVBFX1RPVUNIXCIsXG4gICAgXCJNU19BU1lOQ19DQUxMQkFDS19TVEFUVVNfQVNTSUdOX0RFTEVHQVRFXCIsXG4gICAgXCJNU19BU1lOQ19DQUxMQkFDS19TVEFUVVNfQ0FOQ0VMXCIsXG4gICAgXCJNU19BU1lOQ19DQUxMQkFDS19TVEFUVVNfQ0hPT1NFQU5ZXCIsXG4gICAgXCJNU19BU1lOQ19DQUxMQkFDS19TVEFUVVNfRVJST1JcIixcbiAgICBcIk1TX0FTWU5DX0NBTExCQUNLX1NUQVRVU19KT0lOXCIsXG4gICAgXCJNU19BU1lOQ19PUF9TVEFUVVNfQ0FOQ0VMRURcIixcbiAgICBcIk1TX0FTWU5DX09QX1NUQVRVU19FUlJPUlwiLFxuICAgIFwiTVNfQVNZTkNfT1BfU1RBVFVTX1NVQ0NFU1NcIixcbiAgICBcIk1TX01BTklQVUxBVElPTl9TVEFURV9BQ1RJVkVcIixcbiAgICBcIk1TX01BTklQVUxBVElPTl9TVEFURV9DQU5DRUxMRURcIixcbiAgICBcIk1TX01BTklQVUxBVElPTl9TVEFURV9DT01NSVRURURcIixcbiAgICBcIk1TX01BTklQVUxBVElPTl9TVEFURV9EUkFHR0lOR1wiLFxuICAgIFwiTVNfTUFOSVBVTEFUSU9OX1NUQVRFX0lORVJUSUFcIixcbiAgICBcIk1TX01BTklQVUxBVElPTl9TVEFURV9QUkVTRUxFQ1RcIixcbiAgICBcIk1TX01BTklQVUxBVElPTl9TVEFURV9TRUxFQ1RJTkdcIixcbiAgICBcIk1TX01BTklQVUxBVElPTl9TVEFURV9TVE9QUEVEXCIsXG4gICAgXCJNU19NRURJQV9FUlJfRU5DUllQVEVEXCIsXG4gICAgXCJNU19NRURJQV9LRVlFUlJfQ0xJRU5UXCIsXG4gICAgXCJNU19NRURJQV9LRVlFUlJfRE9NQUlOXCIsXG4gICAgXCJNU19NRURJQV9LRVlFUlJfSEFSRFdBUkVDSEFOR0VcIixcbiAgICBcIk1TX01FRElBX0tFWUVSUl9PVVRQVVRcIixcbiAgICBcIk1TX01FRElBX0tFWUVSUl9TRVJWSUNFXCIsXG4gICAgXCJNU19NRURJQV9LRVlFUlJfVU5LTk9XTlwiLFxuICAgIFwiTWFwXCIsXG4gICAgXCJNYXRoXCIsXG4gICAgXCJNYXRoTUxFbGVtZW50XCIsXG4gICAgXCJNZWRpYUNhcGFiaWxpdGllc1wiLFxuICAgIFwiTWVkaWFDYXBhYmlsaXRpZXNJbmZvXCIsXG4gICAgXCJNZWRpYUNvbnRyb2xsZXJcIixcbiAgICBcIk1lZGlhRGV2aWNlSW5mb1wiLFxuICAgIFwiTWVkaWFEZXZpY2VzXCIsXG4gICAgXCJNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGVcIixcbiAgICBcIk1lZGlhRW5jcnlwdGVkRXZlbnRcIixcbiAgICBcIk1lZGlhRXJyb3JcIixcbiAgICBcIk1lZGlhS2V5RXJyb3JcIixcbiAgICBcIk1lZGlhS2V5RXZlbnRcIixcbiAgICBcIk1lZGlhS2V5TWVzc2FnZUV2ZW50XCIsXG4gICAgXCJNZWRpYUtleU5lZWRlZEV2ZW50XCIsXG4gICAgXCJNZWRpYUtleVNlc3Npb25cIixcbiAgICBcIk1lZGlhS2V5U3RhdHVzTWFwXCIsXG4gICAgXCJNZWRpYUtleVN5c3RlbUFjY2Vzc1wiLFxuICAgIFwiTWVkaWFLZXlzXCIsXG4gICAgXCJNZWRpYUxpc3RcIixcbiAgICBcIk1lZGlhTWV0YWRhdGFcIixcbiAgICBcIk1lZGlhUXVlcnlMaXN0XCIsXG4gICAgXCJNZWRpYVF1ZXJ5TGlzdEV2ZW50XCIsXG4gICAgXCJNZWRpYVJlY29yZGVyXCIsXG4gICAgXCJNZWRpYVJlY29yZGVyRXJyb3JFdmVudFwiLFxuICAgIFwiTWVkaWFTZXNzaW9uXCIsXG4gICAgXCJNZWRpYVNldHRpbmdzUmFuZ2VcIixcbiAgICBcIk1lZGlhU291cmNlXCIsXG4gICAgXCJNZWRpYVN0cmVhbVwiLFxuICAgIFwiTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZVwiLFxuICAgIFwiTWVkaWFTdHJlYW1BdWRpb1NvdXJjZU5vZGVcIixcbiAgICBcIk1lZGlhU3RyZWFtRXZlbnRcIixcbiAgICBcIk1lZGlhU3RyZWFtVHJhY2tcIixcbiAgICBcIk1lZGlhU3RyZWFtVHJhY2tBdWRpb1NvdXJjZU5vZGVcIixcbiAgICBcIk1lZGlhU3RyZWFtVHJhY2tFdmVudFwiLFxuICAgIFwiTWVtb3J5XCIsXG4gICAgXCJNZXNzYWdlQ2hhbm5lbFwiLFxuICAgIFwiTWVzc2FnZUV2ZW50XCIsXG4gICAgXCJNZXNzYWdlUG9ydFwiLFxuICAgIFwiTWV0aG9kc1wiLFxuICAgIFwiTWltZVR5cGVcIixcbiAgICBcIk1pbWVUeXBlQXJyYXlcIixcbiAgICBcIk1vZHVsZVwiLFxuICAgIFwiTW91c2VFdmVudFwiLFxuICAgIFwiTW91c2VTY3JvbGxFdmVudFwiLFxuICAgIFwiTW96QW5pbWF0aW9uXCIsXG4gICAgXCJNb3pBbmltYXRpb25EZWxheVwiLFxuICAgIFwiTW96QW5pbWF0aW9uRGlyZWN0aW9uXCIsXG4gICAgXCJNb3pBbmltYXRpb25EdXJhdGlvblwiLFxuICAgIFwiTW96QW5pbWF0aW9uRmlsbE1vZGVcIixcbiAgICBcIk1vekFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCIsXG4gICAgXCJNb3pBbmltYXRpb25OYW1lXCIsXG4gICAgXCJNb3pBbmltYXRpb25QbGF5U3RhdGVcIixcbiAgICBcIk1vekFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uXCIsXG4gICAgXCJNb3pBcHBlYXJhbmNlXCIsXG4gICAgXCJNb3pCYWNrZmFjZVZpc2liaWxpdHlcIixcbiAgICBcIk1vekJpbmRpbmdcIixcbiAgICBcIk1vekJvcmRlckJvdHRvbUNvbG9yc1wiLFxuICAgIFwiTW96Qm9yZGVyRW5kXCIsXG4gICAgXCJNb3pCb3JkZXJFbmRDb2xvclwiLFxuICAgIFwiTW96Qm9yZGVyRW5kU3R5bGVcIixcbiAgICBcIk1vekJvcmRlckVuZFdpZHRoXCIsXG4gICAgXCJNb3pCb3JkZXJJbWFnZVwiLFxuICAgIFwiTW96Qm9yZGVyTGVmdENvbG9yc1wiLFxuICAgIFwiTW96Qm9yZGVyUmlnaHRDb2xvcnNcIixcbiAgICBcIk1vekJvcmRlclN0YXJ0XCIsXG4gICAgXCJNb3pCb3JkZXJTdGFydENvbG9yXCIsXG4gICAgXCJNb3pCb3JkZXJTdGFydFN0eWxlXCIsXG4gICAgXCJNb3pCb3JkZXJTdGFydFdpZHRoXCIsXG4gICAgXCJNb3pCb3JkZXJUb3BDb2xvcnNcIixcbiAgICBcIk1vekJveEFsaWduXCIsXG4gICAgXCJNb3pCb3hEaXJlY3Rpb25cIixcbiAgICBcIk1vekJveEZsZXhcIixcbiAgICBcIk1vekJveE9yZGluYWxHcm91cFwiLFxuICAgIFwiTW96Qm94T3JpZW50XCIsXG4gICAgXCJNb3pCb3hQYWNrXCIsXG4gICAgXCJNb3pCb3hTaXppbmdcIixcbiAgICBcIk1vekNTU0tleWZyYW1lUnVsZVwiLFxuICAgIFwiTW96Q1NTS2V5ZnJhbWVzUnVsZVwiLFxuICAgIFwiTW96Q29sdW1uQ291bnRcIixcbiAgICBcIk1vekNvbHVtbkZpbGxcIixcbiAgICBcIk1vekNvbHVtbkdhcFwiLFxuICAgIFwiTW96Q29sdW1uUnVsZVwiLFxuICAgIFwiTW96Q29sdW1uUnVsZUNvbG9yXCIsXG4gICAgXCJNb3pDb2x1bW5SdWxlU3R5bGVcIixcbiAgICBcIk1vekNvbHVtblJ1bGVXaWR0aFwiLFxuICAgIFwiTW96Q29sdW1uV2lkdGhcIixcbiAgICBcIk1vekNvbHVtbnNcIixcbiAgICBcIk1vekNvbnRhY3RDaGFuZ2VFdmVudFwiLFxuICAgIFwiTW96RmxvYXRFZGdlXCIsXG4gICAgXCJNb3pGb250RmVhdHVyZVNldHRpbmdzXCIsXG4gICAgXCJNb3pGb250TGFuZ3VhZ2VPdmVycmlkZVwiLFxuICAgIFwiTW96Rm9yY2VCcm9rZW5JbWFnZUljb25cIixcbiAgICBcIk1vekh5cGhlbnNcIixcbiAgICBcIk1vekltYWdlUmVnaW9uXCIsXG4gICAgXCJNb3pNYXJnaW5FbmRcIixcbiAgICBcIk1vek1hcmdpblN0YXJ0XCIsXG4gICAgXCJNb3pNbXNFdmVudFwiLFxuICAgIFwiTW96TW1zTWVzc2FnZVwiLFxuICAgIFwiTW96TW9iaWxlTWVzc2FnZVRocmVhZFwiLFxuICAgIFwiTW96T1NYRm9udFNtb290aGluZ1wiLFxuICAgIFwiTW96T3JpZW50XCIsXG4gICAgXCJNb3pPc3hGb250U21vb3RoaW5nXCIsXG4gICAgXCJNb3pPdXRsaW5lUmFkaXVzXCIsXG4gICAgXCJNb3pPdXRsaW5lUmFkaXVzQm90dG9tbGVmdFwiLFxuICAgIFwiTW96T3V0bGluZVJhZGl1c0JvdHRvbXJpZ2h0XCIsXG4gICAgXCJNb3pPdXRsaW5lUmFkaXVzVG9wbGVmdFwiLFxuICAgIFwiTW96T3V0bGluZVJhZGl1c1RvcHJpZ2h0XCIsXG4gICAgXCJNb3pQYWRkaW5nRW5kXCIsXG4gICAgXCJNb3pQYWRkaW5nU3RhcnRcIixcbiAgICBcIk1velBlcnNwZWN0aXZlXCIsXG4gICAgXCJNb3pQZXJzcGVjdGl2ZU9yaWdpblwiLFxuICAgIFwiTW96UG93ZXJNYW5hZ2VyXCIsXG4gICAgXCJNb3pTZXR0aW5nc0V2ZW50XCIsXG4gICAgXCJNb3pTbXNFdmVudFwiLFxuICAgIFwiTW96U21zTWVzc2FnZVwiLFxuICAgIFwiTW96U3RhY2tTaXppbmdcIixcbiAgICBcIk1velRhYlNpemVcIixcbiAgICBcIk1velRleHRBbGlnbkxhc3RcIixcbiAgICBcIk1velRleHREZWNvcmF0aW9uQ29sb3JcIixcbiAgICBcIk1velRleHREZWNvcmF0aW9uTGluZVwiLFxuICAgIFwiTW96VGV4dERlY29yYXRpb25TdHlsZVwiLFxuICAgIFwiTW96VGV4dFNpemVBZGp1c3RcIixcbiAgICBcIk1velRyYW5zZm9ybVwiLFxuICAgIFwiTW96VHJhbnNmb3JtT3JpZ2luXCIsXG4gICAgXCJNb3pUcmFuc2Zvcm1TdHlsZVwiLFxuICAgIFwiTW96VHJhbnNpdGlvblwiLFxuICAgIFwiTW96VHJhbnNpdGlvbkRlbGF5XCIsXG4gICAgXCJNb3pUcmFuc2l0aW9uRHVyYXRpb25cIixcbiAgICBcIk1velRyYW5zaXRpb25Qcm9wZXJ0eVwiLFxuICAgIFwiTW96VHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXCIsXG4gICAgXCJNb3pVc2VyRm9jdXNcIixcbiAgICBcIk1velVzZXJJbnB1dFwiLFxuICAgIFwiTW96VXNlck1vZGlmeVwiLFxuICAgIFwiTW96VXNlclNlbGVjdFwiLFxuICAgIFwiTW96V2luZG93RHJhZ2dpbmdcIixcbiAgICBcIk1veldpbmRvd1NoYWRvd1wiLFxuICAgIFwiTXV0YXRpb25FdmVudFwiLFxuICAgIFwiTXV0YXRpb25PYnNlcnZlclwiLFxuICAgIFwiTXV0YXRpb25SZWNvcmRcIixcbiAgICBcIk5BTUVTUEFDRV9FUlJcIixcbiAgICBcIk5BTUVTUEFDRV9SVUxFXCIsXG4gICAgXCJORUFSRVNUXCIsXG4gICAgXCJORUFSRVNUX01JUE1BUF9MSU5FQVJcIixcbiAgICBcIk5FQVJFU1RfTUlQTUFQX05FQVJFU1RcIixcbiAgICBcIk5FR0FUSVZFX0lORklOSVRZXCIsXG4gICAgXCJORVRXT1JLX0VNUFRZXCIsXG4gICAgXCJORVRXT1JLX0VSUlwiLFxuICAgIFwiTkVUV09SS19JRExFXCIsXG4gICAgXCJORVRXT1JLX0xPQURFRFwiLFxuICAgIFwiTkVUV09SS19MT0FESU5HXCIsXG4gICAgXCJORVRXT1JLX05PX1NPVVJDRVwiLFxuICAgIFwiTkVWRVJcIixcbiAgICBcIk5FV1wiLFxuICAgIFwiTkVYVFwiLFxuICAgIFwiTkVYVF9OT19EVVBMSUNBVEVcIixcbiAgICBcIk5JQ0VTVFwiLFxuICAgIFwiTk9ERV9BRlRFUlwiLFxuICAgIFwiTk9ERV9CRUZPUkVcIixcbiAgICBcIk5PREVfQkVGT1JFX0FORF9BRlRFUlwiLFxuICAgIFwiTk9ERV9JTlNJREVcIixcbiAgICBcIk5PTkVcIixcbiAgICBcIk5PTl9UUkFOU0lFTlRfRVJSXCIsXG4gICAgXCJOT1RBVElPTl9OT0RFXCIsXG4gICAgXCJOT1RDSFwiLFxuICAgIFwiTk9URVFVQUxcIixcbiAgICBcIk5PVF9BTExPV0VEX0VSUlwiLFxuICAgIFwiTk9UX0ZPVU5EX0VSUlwiLFxuICAgIFwiTk9UX1JFQURBQkxFX0VSUlwiLFxuICAgIFwiTk9UX1NVUFBPUlRFRF9FUlJcIixcbiAgICBcIk5PX0RBVEFfQUxMT1dFRF9FUlJcIixcbiAgICBcIk5PX0VSUlwiLFxuICAgIFwiTk9fRVJST1JcIixcbiAgICBcIk5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUlwiLFxuICAgIFwiTlVNQkVSX1RZUEVcIixcbiAgICBcIk5VTV9DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUU1wiLFxuICAgIFwiTmFOXCIsXG4gICAgXCJOYW1lZE5vZGVNYXBcIixcbiAgICBcIk5hdmlnYXRpb25QcmVsb2FkTWFuYWdlclwiLFxuICAgIFwiTmF2aWdhdG9yXCIsXG4gICAgXCJOZWFyYnlMaW5rc1wiLFxuICAgIFwiTmV0d29ya0luZm9ybWF0aW9uXCIsXG4gICAgXCJOb2RlXCIsXG4gICAgXCJOb2RlRmlsdGVyXCIsXG4gICAgXCJOb2RlSXRlcmF0b3JcIixcbiAgICBcIk5vZGVMaXN0XCIsXG4gICAgXCJOb3RhdGlvblwiLFxuICAgIFwiTm90aWZpY2F0aW9uXCIsXG4gICAgXCJOb3RpZnlQYWludEV2ZW50XCIsXG4gICAgXCJOdW1iZXJcIixcbiAgICBcIk51bWJlckZvcm1hdFwiLFxuICAgIFwiT0JKRUNUX1RZUEVcIixcbiAgICBcIk9CU09MRVRFXCIsXG4gICAgXCJPS1wiLFxuICAgIFwiT05FXCIsXG4gICAgXCJPTkVfTUlOVVNfQ09OU1RBTlRfQUxQSEFcIixcbiAgICBcIk9ORV9NSU5VU19DT05TVEFOVF9DT0xPUlwiLFxuICAgIFwiT05FX01JTlVTX0RTVF9BTFBIQVwiLFxuICAgIFwiT05FX01JTlVTX0RTVF9DT0xPUlwiLFxuICAgIFwiT05FX01JTlVTX1NSQ19BTFBIQVwiLFxuICAgIFwiT05FX01JTlVTX1NSQ19DT0xPUlwiLFxuICAgIFwiT1BFTlwiLFxuICAgIFwiT1BFTkVEXCIsXG4gICAgXCJPUEVOSU5HXCIsXG4gICAgXCJPUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRVwiLFxuICAgIFwiT1JERVJFRF9OT0RFX1NOQVBTSE9UX1RZUEVcIixcbiAgICBcIk9USEVSX0VSUk9SXCIsXG4gICAgXCJPVVRfT0ZfTUVNT1JZXCIsXG4gICAgXCJPYmplY3RcIixcbiAgICBcIk9mZmxpbmVBdWRpb0NvbXBsZXRpb25FdmVudFwiLFxuICAgIFwiT2ZmbGluZUF1ZGlvQ29udGV4dFwiLFxuICAgIFwiT2ZmbGluZVJlc291cmNlTGlzdFwiLFxuICAgIFwiT2Zmc2NyZWVuQ2FudmFzXCIsXG4gICAgXCJPZmZzY3JlZW5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcIixcbiAgICBcIk9wdGlvblwiLFxuICAgIFwiT3JpZW50YXRpb25TZW5zb3JcIixcbiAgICBcIk9zY2lsbGF0b3JOb2RlXCIsXG4gICAgXCJPdmVyY29uc3RyYWluZWRFcnJvclwiLFxuICAgIFwiT3ZlcmZsb3dFdmVudFwiLFxuICAgIFwiUEFDS19BTElHTk1FTlRcIixcbiAgICBcIlBBQ0tfUk9XX0xFTkdUSFwiLFxuICAgIFwiUEFDS19TS0lQX1BJWEVMU1wiLFxuICAgIFwiUEFDS19TS0lQX1JPV1NcIixcbiAgICBcIlBBR0VfUlVMRVwiLFxuICAgIFwiUEFSU0VfRVJSXCIsXG4gICAgXCJQQVRIU0VHX0FSQ19BQlNcIixcbiAgICBcIlBBVEhTRUdfQVJDX1JFTFwiLFxuICAgIFwiUEFUSFNFR19DTE9TRVBBVEhcIixcbiAgICBcIlBBVEhTRUdfQ1VSVkVUT19DVUJJQ19BQlNcIixcbiAgICBcIlBBVEhTRUdfQ1VSVkVUT19DVUJJQ19SRUxcIixcbiAgICBcIlBBVEhTRUdfQ1VSVkVUT19DVUJJQ19TTU9PVEhfQUJTXCIsXG4gICAgXCJQQVRIU0VHX0NVUlZFVE9fQ1VCSUNfU01PT1RIX1JFTFwiLFxuICAgIFwiUEFUSFNFR19DVVJWRVRPX1FVQURSQVRJQ19BQlNcIixcbiAgICBcIlBBVEhTRUdfQ1VSVkVUT19RVUFEUkFUSUNfUkVMXCIsXG4gICAgXCJQQVRIU0VHX0NVUlZFVE9fUVVBRFJBVElDX1NNT09USF9BQlNcIixcbiAgICBcIlBBVEhTRUdfQ1VSVkVUT19RVUFEUkFUSUNfU01PT1RIX1JFTFwiLFxuICAgIFwiUEFUSFNFR19MSU5FVE9fQUJTXCIsXG4gICAgXCJQQVRIU0VHX0xJTkVUT19IT1JJWk9OVEFMX0FCU1wiLFxuICAgIFwiUEFUSFNFR19MSU5FVE9fSE9SSVpPTlRBTF9SRUxcIixcbiAgICBcIlBBVEhTRUdfTElORVRPX1JFTFwiLFxuICAgIFwiUEFUSFNFR19MSU5FVE9fVkVSVElDQUxfQUJTXCIsXG4gICAgXCJQQVRIU0VHX0xJTkVUT19WRVJUSUNBTF9SRUxcIixcbiAgICBcIlBBVEhTRUdfTU9WRVRPX0FCU1wiLFxuICAgIFwiUEFUSFNFR19NT1ZFVE9fUkVMXCIsXG4gICAgXCJQQVRIU0VHX1VOS05PV05cIixcbiAgICBcIlBBVEhfRVhJU1RTX0VSUlwiLFxuICAgIFwiUEVBS0lOR1wiLFxuICAgIFwiUEVSTUlTU0lPTl9ERU5JRURcIixcbiAgICBcIlBFUlNJU1RFTlRcIixcbiAgICBcIlBJXCIsXG4gICAgXCJQSVhFTF9QQUNLX0JVRkZFUlwiLFxuICAgIFwiUElYRUxfUEFDS19CVUZGRVJfQklORElOR1wiLFxuICAgIFwiUElYRUxfVU5QQUNLX0JVRkZFUlwiLFxuICAgIFwiUElYRUxfVU5QQUNLX0JVRkZFUl9CSU5ESU5HXCIsXG4gICAgXCJQTEFZSU5HX1NUQVRFXCIsXG4gICAgXCJQT0lOVFNcIixcbiAgICBcIlBPTFlHT05fT0ZGU0VUX0ZBQ1RPUlwiLFxuICAgIFwiUE9MWUdPTl9PRkZTRVRfRklMTFwiLFxuICAgIFwiUE9MWUdPTl9PRkZTRVRfVU5JVFNcIixcbiAgICBcIlBPU0lUSU9OX1VOQVZBSUxBQkxFXCIsXG4gICAgXCJQT1NJVElWRV9JTkZJTklUWVwiLFxuICAgIFwiUFJFVlwiLFxuICAgIFwiUFJFVl9OT19EVVBMSUNBVEVcIixcbiAgICBcIlBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERVwiLFxuICAgIFwiUGFnZUNoYW5nZUV2ZW50XCIsXG4gICAgXCJQYWdlVHJhbnNpdGlvbkV2ZW50XCIsXG4gICAgXCJQYWludFJlcXVlc3RcIixcbiAgICBcIlBhaW50UmVxdWVzdExpc3RcIixcbiAgICBcIlBhbm5lck5vZGVcIixcbiAgICBcIlBhc3N3b3JkQ3JlZGVudGlhbFwiLFxuICAgIFwiUGF0aDJEXCIsXG4gICAgXCJQYXltZW50QWRkcmVzc1wiLFxuICAgIFwiUGF5bWVudEluc3RydW1lbnRzXCIsXG4gICAgXCJQYXltZW50TWFuYWdlclwiLFxuICAgIFwiUGF5bWVudE1ldGhvZENoYW5nZUV2ZW50XCIsXG4gICAgXCJQYXltZW50UmVxdWVzdFwiLFxuICAgIFwiUGF5bWVudFJlcXVlc3RVcGRhdGVFdmVudFwiLFxuICAgIFwiUGF5bWVudFJlc3BvbnNlXCIsXG4gICAgXCJQZXJmb3JtYW5jZVwiLFxuICAgIFwiUGVyZm9ybWFuY2VFbGVtZW50VGltaW5nXCIsXG4gICAgXCJQZXJmb3JtYW5jZUVudHJ5XCIsXG4gICAgXCJQZXJmb3JtYW5jZUV2ZW50VGltaW5nXCIsXG4gICAgXCJQZXJmb3JtYW5jZUxvbmdUYXNrVGltaW5nXCIsXG4gICAgXCJQZXJmb3JtYW5jZU1hcmtcIixcbiAgICBcIlBlcmZvcm1hbmNlTWVhc3VyZVwiLFxuICAgIFwiUGVyZm9ybWFuY2VOYXZpZ2F0aW9uXCIsXG4gICAgXCJQZXJmb3JtYW5jZU5hdmlnYXRpb25UaW1pbmdcIixcbiAgICBcIlBlcmZvcm1hbmNlT2JzZXJ2ZXJcIixcbiAgICBcIlBlcmZvcm1hbmNlT2JzZXJ2ZXJFbnRyeUxpc3RcIixcbiAgICBcIlBlcmZvcm1hbmNlUGFpbnRUaW1pbmdcIixcbiAgICBcIlBlcmZvcm1hbmNlUmVzb3VyY2VUaW1pbmdcIixcbiAgICBcIlBlcmZvcm1hbmNlU2VydmVyVGltaW5nXCIsXG4gICAgXCJQZXJmb3JtYW5jZVRpbWluZ1wiLFxuICAgIFwiUGVyaW9kaWNTeW5jTWFuYWdlclwiLFxuICAgIFwiUGVyaW9kaWNXYXZlXCIsXG4gICAgXCJQZXJtaXNzaW9uU3RhdHVzXCIsXG4gICAgXCJQZXJtaXNzaW9uc1wiLFxuICAgIFwiUGhvdG9DYXBhYmlsaXRpZXNcIixcbiAgICBcIlBpY3R1cmVJblBpY3R1cmVXaW5kb3dcIixcbiAgICBcIlBsdWdpblwiLFxuICAgIFwiUGx1Z2luQXJyYXlcIixcbiAgICBcIlBsdXJhbFJ1bGVzXCIsXG4gICAgXCJQb2ludGVyRXZlbnRcIixcbiAgICBcIlBvcFN0YXRlRXZlbnRcIixcbiAgICBcIlBvcHVwQmxvY2tlZEV2ZW50XCIsXG4gICAgXCJQcmVzZW50YXRpb25cIixcbiAgICBcIlByZXNlbnRhdGlvbkF2YWlsYWJpbGl0eVwiLFxuICAgIFwiUHJlc2VudGF0aW9uQ29ubmVjdGlvblwiLFxuICAgIFwiUHJlc2VudGF0aW9uQ29ubmVjdGlvbkF2YWlsYWJsZUV2ZW50XCIsXG4gICAgXCJQcmVzZW50YXRpb25Db25uZWN0aW9uQ2xvc2VFdmVudFwiLFxuICAgIFwiUHJlc2VudGF0aW9uQ29ubmVjdGlvbkxpc3RcIixcbiAgICBcIlByZXNlbnRhdGlvblJlY2VpdmVyXCIsXG4gICAgXCJQcmVzZW50YXRpb25SZXF1ZXN0XCIsXG4gICAgXCJQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cIixcbiAgICBcIlByb2dyZXNzRXZlbnRcIixcbiAgICBcIlByb21pc2VcIixcbiAgICBcIlByb21pc2VSZWplY3Rpb25FdmVudFwiLFxuICAgIFwiUHJvcGVydHlOb2RlTGlzdFwiLFxuICAgIFwiUHJveHlcIixcbiAgICBcIlB1YmxpY0tleUNyZWRlbnRpYWxcIixcbiAgICBcIlB1c2hNYW5hZ2VyXCIsXG4gICAgXCJQdXNoU3Vic2NyaXB0aW9uXCIsXG4gICAgXCJQdXNoU3Vic2NyaXB0aW9uT3B0aW9uc1wiLFxuICAgIFwiUVwiLFxuICAgIFwiUVVFUllfUkVTVUxUXCIsXG4gICAgXCJRVUVSWV9SRVNVTFRfQVZBSUxBQkxFXCIsXG4gICAgXCJRVU9UQV9FUlJcIixcbiAgICBcIlFVT1RBX0VYQ0VFREVEX0VSUlwiLFxuICAgIFwiUXVlcnlJbnRlcmZhY2VcIixcbiAgICBcIlIxMUZfRzExRl9CMTBGXCIsXG4gICAgXCJSMTZGXCIsXG4gICAgXCJSMTZJXCIsXG4gICAgXCJSMTZVSVwiLFxuICAgIFwiUjMyRlwiLFxuICAgIFwiUjMySVwiLFxuICAgIFwiUjMyVUlcIixcbiAgICBcIlI4XCIsXG4gICAgXCJSOElcIixcbiAgICBcIlI4VUlcIixcbiAgICBcIlI4X1NOT1JNXCIsXG4gICAgXCJSQVNURVJJWkVSX0RJU0NBUkRcIixcbiAgICBcIlJFQURfQlVGRkVSXCIsXG4gICAgXCJSRUFEX0ZSQU1FQlVGRkVSXCIsXG4gICAgXCJSRUFEX0ZSQU1FQlVGRkVSX0JJTkRJTkdcIixcbiAgICBcIlJFQURfT05MWVwiLFxuICAgIFwiUkVBRF9PTkxZX0VSUlwiLFxuICAgIFwiUkVBRF9XUklURVwiLFxuICAgIFwiUkVEXCIsXG4gICAgXCJSRURfQklUU1wiLFxuICAgIFwiUkVEX0lOVEVHRVJcIixcbiAgICBcIlJFTU9WQUxcIixcbiAgICBcIlJFTkRFUkJVRkZFUlwiLFxuICAgIFwiUkVOREVSQlVGRkVSX0FMUEhBX1NJWkVcIixcbiAgICBcIlJFTkRFUkJVRkZFUl9CSU5ESU5HXCIsXG4gICAgXCJSRU5ERVJCVUZGRVJfQkxVRV9TSVpFXCIsXG4gICAgXCJSRU5ERVJCVUZGRVJfREVQVEhfU0laRVwiLFxuICAgIFwiUkVOREVSQlVGRkVSX0dSRUVOX1NJWkVcIixcbiAgICBcIlJFTkRFUkJVRkZFUl9IRUlHSFRcIixcbiAgICBcIlJFTkRFUkJVRkZFUl9JTlRFUk5BTF9GT1JNQVRcIixcbiAgICBcIlJFTkRFUkJVRkZFUl9SRURfU0laRVwiLFxuICAgIFwiUkVOREVSQlVGRkVSX1NBTVBMRVNcIixcbiAgICBcIlJFTkRFUkJVRkZFUl9TVEVOQ0lMX1NJWkVcIixcbiAgICBcIlJFTkRFUkJVRkZFUl9XSURUSFwiLFxuICAgIFwiUkVOREVSRVJcIixcbiAgICBcIlJFTkRFUklOR19JTlRFTlRfQUJTT0xVVEVfQ09MT1JJTUVUUklDXCIsXG4gICAgXCJSRU5ERVJJTkdfSU5URU5UX0FVVE9cIixcbiAgICBcIlJFTkRFUklOR19JTlRFTlRfUEVSQ0VQVFVBTFwiLFxuICAgIFwiUkVOREVSSU5HX0lOVEVOVF9SRUxBVElWRV9DT0xPUklNRVRSSUNcIixcbiAgICBcIlJFTkRFUklOR19JTlRFTlRfU0FUVVJBVElPTlwiLFxuICAgIFwiUkVOREVSSU5HX0lOVEVOVF9VTktOT1dOXCIsXG4gICAgXCJSRVBFQVRcIixcbiAgICBcIlJFUExBQ0VcIixcbiAgICBcIlJHXCIsXG4gICAgXCJSRzE2RlwiLFxuICAgIFwiUkcxNklcIixcbiAgICBcIlJHMTZVSVwiLFxuICAgIFwiUkczMkZcIixcbiAgICBcIlJHMzJJXCIsXG4gICAgXCJSRzMyVUlcIixcbiAgICBcIlJHOFwiLFxuICAgIFwiUkc4SVwiLFxuICAgIFwiUkc4VUlcIixcbiAgICBcIlJHOF9TTk9STVwiLFxuICAgIFwiUkdCXCIsXG4gICAgXCJSR0IxMF9BMlwiLFxuICAgIFwiUkdCMTBfQTJVSVwiLFxuICAgIFwiUkdCMTZGXCIsXG4gICAgXCJSR0IxNklcIixcbiAgICBcIlJHQjE2VUlcIixcbiAgICBcIlJHQjMyRlwiLFxuICAgIFwiUkdCMzJJXCIsXG4gICAgXCJSR0IzMlVJXCIsXG4gICAgXCJSR0I1NjVcIixcbiAgICBcIlJHQjVfQTFcIixcbiAgICBcIlJHQjhcIixcbiAgICBcIlJHQjhJXCIsXG4gICAgXCJSR0I4VUlcIixcbiAgICBcIlJHQjhfU05PUk1cIixcbiAgICBcIlJHQjlfRTVcIixcbiAgICBcIlJHQkFcIixcbiAgICBcIlJHQkExNkZcIixcbiAgICBcIlJHQkExNklcIixcbiAgICBcIlJHQkExNlVJXCIsXG4gICAgXCJSR0JBMzJGXCIsXG4gICAgXCJSR0JBMzJJXCIsXG4gICAgXCJSR0JBMzJVSVwiLFxuICAgIFwiUkdCQTRcIixcbiAgICBcIlJHQkE4XCIsXG4gICAgXCJSR0JBOElcIixcbiAgICBcIlJHQkE4VUlcIixcbiAgICBcIlJHQkE4X1NOT1JNXCIsXG4gICAgXCJSR0JBX0lOVEVHRVJcIixcbiAgICBcIlJHQkNvbG9yXCIsXG4gICAgXCJSR0JfSU5URUdFUlwiLFxuICAgIFwiUkdfSU5URUdFUlwiLFxuICAgIFwiUk9UQVRJT05fQ0xPQ0tXSVNFXCIsXG4gICAgXCJST1RBVElPTl9DT1VOVEVSQ0xPQ0tXSVNFXCIsXG4gICAgXCJSVENDZXJ0aWZpY2F0ZVwiLFxuICAgIFwiUlRDRFRNRlNlbmRlclwiLFxuICAgIFwiUlRDRFRNRlRvbmVDaGFuZ2VFdmVudFwiLFxuICAgIFwiUlRDRGF0YUNoYW5uZWxcIixcbiAgICBcIlJUQ0RhdGFDaGFubmVsRXZlbnRcIixcbiAgICBcIlJUQ0R0bHNUcmFuc3BvcnRcIixcbiAgICBcIlJUQ0Vycm9yXCIsXG4gICAgXCJSVENFcnJvckV2ZW50XCIsXG4gICAgXCJSVENJY2VDYW5kaWRhdGVcIixcbiAgICBcIlJUQ0ljZVRyYW5zcG9ydFwiLFxuICAgIFwiUlRDUGVlckNvbm5lY3Rpb25cIixcbiAgICBcIlJUQ1BlZXJDb25uZWN0aW9uSWNlRXJyb3JFdmVudFwiLFxuICAgIFwiUlRDUGVlckNvbm5lY3Rpb25JY2VFdmVudFwiLFxuICAgIFwiUlRDUnRwUmVjZWl2ZXJcIixcbiAgICBcIlJUQ1J0cFNlbmRlclwiLFxuICAgIFwiUlRDUnRwVHJhbnNjZWl2ZXJcIixcbiAgICBcIlJUQ1NjdHBUcmFuc3BvcnRcIixcbiAgICBcIlJUQ1Nlc3Npb25EZXNjcmlwdGlvblwiLFxuICAgIFwiUlRDU3RhdHNSZXBvcnRcIixcbiAgICBcIlJUQ1RyYWNrRXZlbnRcIixcbiAgICBcIlJhZGlvTm9kZUxpc3RcIixcbiAgICBcIlJhbmdlXCIsXG4gICAgXCJSYW5nZUVycm9yXCIsXG4gICAgXCJSYW5nZUV4Y2VwdGlvblwiLFxuICAgIFwiUmVhZGFibGVTdHJlYW1cIixcbiAgICBcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclwiLFxuICAgIFwiUmVjb3JkRXJyb3JFdmVudFwiLFxuICAgIFwiUmVjdFwiLFxuICAgIFwiUmVmZXJlbmNlRXJyb3JcIixcbiAgICBcIlJlZmxlY3RcIixcbiAgICBcIlJlZ0V4cFwiLFxuICAgIFwiUmVsYXRpdmVPcmllbnRhdGlvblNlbnNvclwiLFxuICAgIFwiUmVsYXRpdmVUaW1lRm9ybWF0XCIsXG4gICAgXCJSZW1vdGVQbGF5YmFja1wiLFxuICAgIFwiUmVwb3J0XCIsXG4gICAgXCJSZXBvcnRCb2R5XCIsXG4gICAgXCJSZXBvcnRpbmdPYnNlcnZlclwiLFxuICAgIFwiUmVxdWVzdFwiLFxuICAgIFwiUmVzaXplT2JzZXJ2ZXJcIixcbiAgICBcIlJlc2l6ZU9ic2VydmVyRW50cnlcIixcbiAgICBcIlJlc2l6ZU9ic2VydmVyU2l6ZVwiLFxuICAgIFwiUmVzcG9uc2VcIixcbiAgICBcIlJ1bnRpbWVFcnJvclwiLFxuICAgIFwiU0FNUExFUl8yRFwiLFxuICAgIFwiU0FNUExFUl8yRF9BUlJBWVwiLFxuICAgIFwiU0FNUExFUl8yRF9BUlJBWV9TSEFET1dcIixcbiAgICBcIlNBTVBMRVJfMkRfU0hBRE9XXCIsXG4gICAgXCJTQU1QTEVSXzNEXCIsXG4gICAgXCJTQU1QTEVSX0JJTkRJTkdcIixcbiAgICBcIlNBTVBMRVJfQ1VCRVwiLFxuICAgIFwiU0FNUExFUl9DVUJFX1NIQURPV1wiLFxuICAgIFwiU0FNUExFU1wiLFxuICAgIFwiU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFXCIsXG4gICAgXCJTQU1QTEVfQlVGRkVSU1wiLFxuICAgIFwiU0FNUExFX0NPVkVSQUdFXCIsXG4gICAgXCJTQU1QTEVfQ09WRVJBR0VfSU5WRVJUXCIsXG4gICAgXCJTQU1QTEVfQ09WRVJBR0VfVkFMVUVcIixcbiAgICBcIlNBV1RPT1RIXCIsXG4gICAgXCJTQ0hFRFVMRURfU1RBVEVcIixcbiAgICBcIlNDSVNTT1JfQk9YXCIsXG4gICAgXCJTQ0lTU09SX1RFU1RcIixcbiAgICBcIlNDUk9MTF9QQUdFX0RPV05cIixcbiAgICBcIlNDUk9MTF9QQUdFX1VQXCIsXG4gICAgXCJTRFBfQU5TV0VSXCIsXG4gICAgXCJTRFBfT0ZGRVJcIixcbiAgICBcIlNEUF9QUkFOU1dFUlwiLFxuICAgIFwiU0VDVVJJVFlfRVJSXCIsXG4gICAgXCJTRUxFQ1RcIixcbiAgICBcIlNFUEFSQVRFX0FUVFJJQlNcIixcbiAgICBcIlNFUklBTElaRV9FUlJcIixcbiAgICBcIlNFVkVSSVRZX0VSUk9SXCIsXG4gICAgXCJTRVZFUklUWV9GQVRBTF9FUlJPUlwiLFxuICAgIFwiU0VWRVJJVFlfV0FSTklOR1wiLFxuICAgIFwiU0hBREVSX0NPTVBJTEVSXCIsXG4gICAgXCJTSEFERVJfVFlQRVwiLFxuICAgIFwiU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OXCIsXG4gICAgXCJTSElGVF9NQVNLXCIsXG4gICAgXCJTSE9SVFwiLFxuICAgIFwiU0hPV0lOR1wiLFxuICAgIFwiU0hPV19BTExcIixcbiAgICBcIlNIT1dfQVRUUklCVVRFXCIsXG4gICAgXCJTSE9XX0NEQVRBX1NFQ1RJT05cIixcbiAgICBcIlNIT1dfQ09NTUVOVFwiLFxuICAgIFwiU0hPV19ET0NVTUVOVFwiLFxuICAgIFwiU0hPV19ET0NVTUVOVF9GUkFHTUVOVFwiLFxuICAgIFwiU0hPV19ET0NVTUVOVF9UWVBFXCIsXG4gICAgXCJTSE9XX0VMRU1FTlRcIixcbiAgICBcIlNIT1dfRU5USVRZXCIsXG4gICAgXCJTSE9XX0VOVElUWV9SRUZFUkVOQ0VcIixcbiAgICBcIlNIT1dfTk9UQVRJT05cIixcbiAgICBcIlNIT1dfUFJPQ0VTU0lOR19JTlNUUlVDVElPTlwiLFxuICAgIFwiU0hPV19URVhUXCIsXG4gICAgXCJTSUdOQUxFRFwiLFxuICAgIFwiU0lHTkVEX05PUk1BTElaRURcIixcbiAgICBcIlNJTkVcIixcbiAgICBcIlNPVU5ERklFTERcIixcbiAgICBcIlNRTEV4Y2VwdGlvblwiLFxuICAgIFwiU1FSVDFfMlwiLFxuICAgIFwiU1FSVDJcIixcbiAgICBcIlNRVUFSRVwiLFxuICAgIFwiU1JDX0FMUEhBXCIsXG4gICAgXCJTUkNfQUxQSEFfU0FUVVJBVEVcIixcbiAgICBcIlNSQ19DT0xPUlwiLFxuICAgIFwiU1JHQlwiLFxuICAgIFwiU1JHQjhcIixcbiAgICBcIlNSR0I4X0FMUEhBOFwiLFxuICAgIFwiU1RBUlRfVE9fRU5EXCIsXG4gICAgXCJTVEFSVF9UT19TVEFSVFwiLFxuICAgIFwiU1RBVElDX0NPUFlcIixcbiAgICBcIlNUQVRJQ19EUkFXXCIsXG4gICAgXCJTVEFUSUNfUkVBRFwiLFxuICAgIFwiU1RFTkNJTFwiLFxuICAgIFwiU1RFTkNJTF9BVFRBQ0hNRU5UXCIsXG4gICAgXCJTVEVOQ0lMX0JBQ0tfRkFJTFwiLFxuICAgIFwiU1RFTkNJTF9CQUNLX0ZVTkNcIixcbiAgICBcIlNURU5DSUxfQkFDS19QQVNTX0RFUFRIX0ZBSUxcIixcbiAgICBcIlNURU5DSUxfQkFDS19QQVNTX0RFUFRIX1BBU1NcIixcbiAgICBcIlNURU5DSUxfQkFDS19SRUZcIixcbiAgICBcIlNURU5DSUxfQkFDS19WQUxVRV9NQVNLXCIsXG4gICAgXCJTVEVOQ0lMX0JBQ0tfV1JJVEVNQVNLXCIsXG4gICAgXCJTVEVOQ0lMX0JJVFNcIixcbiAgICBcIlNURU5DSUxfQlVGRkVSX0JJVFwiLFxuICAgIFwiU1RFTkNJTF9DTEVBUl9WQUxVRVwiLFxuICAgIFwiU1RFTkNJTF9GQUlMXCIsXG4gICAgXCJTVEVOQ0lMX0ZVTkNcIixcbiAgICBcIlNURU5DSUxfSU5ERVhcIixcbiAgICBcIlNURU5DSUxfSU5ERVg4XCIsXG4gICAgXCJTVEVOQ0lMX1BBU1NfREVQVEhfRkFJTFwiLFxuICAgIFwiU1RFTkNJTF9QQVNTX0RFUFRIX1BBU1NcIixcbiAgICBcIlNURU5DSUxfUkVGXCIsXG4gICAgXCJTVEVOQ0lMX1RFU1RcIixcbiAgICBcIlNURU5DSUxfVkFMVUVfTUFTS1wiLFxuICAgIFwiU1RFTkNJTF9XUklURU1BU0tcIixcbiAgICBcIlNUUkVBTV9DT1BZXCIsXG4gICAgXCJTVFJFQU1fRFJBV1wiLFxuICAgIFwiU1RSRUFNX1JFQURcIixcbiAgICBcIlNUUklOR19UWVBFXCIsXG4gICAgXCJTVFlMRV9SVUxFXCIsXG4gICAgXCJTVUJQSVhFTF9CSVRTXCIsXG4gICAgXCJTVVBQT1JUU19SVUxFXCIsXG4gICAgXCJTVkdBRWxlbWVudFwiLFxuICAgIFwiU1ZHQWx0R2x5cGhEZWZFbGVtZW50XCIsXG4gICAgXCJTVkdBbHRHbHlwaEVsZW1lbnRcIixcbiAgICBcIlNWR0FsdEdseXBoSXRlbUVsZW1lbnRcIixcbiAgICBcIlNWR0FuZ2xlXCIsXG4gICAgXCJTVkdBbmltYXRlQ29sb3JFbGVtZW50XCIsXG4gICAgXCJTVkdBbmltYXRlRWxlbWVudFwiLFxuICAgIFwiU1ZHQW5pbWF0ZU1vdGlvbkVsZW1lbnRcIixcbiAgICBcIlNWR0FuaW1hdGVUcmFuc2Zvcm1FbGVtZW50XCIsXG4gICAgXCJTVkdBbmltYXRlZEFuZ2xlXCIsXG4gICAgXCJTVkdBbmltYXRlZEJvb2xlYW5cIixcbiAgICBcIlNWR0FuaW1hdGVkRW51bWVyYXRpb25cIixcbiAgICBcIlNWR0FuaW1hdGVkSW50ZWdlclwiLFxuICAgIFwiU1ZHQW5pbWF0ZWRMZW5ndGhcIixcbiAgICBcIlNWR0FuaW1hdGVkTGVuZ3RoTGlzdFwiLFxuICAgIFwiU1ZHQW5pbWF0ZWROdW1iZXJcIixcbiAgICBcIlNWR0FuaW1hdGVkTnVtYmVyTGlzdFwiLFxuICAgIFwiU1ZHQW5pbWF0ZWRQcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsXG4gICAgXCJTVkdBbmltYXRlZFJlY3RcIixcbiAgICBcIlNWR0FuaW1hdGVkU3RyaW5nXCIsXG4gICAgXCJTVkdBbmltYXRlZFRyYW5zZm9ybUxpc3RcIixcbiAgICBcIlNWR0FuaW1hdGlvbkVsZW1lbnRcIixcbiAgICBcIlNWR0NpcmNsZUVsZW1lbnRcIixcbiAgICBcIlNWR0NsaXBQYXRoRWxlbWVudFwiLFxuICAgIFwiU1ZHQ29sb3JcIixcbiAgICBcIlNWR0NvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb25FbGVtZW50XCIsXG4gICAgXCJTVkdDdXJzb3JFbGVtZW50XCIsXG4gICAgXCJTVkdEZWZzRWxlbWVudFwiLFxuICAgIFwiU1ZHRGVzY0VsZW1lbnRcIixcbiAgICBcIlNWR0Rpc2NhcmRFbGVtZW50XCIsXG4gICAgXCJTVkdEb2N1bWVudFwiLFxuICAgIFwiU1ZHRWxlbWVudFwiLFxuICAgIFwiU1ZHRWxlbWVudEluc3RhbmNlXCIsXG4gICAgXCJTVkdFbGVtZW50SW5zdGFuY2VMaXN0XCIsXG4gICAgXCJTVkdFbGxpcHNlRWxlbWVudFwiLFxuICAgIFwiU1ZHRXhjZXB0aW9uXCIsXG4gICAgXCJTVkdGRUJsZW5kRWxlbWVudFwiLFxuICAgIFwiU1ZHRkVDb2xvck1hdHJpeEVsZW1lbnRcIixcbiAgICBcIlNWR0ZFQ29tcG9uZW50VHJhbnNmZXJFbGVtZW50XCIsXG4gICAgXCJTVkdGRUNvbXBvc2l0ZUVsZW1lbnRcIixcbiAgICBcIlNWR0ZFQ29udm9sdmVNYXRyaXhFbGVtZW50XCIsXG4gICAgXCJTVkdGRURpZmZ1c2VMaWdodGluZ0VsZW1lbnRcIixcbiAgICBcIlNWR0ZFRGlzcGxhY2VtZW50TWFwRWxlbWVudFwiLFxuICAgIFwiU1ZHRkVEaXN0YW50TGlnaHRFbGVtZW50XCIsXG4gICAgXCJTVkdGRURyb3BTaGFkb3dFbGVtZW50XCIsXG4gICAgXCJTVkdGRUZsb29kRWxlbWVudFwiLFxuICAgIFwiU1ZHRkVGdW5jQUVsZW1lbnRcIixcbiAgICBcIlNWR0ZFRnVuY0JFbGVtZW50XCIsXG4gICAgXCJTVkdGRUZ1bmNHRWxlbWVudFwiLFxuICAgIFwiU1ZHRkVGdW5jUkVsZW1lbnRcIixcbiAgICBcIlNWR0ZFR2F1c3NpYW5CbHVyRWxlbWVudFwiLFxuICAgIFwiU1ZHRkVJbWFnZUVsZW1lbnRcIixcbiAgICBcIlNWR0ZFTWVyZ2VFbGVtZW50XCIsXG4gICAgXCJTVkdGRU1lcmdlTm9kZUVsZW1lbnRcIixcbiAgICBcIlNWR0ZFTW9ycGhvbG9neUVsZW1lbnRcIixcbiAgICBcIlNWR0ZFT2Zmc2V0RWxlbWVudFwiLFxuICAgIFwiU1ZHRkVQb2ludExpZ2h0RWxlbWVudFwiLFxuICAgIFwiU1ZHRkVTcGVjdWxhckxpZ2h0aW5nRWxlbWVudFwiLFxuICAgIFwiU1ZHRkVTcG90TGlnaHRFbGVtZW50XCIsXG4gICAgXCJTVkdGRVRpbGVFbGVtZW50XCIsXG4gICAgXCJTVkdGRVR1cmJ1bGVuY2VFbGVtZW50XCIsXG4gICAgXCJTVkdGaWx0ZXJFbGVtZW50XCIsXG4gICAgXCJTVkdGb250RWxlbWVudFwiLFxuICAgIFwiU1ZHRm9udEZhY2VFbGVtZW50XCIsXG4gICAgXCJTVkdGb250RmFjZUZvcm1hdEVsZW1lbnRcIixcbiAgICBcIlNWR0ZvbnRGYWNlTmFtZUVsZW1lbnRcIixcbiAgICBcIlNWR0ZvbnRGYWNlU3JjRWxlbWVudFwiLFxuICAgIFwiU1ZHRm9udEZhY2VVcmlFbGVtZW50XCIsXG4gICAgXCJTVkdGb3JlaWduT2JqZWN0RWxlbWVudFwiLFxuICAgIFwiU1ZHR0VsZW1lbnRcIixcbiAgICBcIlNWR0dlb21ldHJ5RWxlbWVudFwiLFxuICAgIFwiU1ZHR2x5cGhFbGVtZW50XCIsXG4gICAgXCJTVkdHbHlwaFJlZkVsZW1lbnRcIixcbiAgICBcIlNWR0dyYWRpZW50RWxlbWVudFwiLFxuICAgIFwiU1ZHR3JhcGhpY3NFbGVtZW50XCIsXG4gICAgXCJTVkdIS2VybkVsZW1lbnRcIixcbiAgICBcIlNWR0ltYWdlRWxlbWVudFwiLFxuICAgIFwiU1ZHTGVuZ3RoXCIsXG4gICAgXCJTVkdMZW5ndGhMaXN0XCIsXG4gICAgXCJTVkdMaW5lRWxlbWVudFwiLFxuICAgIFwiU1ZHTGluZWFyR3JhZGllbnRFbGVtZW50XCIsXG4gICAgXCJTVkdNUGF0aEVsZW1lbnRcIixcbiAgICBcIlNWR01hcmtlckVsZW1lbnRcIixcbiAgICBcIlNWR01hc2tFbGVtZW50XCIsXG4gICAgXCJTVkdNYXRyaXhcIixcbiAgICBcIlNWR01ldGFkYXRhRWxlbWVudFwiLFxuICAgIFwiU1ZHTWlzc2luZ0dseXBoRWxlbWVudFwiLFxuICAgIFwiU1ZHTnVtYmVyXCIsXG4gICAgXCJTVkdOdW1iZXJMaXN0XCIsXG4gICAgXCJTVkdQYWludFwiLFxuICAgIFwiU1ZHUGF0aEVsZW1lbnRcIixcbiAgICBcIlNWR1BhdGhTZWdcIixcbiAgICBcIlNWR1BhdGhTZWdBcmNBYnNcIixcbiAgICBcIlNWR1BhdGhTZWdBcmNSZWxcIixcbiAgICBcIlNWR1BhdGhTZWdDbG9zZVBhdGhcIixcbiAgICBcIlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNBYnNcIixcbiAgICBcIlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNSZWxcIixcbiAgICBcIlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhBYnNcIixcbiAgICBcIlNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhSZWxcIixcbiAgICBcIlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljQWJzXCIsXG4gICAgXCJTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbFwiLFxuICAgIFwiU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNTbW9vdGhBYnNcIixcbiAgICBcIlNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoUmVsXCIsXG4gICAgXCJTVkdQYXRoU2VnTGluZXRvQWJzXCIsXG4gICAgXCJTVkdQYXRoU2VnTGluZXRvSG9yaXpvbnRhbEFic1wiLFxuICAgIFwiU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxSZWxcIixcbiAgICBcIlNWR1BhdGhTZWdMaW5ldG9SZWxcIixcbiAgICBcIlNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbEFic1wiLFxuICAgIFwiU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsUmVsXCIsXG4gICAgXCJTVkdQYXRoU2VnTGlzdFwiLFxuICAgIFwiU1ZHUGF0aFNlZ01vdmV0b0Fic1wiLFxuICAgIFwiU1ZHUGF0aFNlZ01vdmV0b1JlbFwiLFxuICAgIFwiU1ZHUGF0dGVybkVsZW1lbnRcIixcbiAgICBcIlNWR1BvaW50XCIsXG4gICAgXCJTVkdQb2ludExpc3RcIixcbiAgICBcIlNWR1BvbHlnb25FbGVtZW50XCIsXG4gICAgXCJTVkdQb2x5bGluZUVsZW1lbnRcIixcbiAgICBcIlNWR1ByZXNlcnZlQXNwZWN0UmF0aW9cIixcbiAgICBcIlNWR1JhZGlhbEdyYWRpZW50RWxlbWVudFwiLFxuICAgIFwiU1ZHUmVjdFwiLFxuICAgIFwiU1ZHUmVjdEVsZW1lbnRcIixcbiAgICBcIlNWR1JlbmRlcmluZ0ludGVudFwiLFxuICAgIFwiU1ZHU1ZHRWxlbWVudFwiLFxuICAgIFwiU1ZHU2NyaXB0RWxlbWVudFwiLFxuICAgIFwiU1ZHU2V0RWxlbWVudFwiLFxuICAgIFwiU1ZHU3RvcEVsZW1lbnRcIixcbiAgICBcIlNWR1N0cmluZ0xpc3RcIixcbiAgICBcIlNWR1N0eWxlRWxlbWVudFwiLFxuICAgIFwiU1ZHU3dpdGNoRWxlbWVudFwiLFxuICAgIFwiU1ZHU3ltYm9sRWxlbWVudFwiLFxuICAgIFwiU1ZHVFJlZkVsZW1lbnRcIixcbiAgICBcIlNWR1RTcGFuRWxlbWVudFwiLFxuICAgIFwiU1ZHVGV4dENvbnRlbnRFbGVtZW50XCIsXG4gICAgXCJTVkdUZXh0RWxlbWVudFwiLFxuICAgIFwiU1ZHVGV4dFBhdGhFbGVtZW50XCIsXG4gICAgXCJTVkdUZXh0UG9zaXRpb25pbmdFbGVtZW50XCIsXG4gICAgXCJTVkdUaXRsZUVsZW1lbnRcIixcbiAgICBcIlNWR1RyYW5zZm9ybVwiLFxuICAgIFwiU1ZHVHJhbnNmb3JtTGlzdFwiLFxuICAgIFwiU1ZHVW5pdFR5cGVzXCIsXG4gICAgXCJTVkdVc2VFbGVtZW50XCIsXG4gICAgXCJTVkdWS2VybkVsZW1lbnRcIixcbiAgICBcIlNWR1ZpZXdFbGVtZW50XCIsXG4gICAgXCJTVkdWaWV3U3BlY1wiLFxuICAgIFwiU1ZHWm9vbUFuZFBhblwiLFxuICAgIFwiU1ZHWm9vbUV2ZW50XCIsXG4gICAgXCJTVkdfQU5HTEVUWVBFX0RFR1wiLFxuICAgIFwiU1ZHX0FOR0xFVFlQRV9HUkFEXCIsXG4gICAgXCJTVkdfQU5HTEVUWVBFX1JBRFwiLFxuICAgIFwiU1ZHX0FOR0xFVFlQRV9VTktOT1dOXCIsXG4gICAgXCJTVkdfQU5HTEVUWVBFX1VOU1BFQ0lGSUVEXCIsXG4gICAgXCJTVkdfQ0hBTk5FTF9BXCIsXG4gICAgXCJTVkdfQ0hBTk5FTF9CXCIsXG4gICAgXCJTVkdfQ0hBTk5FTF9HXCIsXG4gICAgXCJTVkdfQ0hBTk5FTF9SXCIsXG4gICAgXCJTVkdfQ0hBTk5FTF9VTktOT1dOXCIsXG4gICAgXCJTVkdfQ09MT1JUWVBFX0NVUlJFTlRDT0xPUlwiLFxuICAgIFwiU1ZHX0NPTE9SVFlQRV9SR0JDT0xPUlwiLFxuICAgIFwiU1ZHX0NPTE9SVFlQRV9SR0JDT0xPUl9JQ0NDT0xPUlwiLFxuICAgIFwiU1ZHX0NPTE9SVFlQRV9VTktOT1dOXCIsXG4gICAgXCJTVkdfRURHRU1PREVfRFVQTElDQVRFXCIsXG4gICAgXCJTVkdfRURHRU1PREVfTk9ORVwiLFxuICAgIFwiU1ZHX0VER0VNT0RFX1VOS05PV05cIixcbiAgICBcIlNWR19FREdFTU9ERV9XUkFQXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX0NPTE9SXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX0NPTE9SX0JVUk5cIixcbiAgICBcIlNWR19GRUJMRU5EX01PREVfQ09MT1JfRE9ER0VcIixcbiAgICBcIlNWR19GRUJMRU5EX01PREVfREFSS0VOXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX0RJRkZFUkVOQ0VcIixcbiAgICBcIlNWR19GRUJMRU5EX01PREVfRVhDTFVTSU9OXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX0hBUkRfTElHSFRcIixcbiAgICBcIlNWR19GRUJMRU5EX01PREVfSFVFXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX0xJR0hURU5cIixcbiAgICBcIlNWR19GRUJMRU5EX01PREVfTFVNSU5PU0lUWVwiLFxuICAgIFwiU1ZHX0ZFQkxFTkRfTU9ERV9NVUxUSVBMWVwiLFxuICAgIFwiU1ZHX0ZFQkxFTkRfTU9ERV9OT1JNQUxcIixcbiAgICBcIlNWR19GRUJMRU5EX01PREVfT1ZFUkxBWVwiLFxuICAgIFwiU1ZHX0ZFQkxFTkRfTU9ERV9TQVRVUkFUSU9OXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX1NDUkVFTlwiLFxuICAgIFwiU1ZHX0ZFQkxFTkRfTU9ERV9TT0ZUX0xJR0hUXCIsXG4gICAgXCJTVkdfRkVCTEVORF9NT0RFX1VOS05PV05cIixcbiAgICBcIlNWR19GRUNPTE9STUFUUklYX1RZUEVfSFVFUk9UQVRFXCIsXG4gICAgXCJTVkdfRkVDT0xPUk1BVFJJWF9UWVBFX0xVTUlOQU5DRVRPQUxQSEFcIixcbiAgICBcIlNWR19GRUNPTE9STUFUUklYX1RZUEVfTUFUUklYXCIsXG4gICAgXCJTVkdfRkVDT0xPUk1BVFJJWF9UWVBFX1NBVFVSQVRFXCIsXG4gICAgXCJTVkdfRkVDT0xPUk1BVFJJWF9UWVBFX1VOS05PV05cIixcbiAgICBcIlNWR19GRUNPTVBPTkVOVFRSQU5TRkVSX1RZUEVfRElTQ1JFVEVcIixcbiAgICBcIlNWR19GRUNPTVBPTkVOVFRSQU5TRkVSX1RZUEVfR0FNTUFcIixcbiAgICBcIlNWR19GRUNPTVBPTkVOVFRSQU5TRkVSX1RZUEVfSURFTlRJVFlcIixcbiAgICBcIlNWR19GRUNPTVBPTkVOVFRSQU5TRkVSX1RZUEVfTElORUFSXCIsXG4gICAgXCJTVkdfRkVDT01QT05FTlRUUkFOU0ZFUl9UWVBFX1RBQkxFXCIsXG4gICAgXCJTVkdfRkVDT01QT05FTlRUUkFOU0ZFUl9UWVBFX1VOS05PV05cIixcbiAgICBcIlNWR19GRUNPTVBPU0lURV9PUEVSQVRPUl9BUklUSE1FVElDXCIsXG4gICAgXCJTVkdfRkVDT01QT1NJVEVfT1BFUkFUT1JfQVRPUFwiLFxuICAgIFwiU1ZHX0ZFQ09NUE9TSVRFX09QRVJBVE9SX0lOXCIsXG4gICAgXCJTVkdfRkVDT01QT1NJVEVfT1BFUkFUT1JfT1VUXCIsXG4gICAgXCJTVkdfRkVDT01QT1NJVEVfT1BFUkFUT1JfT1ZFUlwiLFxuICAgIFwiU1ZHX0ZFQ09NUE9TSVRFX09QRVJBVE9SX1VOS05PV05cIixcbiAgICBcIlNWR19GRUNPTVBPU0lURV9PUEVSQVRPUl9YT1JcIixcbiAgICBcIlNWR19JTlZBTElEX1ZBTFVFX0VSUlwiLFxuICAgIFwiU1ZHX0xFTkdUSFRZUEVfQ01cIixcbiAgICBcIlNWR19MRU5HVEhUWVBFX0VNU1wiLFxuICAgIFwiU1ZHX0xFTkdUSFRZUEVfRVhTXCIsXG4gICAgXCJTVkdfTEVOR1RIVFlQRV9JTlwiLFxuICAgIFwiU1ZHX0xFTkdUSFRZUEVfTU1cIixcbiAgICBcIlNWR19MRU5HVEhUWVBFX05VTUJFUlwiLFxuICAgIFwiU1ZHX0xFTkdUSFRZUEVfUENcIixcbiAgICBcIlNWR19MRU5HVEhUWVBFX1BFUkNFTlRBR0VcIixcbiAgICBcIlNWR19MRU5HVEhUWVBFX1BUXCIsXG4gICAgXCJTVkdfTEVOR1RIVFlQRV9QWFwiLFxuICAgIFwiU1ZHX0xFTkdUSFRZUEVfVU5LTk9XTlwiLFxuICAgIFwiU1ZHX01BUktFUlVOSVRTX1NUUk9LRVdJRFRIXCIsXG4gICAgXCJTVkdfTUFSS0VSVU5JVFNfVU5LTk9XTlwiLFxuICAgIFwiU1ZHX01BUktFUlVOSVRTX1VTRVJTUEFDRU9OVVNFXCIsXG4gICAgXCJTVkdfTUFSS0VSX09SSUVOVF9BTkdMRVwiLFxuICAgIFwiU1ZHX01BUktFUl9PUklFTlRfQVVUT1wiLFxuICAgIFwiU1ZHX01BUktFUl9PUklFTlRfVU5LTk9XTlwiLFxuICAgIFwiU1ZHX01BU0tUWVBFX0FMUEhBXCIsXG4gICAgXCJTVkdfTUFTS1RZUEVfTFVNSU5BTkNFXCIsXG4gICAgXCJTVkdfTUFUUklYX05PVF9JTlZFUlRBQkxFXCIsXG4gICAgXCJTVkdfTUVFVE9SU0xJQ0VfTUVFVFwiLFxuICAgIFwiU1ZHX01FRVRPUlNMSUNFX1NMSUNFXCIsXG4gICAgXCJTVkdfTUVFVE9SU0xJQ0VfVU5LTk9XTlwiLFxuICAgIFwiU1ZHX01PUlBIT0xPR1lfT1BFUkFUT1JfRElMQVRFXCIsXG4gICAgXCJTVkdfTU9SUEhPTE9HWV9PUEVSQVRPUl9FUk9ERVwiLFxuICAgIFwiU1ZHX01PUlBIT0xPR1lfT1BFUkFUT1JfVU5LTk9XTlwiLFxuICAgIFwiU1ZHX1BBSU5UVFlQRV9DVVJSRU5UQ09MT1JcIixcbiAgICBcIlNWR19QQUlOVFRZUEVfTk9ORVwiLFxuICAgIFwiU1ZHX1BBSU5UVFlQRV9SR0JDT0xPUlwiLFxuICAgIFwiU1ZHX1BBSU5UVFlQRV9SR0JDT0xPUl9JQ0NDT0xPUlwiLFxuICAgIFwiU1ZHX1BBSU5UVFlQRV9VTktOT1dOXCIsXG4gICAgXCJTVkdfUEFJTlRUWVBFX1VSSVwiLFxuICAgIFwiU1ZHX1BBSU5UVFlQRV9VUklfQ1VSUkVOVENPTE9SXCIsXG4gICAgXCJTVkdfUEFJTlRUWVBFX1VSSV9OT05FXCIsXG4gICAgXCJTVkdfUEFJTlRUWVBFX1VSSV9SR0JDT0xPUlwiLFxuICAgIFwiU1ZHX1BBSU5UVFlQRV9VUklfUkdCQ09MT1JfSUNDQ09MT1JcIixcbiAgICBcIlNWR19QUkVTRVJWRUFTUEVDVFJBVElPX05PTkVcIixcbiAgICBcIlNWR19QUkVTRVJWRUFTUEVDVFJBVElPX1VOS05PV05cIixcbiAgICBcIlNWR19QUkVTRVJWRUFTUEVDVFJBVElPX1hNQVhZTUFYXCIsXG4gICAgXCJTVkdfUFJFU0VSVkVBU1BFQ1RSQVRJT19YTUFYWU1JRFwiLFxuICAgIFwiU1ZHX1BSRVNFUlZFQVNQRUNUUkFUSU9fWE1BWFlNSU5cIixcbiAgICBcIlNWR19QUkVTRVJWRUFTUEVDVFJBVElPX1hNSURZTUFYXCIsXG4gICAgXCJTVkdfUFJFU0VSVkVBU1BFQ1RSQVRJT19YTUlEWU1JRFwiLFxuICAgIFwiU1ZHX1BSRVNFUlZFQVNQRUNUUkFUSU9fWE1JRFlNSU5cIixcbiAgICBcIlNWR19QUkVTRVJWRUFTUEVDVFJBVElPX1hNSU5ZTUFYXCIsXG4gICAgXCJTVkdfUFJFU0VSVkVBU1BFQ1RSQVRJT19YTUlOWU1JRFwiLFxuICAgIFwiU1ZHX1BSRVNFUlZFQVNQRUNUUkFUSU9fWE1JTllNSU5cIixcbiAgICBcIlNWR19TUFJFQURNRVRIT0RfUEFEXCIsXG4gICAgXCJTVkdfU1BSRUFETUVUSE9EX1JFRkxFQ1RcIixcbiAgICBcIlNWR19TUFJFQURNRVRIT0RfUkVQRUFUXCIsXG4gICAgXCJTVkdfU1BSRUFETUVUSE9EX1VOS05PV05cIixcbiAgICBcIlNWR19TVElUQ0hUWVBFX05PU1RJVENIXCIsXG4gICAgXCJTVkdfU1RJVENIVFlQRV9TVElUQ0hcIixcbiAgICBcIlNWR19TVElUQ0hUWVBFX1VOS05PV05cIixcbiAgICBcIlNWR19UUkFOU0ZPUk1fTUFUUklYXCIsXG4gICAgXCJTVkdfVFJBTlNGT1JNX1JPVEFURVwiLFxuICAgIFwiU1ZHX1RSQU5TRk9STV9TQ0FMRVwiLFxuICAgIFwiU1ZHX1RSQU5TRk9STV9TS0VXWFwiLFxuICAgIFwiU1ZHX1RSQU5TRk9STV9TS0VXWVwiLFxuICAgIFwiU1ZHX1RSQU5TRk9STV9UUkFOU0xBVEVcIixcbiAgICBcIlNWR19UUkFOU0ZPUk1fVU5LTk9XTlwiLFxuICAgIFwiU1ZHX1RVUkJVTEVOQ0VfVFlQRV9GUkFDVEFMTk9JU0VcIixcbiAgICBcIlNWR19UVVJCVUxFTkNFX1RZUEVfVFVSQlVMRU5DRVwiLFxuICAgIFwiU1ZHX1RVUkJVTEVOQ0VfVFlQRV9VTktOT1dOXCIsXG4gICAgXCJTVkdfVU5JVF9UWVBFX09CSkVDVEJPVU5ESU5HQk9YXCIsXG4gICAgXCJTVkdfVU5JVF9UWVBFX1VOS05PV05cIixcbiAgICBcIlNWR19VTklUX1RZUEVfVVNFUlNQQUNFT05VU0VcIixcbiAgICBcIlNWR19XUk9OR19UWVBFX0VSUlwiLFxuICAgIFwiU1ZHX1pPT01BTkRQQU5fRElTQUJMRVwiLFxuICAgIFwiU1ZHX1pPT01BTkRQQU5fTUFHTklGWVwiLFxuICAgIFwiU1ZHX1pPT01BTkRQQU5fVU5LTk9XTlwiLFxuICAgIFwiU1lOQ19DT05ESVRJT05cIixcbiAgICBcIlNZTkNfRkVOQ0VcIixcbiAgICBcIlNZTkNfRkxBR1NcIixcbiAgICBcIlNZTkNfRkxVU0hfQ09NTUFORFNfQklUXCIsXG4gICAgXCJTWU5DX0dQVV9DT01NQU5EU19DT01QTEVURVwiLFxuICAgIFwiU1lOQ19TVEFUVVNcIixcbiAgICBcIlNZTlRBWF9FUlJcIixcbiAgICBcIlNhdmVkUGFnZXNcIixcbiAgICBcIlNjcmVlblwiLFxuICAgIFwiU2NyZWVuT3JpZW50YXRpb25cIixcbiAgICBcIlNjcmlwdFwiLFxuICAgIFwiU2NyaXB0UHJvY2Vzc29yTm9kZVwiLFxuICAgIFwiU2Nyb2xsQXJlYUV2ZW50XCIsXG4gICAgXCJTZWN1cml0eVBvbGljeVZpb2xhdGlvbkV2ZW50XCIsXG4gICAgXCJTZWxlY3Rpb25cIixcbiAgICBcIlNlbnNvclwiLFxuICAgIFwiU2Vuc29yRXJyb3JFdmVudFwiLFxuICAgIFwiU2VydmljZVdvcmtlclwiLFxuICAgIFwiU2VydmljZVdvcmtlckNvbnRhaW5lclwiLFxuICAgIFwiU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvblwiLFxuICAgIFwiU2Vzc2lvbkRlc2NyaXB0aW9uXCIsXG4gICAgXCJTZXRcIixcbiAgICBcIlNoYWRvd1Jvb3RcIixcbiAgICBcIlNoYXJlZEFycmF5QnVmZmVyXCIsXG4gICAgXCJTaGFyZWRXb3JrZXJcIixcbiAgICBcIlNpbXBsZUdlc3R1cmVFdmVudFwiLFxuICAgIFwiU291cmNlQnVmZmVyXCIsXG4gICAgXCJTb3VyY2VCdWZmZXJMaXN0XCIsXG4gICAgXCJTcGVlY2hTeW50aGVzaXNcIixcbiAgICBcIlNwZWVjaFN5bnRoZXNpc0Vycm9yRXZlbnRcIixcbiAgICBcIlNwZWVjaFN5bnRoZXNpc0V2ZW50XCIsXG4gICAgXCJTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2VcIixcbiAgICBcIlNwZWVjaFN5bnRoZXNpc1ZvaWNlXCIsXG4gICAgXCJTdGF0aWNSYW5nZVwiLFxuICAgIFwiU3RlcmVvUGFubmVyTm9kZVwiLFxuICAgIFwiU3RvcEl0ZXJhdGlvblwiLFxuICAgIFwiU3RvcmFnZVwiLFxuICAgIFwiU3RvcmFnZUV2ZW50XCIsXG4gICAgXCJTdG9yYWdlTWFuYWdlclwiLFxuICAgIFwiU3RyaW5nXCIsXG4gICAgXCJTdHJ1Y3RUeXBlXCIsXG4gICAgXCJTdHlsZVByb3BlcnR5TWFwXCIsXG4gICAgXCJTdHlsZVByb3BlcnR5TWFwUmVhZE9ubHlcIixcbiAgICBcIlN0eWxlU2hlZXRcIixcbiAgICBcIlN0eWxlU2hlZXRMaXN0XCIsXG4gICAgXCJTdWJtaXRFdmVudFwiLFxuICAgIFwiU3VidGxlQ3J5cHRvXCIsXG4gICAgXCJTeW1ib2xcIixcbiAgICBcIlN5bmNNYW5hZ2VyXCIsXG4gICAgXCJTeW50YXhFcnJvclwiLFxuICAgIFwiVEVNUE9SQVJZXCIsXG4gICAgXCJURVhUUEFUSF9NRVRIT0RUWVBFX0FMSUdOXCIsXG4gICAgXCJURVhUUEFUSF9NRVRIT0RUWVBFX1NUUkVUQ0hcIixcbiAgICBcIlRFWFRQQVRIX01FVEhPRFRZUEVfVU5LTk9XTlwiLFxuICAgIFwiVEVYVFBBVEhfU1BBQ0lOR1RZUEVfQVVUT1wiLFxuICAgIFwiVEVYVFBBVEhfU1BBQ0lOR1RZUEVfRVhBQ1RcIixcbiAgICBcIlRFWFRQQVRIX1NQQUNJTkdUWVBFX1VOS05PV05cIixcbiAgICBcIlRFWFRVUkVcIixcbiAgICBcIlRFWFRVUkUwXCIsXG4gICAgXCJURVhUVVJFMVwiLFxuICAgIFwiVEVYVFVSRTEwXCIsXG4gICAgXCJURVhUVVJFMTFcIixcbiAgICBcIlRFWFRVUkUxMlwiLFxuICAgIFwiVEVYVFVSRTEzXCIsXG4gICAgXCJURVhUVVJFMTRcIixcbiAgICBcIlRFWFRVUkUxNVwiLFxuICAgIFwiVEVYVFVSRTE2XCIsXG4gICAgXCJURVhUVVJFMTdcIixcbiAgICBcIlRFWFRVUkUxOFwiLFxuICAgIFwiVEVYVFVSRTE5XCIsXG4gICAgXCJURVhUVVJFMlwiLFxuICAgIFwiVEVYVFVSRTIwXCIsXG4gICAgXCJURVhUVVJFMjFcIixcbiAgICBcIlRFWFRVUkUyMlwiLFxuICAgIFwiVEVYVFVSRTIzXCIsXG4gICAgXCJURVhUVVJFMjRcIixcbiAgICBcIlRFWFRVUkUyNVwiLFxuICAgIFwiVEVYVFVSRTI2XCIsXG4gICAgXCJURVhUVVJFMjdcIixcbiAgICBcIlRFWFRVUkUyOFwiLFxuICAgIFwiVEVYVFVSRTI5XCIsXG4gICAgXCJURVhUVVJFM1wiLFxuICAgIFwiVEVYVFVSRTMwXCIsXG4gICAgXCJURVhUVVJFMzFcIixcbiAgICBcIlRFWFRVUkU0XCIsXG4gICAgXCJURVhUVVJFNVwiLFxuICAgIFwiVEVYVFVSRTZcIixcbiAgICBcIlRFWFRVUkU3XCIsXG4gICAgXCJURVhUVVJFOFwiLFxuICAgIFwiVEVYVFVSRTlcIixcbiAgICBcIlRFWFRVUkVfMkRcIixcbiAgICBcIlRFWFRVUkVfMkRfQVJSQVlcIixcbiAgICBcIlRFWFRVUkVfM0RcIixcbiAgICBcIlRFWFRVUkVfQkFTRV9MRVZFTFwiLFxuICAgIFwiVEVYVFVSRV9CSU5ESU5HXzJEXCIsXG4gICAgXCJURVhUVVJFX0JJTkRJTkdfMkRfQVJSQVlcIixcbiAgICBcIlRFWFRVUkVfQklORElOR18zRFwiLFxuICAgIFwiVEVYVFVSRV9CSU5ESU5HX0NVQkVfTUFQXCIsXG4gICAgXCJURVhUVVJFX0NPTVBBUkVfRlVOQ1wiLFxuICAgIFwiVEVYVFVSRV9DT01QQVJFX01PREVcIixcbiAgICBcIlRFWFRVUkVfQ1VCRV9NQVBcIixcbiAgICBcIlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWFwiLFxuICAgIFwiVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZXCIsXG4gICAgXCJURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1pcIixcbiAgICBcIlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWFwiLFxuICAgIFwiVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZXCIsXG4gICAgXCJURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1pcIixcbiAgICBcIlRFWFRVUkVfSU1NVVRBQkxFX0ZPUk1BVFwiLFxuICAgIFwiVEVYVFVSRV9JTU1VVEFCTEVfTEVWRUxTXCIsXG4gICAgXCJURVhUVVJFX01BR19GSUxURVJcIixcbiAgICBcIlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUXCIsXG4gICAgXCJURVhUVVJFX01BWF9MRVZFTFwiLFxuICAgIFwiVEVYVFVSRV9NQVhfTE9EXCIsXG4gICAgXCJURVhUVVJFX01JTl9GSUxURVJcIixcbiAgICBcIlRFWFRVUkVfTUlOX0xPRFwiLFxuICAgIFwiVEVYVFVSRV9XUkFQX1JcIixcbiAgICBcIlRFWFRVUkVfV1JBUF9TXCIsXG4gICAgXCJURVhUVVJFX1dSQVBfVFwiLFxuICAgIFwiVEVYVF9OT0RFXCIsXG4gICAgXCJUSU1FT1VUXCIsXG4gICAgXCJUSU1FT1VUX0VSUlwiLFxuICAgIFwiVElNRU9VVF9FWFBJUkVEXCIsXG4gICAgXCJUSU1FT1VUX0lHTk9SRURcIixcbiAgICBcIlRPT19MQVJHRV9FUlJcIixcbiAgICBcIlRSQU5TQUNUSU9OX0lOQUNUSVZFX0VSUlwiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLXCIsXG4gICAgXCJUUkFOU0ZPUk1fRkVFREJBQ0tfQUNUSVZFXCIsXG4gICAgXCJUUkFOU0ZPUk1fRkVFREJBQ0tfQklORElOR1wiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUlwiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUl9CSU5ESU5HXCIsXG4gICAgXCJUUkFOU0ZPUk1fRkVFREJBQ0tfQlVGRkVSX01PREVcIixcbiAgICBcIlRSQU5TRk9STV9GRUVEQkFDS19CVUZGRVJfU0laRVwiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLX0JVRkZFUl9TVEFSVFwiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLX1BBVVNFRFwiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLX1BSSU1JVElWRVNfV1JJVFRFTlwiLFxuICAgIFwiVFJBTlNGT1JNX0ZFRURCQUNLX1ZBUllJTkdTXCIsXG4gICAgXCJUUklBTkdMRVwiLFxuICAgIFwiVFJJQU5HTEVTXCIsXG4gICAgXCJUUklBTkdMRV9GQU5cIixcbiAgICBcIlRSSUFOR0xFX1NUUklQXCIsXG4gICAgXCJUWVBFX0JBQ0tfRk9SV0FSRFwiLFxuICAgIFwiVFlQRV9FUlJcIixcbiAgICBcIlRZUEVfTUlTTUFUQ0hfRVJSXCIsXG4gICAgXCJUWVBFX05BVklHQVRFXCIsXG4gICAgXCJUWVBFX1JFTE9BRFwiLFxuICAgIFwiVFlQRV9SRVNFUlZFRFwiLFxuICAgIFwiVGFibGVcIixcbiAgICBcIlRhc2tBdHRyaWJ1dGlvblRpbWluZ1wiLFxuICAgIFwiVGV4dFwiLFxuICAgIFwiVGV4dERlY29kZXJcIixcbiAgICBcIlRleHREZWNvZGVyU3RyZWFtXCIsXG4gICAgXCJUZXh0RW5jb2RlclwiLFxuICAgIFwiVGV4dEVuY29kZXJTdHJlYW1cIixcbiAgICBcIlRleHRFdmVudFwiLFxuICAgIFwiVGV4dE1ldHJpY3NcIixcbiAgICBcIlRleHRUcmFja1wiLFxuICAgIFwiVGV4dFRyYWNrQ3VlXCIsXG4gICAgXCJUZXh0VHJhY2tDdWVMaXN0XCIsXG4gICAgXCJUZXh0VHJhY2tMaXN0XCIsXG4gICAgXCJUaW1lRXZlbnRcIixcbiAgICBcIlRpbWVSYW5nZXNcIixcbiAgICBcIlRvdWNoXCIsXG4gICAgXCJUb3VjaEV2ZW50XCIsXG4gICAgXCJUb3VjaExpc3RcIixcbiAgICBcIlRyYWNrRXZlbnRcIixcbiAgICBcIlRyYW5zZm9ybVN0cmVhbVwiLFxuICAgIFwiVHJhbnNpdGlvbkV2ZW50XCIsXG4gICAgXCJUcmVlV2Fsa2VyXCIsXG4gICAgXCJUcnVzdGVkSFRNTFwiLFxuICAgIFwiVHJ1c3RlZFNjcmlwdFwiLFxuICAgIFwiVHJ1c3RlZFNjcmlwdFVSTFwiLFxuICAgIFwiVHJ1c3RlZFR5cGVQb2xpY3lcIixcbiAgICBcIlRydXN0ZWRUeXBlUG9saWN5RmFjdG9yeVwiLFxuICAgIFwiVHlwZUVycm9yXCIsXG4gICAgXCJUeXBlZE9iamVjdFwiLFxuICAgIFwiVTJGXCIsXG4gICAgXCJVSUV2ZW50XCIsXG4gICAgXCJVTkNBQ0hFRFwiLFxuICAgIFwiVU5JRk9STV9BUlJBWV9TVFJJREVcIixcbiAgICBcIlVOSUZPUk1fQkxPQ0tfQUNUSVZFX1VOSUZPUk1TXCIsXG4gICAgXCJVTklGT1JNX0JMT0NLX0FDVElWRV9VTklGT1JNX0lORElDRVNcIixcbiAgICBcIlVOSUZPUk1fQkxPQ0tfQklORElOR1wiLFxuICAgIFwiVU5JRk9STV9CTE9DS19EQVRBX1NJWkVcIixcbiAgICBcIlVOSUZPUk1fQkxPQ0tfSU5ERVhcIixcbiAgICBcIlVOSUZPUk1fQkxPQ0tfUkVGRVJFTkNFRF9CWV9GUkFHTUVOVF9TSEFERVJcIixcbiAgICBcIlVOSUZPUk1fQkxPQ0tfUkVGRVJFTkNFRF9CWV9WRVJURVhfU0hBREVSXCIsXG4gICAgXCJVTklGT1JNX0JVRkZFUlwiLFxuICAgIFwiVU5JRk9STV9CVUZGRVJfQklORElOR1wiLFxuICAgIFwiVU5JRk9STV9CVUZGRVJfT0ZGU0VUX0FMSUdOTUVOVFwiLFxuICAgIFwiVU5JRk9STV9CVUZGRVJfU0laRVwiLFxuICAgIFwiVU5JRk9STV9CVUZGRVJfU1RBUlRcIixcbiAgICBcIlVOSUZPUk1fSVNfUk9XX01BSk9SXCIsXG4gICAgXCJVTklGT1JNX01BVFJJWF9TVFJJREVcIixcbiAgICBcIlVOSUZPUk1fT0ZGU0VUXCIsXG4gICAgXCJVTklGT1JNX1NJWkVcIixcbiAgICBcIlVOSUZPUk1fVFlQRVwiLFxuICAgIFwiVU5LTk9XTl9FUlJcIixcbiAgICBcIlVOS05PV05fUlVMRVwiLFxuICAgIFwiVU5NQVNLRURfUkVOREVSRVJfV0VCR0xcIixcbiAgICBcIlVOTUFTS0VEX1ZFTkRPUl9XRUJHTFwiLFxuICAgIFwiVU5PUkRFUkVEX05PREVfSVRFUkFUT1JfVFlQRVwiLFxuICAgIFwiVU5PUkRFUkVEX05PREVfU05BUFNIT1RfVFlQRVwiLFxuICAgIFwiVU5QQUNLX0FMSUdOTUVOVFwiLFxuICAgIFwiVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTFwiLFxuICAgIFwiVU5QQUNLX0ZMSVBfWV9XRUJHTFwiLFxuICAgIFwiVU5QQUNLX0lNQUdFX0hFSUdIVFwiLFxuICAgIFwiVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMXCIsXG4gICAgXCJVTlBBQ0tfUk9XX0xFTkdUSFwiLFxuICAgIFwiVU5QQUNLX1NLSVBfSU1BR0VTXCIsXG4gICAgXCJVTlBBQ0tfU0tJUF9QSVhFTFNcIixcbiAgICBcIlVOUEFDS19TS0lQX1JPV1NcIixcbiAgICBcIlVOU0NIRURVTEVEX1NUQVRFXCIsXG4gICAgXCJVTlNFTlRcIixcbiAgICBcIlVOU0lHTkFMRURcIixcbiAgICBcIlVOU0lHTkVEX0JZVEVcIixcbiAgICBcIlVOU0lHTkVEX0lOVFwiLFxuICAgIFwiVU5TSUdORURfSU5UXzEwRl8xMUZfMTFGX1JFVlwiLFxuICAgIFwiVU5TSUdORURfSU5UXzI0XzhcIixcbiAgICBcIlVOU0lHTkVEX0lOVF8yXzEwXzEwXzEwX1JFVlwiLFxuICAgIFwiVU5TSUdORURfSU5UXzVfOV85XzlfUkVWXCIsXG4gICAgXCJVTlNJR05FRF9JTlRfU0FNUExFUl8yRFwiLFxuICAgIFwiVU5TSUdORURfSU5UX1NBTVBMRVJfMkRfQVJSQVlcIixcbiAgICBcIlVOU0lHTkVEX0lOVF9TQU1QTEVSXzNEXCIsXG4gICAgXCJVTlNJR05FRF9JTlRfU0FNUExFUl9DVUJFXCIsXG4gICAgXCJVTlNJR05FRF9JTlRfVkVDMlwiLFxuICAgIFwiVU5TSUdORURfSU5UX1ZFQzNcIixcbiAgICBcIlVOU0lHTkVEX0lOVF9WRUM0XCIsXG4gICAgXCJVTlNJR05FRF9OT1JNQUxJWkVEXCIsXG4gICAgXCJVTlNJR05FRF9TSE9SVFwiLFxuICAgIFwiVU5TSUdORURfU0hPUlRfNF80XzRfNFwiLFxuICAgIFwiVU5TSUdORURfU0hPUlRfNV81XzVfMVwiLFxuICAgIFwiVU5TSUdORURfU0hPUlRfNV82XzVcIixcbiAgICBcIlVOU1BFQ0lGSUVEX0VWRU5UX1RZUEVfRVJSXCIsXG4gICAgXCJVUERBVEVSRUFEWVwiLFxuICAgIFwiVVJJRXJyb3JcIixcbiAgICBcIlVSTFwiLFxuICAgIFwiVVJMU2VhcmNoUGFyYW1zXCIsXG4gICAgXCJVUkxVbmVuY29kZWRcIixcbiAgICBcIlVSTF9NSVNNQVRDSF9FUlJcIixcbiAgICBcIlVTQlwiLFxuICAgIFwiVVNCQWx0ZXJuYXRlSW50ZXJmYWNlXCIsXG4gICAgXCJVU0JDb25maWd1cmF0aW9uXCIsXG4gICAgXCJVU0JDb25uZWN0aW9uRXZlbnRcIixcbiAgICBcIlVTQkRldmljZVwiLFxuICAgIFwiVVNCRW5kcG9pbnRcIixcbiAgICBcIlVTQkluVHJhbnNmZXJSZXN1bHRcIixcbiAgICBcIlVTQkludGVyZmFjZVwiLFxuICAgIFwiVVNCSXNvY2hyb25vdXNJblRyYW5zZmVyUGFja2V0XCIsXG4gICAgXCJVU0JJc29jaHJvbm91c0luVHJhbnNmZXJSZXN1bHRcIixcbiAgICBcIlVTQklzb2Nocm9ub3VzT3V0VHJhbnNmZXJQYWNrZXRcIixcbiAgICBcIlVTQklzb2Nocm9ub3VzT3V0VHJhbnNmZXJSZXN1bHRcIixcbiAgICBcIlVTQk91dFRyYW5zZmVyUmVzdWx0XCIsXG4gICAgXCJVVENcIixcbiAgICBcIlVpbnQxNkFycmF5XCIsXG4gICAgXCJVaW50MzJBcnJheVwiLFxuICAgIFwiVWludDhBcnJheVwiLFxuICAgIFwiVWludDhDbGFtcGVkQXJyYXlcIixcbiAgICBcIlVzZXJBY3RpdmF0aW9uXCIsXG4gICAgXCJVc2VyTWVzc2FnZUhhbmRsZXJcIixcbiAgICBcIlVzZXJNZXNzYWdlSGFuZGxlcnNOYW1lc3BhY2VcIixcbiAgICBcIlVzZXJQcm94aW1pdHlFdmVudFwiLFxuICAgIFwiVkFMSURBVEVfU1RBVFVTXCIsXG4gICAgXCJWQUxJREFUSU9OX0VSUlwiLFxuICAgIFwiVkFSSUFCTEVTX1JVTEVcIixcbiAgICBcIlZFTkRPUlwiLFxuICAgIFwiVkVSU0lPTlwiLFxuICAgIFwiVkVSU0lPTl9DSEFOR0VcIixcbiAgICBcIlZFUlNJT05fRVJSXCIsXG4gICAgXCJWRVJURVhfQVJSQVlfQklORElOR1wiLFxuICAgIFwiVkVSVEVYX0FUVFJJQl9BUlJBWV9CVUZGRVJfQklORElOR1wiLFxuICAgIFwiVkVSVEVYX0FUVFJJQl9BUlJBWV9ESVZJU09SXCIsXG4gICAgXCJWRVJURVhfQVRUUklCX0FSUkFZX0RJVklTT1JfQU5HTEVcIixcbiAgICBcIlZFUlRFWF9BVFRSSUJfQVJSQVlfRU5BQkxFRFwiLFxuICAgIFwiVkVSVEVYX0FUVFJJQl9BUlJBWV9JTlRFR0VSXCIsXG4gICAgXCJWRVJURVhfQVRUUklCX0FSUkFZX05PUk1BTElaRURcIixcbiAgICBcIlZFUlRFWF9BVFRSSUJfQVJSQVlfUE9JTlRFUlwiLFxuICAgIFwiVkVSVEVYX0FUVFJJQl9BUlJBWV9TSVpFXCIsXG4gICAgXCJWRVJURVhfQVRUUklCX0FSUkFZX1NUUklERVwiLFxuICAgIFwiVkVSVEVYX0FUVFJJQl9BUlJBWV9UWVBFXCIsXG4gICAgXCJWRVJURVhfU0hBREVSXCIsXG4gICAgXCJWRVJUSUNBTFwiLFxuICAgIFwiVkVSVElDQUxfQVhJU1wiLFxuICAgIFwiVkVSX0VSUlwiLFxuICAgIFwiVklFV1BPUlRcIixcbiAgICBcIlZJRVdQT1JUX1JVTEVcIixcbiAgICBcIlZSRGlzcGxheVwiLFxuICAgIFwiVlJEaXNwbGF5Q2FwYWJpbGl0aWVzXCIsXG4gICAgXCJWUkRpc3BsYXlFdmVudFwiLFxuICAgIFwiVlJFeWVQYXJhbWV0ZXJzXCIsXG4gICAgXCJWUkZpZWxkT2ZWaWV3XCIsXG4gICAgXCJWUkZyYW1lRGF0YVwiLFxuICAgIFwiVlJQb3NlXCIsXG4gICAgXCJWUlN0YWdlUGFyYW1ldGVyc1wiLFxuICAgIFwiVlRUQ3VlXCIsXG4gICAgXCJWVFRSZWdpb25cIixcbiAgICBcIlZhbGlkaXR5U3RhdGVcIixcbiAgICBcIlZpZGVvUGxheWJhY2tRdWFsaXR5XCIsXG4gICAgXCJWaWRlb1N0cmVhbVRyYWNrXCIsXG4gICAgXCJWaXN1YWxWaWV3cG9ydFwiLFxuICAgIFwiV0FJVF9GQUlMRURcIixcbiAgICBcIldFQktJVF9GSUxURVJfUlVMRVwiLFxuICAgIFwiV0VCS0lUX0tFWUZSQU1FU19SVUxFXCIsXG4gICAgXCJXRUJLSVRfS0VZRlJBTUVfUlVMRVwiLFxuICAgIFwiV0VCS0lUX1JFR0lPTl9SVUxFXCIsXG4gICAgXCJXUk9OR19ET0NVTUVOVF9FUlJcIixcbiAgICBcIldha2VMb2NrXCIsXG4gICAgXCJXYWtlTG9ja1NlbnRpbmVsXCIsXG4gICAgXCJXYXNtQW55UmVmXCIsXG4gICAgXCJXYXZlU2hhcGVyTm9kZVwiLFxuICAgIFwiV2Vha01hcFwiLFxuICAgIFwiV2Vha1JlZlwiLFxuICAgIFwiV2Vha1NldFwiLFxuICAgIFwiV2ViQXNzZW1ibHlcIixcbiAgICBcIldlYkdMMlJlbmRlcmluZ0NvbnRleHRcIixcbiAgICBcIldlYkdMQWN0aXZlSW5mb1wiLFxuICAgIFwiV2ViR0xCdWZmZXJcIixcbiAgICBcIldlYkdMQ29udGV4dEV2ZW50XCIsXG4gICAgXCJXZWJHTEZyYW1lYnVmZmVyXCIsXG4gICAgXCJXZWJHTFByb2dyYW1cIixcbiAgICBcIldlYkdMUXVlcnlcIixcbiAgICBcIldlYkdMUmVuZGVyYnVmZmVyXCIsXG4gICAgXCJXZWJHTFJlbmRlcmluZ0NvbnRleHRcIixcbiAgICBcIldlYkdMU2FtcGxlclwiLFxuICAgIFwiV2ViR0xTaGFkZXJcIixcbiAgICBcIldlYkdMU2hhZGVyUHJlY2lzaW9uRm9ybWF0XCIsXG4gICAgXCJXZWJHTFN5bmNcIixcbiAgICBcIldlYkdMVGV4dHVyZVwiLFxuICAgIFwiV2ViR0xUcmFuc2Zvcm1GZWVkYmFja1wiLFxuICAgIFwiV2ViR0xVbmlmb3JtTG9jYXRpb25cIixcbiAgICBcIldlYkdMVmVydGV4QXJyYXlcIixcbiAgICBcIldlYkdMVmVydGV4QXJyYXlPYmplY3RcIixcbiAgICBcIldlYktpdEFuaW1hdGlvbkV2ZW50XCIsXG4gICAgXCJXZWJLaXRCbG9iQnVpbGRlclwiLFxuICAgIFwiV2ViS2l0Q1NTRmlsdGVyUnVsZVwiLFxuICAgIFwiV2ViS2l0Q1NTRmlsdGVyVmFsdWVcIixcbiAgICBcIldlYktpdENTU0tleWZyYW1lUnVsZVwiLFxuICAgIFwiV2ViS2l0Q1NTS2V5ZnJhbWVzUnVsZVwiLFxuICAgIFwiV2ViS2l0Q1NTTWF0cml4XCIsXG4gICAgXCJXZWJLaXRDU1NSZWdpb25SdWxlXCIsXG4gICAgXCJXZWJLaXRDU1NUcmFuc2Zvcm1WYWx1ZVwiLFxuICAgIFwiV2ViS2l0RGF0YUN1ZVwiLFxuICAgIFwiV2ViS2l0R2FtZXBhZFwiLFxuICAgIFwiV2ViS2l0TWVkaWFLZXlFcnJvclwiLFxuICAgIFwiV2ViS2l0TWVkaWFLZXlNZXNzYWdlRXZlbnRcIixcbiAgICBcIldlYktpdE1lZGlhS2V5U2Vzc2lvblwiLFxuICAgIFwiV2ViS2l0TWVkaWFLZXlzXCIsXG4gICAgXCJXZWJLaXRNZWRpYVNvdXJjZVwiLFxuICAgIFwiV2ViS2l0TXV0YXRpb25PYnNlcnZlclwiLFxuICAgIFwiV2ViS2l0TmFtZXNwYWNlXCIsXG4gICAgXCJXZWJLaXRQbGF5YmFja1RhcmdldEF2YWlsYWJpbGl0eUV2ZW50XCIsXG4gICAgXCJXZWJLaXRQb2ludFwiLFxuICAgIFwiV2ViS2l0U2hhZG93Um9vdFwiLFxuICAgIFwiV2ViS2l0U291cmNlQnVmZmVyXCIsXG4gICAgXCJXZWJLaXRTb3VyY2VCdWZmZXJMaXN0XCIsXG4gICAgXCJXZWJLaXRUcmFuc2l0aW9uRXZlbnRcIixcbiAgICBcIldlYlNvY2tldFwiLFxuICAgIFwiV2Via2l0QWxpZ25Db250ZW50XCIsXG4gICAgXCJXZWJraXRBbGlnbkl0ZW1zXCIsXG4gICAgXCJXZWJraXRBbGlnblNlbGZcIixcbiAgICBcIldlYmtpdEFuaW1hdGlvblwiLFxuICAgIFwiV2Via2l0QW5pbWF0aW9uRGVsYXlcIixcbiAgICBcIldlYmtpdEFuaW1hdGlvbkRpcmVjdGlvblwiLFxuICAgIFwiV2Via2l0QW5pbWF0aW9uRHVyYXRpb25cIixcbiAgICBcIldlYmtpdEFuaW1hdGlvbkZpbGxNb2RlXCIsXG4gICAgXCJXZWJraXRBbmltYXRpb25JdGVyYXRpb25Db3VudFwiLFxuICAgIFwiV2Via2l0QW5pbWF0aW9uTmFtZVwiLFxuICAgIFwiV2Via2l0QW5pbWF0aW9uUGxheVN0YXRlXCIsXG4gICAgXCJXZWJraXRBbmltYXRpb25UaW1pbmdGdW5jdGlvblwiLFxuICAgIFwiV2Via2l0QXBwZWFyYW5jZVwiLFxuICAgIFwiV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5XCIsXG4gICAgXCJXZWJraXRCYWNrZ3JvdW5kQ2xpcFwiLFxuICAgIFwiV2Via2l0QmFja2dyb3VuZE9yaWdpblwiLFxuICAgIFwiV2Via2l0QmFja2dyb3VuZFNpemVcIixcbiAgICBcIldlYmtpdEJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIixcbiAgICBcIldlYmtpdEJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXG4gICAgXCJXZWJraXRCb3JkZXJJbWFnZVwiLFxuICAgIFwiV2Via2l0Qm9yZGVyUmFkaXVzXCIsXG4gICAgXCJXZWJraXRCb3JkZXJUb3BMZWZ0UmFkaXVzXCIsXG4gICAgXCJXZWJraXRCb3JkZXJUb3BSaWdodFJhZGl1c1wiLFxuICAgIFwiV2Via2l0Qm94QWxpZ25cIixcbiAgICBcIldlYmtpdEJveERpcmVjdGlvblwiLFxuICAgIFwiV2Via2l0Qm94RmxleFwiLFxuICAgIFwiV2Via2l0Qm94T3JkaW5hbEdyb3VwXCIsXG4gICAgXCJXZWJraXRCb3hPcmllbnRcIixcbiAgICBcIldlYmtpdEJveFBhY2tcIixcbiAgICBcIldlYmtpdEJveFNoYWRvd1wiLFxuICAgIFwiV2Via2l0Qm94U2l6aW5nXCIsXG4gICAgXCJXZWJraXRGaWx0ZXJcIixcbiAgICBcIldlYmtpdEZsZXhcIixcbiAgICBcIldlYmtpdEZsZXhCYXNpc1wiLFxuICAgIFwiV2Via2l0RmxleERpcmVjdGlvblwiLFxuICAgIFwiV2Via2l0RmxleEZsb3dcIixcbiAgICBcIldlYmtpdEZsZXhHcm93XCIsXG4gICAgXCJXZWJraXRGbGV4U2hyaW5rXCIsXG4gICAgXCJXZWJraXRGbGV4V3JhcFwiLFxuICAgIFwiV2Via2l0SnVzdGlmeUNvbnRlbnRcIixcbiAgICBcIldlYmtpdExpbmVDbGFtcFwiLFxuICAgIFwiV2Via2l0TWFza1wiLFxuICAgIFwiV2Via2l0TWFza0NsaXBcIixcbiAgICBcIldlYmtpdE1hc2tDb21wb3NpdGVcIixcbiAgICBcIldlYmtpdE1hc2tJbWFnZVwiLFxuICAgIFwiV2Via2l0TWFza09yaWdpblwiLFxuICAgIFwiV2Via2l0TWFza1Bvc2l0aW9uXCIsXG4gICAgXCJXZWJraXRNYXNrUG9zaXRpb25YXCIsXG4gICAgXCJXZWJraXRNYXNrUG9zaXRpb25ZXCIsXG4gICAgXCJXZWJraXRNYXNrUmVwZWF0XCIsXG4gICAgXCJXZWJraXRNYXNrU2l6ZVwiLFxuICAgIFwiV2Via2l0T3JkZXJcIixcbiAgICBcIldlYmtpdFBlcnNwZWN0aXZlXCIsXG4gICAgXCJXZWJraXRQZXJzcGVjdGl2ZU9yaWdpblwiLFxuICAgIFwiV2Via2l0VGV4dEZpbGxDb2xvclwiLFxuICAgIFwiV2Via2l0VGV4dFNpemVBZGp1c3RcIixcbiAgICBcIldlYmtpdFRleHRTdHJva2VcIixcbiAgICBcIldlYmtpdFRleHRTdHJva2VDb2xvclwiLFxuICAgIFwiV2Via2l0VGV4dFN0cm9rZVdpZHRoXCIsXG4gICAgXCJXZWJraXRUcmFuc2Zvcm1cIixcbiAgICBcIldlYmtpdFRyYW5zZm9ybU9yaWdpblwiLFxuICAgIFwiV2Via2l0VHJhbnNmb3JtU3R5bGVcIixcbiAgICBcIldlYmtpdFRyYW5zaXRpb25cIixcbiAgICBcIldlYmtpdFRyYW5zaXRpb25EZWxheVwiLFxuICAgIFwiV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXCIsXG4gICAgXCJXZWJraXRUcmFuc2l0aW9uUHJvcGVydHlcIixcbiAgICBcIldlYmtpdFRyYW5zaXRpb25UaW1pbmdGdW5jdGlvblwiLFxuICAgIFwiV2Via2l0VXNlclNlbGVjdFwiLFxuICAgIFwiV2hlZWxFdmVudFwiLFxuICAgIFwiV2luZG93XCIsXG4gICAgXCJXb3JrZXJcIixcbiAgICBcIldvcmtsZXRcIixcbiAgICBcIldyaXRhYmxlU3RyZWFtXCIsXG4gICAgXCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJcIixcbiAgICBcIlhNTERvY3VtZW50XCIsXG4gICAgXCJYTUxIdHRwUmVxdWVzdFwiLFxuICAgIFwiWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldFwiLFxuICAgIFwiWE1MSHR0cFJlcXVlc3RFeGNlcHRpb25cIixcbiAgICBcIlhNTEh0dHBSZXF1ZXN0UHJvZ3Jlc3NFdmVudFwiLFxuICAgIFwiWE1MSHR0cFJlcXVlc3RVcGxvYWRcIixcbiAgICBcIlhNTFNlcmlhbGl6ZXJcIixcbiAgICBcIlhNTFN0eWxlc2hlZXRQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cIixcbiAgICBcIlhQYXRoRXZhbHVhdG9yXCIsXG4gICAgXCJYUGF0aEV4Y2VwdGlvblwiLFxuICAgIFwiWFBhdGhFeHByZXNzaW9uXCIsXG4gICAgXCJYUGF0aE5TUmVzb2x2ZXJcIixcbiAgICBcIlhQYXRoUmVzdWx0XCIsXG4gICAgXCJYUkJvdW5kZWRSZWZlcmVuY2VTcGFjZVwiLFxuICAgIFwiWFJET01PdmVybGF5U3RhdGVcIixcbiAgICBcIlhSRnJhbWVcIixcbiAgICBcIlhSSGl0VGVzdFJlc3VsdFwiLFxuICAgIFwiWFJIaXRUZXN0U291cmNlXCIsXG4gICAgXCJYUklucHV0U291cmNlXCIsXG4gICAgXCJYUklucHV0U291cmNlQXJyYXlcIixcbiAgICBcIlhSSW5wdXRTb3VyY2VFdmVudFwiLFxuICAgIFwiWFJJbnB1dFNvdXJjZXNDaGFuZ2VFdmVudFwiLFxuICAgIFwiWFJMYXllclwiLFxuICAgIFwiWFJQb3NlXCIsXG4gICAgXCJYUlJheVwiLFxuICAgIFwiWFJSZWZlcmVuY2VTcGFjZVwiLFxuICAgIFwiWFJSZWZlcmVuY2VTcGFjZUV2ZW50XCIsXG4gICAgXCJYUlJlbmRlclN0YXRlXCIsXG4gICAgXCJYUlJpZ2lkVHJhbnNmb3JtXCIsXG4gICAgXCJYUlNlc3Npb25cIixcbiAgICBcIlhSU2Vzc2lvbkV2ZW50XCIsXG4gICAgXCJYUlNwYWNlXCIsXG4gICAgXCJYUlN5c3RlbVwiLFxuICAgIFwiWFJUcmFuc2llbnRJbnB1dEhpdFRlc3RSZXN1bHRcIixcbiAgICBcIlhSVHJhbnNpZW50SW5wdXRIaXRUZXN0U291cmNlXCIsXG4gICAgXCJYUlZpZXdcIixcbiAgICBcIlhSVmlld2VyUG9zZVwiLFxuICAgIFwiWFJWaWV3cG9ydFwiLFxuICAgIFwiWFJXZWJHTExheWVyXCIsXG4gICAgXCJYU0xUUHJvY2Vzc29yXCIsXG4gICAgXCJaRVJPXCIsXG4gICAgXCJfWEQwTV9cIixcbiAgICBcIl9ZRDBNX1wiLFxuICAgIFwiX19kZWZpbmVHZXR0ZXJfX1wiLFxuICAgIFwiX19kZWZpbmVTZXR0ZXJfX1wiLFxuICAgIFwiX19sb29rdXBHZXR0ZXJfX1wiLFxuICAgIFwiX19sb29rdXBTZXR0ZXJfX1wiLFxuICAgIFwiX19vcGVyYVwiLFxuICAgIFwiX19wcm90b19fXCIsXG4gICAgXCJfYnJvd3NlcmpzcmFuXCIsXG4gICAgXCJhXCIsXG4gICAgXCJhTGlua1wiLFxuICAgIFwiYWJiclwiLFxuICAgIFwiYWJvcnRcIixcbiAgICBcImFib3J0ZWRcIixcbiAgICBcImFic1wiLFxuICAgIFwiYWJzb2x1dGVcIixcbiAgICBcImFjY2VsZXJhdGlvblwiLFxuICAgIFwiYWNjZWxlcmF0aW9uSW5jbHVkaW5nR3Jhdml0eVwiLFxuICAgIFwiYWNjZWxlcmF0b3JcIixcbiAgICBcImFjY2VwdFwiLFxuICAgIFwiYWNjZXB0Q2hhcnNldFwiLFxuICAgIFwiYWNjZXB0Tm9kZVwiLFxuICAgIFwiYWNjZXNzS2V5XCIsXG4gICAgXCJhY2Nlc3NLZXlMYWJlbFwiLFxuICAgIFwiYWNjdXJhY3lcIixcbiAgICBcImFjb3NcIixcbiAgICBcImFjb3NoXCIsXG4gICAgXCJhY3Rpb25cIixcbiAgICBcImFjdGlvblVSTFwiLFxuICAgIFwiYWN0aW9uc1wiLFxuICAgIFwiYWN0aXZhdGVkXCIsXG4gICAgXCJhY3RpdmVcIixcbiAgICBcImFjdGl2ZUN1ZXNcIixcbiAgICBcImFjdGl2ZUVsZW1lbnRcIixcbiAgICBcImFjdGl2ZVNvdXJjZUJ1ZmZlcnNcIixcbiAgICBcImFjdGl2ZVNvdXJjZUNvdW50XCIsXG4gICAgXCJhY3RpdmVUZXh0dXJlXCIsXG4gICAgXCJhY3RpdmVWUkRpc3BsYXlzXCIsXG4gICAgXCJhY3R1YWxCb3VuZGluZ0JveEFzY2VudFwiLFxuICAgIFwiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50XCIsXG4gICAgXCJhY3R1YWxCb3VuZGluZ0JveExlZnRcIixcbiAgICBcImFjdHVhbEJvdW5kaW5nQm94UmlnaHRcIixcbiAgICBcImFkZFwiLFxuICAgIFwiYWRkQWxsXCIsXG4gICAgXCJhZGRCZWhhdmlvclwiLFxuICAgIFwiYWRkQ2FuZGlkYXRlXCIsXG4gICAgXCJhZGRDb2xvclN0b3BcIixcbiAgICBcImFkZEN1ZVwiLFxuICAgIFwiYWRkRWxlbWVudFwiLFxuICAgIFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgIFwiYWRkRmlsdGVyXCIsXG4gICAgXCJhZGRGcm9tU3RyaW5nXCIsXG4gICAgXCJhZGRGcm9tVXJpXCIsXG4gICAgXCJhZGRJY2VDYW5kaWRhdGVcIixcbiAgICBcImFkZEltcG9ydFwiLFxuICAgIFwiYWRkTGlzdGVuZXJcIixcbiAgICBcImFkZE1vZHVsZVwiLFxuICAgIFwiYWRkTmFtZWRcIixcbiAgICBcImFkZFBhZ2VSdWxlXCIsXG4gICAgXCJhZGRQYXRoXCIsXG4gICAgXCJhZGRQb2ludGVyXCIsXG4gICAgXCJhZGRSYW5nZVwiLFxuICAgIFwiYWRkUmVnaW9uXCIsXG4gICAgXCJhZGRSdWxlXCIsXG4gICAgXCJhZGRTZWFyY2hFbmdpbmVcIixcbiAgICBcImFkZFNvdXJjZUJ1ZmZlclwiLFxuICAgIFwiYWRkU3RyZWFtXCIsXG4gICAgXCJhZGRUZXh0VHJhY2tcIixcbiAgICBcImFkZFRyYWNrXCIsXG4gICAgXCJhZGRUcmFuc2NlaXZlclwiLFxuICAgIFwiYWRkV2FrZUxvY2tMaXN0ZW5lclwiLFxuICAgIFwiYWRkZWRcIixcbiAgICBcImFkZGVkTm9kZXNcIixcbiAgICBcImFkZGl0aW9uYWxOYW1lXCIsXG4gICAgXCJhZGRpdGl2ZVN5bWJvbHNcIixcbiAgICBcImFkZG9uc1wiLFxuICAgIFwiYWRkcmVzc1wiLFxuICAgIFwiYWRkcmVzc0xpbmVcIixcbiAgICBcImFkb3B0Tm9kZVwiLFxuICAgIFwiYWRvcHRlZFN0eWxlU2hlZXRzXCIsXG4gICAgXCJhZHJcIixcbiAgICBcImFkdmFuY2VcIixcbiAgICBcImFmdGVyXCIsXG4gICAgXCJhbGJ1bVwiLFxuICAgIFwiYWxlcnRcIixcbiAgICBcImFsZ29yaXRobVwiLFxuICAgIFwiYWxpZ25cIixcbiAgICBcImFsaWduLWNvbnRlbnRcIixcbiAgICBcImFsaWduLWl0ZW1zXCIsXG4gICAgXCJhbGlnbi1zZWxmXCIsXG4gICAgXCJhbGlnbkNvbnRlbnRcIixcbiAgICBcImFsaWduSXRlbXNcIixcbiAgICBcImFsaWduU2VsZlwiLFxuICAgIFwiYWxpZ25tZW50QmFzZWxpbmVcIixcbiAgICBcImFsaW5rQ29sb3JcIixcbiAgICBcImFsbFwiLFxuICAgIFwiYWxsU2V0dGxlZFwiLFxuICAgIFwiYWxsb3dcIixcbiAgICBcImFsbG93RnVsbHNjcmVlblwiLFxuICAgIFwiYWxsb3dQYXltZW50UmVxdWVzdFwiLFxuICAgIFwiYWxsb3dlZERpcmVjdGlvbnNcIixcbiAgICBcImFsbG93ZWRGZWF0dXJlc1wiLFxuICAgIFwiYWxsb3dlZFRvUGxheVwiLFxuICAgIFwiYWxsb3dzRmVhdHVyZVwiLFxuICAgIFwiYWxwaGFcIixcbiAgICBcImFsdFwiLFxuICAgIFwiYWx0R3JhcGhLZXlcIixcbiAgICBcImFsdEh0bWxcIixcbiAgICBcImFsdEtleVwiLFxuICAgIFwiYWx0TGVmdFwiLFxuICAgIFwiYWx0ZXJuYXRlXCIsXG4gICAgXCJhbHRlcm5hdGVTZXR0aW5nXCIsXG4gICAgXCJhbHRlcm5hdGVzXCIsXG4gICAgXCJhbHRpdHVkZVwiLFxuICAgIFwiYWx0aXR1ZGVBY2N1cmFjeVwiLFxuICAgIFwiYW1wbGl0dWRlXCIsXG4gICAgXCJhbmNlc3Rvck9yaWdpbnNcIixcbiAgICBcImFuY2hvclwiLFxuICAgIFwiYW5jaG9yTm9kZVwiLFxuICAgIFwiYW5jaG9yT2Zmc2V0XCIsXG4gICAgXCJhbmNob3JzXCIsXG4gICAgXCJhbmRcIixcbiAgICBcImFuZ2xlXCIsXG4gICAgXCJhbmd1bGFyQWNjZWxlcmF0aW9uXCIsXG4gICAgXCJhbmd1bGFyVmVsb2NpdHlcIixcbiAgICBcImFuaW1WYWxcIixcbiAgICBcImFuaW1hdGVcIixcbiAgICBcImFuaW1hdGVkSW5zdGFuY2VSb290XCIsXG4gICAgXCJhbmltYXRlZE5vcm1hbGl6ZWRQYXRoU2VnTGlzdFwiLFxuICAgIFwiYW5pbWF0ZWRQYXRoU2VnTGlzdFwiLFxuICAgIFwiYW5pbWF0ZWRQb2ludHNcIixcbiAgICBcImFuaW1hdGlvblwiLFxuICAgIFwiYW5pbWF0aW9uLWRlbGF5XCIsXG4gICAgXCJhbmltYXRpb24tZGlyZWN0aW9uXCIsXG4gICAgXCJhbmltYXRpb24tZHVyYXRpb25cIixcbiAgICBcImFuaW1hdGlvbi1maWxsLW1vZGVcIixcbiAgICBcImFuaW1hdGlvbi1pdGVyYXRpb24tY291bnRcIixcbiAgICBcImFuaW1hdGlvbi1uYW1lXCIsXG4gICAgXCJhbmltYXRpb24tcGxheS1zdGF0ZVwiLFxuICAgIFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblwiLFxuICAgIFwiYW5pbWF0aW9uRGVsYXlcIixcbiAgICBcImFuaW1hdGlvbkRpcmVjdGlvblwiLFxuICAgIFwiYW5pbWF0aW9uRHVyYXRpb25cIixcbiAgICBcImFuaW1hdGlvbkZpbGxNb2RlXCIsXG4gICAgXCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiLFxuICAgIFwiYW5pbWF0aW9uTmFtZVwiLFxuICAgIFwiYW5pbWF0aW9uUGxheVN0YXRlXCIsXG4gICAgXCJhbmltYXRpb25TdGFydFRpbWVcIixcbiAgICBcImFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uXCIsXG4gICAgXCJhbmltYXRpb25zUGF1c2VkXCIsXG4gICAgXCJhbm5pdmVyc2FyeVwiLFxuICAgIFwiYW50aWFsaWFzXCIsXG4gICAgXCJhbnRpY2lwYXRlZFJlbW92YWxcIixcbiAgICBcImFueVwiLFxuICAgIFwiYXBwXCIsXG4gICAgXCJhcHBDb2RlTmFtZVwiLFxuICAgIFwiYXBwTWlub3JWZXJzaW9uXCIsXG4gICAgXCJhcHBOYW1lXCIsXG4gICAgXCJhcHBOb3RpZmljYXRpb25zXCIsXG4gICAgXCJhcHBWZXJzaW9uXCIsXG4gICAgXCJhcHBlYXJhbmNlXCIsXG4gICAgXCJhcHBlbmRcIixcbiAgICBcImFwcGVuZEJ1ZmZlclwiLFxuICAgIFwiYXBwZW5kQ2hpbGRcIixcbiAgICBcImFwcGVuZERhdGFcIixcbiAgICBcImFwcGVuZEl0ZW1cIixcbiAgICBcImFwcGVuZE1lZGl1bVwiLFxuICAgIFwiYXBwZW5kTmFtZWRcIixcbiAgICBcImFwcGVuZFJ1bGVcIixcbiAgICBcImFwcGVuZFN0cmVhbVwiLFxuICAgIFwiYXBwZW5kV2luZG93RW5kXCIsXG4gICAgXCJhcHBlbmRXaW5kb3dTdGFydFwiLFxuICAgIFwiYXBwbGV0c1wiLFxuICAgIFwiYXBwbGljYXRpb25DYWNoZVwiLFxuICAgIFwiYXBwbGljYXRpb25TZXJ2ZXJLZXlcIixcbiAgICBcImFwcGx5XCIsXG4gICAgXCJhcHBseUNvbnN0cmFpbnRzXCIsXG4gICAgXCJhcHBseUVsZW1lbnRcIixcbiAgICBcImFyY1wiLFxuICAgIFwiYXJjVG9cIixcbiAgICBcImFyY2hpdmVcIixcbiAgICBcImFyZWFzXCIsXG4gICAgXCJhcmd1bWVudHNcIixcbiAgICBcImFyaWFBdG9taWNcIixcbiAgICBcImFyaWFBdXRvQ29tcGxldGVcIixcbiAgICBcImFyaWFCdXN5XCIsXG4gICAgXCJhcmlhQ2hlY2tlZFwiLFxuICAgIFwiYXJpYUNvbENvdW50XCIsXG4gICAgXCJhcmlhQ29sSW5kZXhcIixcbiAgICBcImFyaWFDb2xTcGFuXCIsXG4gICAgXCJhcmlhQ3VycmVudFwiLFxuICAgIFwiYXJpYURlc2NyaXB0aW9uXCIsXG4gICAgXCJhcmlhRGlzYWJsZWRcIixcbiAgICBcImFyaWFFeHBhbmRlZFwiLFxuICAgIFwiYXJpYUhhc1BvcHVwXCIsXG4gICAgXCJhcmlhSGlkZGVuXCIsXG4gICAgXCJhcmlhS2V5U2hvcnRjdXRzXCIsXG4gICAgXCJhcmlhTGFiZWxcIixcbiAgICBcImFyaWFMZXZlbFwiLFxuICAgIFwiYXJpYUxpdmVcIixcbiAgICBcImFyaWFNb2RhbFwiLFxuICAgIFwiYXJpYU11bHRpTGluZVwiLFxuICAgIFwiYXJpYU11bHRpU2VsZWN0YWJsZVwiLFxuICAgIFwiYXJpYU9yaWVudGF0aW9uXCIsXG4gICAgXCJhcmlhUGxhY2Vob2xkZXJcIixcbiAgICBcImFyaWFQb3NJblNldFwiLFxuICAgIFwiYXJpYVByZXNzZWRcIixcbiAgICBcImFyaWFSZWFkT25seVwiLFxuICAgIFwiYXJpYVJlbGV2YW50XCIsXG4gICAgXCJhcmlhUmVxdWlyZWRcIixcbiAgICBcImFyaWFSb2xlRGVzY3JpcHRpb25cIixcbiAgICBcImFyaWFSb3dDb3VudFwiLFxuICAgIFwiYXJpYVJvd0luZGV4XCIsXG4gICAgXCJhcmlhUm93U3BhblwiLFxuICAgIFwiYXJpYVNlbGVjdGVkXCIsXG4gICAgXCJhcmlhU2V0U2l6ZVwiLFxuICAgIFwiYXJpYVNvcnRcIixcbiAgICBcImFyaWFWYWx1ZU1heFwiLFxuICAgIFwiYXJpYVZhbHVlTWluXCIsXG4gICAgXCJhcmlhVmFsdWVOb3dcIixcbiAgICBcImFyaWFWYWx1ZVRleHRcIixcbiAgICBcImFycmF5QnVmZmVyXCIsXG4gICAgXCJhcnRpc3RcIixcbiAgICBcImFydHdvcmtcIixcbiAgICBcImFzXCIsXG4gICAgXCJhc0ludE5cIixcbiAgICBcImFzVWludE5cIixcbiAgICBcImFzaW5cIixcbiAgICBcImFzaW5oXCIsXG4gICAgXCJhc3NlcnRcIixcbiAgICBcImFzc2lnblwiLFxuICAgIFwiYXNzaWduZWRFbGVtZW50c1wiLFxuICAgIFwiYXNzaWduZWROb2Rlc1wiLFxuICAgIFwiYXNzaWduZWRTbG90XCIsXG4gICAgXCJhc3luY1wiLFxuICAgIFwiYXN5bmNJdGVyYXRvclwiLFxuICAgIFwiYXRFbmRcIixcbiAgICBcImF0YW5cIixcbiAgICBcImF0YW4yXCIsXG4gICAgXCJhdGFuaFwiLFxuICAgIFwiYXRvYlwiLFxuICAgIFwiYXR0YWNoRXZlbnRcIixcbiAgICBcImF0dGFjaEludGVybmFsc1wiLFxuICAgIFwiYXR0YWNoU2hhZGVyXCIsXG4gICAgXCJhdHRhY2hTaGFkb3dcIixcbiAgICBcImF0dGFjaG1lbnRzXCIsXG4gICAgXCJhdHRhY2tcIixcbiAgICBcImF0dGVzdGF0aW9uT2JqZWN0XCIsXG4gICAgXCJhdHRyQ2hhbmdlXCIsXG4gICAgXCJhdHRyTmFtZVwiLFxuICAgIFwiYXR0cmlidXRlRmlsdGVyXCIsXG4gICAgXCJhdHRyaWJ1dGVOYW1lXCIsXG4gICAgXCJhdHRyaWJ1dGVOYW1lc3BhY2VcIixcbiAgICBcImF0dHJpYnV0ZU9sZFZhbHVlXCIsXG4gICAgXCJhdHRyaWJ1dGVTdHlsZU1hcFwiLFxuICAgIFwiYXR0cmlidXRlc1wiLFxuICAgIFwiYXR0cmlidXRpb25cIixcbiAgICBcImF1ZGlvQml0c1BlclNlY29uZFwiLFxuICAgIFwiYXVkaW9UcmFja3NcIixcbiAgICBcImF1ZGlvV29ya2xldFwiLFxuICAgIFwiYXV0aGVudGljYXRlZFNpZ25lZFdyaXRlc1wiLFxuICAgIFwiYXV0aGVudGljYXRvckRhdGFcIixcbiAgICBcImF1dG9JbmNyZW1lbnRcIixcbiAgICBcImF1dG9idWZmZXJcIixcbiAgICBcImF1dG9jYXBpdGFsaXplXCIsXG4gICAgXCJhdXRvY29tcGxldGVcIixcbiAgICBcImF1dG9jb3JyZWN0XCIsXG4gICAgXCJhdXRvZm9jdXNcIixcbiAgICBcImF1dG9tYXRpb25SYXRlXCIsXG4gICAgXCJhdXRvcGxheVwiLFxuICAgIFwiYXZhaWxIZWlnaHRcIixcbiAgICBcImF2YWlsTGVmdFwiLFxuICAgIFwiYXZhaWxUb3BcIixcbiAgICBcImF2YWlsV2lkdGhcIixcbiAgICBcImF2YWlsYWJpbGl0eVwiLFxuICAgIFwiYXZhaWxhYmxlXCIsXG4gICAgXCJhdmVyc2lvblwiLFxuICAgIFwiYXhcIixcbiAgICBcImF4ZXNcIixcbiAgICBcImF4aXNcIixcbiAgICBcImF5XCIsXG4gICAgXCJhemltdXRoXCIsXG4gICAgXCJiXCIsXG4gICAgXCJiYWNrXCIsXG4gICAgXCJiYWNrZmFjZS12aXNpYmlsaXR5XCIsXG4gICAgXCJiYWNrZmFjZVZpc2liaWxpdHlcIixcbiAgICBcImJhY2tncm91bmRcIixcbiAgICBcImJhY2tncm91bmQtYXR0YWNobWVudFwiLFxuICAgIFwiYmFja2dyb3VuZC1ibGVuZC1tb2RlXCIsXG4gICAgXCJiYWNrZ3JvdW5kLWNsaXBcIixcbiAgICBcImJhY2tncm91bmQtY29sb3JcIixcbiAgICBcImJhY2tncm91bmQtaW1hZ2VcIixcbiAgICBcImJhY2tncm91bmQtb3JpZ2luXCIsXG4gICAgXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIsXG4gICAgXCJiYWNrZ3JvdW5kLXBvc2l0aW9uLXhcIixcbiAgICBcImJhY2tncm91bmQtcG9zaXRpb24teVwiLFxuICAgIFwiYmFja2dyb3VuZC1yZXBlYXRcIixcbiAgICBcImJhY2tncm91bmQtc2l6ZVwiLFxuICAgIFwiYmFja2dyb3VuZEF0dGFjaG1lbnRcIixcbiAgICBcImJhY2tncm91bmRCbGVuZE1vZGVcIixcbiAgICBcImJhY2tncm91bmRDbGlwXCIsXG4gICAgXCJiYWNrZ3JvdW5kQ29sb3JcIixcbiAgICBcImJhY2tncm91bmRGZXRjaFwiLFxuICAgIFwiYmFja2dyb3VuZEltYWdlXCIsXG4gICAgXCJiYWNrZ3JvdW5kT3JpZ2luXCIsXG4gICAgXCJiYWNrZ3JvdW5kUG9zaXRpb25cIixcbiAgICBcImJhY2tncm91bmRQb3NpdGlvblhcIixcbiAgICBcImJhY2tncm91bmRQb3NpdGlvbllcIixcbiAgICBcImJhY2tncm91bmRSZXBlYXRcIixcbiAgICBcImJhY2tncm91bmRTaXplXCIsXG4gICAgXCJiYWRJbnB1dFwiLFxuICAgIFwiYmFkZ2VcIixcbiAgICBcImJhbGFuY2VcIixcbiAgICBcImJhc2VGcmVxdWVuY3lYXCIsXG4gICAgXCJiYXNlRnJlcXVlbmN5WVwiLFxuICAgIFwiYmFzZUxhdGVuY3lcIixcbiAgICBcImJhc2VMYXllclwiLFxuICAgIFwiYmFzZU5vZGVcIixcbiAgICBcImJhc2VPZmZzZXRcIixcbiAgICBcImJhc2VVUklcIixcbiAgICBcImJhc2VWYWxcIixcbiAgICBcImJhc2VsaW5lU2hpZnRcIixcbiAgICBcImJhdHRlcnlcIixcbiAgICBcImJkYXlcIixcbiAgICBcImJlZm9yZVwiLFxuICAgIFwiYmVnaW5FbGVtZW50XCIsXG4gICAgXCJiZWdpbkVsZW1lbnRBdFwiLFxuICAgIFwiYmVnaW5QYXRoXCIsXG4gICAgXCJiZWdpblF1ZXJ5XCIsXG4gICAgXCJiZWdpblRyYW5zZm9ybUZlZWRiYWNrXCIsXG4gICAgXCJiZWhhdmlvclwiLFxuICAgIFwiYmVoYXZpb3JDb29raWVcIixcbiAgICBcImJlaGF2aW9yUGFydFwiLFxuICAgIFwiYmVoYXZpb3JVcm5zXCIsXG4gICAgXCJiZXRhXCIsXG4gICAgXCJiZXppZXJDdXJ2ZVRvXCIsXG4gICAgXCJiZ0NvbG9yXCIsXG4gICAgXCJiZ1Byb3BlcnRpZXNcIixcbiAgICBcImJpYXNcIixcbiAgICBcImJpZ1wiLFxuICAgIFwiYmlnaW50NjRcIixcbiAgICBcImJpZ3VpbnQ2NFwiLFxuICAgIFwiYmluYXJ5VHlwZVwiLFxuICAgIFwiYmluZFwiLFxuICAgIFwiYmluZEF0dHJpYkxvY2F0aW9uXCIsXG4gICAgXCJiaW5kQnVmZmVyXCIsXG4gICAgXCJiaW5kQnVmZmVyQmFzZVwiLFxuICAgIFwiYmluZEJ1ZmZlclJhbmdlXCIsXG4gICAgXCJiaW5kRnJhbWVidWZmZXJcIixcbiAgICBcImJpbmRSZW5kZXJidWZmZXJcIixcbiAgICBcImJpbmRTYW1wbGVyXCIsXG4gICAgXCJiaW5kVGV4dHVyZVwiLFxuICAgIFwiYmluZFRyYW5zZm9ybUZlZWRiYWNrXCIsXG4gICAgXCJiaW5kVmVydGV4QXJyYXlcIixcbiAgICBcImJsZW5kQ29sb3JcIixcbiAgICBcImJsZW5kRXF1YXRpb25cIixcbiAgICBcImJsZW5kRXF1YXRpb25TZXBhcmF0ZVwiLFxuICAgIFwiYmxlbmRGdW5jXCIsXG4gICAgXCJibGVuZEZ1bmNTZXBhcmF0ZVwiLFxuICAgIFwiYmxpbmtcIixcbiAgICBcImJsaXRGcmFtZWJ1ZmZlclwiLFxuICAgIFwiYmxvYlwiLFxuICAgIFwiYmxvY2stc2l6ZVwiLFxuICAgIFwiYmxvY2tEaXJlY3Rpb25cIixcbiAgICBcImJsb2NrU2l6ZVwiLFxuICAgIFwiYmxvY2tlZFVSSVwiLFxuICAgIFwiYmx1ZVwiLFxuICAgIFwiYmx1ZXRvb3RoXCIsXG4gICAgXCJibHVyXCIsXG4gICAgXCJib2R5XCIsXG4gICAgXCJib2R5VXNlZFwiLFxuICAgIFwiYm9sZFwiLFxuICAgIFwiYm9va21hcmtzXCIsXG4gICAgXCJib29sZWFuVmFsdWVcIixcbiAgICBcImJvcmRlclwiLFxuICAgIFwiYm9yZGVyLWJsb2NrXCIsXG4gICAgXCJib3JkZXItYmxvY2stY29sb3JcIixcbiAgICBcImJvcmRlci1ibG9jay1lbmRcIixcbiAgICBcImJvcmRlci1ibG9jay1lbmQtY29sb3JcIixcbiAgICBcImJvcmRlci1ibG9jay1lbmQtc3R5bGVcIixcbiAgICBcImJvcmRlci1ibG9jay1lbmQtd2lkdGhcIixcbiAgICBcImJvcmRlci1ibG9jay1zdGFydFwiLFxuICAgIFwiYm9yZGVyLWJsb2NrLXN0YXJ0LWNvbG9yXCIsXG4gICAgXCJib3JkZXItYmxvY2stc3RhcnQtc3R5bGVcIixcbiAgICBcImJvcmRlci1ibG9jay1zdGFydC13aWR0aFwiLFxuICAgIFwiYm9yZGVyLWJsb2NrLXN0eWxlXCIsXG4gICAgXCJib3JkZXItYmxvY2std2lkdGhcIixcbiAgICBcImJvcmRlci1ib3R0b21cIixcbiAgICBcImJvcmRlci1ib3R0b20tY29sb3JcIixcbiAgICBcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIixcbiAgICBcImJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzXCIsXG4gICAgXCJib3JkZXItYm90dG9tLXN0eWxlXCIsXG4gICAgXCJib3JkZXItYm90dG9tLXdpZHRoXCIsXG4gICAgXCJib3JkZXItY29sbGFwc2VcIixcbiAgICBcImJvcmRlci1jb2xvclwiLFxuICAgIFwiYm9yZGVyLWVuZC1lbmQtcmFkaXVzXCIsXG4gICAgXCJib3JkZXItZW5kLXN0YXJ0LXJhZGl1c1wiLFxuICAgIFwiYm9yZGVyLWltYWdlXCIsXG4gICAgXCJib3JkZXItaW1hZ2Utb3V0c2V0XCIsXG4gICAgXCJib3JkZXItaW1hZ2UtcmVwZWF0XCIsXG4gICAgXCJib3JkZXItaW1hZ2Utc2xpY2VcIixcbiAgICBcImJvcmRlci1pbWFnZS1zb3VyY2VcIixcbiAgICBcImJvcmRlci1pbWFnZS13aWR0aFwiLFxuICAgIFwiYm9yZGVyLWlubGluZVwiLFxuICAgIFwiYm9yZGVyLWlubGluZS1jb2xvclwiLFxuICAgIFwiYm9yZGVyLWlubGluZS1lbmRcIixcbiAgICBcImJvcmRlci1pbmxpbmUtZW5kLWNvbG9yXCIsXG4gICAgXCJib3JkZXItaW5saW5lLWVuZC1zdHlsZVwiLFxuICAgIFwiYm9yZGVyLWlubGluZS1lbmQtd2lkdGhcIixcbiAgICBcImJvcmRlci1pbmxpbmUtc3RhcnRcIixcbiAgICBcImJvcmRlci1pbmxpbmUtc3RhcnQtY29sb3JcIixcbiAgICBcImJvcmRlci1pbmxpbmUtc3RhcnQtc3R5bGVcIixcbiAgICBcImJvcmRlci1pbmxpbmUtc3RhcnQtd2lkdGhcIixcbiAgICBcImJvcmRlci1pbmxpbmUtc3R5bGVcIixcbiAgICBcImJvcmRlci1pbmxpbmUtd2lkdGhcIixcbiAgICBcImJvcmRlci1sZWZ0XCIsXG4gICAgXCJib3JkZXItbGVmdC1jb2xvclwiLFxuICAgIFwiYm9yZGVyLWxlZnQtc3R5bGVcIixcbiAgICBcImJvcmRlci1sZWZ0LXdpZHRoXCIsXG4gICAgXCJib3JkZXItcmFkaXVzXCIsXG4gICAgXCJib3JkZXItcmlnaHRcIixcbiAgICBcImJvcmRlci1yaWdodC1jb2xvclwiLFxuICAgIFwiYm9yZGVyLXJpZ2h0LXN0eWxlXCIsXG4gICAgXCJib3JkZXItcmlnaHQtd2lkdGhcIixcbiAgICBcImJvcmRlci1zcGFjaW5nXCIsXG4gICAgXCJib3JkZXItc3RhcnQtZW5kLXJhZGl1c1wiLFxuICAgIFwiYm9yZGVyLXN0YXJ0LXN0YXJ0LXJhZGl1c1wiLFxuICAgIFwiYm9yZGVyLXN0eWxlXCIsXG4gICAgXCJib3JkZXItdG9wXCIsXG4gICAgXCJib3JkZXItdG9wLWNvbG9yXCIsXG4gICAgXCJib3JkZXItdG9wLWxlZnQtcmFkaXVzXCIsXG4gICAgXCJib3JkZXItdG9wLXJpZ2h0LXJhZGl1c1wiLFxuICAgIFwiYm9yZGVyLXRvcC1zdHlsZVwiLFxuICAgIFwiYm9yZGVyLXRvcC13aWR0aFwiLFxuICAgIFwiYm9yZGVyLXdpZHRoXCIsXG4gICAgXCJib3JkZXJCbG9ja1wiLFxuICAgIFwiYm9yZGVyQmxvY2tDb2xvclwiLFxuICAgIFwiYm9yZGVyQmxvY2tFbmRcIixcbiAgICBcImJvcmRlckJsb2NrRW5kQ29sb3JcIixcbiAgICBcImJvcmRlckJsb2NrRW5kU3R5bGVcIixcbiAgICBcImJvcmRlckJsb2NrRW5kV2lkdGhcIixcbiAgICBcImJvcmRlckJsb2NrU3RhcnRcIixcbiAgICBcImJvcmRlckJsb2NrU3RhcnRDb2xvclwiLFxuICAgIFwiYm9yZGVyQmxvY2tTdGFydFN0eWxlXCIsXG4gICAgXCJib3JkZXJCbG9ja1N0YXJ0V2lkdGhcIixcbiAgICBcImJvcmRlckJsb2NrU3R5bGVcIixcbiAgICBcImJvcmRlckJsb2NrV2lkdGhcIixcbiAgICBcImJvcmRlckJvdHRvbVwiLFxuICAgIFwiYm9yZGVyQm90dG9tQ29sb3JcIixcbiAgICBcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIixcbiAgICBcImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXG4gICAgXCJib3JkZXJCb3R0b21TdHlsZVwiLFxuICAgIFwiYm9yZGVyQm90dG9tV2lkdGhcIixcbiAgICBcImJvcmRlckJveFNpemVcIixcbiAgICBcImJvcmRlckNvbGxhcHNlXCIsXG4gICAgXCJib3JkZXJDb2xvclwiLFxuICAgIFwiYm9yZGVyQ29sb3JEYXJrXCIsXG4gICAgXCJib3JkZXJDb2xvckxpZ2h0XCIsXG4gICAgXCJib3JkZXJFbmRFbmRSYWRpdXNcIixcbiAgICBcImJvcmRlckVuZFN0YXJ0UmFkaXVzXCIsXG4gICAgXCJib3JkZXJJbWFnZVwiLFxuICAgIFwiYm9yZGVySW1hZ2VPdXRzZXRcIixcbiAgICBcImJvcmRlckltYWdlUmVwZWF0XCIsXG4gICAgXCJib3JkZXJJbWFnZVNsaWNlXCIsXG4gICAgXCJib3JkZXJJbWFnZVNvdXJjZVwiLFxuICAgIFwiYm9yZGVySW1hZ2VXaWR0aFwiLFxuICAgIFwiYm9yZGVySW5saW5lXCIsXG4gICAgXCJib3JkZXJJbmxpbmVDb2xvclwiLFxuICAgIFwiYm9yZGVySW5saW5lRW5kXCIsXG4gICAgXCJib3JkZXJJbmxpbmVFbmRDb2xvclwiLFxuICAgIFwiYm9yZGVySW5saW5lRW5kU3R5bGVcIixcbiAgICBcImJvcmRlcklubGluZUVuZFdpZHRoXCIsXG4gICAgXCJib3JkZXJJbmxpbmVTdGFydFwiLFxuICAgIFwiYm9yZGVySW5saW5lU3RhcnRDb2xvclwiLFxuICAgIFwiYm9yZGVySW5saW5lU3RhcnRTdHlsZVwiLFxuICAgIFwiYm9yZGVySW5saW5lU3RhcnRXaWR0aFwiLFxuICAgIFwiYm9yZGVySW5saW5lU3R5bGVcIixcbiAgICBcImJvcmRlcklubGluZVdpZHRoXCIsXG4gICAgXCJib3JkZXJMZWZ0XCIsXG4gICAgXCJib3JkZXJMZWZ0Q29sb3JcIixcbiAgICBcImJvcmRlckxlZnRTdHlsZVwiLFxuICAgIFwiYm9yZGVyTGVmdFdpZHRoXCIsXG4gICAgXCJib3JkZXJSYWRpdXNcIixcbiAgICBcImJvcmRlclJpZ2h0XCIsXG4gICAgXCJib3JkZXJSaWdodENvbG9yXCIsXG4gICAgXCJib3JkZXJSaWdodFN0eWxlXCIsXG4gICAgXCJib3JkZXJSaWdodFdpZHRoXCIsXG4gICAgXCJib3JkZXJTcGFjaW5nXCIsXG4gICAgXCJib3JkZXJTdGFydEVuZFJhZGl1c1wiLFxuICAgIFwiYm9yZGVyU3RhcnRTdGFydFJhZGl1c1wiLFxuICAgIFwiYm9yZGVyU3R5bGVcIixcbiAgICBcImJvcmRlclRvcFwiLFxuICAgIFwiYm9yZGVyVG9wQ29sb3JcIixcbiAgICBcImJvcmRlclRvcExlZnRSYWRpdXNcIixcbiAgICBcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXG4gICAgXCJib3JkZXJUb3BTdHlsZVwiLFxuICAgIFwiYm9yZGVyVG9wV2lkdGhcIixcbiAgICBcImJvcmRlcldpZHRoXCIsXG4gICAgXCJib3R0b21cIixcbiAgICBcImJvdHRvbU1hcmdpblwiLFxuICAgIFwiYm91bmRcIixcbiAgICBcImJvdW5kRWxlbWVudHNcIixcbiAgICBcImJvdW5kaW5nQ2xpZW50UmVjdFwiLFxuICAgIFwiYm91bmRpbmdIZWlnaHRcIixcbiAgICBcImJvdW5kaW5nTGVmdFwiLFxuICAgIFwiYm91bmRpbmdUb3BcIixcbiAgICBcImJvdW5kaW5nV2lkdGhcIixcbiAgICBcImJvdW5kc1wiLFxuICAgIFwiYm91bmRzR2VvbWV0cnlcIixcbiAgICBcImJveC1kZWNvcmF0aW9uLWJyZWFrXCIsXG4gICAgXCJib3gtc2hhZG93XCIsXG4gICAgXCJib3gtc2l6aW5nXCIsXG4gICAgXCJib3hEZWNvcmF0aW9uQnJlYWtcIixcbiAgICBcImJveFNoYWRvd1wiLFxuICAgIFwiYm94U2l6aW5nXCIsXG4gICAgXCJicmVhay1hZnRlclwiLFxuICAgIFwiYnJlYWstYmVmb3JlXCIsXG4gICAgXCJicmVhay1pbnNpZGVcIixcbiAgICBcImJyZWFrQWZ0ZXJcIixcbiAgICBcImJyZWFrQmVmb3JlXCIsXG4gICAgXCJicmVha0luc2lkZVwiLFxuICAgIFwiYnJvYWRjYXN0XCIsXG4gICAgXCJicm93c2VyTGFuZ3VhZ2VcIixcbiAgICBcImJ0b2FcIixcbiAgICBcImJ1YmJsZXNcIixcbiAgICBcImJ1ZmZlclwiLFxuICAgIFwiYnVmZmVyRGF0YVwiLFxuICAgIFwiYnVmZmVyRGVwdGhcIixcbiAgICBcImJ1ZmZlclNpemVcIixcbiAgICBcImJ1ZmZlclN1YkRhdGFcIixcbiAgICBcImJ1ZmZlcmVkXCIsXG4gICAgXCJidWZmZXJlZEFtb3VudFwiLFxuICAgIFwiYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGRcIixcbiAgICBcImJ1aWxkSURcIixcbiAgICBcImJ1aWxkTnVtYmVyXCIsXG4gICAgXCJidXR0b25cIixcbiAgICBcImJ1dHRvbklEXCIsXG4gICAgXCJidXR0b25zXCIsXG4gICAgXCJieXRlTGVuZ3RoXCIsXG4gICAgXCJieXRlT2Zmc2V0XCIsXG4gICAgXCJieXRlc1dyaXR0ZW5cIixcbiAgICBcImNcIixcbiAgICBcImNhY2hlXCIsXG4gICAgXCJjYWNoZXNcIixcbiAgICBcImNhbGxcIixcbiAgICBcImNhbGxlclwiLFxuICAgIFwiY2FuQmVGb3JtYXR0ZWRcIixcbiAgICBcImNhbkJlTW91bnRlZFwiLFxuICAgIFwiY2FuQmVTaGFyZWRcIixcbiAgICBcImNhbkhhdmVDaGlsZHJlblwiLFxuICAgIFwiY2FuSGF2ZUhUTUxcIixcbiAgICBcImNhbkluc2VydERUTUZcIixcbiAgICBcImNhbk1ha2VQYXltZW50XCIsXG4gICAgXCJjYW5QbGF5VHlwZVwiLFxuICAgIFwiY2FuUHJlc2VudFwiLFxuICAgIFwiY2FuVHJpY2tsZUljZUNhbmRpZGF0ZXNcIixcbiAgICBcImNhbmNlbFwiLFxuICAgIFwiY2FuY2VsQW5kSG9sZEF0VGltZVwiLFxuICAgIFwiY2FuY2VsQW5pbWF0aW9uRnJhbWVcIixcbiAgICBcImNhbmNlbEJ1YmJsZVwiLFxuICAgIFwiY2FuY2VsSWRsZUNhbGxiYWNrXCIsXG4gICAgXCJjYW5jZWxTY2hlZHVsZWRWYWx1ZXNcIixcbiAgICBcImNhbmNlbFZpZGVvRnJhbWVDYWxsYmFja1wiLFxuICAgIFwiY2FuY2VsV2F0Y2hBdmFpbGFiaWxpdHlcIixcbiAgICBcImNhbmNlbGFibGVcIixcbiAgICBcImNhbmRpZGF0ZVwiLFxuICAgIFwiY2Fub25pY2FsVVVJRFwiLFxuICAgIFwiY2FudmFzXCIsXG4gICAgXCJjYXBhYmlsaXRpZXNcIixcbiAgICBcImNhcHRpb25cIixcbiAgICBcImNhcHRpb24tc2lkZVwiLFxuICAgIFwiY2FwdGlvblNpZGVcIixcbiAgICBcImNhcHR1cmVcIixcbiAgICBcImNhcHR1cmVFdmVudHNcIixcbiAgICBcImNhcHR1cmVTdGFja1RyYWNlXCIsXG4gICAgXCJjYXB0dXJlU3RyZWFtXCIsXG4gICAgXCJjYXJldC1jb2xvclwiLFxuICAgIFwiY2FyZXRCaWRpTGV2ZWxcIixcbiAgICBcImNhcmV0Q29sb3JcIixcbiAgICBcImNhcmV0UG9zaXRpb25Gcm9tUG9pbnRcIixcbiAgICBcImNhcmV0UmFuZ2VGcm9tUG9pbnRcIixcbiAgICBcImNhc3RcIixcbiAgICBcImNhdGNoXCIsXG4gICAgXCJjYXRlZ29yeVwiLFxuICAgIFwiY2JydFwiLFxuICAgIFwiY2RcIixcbiAgICBcImNlaWxcIixcbiAgICBcImNlbGxJbmRleFwiLFxuICAgIFwiY2VsbFBhZGRpbmdcIixcbiAgICBcImNlbGxTcGFjaW5nXCIsXG4gICAgXCJjZWxsc1wiLFxuICAgIFwiY2hcIixcbiAgICBcImNoT2ZmXCIsXG4gICAgXCJjaGFpblwiLFxuICAgIFwiY2hhbGxlbmdlXCIsXG4gICAgXCJjaGFuZ2VUeXBlXCIsXG4gICAgXCJjaGFuZ2VkVG91Y2hlc1wiLFxuICAgIFwiY2hhbm5lbFwiLFxuICAgIFwiY2hhbm5lbENvdW50XCIsXG4gICAgXCJjaGFubmVsQ291bnRNb2RlXCIsXG4gICAgXCJjaGFubmVsSW50ZXJwcmV0YXRpb25cIixcbiAgICBcImNoYXJcIixcbiAgICBcImNoYXJBdFwiLFxuICAgIFwiY2hhckNvZGVcIixcbiAgICBcImNoYXJDb2RlQXRcIixcbiAgICBcImNoYXJJbmRleFwiLFxuICAgIFwiY2hhckxlbmd0aFwiLFxuICAgIFwiY2hhcmFjdGVyRGF0YVwiLFxuICAgIFwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlXCIsXG4gICAgXCJjaGFyYWN0ZXJTZXRcIixcbiAgICBcImNoYXJhY3RlcmlzdGljXCIsXG4gICAgXCJjaGFyZ2luZ1wiLFxuICAgIFwiY2hhcmdpbmdUaW1lXCIsXG4gICAgXCJjaGFyc2V0XCIsXG4gICAgXCJjaGVja1wiLFxuICAgIFwiY2hlY2tFbmNsb3N1cmVcIixcbiAgICBcImNoZWNrRnJhbWVidWZmZXJTdGF0dXNcIixcbiAgICBcImNoZWNrSW50ZXJzZWN0aW9uXCIsXG4gICAgXCJjaGVja1ZhbGlkaXR5XCIsXG4gICAgXCJjaGVja2VkXCIsXG4gICAgXCJjaGlsZEVsZW1lbnRDb3VudFwiLFxuICAgIFwiY2hpbGRMaXN0XCIsXG4gICAgXCJjaGlsZE5vZGVzXCIsXG4gICAgXCJjaGlsZHJlblwiLFxuICAgIFwiY2hyb21lXCIsXG4gICAgXCJjaXBoZXJ0ZXh0XCIsXG4gICAgXCJjaXRlXCIsXG4gICAgXCJjaXR5XCIsXG4gICAgXCJjbGFpbUludGVyZmFjZVwiLFxuICAgIFwiY2xhaW1lZFwiLFxuICAgIFwiY2xhc3NMaXN0XCIsXG4gICAgXCJjbGFzc05hbWVcIixcbiAgICBcImNsYXNzaWRcIixcbiAgICBcImNsZWFyXCIsXG4gICAgXCJjbGVhckFwcEJhZGdlXCIsXG4gICAgXCJjbGVhckF0dHJpYnV0ZXNcIixcbiAgICBcImNsZWFyQnVmZmVyZmlcIixcbiAgICBcImNsZWFyQnVmZmVyZnZcIixcbiAgICBcImNsZWFyQnVmZmVyaXZcIixcbiAgICBcImNsZWFyQnVmZmVydWl2XCIsXG4gICAgXCJjbGVhckNvbG9yXCIsXG4gICAgXCJjbGVhckRhdGFcIixcbiAgICBcImNsZWFyRGVwdGhcIixcbiAgICBcImNsZWFySGFsdFwiLFxuICAgIFwiY2xlYXJJbW1lZGlhdGVcIixcbiAgICBcImNsZWFySW50ZXJ2YWxcIixcbiAgICBcImNsZWFyTGl2ZVNlZWthYmxlUmFuZ2VcIixcbiAgICBcImNsZWFyTWFya3NcIixcbiAgICBcImNsZWFyTWF4R0NQYXVzZUFjY3VtdWxhdG9yXCIsXG4gICAgXCJjbGVhck1lYXN1cmVzXCIsXG4gICAgXCJjbGVhclBhcmFtZXRlcnNcIixcbiAgICBcImNsZWFyUmVjdFwiLFxuICAgIFwiY2xlYXJSZXNvdXJjZVRpbWluZ3NcIixcbiAgICBcImNsZWFyU2hhZG93XCIsXG4gICAgXCJjbGVhclN0ZW5jaWxcIixcbiAgICBcImNsZWFyVGltZW91dFwiLFxuICAgIFwiY2xlYXJXYXRjaFwiLFxuICAgIFwiY2xpY2tcIixcbiAgICBcImNsaWNrQ291bnRcIixcbiAgICBcImNsaWVudERhdGFKU09OXCIsXG4gICAgXCJjbGllbnRIZWlnaHRcIixcbiAgICBcImNsaWVudEluZm9ybWF0aW9uXCIsXG4gICAgXCJjbGllbnRMZWZ0XCIsXG4gICAgXCJjbGllbnRSZWN0XCIsXG4gICAgXCJjbGllbnRSZWN0c1wiLFxuICAgIFwiY2xpZW50VG9wXCIsXG4gICAgXCJjbGllbnRXYWl0U3luY1wiLFxuICAgIFwiY2xpZW50V2lkdGhcIixcbiAgICBcImNsaWVudFhcIixcbiAgICBcImNsaWVudFlcIixcbiAgICBcImNsaXBcIixcbiAgICBcImNsaXAtcGF0aFwiLFxuICAgIFwiY2xpcC1ydWxlXCIsXG4gICAgXCJjbGlwQm90dG9tXCIsXG4gICAgXCJjbGlwTGVmdFwiLFxuICAgIFwiY2xpcFBhdGhcIixcbiAgICBcImNsaXBQYXRoVW5pdHNcIixcbiAgICBcImNsaXBSaWdodFwiLFxuICAgIFwiY2xpcFJ1bGVcIixcbiAgICBcImNsaXBUb3BcIixcbiAgICBcImNsaXBib2FyZFwiLFxuICAgIFwiY2xpcGJvYXJkRGF0YVwiLFxuICAgIFwiY2xvbmVcIixcbiAgICBcImNsb25lQ29udGVudHNcIixcbiAgICBcImNsb25lTm9kZVwiLFxuICAgIFwiY2xvbmVSYW5nZVwiLFxuICAgIFwiY2xvc2VcIixcbiAgICBcImNsb3NlUGF0aFwiLFxuICAgIFwiY2xvc2VkXCIsXG4gICAgXCJjbG9zZXN0XCIsXG4gICAgXCJjbHpcIixcbiAgICBcImNsejMyXCIsXG4gICAgXCJjbVwiLFxuICAgIFwiY21wXCIsXG4gICAgXCJjb2RlXCIsXG4gICAgXCJjb2RlQmFzZVwiLFxuICAgIFwiY29kZVBvaW50QXRcIixcbiAgICBcImNvZGVUeXBlXCIsXG4gICAgXCJjb2xTcGFuXCIsXG4gICAgXCJjb2xsYXBzZVwiLFxuICAgIFwiY29sbGFwc2VUb0VuZFwiLFxuICAgIFwiY29sbGFwc2VUb1N0YXJ0XCIsXG4gICAgXCJjb2xsYXBzZWRcIixcbiAgICBcImNvbGxlY3RcIixcbiAgICBcImNvbG5vXCIsXG4gICAgXCJjb2xvclwiLFxuICAgIFwiY29sb3ItYWRqdXN0XCIsXG4gICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCIsXG4gICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIixcbiAgICBcImNvbG9yQWRqdXN0XCIsXG4gICAgXCJjb2xvckRlcHRoXCIsXG4gICAgXCJjb2xvckludGVycG9sYXRpb25cIixcbiAgICBcImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnNcIixcbiAgICBcImNvbG9yTWFza1wiLFxuICAgIFwiY29sb3JUeXBlXCIsXG4gICAgXCJjb2xzXCIsXG4gICAgXCJjb2x1bW4tY291bnRcIixcbiAgICBcImNvbHVtbi1maWxsXCIsXG4gICAgXCJjb2x1bW4tZ2FwXCIsXG4gICAgXCJjb2x1bW4tcnVsZVwiLFxuICAgIFwiY29sdW1uLXJ1bGUtY29sb3JcIixcbiAgICBcImNvbHVtbi1ydWxlLXN0eWxlXCIsXG4gICAgXCJjb2x1bW4tcnVsZS13aWR0aFwiLFxuICAgIFwiY29sdW1uLXNwYW5cIixcbiAgICBcImNvbHVtbi13aWR0aFwiLFxuICAgIFwiY29sdW1uQ291bnRcIixcbiAgICBcImNvbHVtbkZpbGxcIixcbiAgICBcImNvbHVtbkdhcFwiLFxuICAgIFwiY29sdW1uTnVtYmVyXCIsXG4gICAgXCJjb2x1bW5SdWxlXCIsXG4gICAgXCJjb2x1bW5SdWxlQ29sb3JcIixcbiAgICBcImNvbHVtblJ1bGVTdHlsZVwiLFxuICAgIFwiY29sdW1uUnVsZVdpZHRoXCIsXG4gICAgXCJjb2x1bW5TcGFuXCIsXG4gICAgXCJjb2x1bW5XaWR0aFwiLFxuICAgIFwiY29sdW1uc1wiLFxuICAgIFwiY29tbWFuZFwiLFxuICAgIFwiY29tbWl0XCIsXG4gICAgXCJjb21taXRQcmVmZXJlbmNlc1wiLFxuICAgIFwiY29tbWl0U3R5bGVzXCIsXG4gICAgXCJjb21tb25BbmNlc3RvckNvbnRhaW5lclwiLFxuICAgIFwiY29tcGFjdFwiLFxuICAgIFwiY29tcGFyZUJvdW5kYXJ5UG9pbnRzXCIsXG4gICAgXCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvblwiLFxuICAgIFwiY29tcGFyZUVuZFBvaW50c1wiLFxuICAgIFwiY29tcGFyZUV4Y2hhbmdlXCIsXG4gICAgXCJjb21wYXJlTm9kZVwiLFxuICAgIFwiY29tcGFyZVBvaW50XCIsXG4gICAgXCJjb21wYXRNb2RlXCIsXG4gICAgXCJjb21wYXRpYmxlXCIsXG4gICAgXCJjb21waWxlXCIsXG4gICAgXCJjb21waWxlU2hhZGVyXCIsXG4gICAgXCJjb21waWxlU3RyZWFtaW5nXCIsXG4gICAgXCJjb21wbGV0ZVwiLFxuICAgIFwiY29tcG9uZW50XCIsXG4gICAgXCJjb21wb25lbnRGcm9tUG9pbnRcIixcbiAgICBcImNvbXBvc2VkXCIsXG4gICAgXCJjb21wb3NlZFBhdGhcIixcbiAgICBcImNvbXBvc2l0ZVwiLFxuICAgIFwiY29tcG9zaXRpb25FbmRPZmZzZXRcIixcbiAgICBcImNvbXBvc2l0aW9uU3RhcnRPZmZzZXRcIixcbiAgICBcImNvbXByZXNzZWRUZXhJbWFnZTJEXCIsXG4gICAgXCJjb21wcmVzc2VkVGV4SW1hZ2UzRFwiLFxuICAgIFwiY29tcHJlc3NlZFRleFN1YkltYWdlMkRcIixcbiAgICBcImNvbXByZXNzZWRUZXhTdWJJbWFnZTNEXCIsXG4gICAgXCJjb21wdXRlZFN0eWxlTWFwXCIsXG4gICAgXCJjb25jYXRcIixcbiAgICBcImNvbmRpdGlvblRleHRcIixcbiAgICBcImNvbmVJbm5lckFuZ2xlXCIsXG4gICAgXCJjb25lT3V0ZXJBbmdsZVwiLFxuICAgIFwiY29uZU91dGVyR2FpblwiLFxuICAgIFwiY29uZmlndXJhdGlvblwiLFxuICAgIFwiY29uZmlndXJhdGlvbk5hbWVcIixcbiAgICBcImNvbmZpZ3VyYXRpb25WYWx1ZVwiLFxuICAgIFwiY29uZmlndXJhdGlvbnNcIixcbiAgICBcImNvbmZpcm1cIixcbiAgICBcImNvbmZpcm1Db21wb3NpdGlvblwiLFxuICAgIFwiY29uZmlybVNpdGVTcGVjaWZpY1RyYWNraW5nRXhjZXB0aW9uXCIsXG4gICAgXCJjb25maXJtV2ViV2lkZVRyYWNraW5nRXhjZXB0aW9uXCIsXG4gICAgXCJjb25uZWN0XCIsXG4gICAgXCJjb25uZWN0RW5kXCIsXG4gICAgXCJjb25uZWN0U2hhcmtcIixcbiAgICBcImNvbm5lY3RTdGFydFwiLFxuICAgIFwiY29ubmVjdGVkXCIsXG4gICAgXCJjb25uZWN0aW9uXCIsXG4gICAgXCJjb25uZWN0aW9uTGlzdFwiLFxuICAgIFwiY29ubmVjdGlvblNwZWVkXCIsXG4gICAgXCJjb25uZWN0aW9uU3RhdGVcIixcbiAgICBcImNvbm5lY3Rpb25zXCIsXG4gICAgXCJjb25zb2xlXCIsXG4gICAgXCJjb25zb2xpZGF0ZVwiLFxuICAgIFwiY29uc3RyYWludFwiLFxuICAgIFwiY29uc3RyaWN0aW9uQWN0aXZlXCIsXG4gICAgXCJjb25zdHJ1Y3RcIixcbiAgICBcImNvbnN0cnVjdG9yXCIsXG4gICAgXCJjb250YWN0SURcIixcbiAgICBcImNvbnRhaW5cIixcbiAgICBcImNvbnRhaW5lcklkXCIsXG4gICAgXCJjb250YWluZXJOYW1lXCIsXG4gICAgXCJjb250YWluZXJTcmNcIixcbiAgICBcImNvbnRhaW5lclR5cGVcIixcbiAgICBcImNvbnRhaW5zXCIsXG4gICAgXCJjb250YWluc05vZGVcIixcbiAgICBcImNvbnRlbnRcIixcbiAgICBcImNvbnRlbnRCb3hTaXplXCIsXG4gICAgXCJjb250ZW50RG9jdW1lbnRcIixcbiAgICBcImNvbnRlbnRFZGl0YWJsZVwiLFxuICAgIFwiY29udGVudEhpbnRcIixcbiAgICBcImNvbnRlbnRPdmVyZmxvd1wiLFxuICAgIFwiY29udGVudFJlY3RcIixcbiAgICBcImNvbnRlbnRTY3JpcHRUeXBlXCIsXG4gICAgXCJjb250ZW50U3R5bGVUeXBlXCIsXG4gICAgXCJjb250ZW50VHlwZVwiLFxuICAgIFwiY29udGVudFdpbmRvd1wiLFxuICAgIFwiY29udGV4dFwiLFxuICAgIFwiY29udGV4dE1lbnVcIixcbiAgICBcImNvbnRleHRtZW51XCIsXG4gICAgXCJjb250aW51ZVwiLFxuICAgIFwiY29udGludWVQcmltYXJ5S2V5XCIsXG4gICAgXCJjb250aW51b3VzXCIsXG4gICAgXCJjb250cm9sXCIsXG4gICAgXCJjb250cm9sVHJhbnNmZXJJblwiLFxuICAgIFwiY29udHJvbFRyYW5zZmVyT3V0XCIsXG4gICAgXCJjb250cm9sbGVyXCIsXG4gICAgXCJjb250cm9sc1wiLFxuICAgIFwiY29udHJvbHNMaXN0XCIsXG4gICAgXCJjb252ZXJ0UG9pbnRGcm9tTm9kZVwiLFxuICAgIFwiY29udmVydFF1YWRGcm9tTm9kZVwiLFxuICAgIFwiY29udmVydFJlY3RGcm9tTm9kZVwiLFxuICAgIFwiY29udmVydFRvQmxvYlwiLFxuICAgIFwiY29udmVydFRvU3BlY2lmaWVkVW5pdHNcIixcbiAgICBcImNvb2tpZVwiLFxuICAgIFwiY29va2llRW5hYmxlZFwiLFxuICAgIFwiY29vcmRzXCIsXG4gICAgXCJjb3B5QnVmZmVyU3ViRGF0YVwiLFxuICAgIFwiY29weUZyb21DaGFubmVsXCIsXG4gICAgXCJjb3B5VGV4SW1hZ2UyRFwiLFxuICAgIFwiY29weVRleFN1YkltYWdlMkRcIixcbiAgICBcImNvcHlUZXhTdWJJbWFnZTNEXCIsXG4gICAgXCJjb3B5VG9DaGFubmVsXCIsXG4gICAgXCJjb3B5V2l0aGluXCIsXG4gICAgXCJjb3JyZXNwb25kaW5nRWxlbWVudFwiLFxuICAgIFwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnRcIixcbiAgICBcImNvcnJ1cHRlZFZpZGVvRnJhbWVzXCIsXG4gICAgXCJjb3NcIixcbiAgICBcImNvc2hcIixcbiAgICBcImNvdW50XCIsXG4gICAgXCJjb3VudFJlc2V0XCIsXG4gICAgXCJjb3VudGVyLWluY3JlbWVudFwiLFxuICAgIFwiY291bnRlci1yZXNldFwiLFxuICAgIFwiY291bnRlci1zZXRcIixcbiAgICBcImNvdW50ZXJJbmNyZW1lbnRcIixcbiAgICBcImNvdW50ZXJSZXNldFwiLFxuICAgIFwiY291bnRlclNldFwiLFxuICAgIFwiY291bnRyeVwiLFxuICAgIFwiY3B1Q2xhc3NcIixcbiAgICBcImNwdVNsZWVwQWxsb3dlZFwiLFxuICAgIFwiY3JlYXRlXCIsXG4gICAgXCJjcmVhdGVBbmFseXNlclwiLFxuICAgIFwiY3JlYXRlQW5zd2VyXCIsXG4gICAgXCJjcmVhdGVBdHRyaWJ1dGVcIixcbiAgICBcImNyZWF0ZUF0dHJpYnV0ZU5TXCIsXG4gICAgXCJjcmVhdGVCaXF1YWRGaWx0ZXJcIixcbiAgICBcImNyZWF0ZUJ1ZmZlclwiLFxuICAgIFwiY3JlYXRlQnVmZmVyU291cmNlXCIsXG4gICAgXCJjcmVhdGVDREFUQVNlY3Rpb25cIixcbiAgICBcImNyZWF0ZUNTU1N0eWxlU2hlZXRcIixcbiAgICBcImNyZWF0ZUNhcHRpb25cIixcbiAgICBcImNyZWF0ZUNoYW5uZWxNZXJnZXJcIixcbiAgICBcImNyZWF0ZUNoYW5uZWxTcGxpdHRlclwiLFxuICAgIFwiY3JlYXRlQ29tbWVudFwiLFxuICAgIFwiY3JlYXRlQ29uc3RhbnRTb3VyY2VcIixcbiAgICBcImNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudFwiLFxuICAgIFwiY3JlYXRlQ29udHJvbFJhbmdlXCIsXG4gICAgXCJjcmVhdGVDb252b2x2ZXJcIixcbiAgICBcImNyZWF0ZURUTUZTZW5kZXJcIixcbiAgICBcImNyZWF0ZURhdGFDaGFubmVsXCIsXG4gICAgXCJjcmVhdGVEZWxheVwiLFxuICAgIFwiY3JlYXRlRGVsYXlOb2RlXCIsXG4gICAgXCJjcmVhdGVEb2N1bWVudFwiLFxuICAgIFwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudFwiLFxuICAgIFwiY3JlYXRlRG9jdW1lbnRUeXBlXCIsXG4gICAgXCJjcmVhdGVEeW5hbWljc0NvbXByZXNzb3JcIixcbiAgICBcImNyZWF0ZUVsZW1lbnRcIixcbiAgICBcImNyZWF0ZUVsZW1lbnROU1wiLFxuICAgIFwiY3JlYXRlRW50aXR5UmVmZXJlbmNlXCIsXG4gICAgXCJjcmVhdGVFdmVudFwiLFxuICAgIFwiY3JlYXRlRXZlbnRPYmplY3RcIixcbiAgICBcImNyZWF0ZUV4cHJlc3Npb25cIixcbiAgICBcImNyZWF0ZUZyYW1lYnVmZmVyXCIsXG4gICAgXCJjcmVhdGVGdW5jdGlvblwiLFxuICAgIFwiY3JlYXRlR2FpblwiLFxuICAgIFwiY3JlYXRlR2Fpbk5vZGVcIixcbiAgICBcImNyZWF0ZUhUTUxcIixcbiAgICBcImNyZWF0ZUhUTUxEb2N1bWVudFwiLFxuICAgIFwiY3JlYXRlSUlSRmlsdGVyXCIsXG4gICAgXCJjcmVhdGVJbWFnZUJpdG1hcFwiLFxuICAgIFwiY3JlYXRlSW1hZ2VEYXRhXCIsXG4gICAgXCJjcmVhdGVJbmRleFwiLFxuICAgIFwiY3JlYXRlSmF2YVNjcmlwdE5vZGVcIixcbiAgICBcImNyZWF0ZUxpbmVhckdyYWRpZW50XCIsXG4gICAgXCJjcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2VcIixcbiAgICBcImNyZWF0ZU1lZGlhS2V5c1wiLFxuICAgIFwiY3JlYXRlTWVkaWFTdHJlYW1EZXN0aW5hdGlvblwiLFxuICAgIFwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2VcIixcbiAgICBcImNyZWF0ZU1lZGlhU3RyZWFtVHJhY2tTb3VyY2VcIixcbiAgICBcImNyZWF0ZU11dGFibGVGaWxlXCIsXG4gICAgXCJjcmVhdGVOU1Jlc29sdmVyXCIsXG4gICAgXCJjcmVhdGVOb2RlSXRlcmF0b3JcIixcbiAgICBcImNyZWF0ZU5vdGlmaWNhdGlvblwiLFxuICAgIFwiY3JlYXRlT2JqZWN0U3RvcmVcIixcbiAgICBcImNyZWF0ZU9iamVjdFVSTFwiLFxuICAgIFwiY3JlYXRlT2ZmZXJcIixcbiAgICBcImNyZWF0ZU9zY2lsbGF0b3JcIixcbiAgICBcImNyZWF0ZVBhbm5lclwiLFxuICAgIFwiY3JlYXRlUGF0dGVyblwiLFxuICAgIFwiY3JlYXRlUGVyaW9kaWNXYXZlXCIsXG4gICAgXCJjcmVhdGVQb2xpY3lcIixcbiAgICBcImNyZWF0ZVBvcHVwXCIsXG4gICAgXCJjcmVhdGVQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cIixcbiAgICBcImNyZWF0ZVByb2dyYW1cIixcbiAgICBcImNyZWF0ZVF1ZXJ5XCIsXG4gICAgXCJjcmVhdGVSYWRpYWxHcmFkaWVudFwiLFxuICAgIFwiY3JlYXRlUmFuZ2VcIixcbiAgICBcImNyZWF0ZVJhbmdlQ29sbGVjdGlvblwiLFxuICAgIFwiY3JlYXRlUmVhZGVyXCIsXG4gICAgXCJjcmVhdGVSZW5kZXJidWZmZXJcIixcbiAgICBcImNyZWF0ZVNWR0FuZ2xlXCIsXG4gICAgXCJjcmVhdGVTVkdMZW5ndGhcIixcbiAgICBcImNyZWF0ZVNWR01hdHJpeFwiLFxuICAgIFwiY3JlYXRlU1ZHTnVtYmVyXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQXJjQWJzXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQXJjUmVsXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ2xvc2VQYXRoXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljQWJzXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljUmVsXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoQWJzXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b0N1YmljU21vb3RoUmVsXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0Fic1wiLFxuICAgIFwiY3JlYXRlU1ZHUGF0aFNlZ0N1cnZldG9RdWFkcmF0aWNSZWxcIixcbiAgICBcImNyZWF0ZVNWR1BhdGhTZWdDdXJ2ZXRvUXVhZHJhdGljU21vb3RoQWJzXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aFJlbFwiLFxuICAgIFwiY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0Fic1wiLFxuICAgIFwiY3JlYXRlU1ZHUGF0aFNlZ0xpbmV0b0hvcml6b250YWxBYnNcIixcbiAgICBcImNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsUmVsXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnTGluZXRvUmVsXCIsXG4gICAgXCJjcmVhdGVTVkdQYXRoU2VnTGluZXRvVmVydGljYWxBYnNcIixcbiAgICBcImNyZWF0ZVNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbFJlbFwiLFxuICAgIFwiY3JlYXRlU1ZHUGF0aFNlZ01vdmV0b0Fic1wiLFxuICAgIFwiY3JlYXRlU1ZHUGF0aFNlZ01vdmV0b1JlbFwiLFxuICAgIFwiY3JlYXRlU1ZHUG9pbnRcIixcbiAgICBcImNyZWF0ZVNWR1JlY3RcIixcbiAgICBcImNyZWF0ZVNWR1RyYW5zZm9ybVwiLFxuICAgIFwiY3JlYXRlU1ZHVHJhbnNmb3JtRnJvbU1hdHJpeFwiLFxuICAgIFwiY3JlYXRlU2FtcGxlclwiLFxuICAgIFwiY3JlYXRlU2NyaXB0XCIsXG4gICAgXCJjcmVhdGVTY3JpcHRQcm9jZXNzb3JcIixcbiAgICBcImNyZWF0ZVNjcmlwdFVSTFwiLFxuICAgIFwiY3JlYXRlU2Vzc2lvblwiLFxuICAgIFwiY3JlYXRlU2hhZGVyXCIsXG4gICAgXCJjcmVhdGVTaGFkb3dSb290XCIsXG4gICAgXCJjcmVhdGVTdGVyZW9QYW5uZXJcIixcbiAgICBcImNyZWF0ZVN0eWxlU2hlZXRcIixcbiAgICBcImNyZWF0ZVRCb2R5XCIsXG4gICAgXCJjcmVhdGVURm9vdFwiLFxuICAgIFwiY3JlYXRlVEhlYWRcIixcbiAgICBcImNyZWF0ZVRleHROb2RlXCIsXG4gICAgXCJjcmVhdGVUZXh0UmFuZ2VcIixcbiAgICBcImNyZWF0ZVRleHR1cmVcIixcbiAgICBcImNyZWF0ZVRvdWNoXCIsXG4gICAgXCJjcmVhdGVUb3VjaExpc3RcIixcbiAgICBcImNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrXCIsXG4gICAgXCJjcmVhdGVUcmVlV2Fsa2VyXCIsXG4gICAgXCJjcmVhdGVWZXJ0ZXhBcnJheVwiLFxuICAgIFwiY3JlYXRlV2F2ZVNoYXBlclwiLFxuICAgIFwiY3JlYXRpb25UaW1lXCIsXG4gICAgXCJjcmVkZW50aWFsc1wiLFxuICAgIFwiY3Jvc3NPcmlnaW5cIixcbiAgICBcImNyb3NzT3JpZ2luSXNvbGF0ZWRcIixcbiAgICBcImNyeXB0b1wiLFxuICAgIFwiY3NpXCIsXG4gICAgXCJjc3BcIixcbiAgICBcImNzc0Zsb2F0XCIsXG4gICAgXCJjc3NSdWxlc1wiLFxuICAgIFwiY3NzVGV4dFwiLFxuICAgIFwiY3NzVmFsdWVUeXBlXCIsXG4gICAgXCJjdHJsS2V5XCIsXG4gICAgXCJjdHJsTGVmdFwiLFxuICAgIFwiY3Vlc1wiLFxuICAgIFwiY3VsbEZhY2VcIixcbiAgICBcImN1cnJlbnREaXJlY3Rpb25cIixcbiAgICBcImN1cnJlbnRMb2NhbERlc2NyaXB0aW9uXCIsXG4gICAgXCJjdXJyZW50Tm9kZVwiLFxuICAgIFwiY3VycmVudFBhZ2VcIixcbiAgICBcImN1cnJlbnRSZWN0XCIsXG4gICAgXCJjdXJyZW50UmVtb3RlRGVzY3JpcHRpb25cIixcbiAgICBcImN1cnJlbnRTY2FsZVwiLFxuICAgIFwiY3VycmVudFNjcmlwdFwiLFxuICAgIFwiY3VycmVudFNyY1wiLFxuICAgIFwiY3VycmVudFN0YXRlXCIsXG4gICAgXCJjdXJyZW50U3R5bGVcIixcbiAgICBcImN1cnJlbnRUYXJnZXRcIixcbiAgICBcImN1cnJlbnRUaW1lXCIsXG4gICAgXCJjdXJyZW50VHJhbnNsYXRlXCIsXG4gICAgXCJjdXJyZW50Vmlld1wiLFxuICAgIFwiY3Vyc29yXCIsXG4gICAgXCJjdXJ2ZVwiLFxuICAgIFwiY3VzdG9tRWxlbWVudHNcIixcbiAgICBcImN1c3RvbUVycm9yXCIsXG4gICAgXCJjeFwiLFxuICAgIFwiY3lcIixcbiAgICBcImRcIixcbiAgICBcImRhdGFcIixcbiAgICBcImRhdGFGbGRcIixcbiAgICBcImRhdGFGb3JtYXRBc1wiLFxuICAgIFwiZGF0YUxvc3NcIixcbiAgICBcImRhdGFMb3NzTWVzc2FnZVwiLFxuICAgIFwiZGF0YVBhZ2VTaXplXCIsXG4gICAgXCJkYXRhU3JjXCIsXG4gICAgXCJkYXRhVHJhbnNmZXJcIixcbiAgICBcImRhdGFiYXNlXCIsXG4gICAgXCJkYXRhYmFzZXNcIixcbiAgICBcImRhdGFzZXRcIixcbiAgICBcImRhdGVUaW1lXCIsXG4gICAgXCJkYlwiLFxuICAgIFwiZGVidWdcIixcbiAgICBcImRlYnVnZ2VyRW5hYmxlZFwiLFxuICAgIFwiZGVjbGFyZVwiLFxuICAgIFwiZGVjb2RlXCIsXG4gICAgXCJkZWNvZGVBdWRpb0RhdGFcIixcbiAgICBcImRlY29kZVVSSVwiLFxuICAgIFwiZGVjb2RlVVJJQ29tcG9uZW50XCIsXG4gICAgXCJkZWNvZGVkQm9keVNpemVcIixcbiAgICBcImRlY29kaW5nXCIsXG4gICAgXCJkZWNvZGluZ0luZm9cIixcbiAgICBcImRlY3J5cHRcIixcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImRlZmF1bHRDaGFyc2V0XCIsXG4gICAgXCJkZWZhdWx0Q2hlY2tlZFwiLFxuICAgIFwiZGVmYXVsdE11dGVkXCIsXG4gICAgXCJkZWZhdWx0UGxheWJhY2tSYXRlXCIsXG4gICAgXCJkZWZhdWx0UG9saWN5XCIsXG4gICAgXCJkZWZhdWx0UHJldmVudGVkXCIsXG4gICAgXCJkZWZhdWx0UmVxdWVzdFwiLFxuICAgIFwiZGVmYXVsdFNlbGVjdGVkXCIsXG4gICAgXCJkZWZhdWx0U3RhdHVzXCIsXG4gICAgXCJkZWZhdWx0VVJMXCIsXG4gICAgXCJkZWZhdWx0VmFsdWVcIixcbiAgICBcImRlZmF1bHRWaWV3XCIsXG4gICAgXCJkZWZhdWx0c3RhdHVzXCIsXG4gICAgXCJkZWZlclwiLFxuICAgIFwiZGVmaW5lXCIsXG4gICAgXCJkZWZpbmVNYWdpY0Z1bmN0aW9uXCIsXG4gICAgXCJkZWZpbmVNYWdpY1ZhcmlhYmxlXCIsXG4gICAgXCJkZWZpbmVQcm9wZXJ0aWVzXCIsXG4gICAgXCJkZWZpbmVQcm9wZXJ0eVwiLFxuICAgIFwiZGVnXCIsXG4gICAgXCJkZWxheVwiLFxuICAgIFwiZGVsYXlUaW1lXCIsXG4gICAgXCJkZWxlZ2F0ZXNGb2N1c1wiLFxuICAgIFwiZGVsZXRlXCIsXG4gICAgXCJkZWxldGVCdWZmZXJcIixcbiAgICBcImRlbGV0ZUNhcHRpb25cIixcbiAgICBcImRlbGV0ZUNlbGxcIixcbiAgICBcImRlbGV0ZUNvbnRlbnRzXCIsXG4gICAgXCJkZWxldGVEYXRhXCIsXG4gICAgXCJkZWxldGVEYXRhYmFzZVwiLFxuICAgIFwiZGVsZXRlRnJhbWVidWZmZXJcIixcbiAgICBcImRlbGV0ZUZyb21Eb2N1bWVudFwiLFxuICAgIFwiZGVsZXRlSW5kZXhcIixcbiAgICBcImRlbGV0ZU1lZGl1bVwiLFxuICAgIFwiZGVsZXRlT2JqZWN0U3RvcmVcIixcbiAgICBcImRlbGV0ZVByb2dyYW1cIixcbiAgICBcImRlbGV0ZVByb3BlcnR5XCIsXG4gICAgXCJkZWxldGVRdWVyeVwiLFxuICAgIFwiZGVsZXRlUmVuZGVyYnVmZmVyXCIsXG4gICAgXCJkZWxldGVSb3dcIixcbiAgICBcImRlbGV0ZVJ1bGVcIixcbiAgICBcImRlbGV0ZVNhbXBsZXJcIixcbiAgICBcImRlbGV0ZVNoYWRlclwiLFxuICAgIFwiZGVsZXRlU3luY1wiLFxuICAgIFwiZGVsZXRlVEZvb3RcIixcbiAgICBcImRlbGV0ZVRIZWFkXCIsXG4gICAgXCJkZWxldGVUZXh0dXJlXCIsXG4gICAgXCJkZWxldGVUcmFuc2Zvcm1GZWVkYmFja1wiLFxuICAgIFwiZGVsZXRlVmVydGV4QXJyYXlcIixcbiAgICBcImRlbGl2ZXJDaGFuZ2VSZWNvcmRzXCIsXG4gICAgXCJkZWxpdmVyeVwiLFxuICAgIFwiZGVsaXZlcnlJbmZvXCIsXG4gICAgXCJkZWxpdmVyeVN0YXR1c1wiLFxuICAgIFwiZGVsaXZlcnlUaW1lc3RhbXBcIixcbiAgICBcImRlbHRhXCIsXG4gICAgXCJkZWx0YU1vZGVcIixcbiAgICBcImRlbHRhWFwiLFxuICAgIFwiZGVsdGFZXCIsXG4gICAgXCJkZWx0YVpcIixcbiAgICBcImRlcGVuZGVudExvY2FsaXR5XCIsXG4gICAgXCJkZXB0aEZhclwiLFxuICAgIFwiZGVwdGhGdW5jXCIsXG4gICAgXCJkZXB0aE1hc2tcIixcbiAgICBcImRlcHRoTmVhclwiLFxuICAgIFwiZGVwdGhSYW5nZVwiLFxuICAgIFwiZGVyZWZcIixcbiAgICBcImRlcml2ZUJpdHNcIixcbiAgICBcImRlcml2ZUtleVwiLFxuICAgIFwiZGVzY3JpcHRpb25cIixcbiAgICBcImRlc2VsZWN0QWxsXCIsXG4gICAgXCJkZXNpZ25Nb2RlXCIsXG4gICAgXCJkZXNpcmVkU2l6ZVwiLFxuICAgIFwiZGVzdGluYXRpb25cIixcbiAgICBcImRlc3RpbmF0aW9uVVJMXCIsXG4gICAgXCJkZXRhY2hcIixcbiAgICBcImRldGFjaEV2ZW50XCIsXG4gICAgXCJkZXRhY2hTaGFkZXJcIixcbiAgICBcImRldGFpbFwiLFxuICAgIFwiZGV0YWlsc1wiLFxuICAgIFwiZGV0ZWN0XCIsXG4gICAgXCJkZXR1bmVcIixcbiAgICBcImRldmljZVwiLFxuICAgIFwiZGV2aWNlQ2xhc3NcIixcbiAgICBcImRldmljZUlkXCIsXG4gICAgXCJkZXZpY2VNZW1vcnlcIixcbiAgICBcImRldmljZVBpeGVsQ29udGVudEJveFNpemVcIixcbiAgICBcImRldmljZVBpeGVsUmF0aW9cIixcbiAgICBcImRldmljZVByb3RvY29sXCIsXG4gICAgXCJkZXZpY2VTdWJjbGFzc1wiLFxuICAgIFwiZGV2aWNlVmVyc2lvbk1ham9yXCIsXG4gICAgXCJkZXZpY2VWZXJzaW9uTWlub3JcIixcbiAgICBcImRldmljZVZlcnNpb25TdWJtaW5vclwiLFxuICAgIFwiZGV2aWNlWERQSVwiLFxuICAgIFwiZGV2aWNlWURQSVwiLFxuICAgIFwiZGlkVGltZW91dFwiLFxuICAgIFwiZGlmZnVzZUNvbnN0YW50XCIsXG4gICAgXCJkaWdlc3RcIixcbiAgICBcImRpbWVuc2lvbnNcIixcbiAgICBcImRpclwiLFxuICAgIFwiZGlyTmFtZVwiLFxuICAgIFwiZGlyZWN0aW9uXCIsXG4gICAgXCJkaXJ4bWxcIixcbiAgICBcImRpc2FibGVcIixcbiAgICBcImRpc2FibGVQaWN0dXJlSW5QaWN0dXJlXCIsXG4gICAgXCJkaXNhYmxlUmVtb3RlUGxheWJhY2tcIixcbiAgICBcImRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheVwiLFxuICAgIFwiZGlzYWJsZWRcIixcbiAgICBcImRpc2NoYXJnaW5nVGltZVwiLFxuICAgIFwiZGlzY29ubmVjdFwiLFxuICAgIFwiZGlzY29ubmVjdFNoYXJrXCIsXG4gICAgXCJkaXNwYXRjaEV2ZW50XCIsXG4gICAgXCJkaXNwbGF5XCIsXG4gICAgXCJkaXNwbGF5SWRcIixcbiAgICBcImRpc3BsYXlOYW1lXCIsXG4gICAgXCJkaXNwb3NpdGlvblwiLFxuICAgIFwiZGlzdGFuY2VNb2RlbFwiLFxuICAgIFwiZGl2XCIsXG4gICAgXCJkaXZpc29yXCIsXG4gICAgXCJkanNhcGlcIixcbiAgICBcImRqc3Byb3h5XCIsXG4gICAgXCJkb0ltcG9ydFwiLFxuICAgIFwiZG9Ob3RUcmFja1wiLFxuICAgIFwiZG9TY3JvbGxcIixcbiAgICBcImRvY3R5cGVcIixcbiAgICBcImRvY3VtZW50XCIsXG4gICAgXCJkb2N1bWVudEVsZW1lbnRcIixcbiAgICBcImRvY3VtZW50TW9kZVwiLFxuICAgIFwiZG9jdW1lbnRVUklcIixcbiAgICBcImRvbHBoaW5cIixcbiAgICBcImRvbHBoaW5HYW1lQ2VudGVyXCIsXG4gICAgXCJkb2xwaGluaW5mb1wiLFxuICAgIFwiZG9scGhpbm1ldGFcIixcbiAgICBcImRvbUNvbXBsZXRlXCIsXG4gICAgXCJkb21Db250ZW50TG9hZGVkRXZlbnRFbmRcIixcbiAgICBcImRvbUNvbnRlbnRMb2FkZWRFdmVudFN0YXJ0XCIsXG4gICAgXCJkb21JbnRlcmFjdGl2ZVwiLFxuICAgIFwiZG9tTG9hZGluZ1wiLFxuICAgIFwiZG9tT3ZlcmxheVN0YXRlXCIsXG4gICAgXCJkb21haW5cIixcbiAgICBcImRvbWFpbkxvb2t1cEVuZFwiLFxuICAgIFwiZG9tYWluTG9va3VwU3RhcnRcIixcbiAgICBcImRvbWluYW50LWJhc2VsaW5lXCIsXG4gICAgXCJkb21pbmFudEJhc2VsaW5lXCIsXG4gICAgXCJkb25lXCIsXG4gICAgXCJkb3BwbGVyRmFjdG9yXCIsXG4gICAgXCJkb3RBbGxcIixcbiAgICBcImRvd25EZWdyZWVzXCIsXG4gICAgXCJkb3dubGlua1wiLFxuICAgIFwiZG93bmxvYWRcIixcbiAgICBcImRvd25sb2FkVG90YWxcIixcbiAgICBcImRvd25sb2FkZWRcIixcbiAgICBcImRwY21cIixcbiAgICBcImRwaVwiLFxuICAgIFwiZHBweFwiLFxuICAgIFwiZHJhZ0Ryb3BcIixcbiAgICBcImRyYWdnYWJsZVwiLFxuICAgIFwiZHJhd0FycmF5c1wiLFxuICAgIFwiZHJhd0FycmF5c0luc3RhbmNlZFwiLFxuICAgIFwiZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFXCIsXG4gICAgXCJkcmF3QnVmZmVyc1wiLFxuICAgIFwiZHJhd0N1c3RvbUZvY3VzUmluZ1wiLFxuICAgIFwiZHJhd0VsZW1lbnRzXCIsXG4gICAgXCJkcmF3RWxlbWVudHNJbnN0YW5jZWRcIixcbiAgICBcImRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFXCIsXG4gICAgXCJkcmF3Rm9jdXNJZk5lZWRlZFwiLFxuICAgIFwiZHJhd0ltYWdlXCIsXG4gICAgXCJkcmF3SW1hZ2VGcm9tUmVjdFwiLFxuICAgIFwiZHJhd1JhbmdlRWxlbWVudHNcIixcbiAgICBcImRyYXdTeXN0ZW1Gb2N1c1JpbmdcIixcbiAgICBcImRyYXdpbmdCdWZmZXJIZWlnaHRcIixcbiAgICBcImRyYXdpbmdCdWZmZXJXaWR0aFwiLFxuICAgIFwiZHJvcEVmZmVjdFwiLFxuICAgIFwiZHJvcHBlZFZpZGVvRnJhbWVzXCIsXG4gICAgXCJkcm9wem9uZVwiLFxuICAgIFwiZHRtZlwiLFxuICAgIFwiZHVtcFwiLFxuICAgIFwiZHVtcFByb2ZpbGVcIixcbiAgICBcImR1cGxpY2F0ZVwiLFxuICAgIFwiZHVyYWJpbGl0eVwiLFxuICAgIFwiZHVyYXRpb25cIixcbiAgICBcImR2bmFtZVwiLFxuICAgIFwiZHZudW1cIixcbiAgICBcImR4XCIsXG4gICAgXCJkeVwiLFxuICAgIFwiZHluc3JjXCIsXG4gICAgXCJlXCIsXG4gICAgXCJlZGdlTW9kZVwiLFxuICAgIFwiZWZmZWN0XCIsXG4gICAgXCJlZmZlY3RBbGxvd2VkXCIsXG4gICAgXCJlZmZlY3RpdmVEaXJlY3RpdmVcIixcbiAgICBcImVmZmVjdGl2ZVR5cGVcIixcbiAgICBcImVsYXBzZWRUaW1lXCIsXG4gICAgXCJlbGVtZW50XCIsXG4gICAgXCJlbGVtZW50RnJvbVBvaW50XCIsXG4gICAgXCJlbGVtZW50VGltaW5nXCIsXG4gICAgXCJlbGVtZW50c1wiLFxuICAgIFwiZWxlbWVudHNGcm9tUG9pbnRcIixcbiAgICBcImVsZXZhdGlvblwiLFxuICAgIFwiZWxsaXBzZVwiLFxuICAgIFwiZW1cIixcbiAgICBcImVtYWlsXCIsXG4gICAgXCJlbWJlZHNcIixcbiAgICBcImVtbWFcIixcbiAgICBcImVtcHR5XCIsXG4gICAgXCJlbXB0eS1jZWxsc1wiLFxuICAgIFwiZW1wdHlDZWxsc1wiLFxuICAgIFwiZW1wdHlIVE1MXCIsXG4gICAgXCJlbXB0eVNjcmlwdFwiLFxuICAgIFwiZW11bGF0ZWRQb3NpdGlvblwiLFxuICAgIFwiZW5hYmxlXCIsXG4gICAgXCJlbmFibGVCYWNrZ3JvdW5kXCIsXG4gICAgXCJlbmFibGVEZWxlZ2F0aW9uc1wiLFxuICAgIFwiZW5hYmxlU3R5bGVTaGVldHNGb3JTZXRcIixcbiAgICBcImVuYWJsZVZlcnRleEF0dHJpYkFycmF5XCIsXG4gICAgXCJlbmFibGVkXCIsXG4gICAgXCJlbmFibGVkUGx1Z2luXCIsXG4gICAgXCJlbmNvZGVcIixcbiAgICBcImVuY29kZUludG9cIixcbiAgICBcImVuY29kZVVSSVwiLFxuICAgIFwiZW5jb2RlVVJJQ29tcG9uZW50XCIsXG4gICAgXCJlbmNvZGVkQm9keVNpemVcIixcbiAgICBcImVuY29kaW5nXCIsXG4gICAgXCJlbmNvZGluZ0luZm9cIixcbiAgICBcImVuY3J5cHRcIixcbiAgICBcImVuY3R5cGVcIixcbiAgICBcImVuZFwiLFxuICAgIFwiZW5kQ29udGFpbmVyXCIsXG4gICAgXCJlbmRFbGVtZW50XCIsXG4gICAgXCJlbmRFbGVtZW50QXRcIixcbiAgICBcImVuZE9mU3RyZWFtXCIsXG4gICAgXCJlbmRPZmZzZXRcIixcbiAgICBcImVuZFF1ZXJ5XCIsXG4gICAgXCJlbmRUaW1lXCIsXG4gICAgXCJlbmRUcmFuc2Zvcm1GZWVkYmFja1wiLFxuICAgIFwiZW5kZWRcIixcbiAgICBcImVuZHBvaW50XCIsXG4gICAgXCJlbmRwb2ludE51bWJlclwiLFxuICAgIFwiZW5kcG9pbnRzXCIsXG4gICAgXCJlbmRzV2l0aFwiLFxuICAgIFwiZW50ZXJLZXlIaW50XCIsXG4gICAgXCJlbnRpdGllc1wiLFxuICAgIFwiZW50cmllc1wiLFxuICAgIFwiZW50cnlUeXBlXCIsXG4gICAgXCJlbnVtZXJhdGVcIixcbiAgICBcImVudW1lcmF0ZURldmljZXNcIixcbiAgICBcImVudW1lcmF0ZUVkaXRhYmxlXCIsXG4gICAgXCJlbnZpcm9ubWVudEJsZW5kTW9kZVwiLFxuICAgIFwiZXF1YWxzXCIsXG4gICAgXCJlcnJvclwiLFxuICAgIFwiZXJyb3JDb2RlXCIsXG4gICAgXCJlcnJvckRldGFpbFwiLFxuICAgIFwiZXJyb3JUZXh0XCIsXG4gICAgXCJlc2NhcGVcIixcbiAgICBcImVzdGltYXRlXCIsXG4gICAgXCJldmFsXCIsXG4gICAgXCJldmFsdWF0ZVwiLFxuICAgIFwiZXZlbnRcIixcbiAgICBcImV2ZW50UGhhc2VcIixcbiAgICBcImV2ZXJ5XCIsXG4gICAgXCJleFwiLFxuICAgIFwiZXhjZXB0aW9uXCIsXG4gICAgXCJleGNoYW5nZVwiLFxuICAgIFwiZXhlY1wiLFxuICAgIFwiZXhlY0NvbW1hbmRcIixcbiAgICBcImV4ZWNDb21tYW5kU2hvd0hlbHBcIixcbiAgICBcImV4ZWNTY3JpcHRcIixcbiAgICBcImV4aXRGdWxsc2NyZWVuXCIsXG4gICAgXCJleGl0UGljdHVyZUluUGljdHVyZVwiLFxuICAgIFwiZXhpdFBvaW50ZXJMb2NrXCIsXG4gICAgXCJleGl0UHJlc2VudFwiLFxuICAgIFwiZXhwXCIsXG4gICAgXCJleHBhbmRcIixcbiAgICBcImV4cGFuZEVudGl0eVJlZmVyZW5jZXNcIixcbiAgICBcImV4cGFuZG9cIixcbiAgICBcImV4cGFuc2lvblwiLFxuICAgIFwiZXhwaXJhdGlvblwiLFxuICAgIFwiZXhwaXJhdGlvblRpbWVcIixcbiAgICBcImV4cGlyZXNcIixcbiAgICBcImV4cGlyeURhdGVcIixcbiAgICBcImV4cGxpY2l0T3JpZ2luYWxUYXJnZXRcIixcbiAgICBcImV4cG0xXCIsXG4gICAgXCJleHBvbmVudFwiLFxuICAgIFwiZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZVwiLFxuICAgIFwiZXhwb3J0S2V5XCIsXG4gICAgXCJleHBvcnRzXCIsXG4gICAgXCJleHRlbmRcIixcbiAgICBcImV4dGVuc2lvbnNcIixcbiAgICBcImV4dGVudE5vZGVcIixcbiAgICBcImV4dGVudE9mZnNldFwiLFxuICAgIFwiZXh0ZXJuYWxcIixcbiAgICBcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixcbiAgICBcImV4dHJhY3RDb250ZW50c1wiLFxuICAgIFwiZXh0cmFjdGFibGVcIixcbiAgICBcImV5ZVwiLFxuICAgIFwiZlwiLFxuICAgIFwiZmFjZVwiLFxuICAgIFwiZmFjdG9yeVJlc2V0XCIsXG4gICAgXCJmYWlsdXJlUmVhc29uXCIsXG4gICAgXCJmYWxsYmFja1wiLFxuICAgIFwiZmFtaWx5XCIsXG4gICAgXCJmYW1pbHlOYW1lXCIsXG4gICAgXCJmYXJ0aGVzdFZpZXdwb3J0RWxlbWVudFwiLFxuICAgIFwiZmFzdFNlZWtcIixcbiAgICBcImZhdGFsXCIsXG4gICAgXCJmZWF0dXJlSWRcIixcbiAgICBcImZlYXR1cmVQb2xpY3lcIixcbiAgICBcImZlYXR1cmVTZXR0aW5nc1wiLFxuICAgIFwiZmVhdHVyZXNcIixcbiAgICBcImZlbmNlU3luY1wiLFxuICAgIFwiZmV0Y2hcIixcbiAgICBcImZldGNoU3RhcnRcIixcbiAgICBcImZmdFNpemVcIixcbiAgICBcImZnQ29sb3JcIixcbiAgICBcImZpZWxkT2ZWaWV3XCIsXG4gICAgXCJmaWxlXCIsXG4gICAgXCJmaWxlQ3JlYXRlZERhdGVcIixcbiAgICBcImZpbGVIYW5kbGVcIixcbiAgICBcImZpbGVNb2RpZmllZERhdGVcIixcbiAgICBcImZpbGVOYW1lXCIsXG4gICAgXCJmaWxlU2l6ZVwiLFxuICAgIFwiZmlsZVVwZGF0ZWREYXRlXCIsXG4gICAgXCJmaWxlbmFtZVwiLFxuICAgIFwiZmlsZXNcIixcbiAgICBcImZpbGVzeXN0ZW1cIixcbiAgICBcImZpbGxcIixcbiAgICBcImZpbGwtb3BhY2l0eVwiLFxuICAgIFwiZmlsbC1ydWxlXCIsXG4gICAgXCJmaWxsTGlnaHRNb2RlXCIsXG4gICAgXCJmaWxsT3BhY2l0eVwiLFxuICAgIFwiZmlsbFJlY3RcIixcbiAgICBcImZpbGxSdWxlXCIsXG4gICAgXCJmaWxsU3R5bGVcIixcbiAgICBcImZpbGxUZXh0XCIsXG4gICAgXCJmaWx0ZXJcIixcbiAgICBcImZpbHRlclJlc1hcIixcbiAgICBcImZpbHRlclJlc1lcIixcbiAgICBcImZpbHRlclVuaXRzXCIsXG4gICAgXCJmaWx0ZXJzXCIsXG4gICAgXCJmaW5hbGx5XCIsXG4gICAgXCJmaW5kXCIsXG4gICAgXCJmaW5kSW5kZXhcIixcbiAgICBcImZpbmRSdWxlXCIsXG4gICAgXCJmaW5kVGV4dFwiLFxuICAgIFwiZmluaXNoXCIsXG4gICAgXCJmaW5pc2hlZFwiLFxuICAgIFwiZmlyZUV2ZW50XCIsXG4gICAgXCJmaXJlc1RvdWNoRXZlbnRzXCIsXG4gICAgXCJmaXJzdENoaWxkXCIsXG4gICAgXCJmaXJzdEVsZW1lbnRDaGlsZFwiLFxuICAgIFwiZmlyc3RQYWdlXCIsXG4gICAgXCJmaXhlZFwiLFxuICAgIFwiZmxhZ3NcIixcbiAgICBcImZsYXRcIixcbiAgICBcImZsYXRNYXBcIixcbiAgICBcImZsZXhcIixcbiAgICBcImZsZXgtYmFzaXNcIixcbiAgICBcImZsZXgtZGlyZWN0aW9uXCIsXG4gICAgXCJmbGV4LWZsb3dcIixcbiAgICBcImZsZXgtZ3Jvd1wiLFxuICAgIFwiZmxleC1zaHJpbmtcIixcbiAgICBcImZsZXgtd3JhcFwiLFxuICAgIFwiZmxleEJhc2lzXCIsXG4gICAgXCJmbGV4RGlyZWN0aW9uXCIsXG4gICAgXCJmbGV4Rmxvd1wiLFxuICAgIFwiZmxleEdyb3dcIixcbiAgICBcImZsZXhTaHJpbmtcIixcbiAgICBcImZsZXhXcmFwXCIsXG4gICAgXCJmbGlwWFwiLFxuICAgIFwiZmxpcFlcIixcbiAgICBcImZsb2F0XCIsXG4gICAgXCJmbG9hdDMyXCIsXG4gICAgXCJmbG9hdDY0XCIsXG4gICAgXCJmbG9vZC1jb2xvclwiLFxuICAgIFwiZmxvb2Qtb3BhY2l0eVwiLFxuICAgIFwiZmxvb2RDb2xvclwiLFxuICAgIFwiZmxvb2RPcGFjaXR5XCIsXG4gICAgXCJmbG9vclwiLFxuICAgIFwiZmx1c2hcIixcbiAgICBcImZvY3VzXCIsXG4gICAgXCJmb2N1c05vZGVcIixcbiAgICBcImZvY3VzT2Zmc2V0XCIsXG4gICAgXCJmb250XCIsXG4gICAgXCJmb250LWZhbWlseVwiLFxuICAgIFwiZm9udC1mZWF0dXJlLXNldHRpbmdzXCIsXG4gICAgXCJmb250LWtlcm5pbmdcIixcbiAgICBcImZvbnQtbGFuZ3VhZ2Utb3ZlcnJpZGVcIixcbiAgICBcImZvbnQtb3B0aWNhbC1zaXppbmdcIixcbiAgICBcImZvbnQtc2l6ZVwiLFxuICAgIFwiZm9udC1zaXplLWFkanVzdFwiLFxuICAgIFwiZm9udC1zdHJldGNoXCIsXG4gICAgXCJmb250LXN0eWxlXCIsXG4gICAgXCJmb250LXN5bnRoZXNpc1wiLFxuICAgIFwiZm9udC12YXJpYW50XCIsXG4gICAgXCJmb250LXZhcmlhbnQtYWx0ZXJuYXRlc1wiLFxuICAgIFwiZm9udC12YXJpYW50LWNhcHNcIixcbiAgICBcImZvbnQtdmFyaWFudC1lYXN0LWFzaWFuXCIsXG4gICAgXCJmb250LXZhcmlhbnQtbGlnYXR1cmVzXCIsXG4gICAgXCJmb250LXZhcmlhbnQtbnVtZXJpY1wiLFxuICAgIFwiZm9udC12YXJpYW50LXBvc2l0aW9uXCIsXG4gICAgXCJmb250LXZhcmlhdGlvbi1zZXR0aW5nc1wiLFxuICAgIFwiZm9udC13ZWlnaHRcIixcbiAgICBcImZvbnRGYW1pbHlcIixcbiAgICBcImZvbnRGZWF0dXJlU2V0dGluZ3NcIixcbiAgICBcImZvbnRLZXJuaW5nXCIsXG4gICAgXCJmb250TGFuZ3VhZ2VPdmVycmlkZVwiLFxuICAgIFwiZm9udE9wdGljYWxTaXppbmdcIixcbiAgICBcImZvbnRTaXplXCIsXG4gICAgXCJmb250U2l6ZUFkanVzdFwiLFxuICAgIFwiZm9udFNtb290aGluZ0VuYWJsZWRcIixcbiAgICBcImZvbnRTdHJldGNoXCIsXG4gICAgXCJmb250U3R5bGVcIixcbiAgICBcImZvbnRTeW50aGVzaXNcIixcbiAgICBcImZvbnRWYXJpYW50XCIsXG4gICAgXCJmb250VmFyaWFudEFsdGVybmF0ZXNcIixcbiAgICBcImZvbnRWYXJpYW50Q2Fwc1wiLFxuICAgIFwiZm9udFZhcmlhbnRFYXN0QXNpYW5cIixcbiAgICBcImZvbnRWYXJpYW50TGlnYXR1cmVzXCIsXG4gICAgXCJmb250VmFyaWFudE51bWVyaWNcIixcbiAgICBcImZvbnRWYXJpYW50UG9zaXRpb25cIixcbiAgICBcImZvbnRWYXJpYXRpb25TZXR0aW5nc1wiLFxuICAgIFwiZm9udFdlaWdodFwiLFxuICAgIFwiZm9udGNvbG9yXCIsXG4gICAgXCJmb250ZmFjZXNcIixcbiAgICBcImZvbnRzXCIsXG4gICAgXCJmb250c2l6ZVwiLFxuICAgIFwiZm9yXCIsXG4gICAgXCJmb3JFYWNoXCIsXG4gICAgXCJmb3JjZVwiLFxuICAgIFwiZm9yY2VSZWRyYXdcIixcbiAgICBcImZvcm1cIixcbiAgICBcImZvcm1BY3Rpb25cIixcbiAgICBcImZvcm1EYXRhXCIsXG4gICAgXCJmb3JtRW5jdHlwZVwiLFxuICAgIFwiZm9ybU1ldGhvZFwiLFxuICAgIFwiZm9ybU5vVmFsaWRhdGVcIixcbiAgICBcImZvcm1UYXJnZXRcIixcbiAgICBcImZvcm1hdFwiLFxuICAgIFwiZm9ybWF0VG9QYXJ0c1wiLFxuICAgIFwiZm9ybXNcIixcbiAgICBcImZvcndhcmRcIixcbiAgICBcImZvcndhcmRYXCIsXG4gICAgXCJmb3J3YXJkWVwiLFxuICAgIFwiZm9yd2FyZFpcIixcbiAgICBcImZvdW5kYXRpb25cIixcbiAgICBcImZyXCIsXG4gICAgXCJmcmFnbWVudERpcmVjdGl2ZVwiLFxuICAgIFwiZnJhbWVcIixcbiAgICBcImZyYW1lQm9yZGVyXCIsXG4gICAgXCJmcmFtZUVsZW1lbnRcIixcbiAgICBcImZyYW1lU3BhY2luZ1wiLFxuICAgIFwiZnJhbWVidWZmZXJcIixcbiAgICBcImZyYW1lYnVmZmVySGVpZ2h0XCIsXG4gICAgXCJmcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlclwiLFxuICAgIFwiZnJhbWVidWZmZXJUZXh0dXJlMkRcIixcbiAgICBcImZyYW1lYnVmZmVyVGV4dHVyZUxheWVyXCIsXG4gICAgXCJmcmFtZWJ1ZmZlcldpZHRoXCIsXG4gICAgXCJmcmFtZXNcIixcbiAgICBcImZyZWVTcGFjZVwiLFxuICAgIFwiZnJlZXplXCIsXG4gICAgXCJmcmVxdWVuY3lcIixcbiAgICBcImZyZXF1ZW5jeUJpbkNvdW50XCIsXG4gICAgXCJmcm9tXCIsXG4gICAgXCJmcm9tQ2hhckNvZGVcIixcbiAgICBcImZyb21Db2RlUG9pbnRcIixcbiAgICBcImZyb21FbGVtZW50XCIsXG4gICAgXCJmcm9tRW50cmllc1wiLFxuICAgIFwiZnJvbUZsb2F0MzJBcnJheVwiLFxuICAgIFwiZnJvbUZsb2F0NjRBcnJheVwiLFxuICAgIFwiZnJvbU1hdHJpeFwiLFxuICAgIFwiZnJvbVBvaW50XCIsXG4gICAgXCJmcm9tUXVhZFwiLFxuICAgIFwiZnJvbVJlY3RcIixcbiAgICBcImZyb250RmFjZVwiLFxuICAgIFwiZnJvdW5kXCIsXG4gICAgXCJmdWxsUGF0aFwiLFxuICAgIFwiZnVsbFNjcmVlblwiLFxuICAgIFwiZnVsbHNjcmVlblwiLFxuICAgIFwiZnVsbHNjcmVlbkVsZW1lbnRcIixcbiAgICBcImZ1bGxzY3JlZW5FbmFibGVkXCIsXG4gICAgXCJmeFwiLFxuICAgIFwiZnlcIixcbiAgICBcImdhaW5cIixcbiAgICBcImdhbWVwYWRcIixcbiAgICBcImdhbW1hXCIsXG4gICAgXCJnYXBcIixcbiAgICBcImdhdGhlcmluZ1N0YXRlXCIsXG4gICAgXCJnYXR0XCIsXG4gICAgXCJnZW5kZXJJZGVudGl0eVwiLFxuICAgIFwiZ2VuZXJhdGVDZXJ0aWZpY2F0ZVwiLFxuICAgIFwiZ2VuZXJhdGVLZXlcIixcbiAgICBcImdlbmVyYXRlTWlwbWFwXCIsXG4gICAgXCJnZW5lcmF0ZVJlcXVlc3RcIixcbiAgICBcImdlb2xvY2F0aW9uXCIsXG4gICAgXCJnZXN0dXJlT2JqZWN0XCIsXG4gICAgXCJnZXRcIixcbiAgICBcImdldEFjdGl2ZUF0dHJpYlwiLFxuICAgIFwiZ2V0QWN0aXZlVW5pZm9ybVwiLFxuICAgIFwiZ2V0QWN0aXZlVW5pZm9ybUJsb2NrTmFtZVwiLFxuICAgIFwiZ2V0QWN0aXZlVW5pZm9ybUJsb2NrUGFyYW1ldGVyXCIsXG4gICAgXCJnZXRBY3RpdmVVbmlmb3Jtc1wiLFxuICAgIFwiZ2V0QWRqYWNlbnRUZXh0XCIsXG4gICAgXCJnZXRBbGxcIixcbiAgICBcImdldEFsbEtleXNcIixcbiAgICBcImdldEFsbFJlc3BvbnNlSGVhZGVyc1wiLFxuICAgIFwiZ2V0QWxsb3dsaXN0Rm9yRmVhdHVyZVwiLFxuICAgIFwiZ2V0QW5pbWF0aW9uc1wiLFxuICAgIFwiZ2V0QXNGaWxlXCIsXG4gICAgXCJnZXRBc1N0cmluZ1wiLFxuICAgIFwiZ2V0QXR0YWNoZWRTaGFkZXJzXCIsXG4gICAgXCJnZXRBdHRyaWJMb2NhdGlvblwiLFxuICAgIFwiZ2V0QXR0cmlidXRlXCIsXG4gICAgXCJnZXRBdHRyaWJ1dGVOU1wiLFxuICAgIFwiZ2V0QXR0cmlidXRlTmFtZXNcIixcbiAgICBcImdldEF0dHJpYnV0ZU5vZGVcIixcbiAgICBcImdldEF0dHJpYnV0ZU5vZGVOU1wiLFxuICAgIFwiZ2V0QXR0cmlidXRlVHlwZVwiLFxuICAgIFwiZ2V0QXVkaW9UcmFja3NcIixcbiAgICBcImdldEF2YWlsYWJpbGl0eVwiLFxuICAgIFwiZ2V0QkJveFwiLFxuICAgIFwiZ2V0QmF0dGVyeVwiLFxuICAgIFwiZ2V0QmlnSW50NjRcIixcbiAgICBcImdldEJpZ1VpbnQ2NFwiLFxuICAgIFwiZ2V0QmxvYlwiLFxuICAgIFwiZ2V0Qm9va21hcmtcIixcbiAgICBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiLFxuICAgIFwiZ2V0Qm91bmRzXCIsXG4gICAgXCJnZXRCb3hRdWFkc1wiLFxuICAgIFwiZ2V0QnVmZmVyUGFyYW1ldGVyXCIsXG4gICAgXCJnZXRCdWZmZXJTdWJEYXRhXCIsXG4gICAgXCJnZXRCeXRlRnJlcXVlbmN5RGF0YVwiLFxuICAgIFwiZ2V0Qnl0ZVRpbWVEb21haW5EYXRhXCIsXG4gICAgXCJnZXRDU1NDYW52YXNDb250ZXh0XCIsXG4gICAgXCJnZXRDVE1cIixcbiAgICBcImdldENhbmRpZGF0ZVdpbmRvd0NsaWVudFJlY3RcIixcbiAgICBcImdldENhbm9uaWNhbExvY2FsZXNcIixcbiAgICBcImdldENhcGFiaWxpdGllc1wiLFxuICAgIFwiZ2V0Q2hhbm5lbERhdGFcIixcbiAgICBcImdldENoYXJOdW1BdFBvc2l0aW9uXCIsXG4gICAgXCJnZXRDaGFyYWN0ZXJpc3RpY1wiLFxuICAgIFwiZ2V0Q2hhcmFjdGVyaXN0aWNzXCIsXG4gICAgXCJnZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzXCIsXG4gICAgXCJnZXRDbGllbnRSZWN0XCIsXG4gICAgXCJnZXRDbGllbnRSZWN0c1wiLFxuICAgIFwiZ2V0Q29hbGVzY2VkRXZlbnRzXCIsXG4gICAgXCJnZXRDb21wb3NpdGlvbkFsdGVybmF0aXZlc1wiLFxuICAgIFwiZ2V0Q29tcHV0ZWRTdHlsZVwiLFxuICAgIFwiZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoXCIsXG4gICAgXCJnZXRDb21wdXRlZFRpbWluZ1wiLFxuICAgIFwiZ2V0Q29uZmlndXJhdGlvblwiLFxuICAgIFwiZ2V0Q29uc3RyYWludHNcIixcbiAgICBcImdldENvbnRleHRcIixcbiAgICBcImdldENvbnRleHRBdHRyaWJ1dGVzXCIsXG4gICAgXCJnZXRDb250cmlidXRpbmdTb3VyY2VzXCIsXG4gICAgXCJnZXRDb3VudGVyVmFsdWVcIixcbiAgICBcImdldEN1ZUFzSFRNTFwiLFxuICAgIFwiZ2V0Q3VlQnlJZFwiLFxuICAgIFwiZ2V0Q3VycmVudFBvc2l0aW9uXCIsXG4gICAgXCJnZXRDdXJyZW50VGltZVwiLFxuICAgIFwiZ2V0RGF0YVwiLFxuICAgIFwiZ2V0RGF0YWJhc2VOYW1lc1wiLFxuICAgIFwiZ2V0RGF0ZVwiLFxuICAgIFwiZ2V0RGF5XCIsXG4gICAgXCJnZXREZWZhdWx0Q29tcHV0ZWRTdHlsZVwiLFxuICAgIFwiZ2V0RGVzY3JpcHRvclwiLFxuICAgIFwiZ2V0RGVzY3JpcHRvcnNcIixcbiAgICBcImdldERlc3RpbmF0aW9uSW5zZXJ0aW9uUG9pbnRzXCIsXG4gICAgXCJnZXREZXZpY2VzXCIsXG4gICAgXCJnZXREaXJlY3RvcnlcIixcbiAgICBcImdldERpc3BsYXlNZWRpYVwiLFxuICAgIFwiZ2V0RGlzdHJpYnV0ZWROb2Rlc1wiLFxuICAgIFwiZ2V0RWRpdGFibGVcIixcbiAgICBcImdldEVsZW1lbnRCeUlkXCIsXG4gICAgXCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lXCIsXG4gICAgXCJnZXRFbGVtZW50c0J5TmFtZVwiLFxuICAgIFwiZ2V0RWxlbWVudHNCeVRhZ05hbWVcIixcbiAgICBcImdldEVsZW1lbnRzQnlUYWdOYW1lTlNcIixcbiAgICBcImdldEVuY2xvc3VyZUxpc3RcIixcbiAgICBcImdldEVuZFBvc2l0aW9uT2ZDaGFyXCIsXG4gICAgXCJnZXRFbnRyaWVzXCIsXG4gICAgXCJnZXRFbnRyaWVzQnlOYW1lXCIsXG4gICAgXCJnZXRFbnRyaWVzQnlUeXBlXCIsXG4gICAgXCJnZXRFcnJvclwiLFxuICAgIFwiZ2V0RXh0ZW5zaW9uXCIsXG4gICAgXCJnZXRFeHRlbnRPZkNoYXJcIixcbiAgICBcImdldEV5ZVBhcmFtZXRlcnNcIixcbiAgICBcImdldEZlYXR1cmVcIixcbiAgICBcImdldEZpbGVcIixcbiAgICBcImdldEZpbGVzXCIsXG4gICAgXCJnZXRGaWxlc0FuZERpcmVjdG9yaWVzXCIsXG4gICAgXCJnZXRGaW5nZXJwcmludHNcIixcbiAgICBcImdldEZsb2F0MzJcIixcbiAgICBcImdldEZsb2F0NjRcIixcbiAgICBcImdldEZsb2F0RnJlcXVlbmN5RGF0YVwiLFxuICAgIFwiZ2V0RmxvYXRUaW1lRG9tYWluRGF0YVwiLFxuICAgIFwiZ2V0RmxvYXRWYWx1ZVwiLFxuICAgIFwiZ2V0RnJhZ0RhdGFMb2NhdGlvblwiLFxuICAgIFwiZ2V0RnJhbWVEYXRhXCIsXG4gICAgXCJnZXRGcmFtZWJ1ZmZlckF0dGFjaG1lbnRQYXJhbWV0ZXJcIixcbiAgICBcImdldEZyZXF1ZW5jeVJlc3BvbnNlXCIsXG4gICAgXCJnZXRGdWxsWWVhclwiLFxuICAgIFwiZ2V0R2FtZXBhZHNcIixcbiAgICBcImdldEhpdFRlc3RSZXN1bHRzXCIsXG4gICAgXCJnZXRIaXRUZXN0UmVzdWx0c0ZvclRyYW5zaWVudElucHV0XCIsXG4gICAgXCJnZXRIb3Vyc1wiLFxuICAgIFwiZ2V0SWRlbnRpdHlBc3NlcnRpb25cIixcbiAgICBcImdldElkc1wiLFxuICAgIFwiZ2V0SW1hZ2VEYXRhXCIsXG4gICAgXCJnZXRJbmRleGVkUGFyYW1ldGVyXCIsXG4gICAgXCJnZXRJbnN0YWxsZWRSZWxhdGVkQXBwc1wiLFxuICAgIFwiZ2V0SW50MTZcIixcbiAgICBcImdldEludDMyXCIsXG4gICAgXCJnZXRJbnQ4XCIsXG4gICAgXCJnZXRJbnRlcm5hbGZvcm1hdFBhcmFtZXRlclwiLFxuICAgIFwiZ2V0SW50ZXJzZWN0aW9uTGlzdFwiLFxuICAgIFwiZ2V0SXRlbVwiLFxuICAgIFwiZ2V0SXRlbXNcIixcbiAgICBcImdldEtleVwiLFxuICAgIFwiZ2V0S2V5ZnJhbWVzXCIsXG4gICAgXCJnZXRMYXllcnNcIixcbiAgICBcImdldExheW91dE1hcFwiLFxuICAgIFwiZ2V0TGluZURhc2hcIixcbiAgICBcImdldExvY2FsQ2FuZGlkYXRlc1wiLFxuICAgIFwiZ2V0TG9jYWxQYXJhbWV0ZXJzXCIsXG4gICAgXCJnZXRMb2NhbFN0cmVhbXNcIixcbiAgICBcImdldE1hcmtzXCIsXG4gICAgXCJnZXRNYXRjaGVkQ1NTUnVsZXNcIixcbiAgICBcImdldE1heEdDUGF1c2VTaW5jZUNsZWFyXCIsXG4gICAgXCJnZXRNZWFzdXJlc1wiLFxuICAgIFwiZ2V0TWV0YWRhdGFcIixcbiAgICBcImdldE1pbGxpc2Vjb25kc1wiLFxuICAgIFwiZ2V0TWludXRlc1wiLFxuICAgIFwiZ2V0TW9kaWZpZXJTdGF0ZVwiLFxuICAgIFwiZ2V0TW9udGhcIixcbiAgICBcImdldE5hbWVkSXRlbVwiLFxuICAgIFwiZ2V0TmFtZWRJdGVtTlNcIixcbiAgICBcImdldE5hdGl2ZUZyYW1lYnVmZmVyU2NhbGVGYWN0b3JcIixcbiAgICBcImdldE5vdGlmaWNhdGlvbnNcIixcbiAgICBcImdldE5vdGlmaWVyXCIsXG4gICAgXCJnZXROdW1iZXJPZkNoYXJzXCIsXG4gICAgXCJnZXRPZmZzZXRSZWZlcmVuY2VTcGFjZVwiLFxuICAgIFwiZ2V0T3V0cHV0VGltZXN0YW1wXCIsXG4gICAgXCJnZXRPdmVycmlkZUhpc3RvcnlOYXZpZ2F0aW9uTW9kZVwiLFxuICAgIFwiZ2V0T3ZlcnJpZGVTdHlsZVwiLFxuICAgIFwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXCIsXG4gICAgXCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzXCIsXG4gICAgXCJnZXRPd25Qcm9wZXJ0eU5hbWVzXCIsXG4gICAgXCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcIixcbiAgICBcImdldFBhcmFtZXRlclwiLFxuICAgIFwiZ2V0UGFyYW1ldGVyc1wiLFxuICAgIFwiZ2V0UGFyZW50XCIsXG4gICAgXCJnZXRQYXRoU2VnQXRMZW5ndGhcIixcbiAgICBcImdldFBob3RvQ2FwYWJpbGl0aWVzXCIsXG4gICAgXCJnZXRQaG90b1NldHRpbmdzXCIsXG4gICAgXCJnZXRQb2ludEF0TGVuZ3RoXCIsXG4gICAgXCJnZXRQb3NlXCIsXG4gICAgXCJnZXRQcmVkaWN0ZWRFdmVudHNcIixcbiAgICBcImdldFByZWZlcmVuY2VcIixcbiAgICBcImdldFByZWZlcmVuY2VEZWZhdWx0XCIsXG4gICAgXCJnZXRQcmVzZW50YXRpb25BdHRyaWJ1dGVcIixcbiAgICBcImdldFByZXZlbnREZWZhdWx0XCIsXG4gICAgXCJnZXRQcmltYXJ5U2VydmljZVwiLFxuICAgIFwiZ2V0UHJpbWFyeVNlcnZpY2VzXCIsXG4gICAgXCJnZXRQcm9ncmFtSW5mb0xvZ1wiLFxuICAgIFwiZ2V0UHJvZ3JhbVBhcmFtZXRlclwiLFxuICAgIFwiZ2V0UHJvcGVydHlDU1NWYWx1ZVwiLFxuICAgIFwiZ2V0UHJvcGVydHlQcmlvcml0eVwiLFxuICAgIFwiZ2V0UHJvcGVydHlTaG9ydGhhbmRcIixcbiAgICBcImdldFByb3BlcnR5VHlwZVwiLFxuICAgIFwiZ2V0UHJvcGVydHlWYWx1ZVwiLFxuICAgIFwiZ2V0UHJvdG90eXBlT2ZcIixcbiAgICBcImdldFF1ZXJ5XCIsXG4gICAgXCJnZXRRdWVyeVBhcmFtZXRlclwiLFxuICAgIFwiZ2V0UkdCQ29sb3JWYWx1ZVwiLFxuICAgIFwiZ2V0UmFuZG9tVmFsdWVzXCIsXG4gICAgXCJnZXRSYW5nZUF0XCIsXG4gICAgXCJnZXRSZWFkZXJcIixcbiAgICBcImdldFJlY2VpdmVyc1wiLFxuICAgIFwiZ2V0UmVjdFZhbHVlXCIsXG4gICAgXCJnZXRSZWdpc3RyYXRpb25cIixcbiAgICBcImdldFJlZ2lzdHJhdGlvbnNcIixcbiAgICBcImdldFJlbW90ZUNhbmRpZGF0ZXNcIixcbiAgICBcImdldFJlbW90ZUNlcnRpZmljYXRlc1wiLFxuICAgIFwiZ2V0UmVtb3RlUGFyYW1ldGVyc1wiLFxuICAgIFwiZ2V0UmVtb3RlU3RyZWFtc1wiLFxuICAgIFwiZ2V0UmVuZGVyYnVmZmVyUGFyYW1ldGVyXCIsXG4gICAgXCJnZXRSZXNwb25zZUhlYWRlclwiLFxuICAgIFwiZ2V0Um9vdFwiLFxuICAgIFwiZ2V0Um9vdE5vZGVcIixcbiAgICBcImdldFJvdGF0aW9uT2ZDaGFyXCIsXG4gICAgXCJnZXRTVkdEb2N1bWVudFwiLFxuICAgIFwiZ2V0U2FtcGxlclBhcmFtZXRlclwiLFxuICAgIFwiZ2V0U2NyZWVuQ1RNXCIsXG4gICAgXCJnZXRTZWNvbmRzXCIsXG4gICAgXCJnZXRTZWxlY3RlZENhbmRpZGF0ZVBhaXJcIixcbiAgICBcImdldFNlbGVjdGlvblwiLFxuICAgIFwiZ2V0U2VuZGVyc1wiLFxuICAgIFwiZ2V0U2VydmljZVwiLFxuICAgIFwiZ2V0U2V0dGluZ3NcIixcbiAgICBcImdldFNoYWRlckluZm9Mb2dcIixcbiAgICBcImdldFNoYWRlclBhcmFtZXRlclwiLFxuICAgIFwiZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0XCIsXG4gICAgXCJnZXRTaGFkZXJTb3VyY2VcIixcbiAgICBcImdldFNpbXBsZUR1cmF0aW9uXCIsXG4gICAgXCJnZXRTaXRlSWNvbnNcIixcbiAgICBcImdldFNvdXJjZXNcIixcbiAgICBcImdldFNwZWN1bGF0aXZlUGFyc2VyVXJsc1wiLFxuICAgIFwiZ2V0U3RhcnRQb3NpdGlvbk9mQ2hhclwiLFxuICAgIFwiZ2V0U3RhcnRUaW1lXCIsXG4gICAgXCJnZXRTdGF0ZVwiLFxuICAgIFwiZ2V0U3RhdHNcIixcbiAgICBcImdldFN0YXR1c0ZvclBvbGljeVwiLFxuICAgIFwiZ2V0U3RvcmFnZVVwZGF0ZXNcIixcbiAgICBcImdldFN0cmVhbUJ5SWRcIixcbiAgICBcImdldFN0cmluZ1ZhbHVlXCIsXG4gICAgXCJnZXRTdWJTdHJpbmdMZW5ndGhcIixcbiAgICBcImdldFN1YnNjcmlwdGlvblwiLFxuICAgIFwiZ2V0U3VwcG9ydGVkQ29uc3RyYWludHNcIixcbiAgICBcImdldFN1cHBvcnRlZEV4dGVuc2lvbnNcIixcbiAgICBcImdldFN1cHBvcnRlZEZvcm1hdHNcIixcbiAgICBcImdldFN5bmNQYXJhbWV0ZXJcIixcbiAgICBcImdldFN5bmNocm9uaXphdGlvblNvdXJjZXNcIixcbiAgICBcImdldFRhZ3NcIixcbiAgICBcImdldFRhcmdldFJhbmdlc1wiLFxuICAgIFwiZ2V0VGV4UGFyYW1ldGVyXCIsXG4gICAgXCJnZXRUaW1lXCIsXG4gICAgXCJnZXRUaW1lem9uZU9mZnNldFwiLFxuICAgIFwiZ2V0VGltaW5nXCIsXG4gICAgXCJnZXRUb3RhbExlbmd0aFwiLFxuICAgIFwiZ2V0VHJhY2tCeUlkXCIsXG4gICAgXCJnZXRUcmFja3NcIixcbiAgICBcImdldFRyYW5zY2VpdmVyc1wiLFxuICAgIFwiZ2V0VHJhbnNmb3JtXCIsXG4gICAgXCJnZXRUcmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmdcIixcbiAgICBcImdldFRyYW5zZm9ybVRvRWxlbWVudFwiLFxuICAgIFwiZ2V0VHJhbnNwb3J0c1wiLFxuICAgIFwiZ2V0VHlwZVwiLFxuICAgIFwiZ2V0VHlwZU1hcHBpbmdcIixcbiAgICBcImdldFVUQ0RhdGVcIixcbiAgICBcImdldFVUQ0RheVwiLFxuICAgIFwiZ2V0VVRDRnVsbFllYXJcIixcbiAgICBcImdldFVUQ0hvdXJzXCIsXG4gICAgXCJnZXRVVENNaWxsaXNlY29uZHNcIixcbiAgICBcImdldFVUQ01pbnV0ZXNcIixcbiAgICBcImdldFVUQ01vbnRoXCIsXG4gICAgXCJnZXRVVENTZWNvbmRzXCIsXG4gICAgXCJnZXRVaW50MTZcIixcbiAgICBcImdldFVpbnQzMlwiLFxuICAgIFwiZ2V0VWludDhcIixcbiAgICBcImdldFVuaWZvcm1cIixcbiAgICBcImdldFVuaWZvcm1CbG9ja0luZGV4XCIsXG4gICAgXCJnZXRVbmlmb3JtSW5kaWNlc1wiLFxuICAgIFwiZ2V0VW5pZm9ybUxvY2F0aW9uXCIsXG4gICAgXCJnZXRVc2VyTWVkaWFcIixcbiAgICBcImdldFZSRGlzcGxheXNcIixcbiAgICBcImdldFZhbHVlc1wiLFxuICAgIFwiZ2V0VmFyRGF0ZVwiLFxuICAgIFwiZ2V0VmFyaWFibGVWYWx1ZVwiLFxuICAgIFwiZ2V0VmVydGV4QXR0cmliXCIsXG4gICAgXCJnZXRWZXJ0ZXhBdHRyaWJPZmZzZXRcIixcbiAgICBcImdldFZpZGVvUGxheWJhY2tRdWFsaXR5XCIsXG4gICAgXCJnZXRWaWRlb1RyYWNrc1wiLFxuICAgIFwiZ2V0Vmlld2VyUG9zZVwiLFxuICAgIFwiZ2V0Vmlld3BvcnRcIixcbiAgICBcImdldFZvaWNlc1wiLFxuICAgIFwiZ2V0V2FrZUxvY2tTdGF0ZVwiLFxuICAgIFwiZ2V0V3JpdGVyXCIsXG4gICAgXCJnZXRZZWFyXCIsXG4gICAgXCJnaXZlbk5hbWVcIixcbiAgICBcImdsb2JhbFwiLFxuICAgIFwiZ2xvYmFsQWxwaGFcIixcbiAgICBcImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblwiLFxuICAgIFwiZ2xvYmFsVGhpc1wiLFxuICAgIFwiZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWxcIixcbiAgICBcImdseXBoT3JpZW50YXRpb25WZXJ0aWNhbFwiLFxuICAgIFwiZ2x5cGhSZWZcIixcbiAgICBcImdvXCIsXG4gICAgXCJncmFiRnJhbWVcIixcbiAgICBcImdyYWRcIixcbiAgICBcImdyYWRpZW50VHJhbnNmb3JtXCIsXG4gICAgXCJncmFkaWVudFVuaXRzXCIsXG4gICAgXCJncmFtbWFyc1wiLFxuICAgIFwiZ3JlZW5cIixcbiAgICBcImdyaWRcIixcbiAgICBcImdyaWQtYXJlYVwiLFxuICAgIFwiZ3JpZC1hdXRvLWNvbHVtbnNcIixcbiAgICBcImdyaWQtYXV0by1mbG93XCIsXG4gICAgXCJncmlkLWF1dG8tcm93c1wiLFxuICAgIFwiZ3JpZC1jb2x1bW5cIixcbiAgICBcImdyaWQtY29sdW1uLWVuZFwiLFxuICAgIFwiZ3JpZC1jb2x1bW4tZ2FwXCIsXG4gICAgXCJncmlkLWNvbHVtbi1zdGFydFwiLFxuICAgIFwiZ3JpZC1nYXBcIixcbiAgICBcImdyaWQtcm93XCIsXG4gICAgXCJncmlkLXJvdy1lbmRcIixcbiAgICBcImdyaWQtcm93LWdhcFwiLFxuICAgIFwiZ3JpZC1yb3ctc3RhcnRcIixcbiAgICBcImdyaWQtdGVtcGxhdGVcIixcbiAgICBcImdyaWQtdGVtcGxhdGUtYXJlYXNcIixcbiAgICBcImdyaWQtdGVtcGxhdGUtY29sdW1uc1wiLFxuICAgIFwiZ3JpZC10ZW1wbGF0ZS1yb3dzXCIsXG4gICAgXCJncmlkQXJlYVwiLFxuICAgIFwiZ3JpZEF1dG9Db2x1bW5zXCIsXG4gICAgXCJncmlkQXV0b0Zsb3dcIixcbiAgICBcImdyaWRBdXRvUm93c1wiLFxuICAgIFwiZ3JpZENvbHVtblwiLFxuICAgIFwiZ3JpZENvbHVtbkVuZFwiLFxuICAgIFwiZ3JpZENvbHVtbkdhcFwiLFxuICAgIFwiZ3JpZENvbHVtblN0YXJ0XCIsXG4gICAgXCJncmlkR2FwXCIsXG4gICAgXCJncmlkUm93XCIsXG4gICAgXCJncmlkUm93RW5kXCIsXG4gICAgXCJncmlkUm93R2FwXCIsXG4gICAgXCJncmlkUm93U3RhcnRcIixcbiAgICBcImdyaWRUZW1wbGF0ZVwiLFxuICAgIFwiZ3JpZFRlbXBsYXRlQXJlYXNcIixcbiAgICBcImdyaWRUZW1wbGF0ZUNvbHVtbnNcIixcbiAgICBcImdyaWRUZW1wbGF0ZVJvd3NcIixcbiAgICBcImdyaXBTcGFjZVwiLFxuICAgIFwiZ3JvdXBcIixcbiAgICBcImdyb3VwQ29sbGFwc2VkXCIsXG4gICAgXCJncm91cEVuZFwiLFxuICAgIFwiZ3JvdXBJZFwiLFxuICAgIFwiaGFkUmVjZW50SW5wdXRcIixcbiAgICBcImhhbmRcIixcbiAgICBcImhhbmRlZG5lc3NcIixcbiAgICBcImhhcHRpY0FjdHVhdG9yc1wiLFxuICAgIFwiaGFyZHdhcmVDb25jdXJyZW5jeVwiLFxuICAgIFwiaGFzXCIsXG4gICAgXCJoYXNBdHRyaWJ1dGVcIixcbiAgICBcImhhc0F0dHJpYnV0ZU5TXCIsXG4gICAgXCJoYXNBdHRyaWJ1dGVzXCIsXG4gICAgXCJoYXNCZWVuQWN0aXZlXCIsXG4gICAgXCJoYXNDaGlsZE5vZGVzXCIsXG4gICAgXCJoYXNDb21wb3NpdGlvblwiLFxuICAgIFwiaGFzRW5yb2xsZWRJbnN0cnVtZW50XCIsXG4gICAgXCJoYXNFeHRlbnNpb25cIixcbiAgICBcImhhc0V4dGVybmFsRGlzcGxheVwiLFxuICAgIFwiaGFzRmVhdHVyZVwiLFxuICAgIFwiaGFzRm9jdXNcIixcbiAgICBcImhhc0luc3RhbmNlXCIsXG4gICAgXCJoYXNMYXlvdXRcIixcbiAgICBcImhhc09yaWVudGF0aW9uXCIsXG4gICAgXCJoYXNPd25Qcm9wZXJ0eVwiLFxuICAgIFwiaGFzUG9pbnRlckNhcHR1cmVcIixcbiAgICBcImhhc1Bvc2l0aW9uXCIsXG4gICAgXCJoYXNSZWFkaW5nXCIsXG4gICAgXCJoYXNTdG9yYWdlQWNjZXNzXCIsXG4gICAgXCJoYXNoXCIsXG4gICAgXCJoZWFkXCIsXG4gICAgXCJoZWFkZXJzXCIsXG4gICAgXCJoZWFkaW5nXCIsXG4gICAgXCJoZWlnaHRcIixcbiAgICBcImhpZGRlblwiLFxuICAgIFwiaGlkZVwiLFxuICAgIFwiaGlkZUZvY3VzXCIsXG4gICAgXCJoaWdoXCIsXG4gICAgXCJoaWdoV2F0ZXJNYXJrXCIsXG4gICAgXCJoaW50XCIsXG4gICAgXCJoaXN0b3J5XCIsXG4gICAgXCJob25vcmlmaWNQcmVmaXhcIixcbiAgICBcImhvbm9yaWZpY1N1ZmZpeFwiLFxuICAgIFwiaG9yaXpvbnRhbE92ZXJmbG93XCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJob3N0Q2FuZGlkYXRlXCIsXG4gICAgXCJob3N0bmFtZVwiLFxuICAgIFwiaHJlZlwiLFxuICAgIFwiaHJlZlRyYW5zbGF0ZVwiLFxuICAgIFwiaHJlZmxhbmdcIixcbiAgICBcImhzcGFjZVwiLFxuICAgIFwiaHRtbDVUYWdDaGVja0luZXJmYWNlXCIsXG4gICAgXCJodG1sRm9yXCIsXG4gICAgXCJodG1sVGV4dFwiLFxuICAgIFwiaHR0cEVxdWl2XCIsXG4gICAgXCJodHRwUmVxdWVzdFN0YXR1c0NvZGVcIixcbiAgICBcImh3VGltZXN0YW1wXCIsXG4gICAgXCJoeXBoZW5zXCIsXG4gICAgXCJoeXBvdFwiLFxuICAgIFwiaWNjSWRcIixcbiAgICBcImljZUNvbm5lY3Rpb25TdGF0ZVwiLFxuICAgIFwiaWNlR2F0aGVyaW5nU3RhdGVcIixcbiAgICBcImljZVRyYW5zcG9ydFwiLFxuICAgIFwiaWNvblwiLFxuICAgIFwiaWNvblVSTFwiLFxuICAgIFwiaWRcIixcbiAgICBcImlkZW50aWZpZXJcIixcbiAgICBcImlkZW50aXR5XCIsXG4gICAgXCJpZHBMb2dpblVybFwiLFxuICAgIFwiaWdub3JlQk9NXCIsXG4gICAgXCJpZ25vcmVDYXNlXCIsXG4gICAgXCJpZ25vcmVEZXB0aFZhbHVlc1wiLFxuICAgIFwiaW1hZ2Utb3JpZW50YXRpb25cIixcbiAgICBcImltYWdlLXJlbmRlcmluZ1wiLFxuICAgIFwiaW1hZ2VIZWlnaHRcIixcbiAgICBcImltYWdlT3JpZW50YXRpb25cIixcbiAgICBcImltYWdlUmVuZGVyaW5nXCIsXG4gICAgXCJpbWFnZVNpemVzXCIsXG4gICAgXCJpbWFnZVNtb290aGluZ0VuYWJsZWRcIixcbiAgICBcImltYWdlU21vb3RoaW5nUXVhbGl0eVwiLFxuICAgIFwiaW1hZ2VTcmNzZXRcIixcbiAgICBcImltYWdlV2lkdGhcIixcbiAgICBcImltYWdlc1wiLFxuICAgIFwiaW1lLW1vZGVcIixcbiAgICBcImltZU1vZGVcIixcbiAgICBcImltcGxlbWVudGF0aW9uXCIsXG4gICAgXCJpbXBvcnRLZXlcIixcbiAgICBcImltcG9ydE5vZGVcIixcbiAgICBcImltcG9ydFN0eWxlc2hlZXRcIixcbiAgICBcImltcG9ydHNcIixcbiAgICBcImltcHBcIixcbiAgICBcImltdWxcIixcbiAgICBcImluXCIsXG4gICAgXCJpbjFcIixcbiAgICBcImluMlwiLFxuICAgIFwiaW5CYW5kTWV0YWRhdGFUcmFja0Rpc3BhdGNoVHlwZVwiLFxuICAgIFwiaW5SYW5nZVwiLFxuICAgIFwiaW5jbHVkZXNcIixcbiAgICBcImluY3JlbWVudGFsXCIsXG4gICAgXCJpbmRldGVybWluYXRlXCIsXG4gICAgXCJpbmRleFwiLFxuICAgIFwiaW5kZXhOYW1lc1wiLFxuICAgIFwiaW5kZXhPZlwiLFxuICAgIFwiaW5kZXhlZERCXCIsXG4gICAgXCJpbmRpY2F0ZVwiLFxuICAgIFwiaW5lcnRpYURlc3RpbmF0aW9uWFwiLFxuICAgIFwiaW5lcnRpYURlc3RpbmF0aW9uWVwiLFxuICAgIFwiaW5mb1wiLFxuICAgIFwiaW5pdFwiLFxuICAgIFwiaW5pdEFuaW1hdGlvbkV2ZW50XCIsXG4gICAgXCJpbml0QmVmb3JlTG9hZEV2ZW50XCIsXG4gICAgXCJpbml0Q2xpcGJvYXJkRXZlbnRcIixcbiAgICBcImluaXRDbG9zZUV2ZW50XCIsXG4gICAgXCJpbml0Q29tbWFuZEV2ZW50XCIsXG4gICAgXCJpbml0Q29tcG9zaXRpb25FdmVudFwiLFxuICAgIFwiaW5pdEN1c3RvbUV2ZW50XCIsXG4gICAgXCJpbml0RGF0YVwiLFxuICAgIFwiaW5pdERhdGFUeXBlXCIsXG4gICAgXCJpbml0RGV2aWNlTW90aW9uRXZlbnRcIixcbiAgICBcImluaXREZXZpY2VPcmllbnRhdGlvbkV2ZW50XCIsXG4gICAgXCJpbml0RHJhZ0V2ZW50XCIsXG4gICAgXCJpbml0RXJyb3JFdmVudFwiLFxuICAgIFwiaW5pdEV2ZW50XCIsXG4gICAgXCJpbml0Rm9jdXNFdmVudFwiLFxuICAgIFwiaW5pdEdlc3R1cmVFdmVudFwiLFxuICAgIFwiaW5pdEhhc2hDaGFuZ2VFdmVudFwiLFxuICAgIFwiaW5pdEtleUV2ZW50XCIsXG4gICAgXCJpbml0S2V5Ym9hcmRFdmVudFwiLFxuICAgIFwiaW5pdE1TTWFuaXB1bGF0aW9uRXZlbnRcIixcbiAgICBcImluaXRNZXNzYWdlRXZlbnRcIixcbiAgICBcImluaXRNb3VzZUV2ZW50XCIsXG4gICAgXCJpbml0TW91c2VTY3JvbGxFdmVudFwiLFxuICAgIFwiaW5pdE1vdXNlV2hlZWxFdmVudFwiLFxuICAgIFwiaW5pdE11dGF0aW9uRXZlbnRcIixcbiAgICBcImluaXROU01vdXNlRXZlbnRcIixcbiAgICBcImluaXRPdmVyZmxvd0V2ZW50XCIsXG4gICAgXCJpbml0UGFnZUV2ZW50XCIsXG4gICAgXCJpbml0UGFnZVRyYW5zaXRpb25FdmVudFwiLFxuICAgIFwiaW5pdFBvaW50ZXJFdmVudFwiLFxuICAgIFwiaW5pdFBvcFN0YXRlRXZlbnRcIixcbiAgICBcImluaXRQcm9ncmVzc0V2ZW50XCIsXG4gICAgXCJpbml0U2Nyb2xsQXJlYUV2ZW50XCIsXG4gICAgXCJpbml0U2ltcGxlR2VzdHVyZUV2ZW50XCIsXG4gICAgXCJpbml0U3RvcmFnZUV2ZW50XCIsXG4gICAgXCJpbml0VGV4dEV2ZW50XCIsXG4gICAgXCJpbml0VGltZUV2ZW50XCIsXG4gICAgXCJpbml0VG91Y2hFdmVudFwiLFxuICAgIFwiaW5pdFRyYW5zaXRpb25FdmVudFwiLFxuICAgIFwiaW5pdFVJRXZlbnRcIixcbiAgICBcImluaXRXZWJLaXRBbmltYXRpb25FdmVudFwiLFxuICAgIFwiaW5pdFdlYktpdFRyYW5zaXRpb25FdmVudFwiLFxuICAgIFwiaW5pdFdlYktpdFdoZWVsRXZlbnRcIixcbiAgICBcImluaXRXaGVlbEV2ZW50XCIsXG4gICAgXCJpbml0aWFsVGltZVwiLFxuICAgIFwiaW5pdGlhbGl6ZVwiLFxuICAgIFwiaW5pdGlhdG9yVHlwZVwiLFxuICAgIFwiaW5saW5lLXNpemVcIixcbiAgICBcImlubGluZVNpemVcIixcbiAgICBcImlubGluZVZlcnRpY2FsRmllbGRPZlZpZXdcIixcbiAgICBcImlubmVyXCIsXG4gICAgXCJpbm5lckhUTUxcIixcbiAgICBcImlubmVySGVpZ2h0XCIsXG4gICAgXCJpbm5lclRleHRcIixcbiAgICBcImlubmVyV2lkdGhcIixcbiAgICBcImlucHV0XCIsXG4gICAgXCJpbnB1dEJ1ZmZlclwiLFxuICAgIFwiaW5wdXRFbmNvZGluZ1wiLFxuICAgIFwiaW5wdXRNZXRob2RcIixcbiAgICBcImlucHV0TW9kZVwiLFxuICAgIFwiaW5wdXRTb3VyY2VcIixcbiAgICBcImlucHV0U291cmNlc1wiLFxuICAgIFwiaW5wdXRUeXBlXCIsXG4gICAgXCJpbnB1dHNcIixcbiAgICBcImluc2VydEFkamFjZW50RWxlbWVudFwiLFxuICAgIFwiaW5zZXJ0QWRqYWNlbnRIVE1MXCIsXG4gICAgXCJpbnNlcnRBZGphY2VudFRleHRcIixcbiAgICBcImluc2VydEJlZm9yZVwiLFxuICAgIFwiaW5zZXJ0Q2VsbFwiLFxuICAgIFwiaW5zZXJ0RFRNRlwiLFxuICAgIFwiaW5zZXJ0RGF0YVwiLFxuICAgIFwiaW5zZXJ0SXRlbUJlZm9yZVwiLFxuICAgIFwiaW5zZXJ0Tm9kZVwiLFxuICAgIFwiaW5zZXJ0Um93XCIsXG4gICAgXCJpbnNlcnRSdWxlXCIsXG4gICAgXCJpbnNldFwiLFxuICAgIFwiaW5zZXQtYmxvY2tcIixcbiAgICBcImluc2V0LWJsb2NrLWVuZFwiLFxuICAgIFwiaW5zZXQtYmxvY2stc3RhcnRcIixcbiAgICBcImluc2V0LWlubGluZVwiLFxuICAgIFwiaW5zZXQtaW5saW5lLWVuZFwiLFxuICAgIFwiaW5zZXQtaW5saW5lLXN0YXJ0XCIsXG4gICAgXCJpbnNldEJsb2NrXCIsXG4gICAgXCJpbnNldEJsb2NrRW5kXCIsXG4gICAgXCJpbnNldEJsb2NrU3RhcnRcIixcbiAgICBcImluc2V0SW5saW5lXCIsXG4gICAgXCJpbnNldElubGluZUVuZFwiLFxuICAgIFwiaW5zZXRJbmxpbmVTdGFydFwiLFxuICAgIFwiaW5zdGFsbGluZ1wiLFxuICAgIFwiaW5zdGFuY2VSb290XCIsXG4gICAgXCJpbnN0YW50aWF0ZVwiLFxuICAgIFwiaW5zdGFudGlhdGVTdHJlYW1pbmdcIixcbiAgICBcImluc3RydW1lbnRzXCIsXG4gICAgXCJpbnQxNlwiLFxuICAgIFwiaW50MzJcIixcbiAgICBcImludDhcIixcbiAgICBcImludGVncml0eVwiLFxuICAgIFwiaW50ZXJhY3Rpb25Nb2RlXCIsXG4gICAgXCJpbnRlcmNlcHRcIixcbiAgICBcImludGVyZmFjZUNsYXNzXCIsXG4gICAgXCJpbnRlcmZhY2VOYW1lXCIsXG4gICAgXCJpbnRlcmZhY2VOdW1iZXJcIixcbiAgICBcImludGVyZmFjZVByb3RvY29sXCIsXG4gICAgXCJpbnRlcmZhY2VTdWJjbGFzc1wiLFxuICAgIFwiaW50ZXJmYWNlc1wiLFxuICAgIFwiaW50ZXJpbVJlc3VsdHNcIixcbiAgICBcImludGVybmFsU3Vic2V0XCIsXG4gICAgXCJpbnRlcnByZXRhdGlvblwiLFxuICAgIFwiaW50ZXJzZWN0aW9uUmF0aW9cIixcbiAgICBcImludGVyc2VjdGlvblJlY3RcIixcbiAgICBcImludGVyc2VjdHNOb2RlXCIsXG4gICAgXCJpbnRlcnZhbFwiLFxuICAgIFwiaW52YWxpZEl0ZXJhdG9yU3RhdGVcIixcbiAgICBcImludmFsaWRhdGVGcmFtZWJ1ZmZlclwiLFxuICAgIFwiaW52YWxpZGF0ZVN1YkZyYW1lYnVmZmVyXCIsXG4gICAgXCJpbnZlcnNlXCIsXG4gICAgXCJpbnZlcnRTZWxmXCIsXG4gICAgXCJpc1wiLFxuICAgIFwiaXMyRFwiLFxuICAgIFwiaXNBY3RpdmVcIixcbiAgICBcImlzQWx0ZXJuYXRlXCIsXG4gICAgXCJpc0FycmF5XCIsXG4gICAgXCJpc0JpbmdDdXJyZW50U2VhcmNoRGVmYXVsdFwiLFxuICAgIFwiaXNCdWZmZXJcIixcbiAgICBcImlzQ2FuZGlkYXRlV2luZG93VmlzaWJsZVwiLFxuICAgIFwiaXNDaGFyXCIsXG4gICAgXCJpc0NvbGxhcHNlZFwiLFxuICAgIFwiaXNDb21wb3NpbmdcIixcbiAgICBcImlzQ29uY2F0U3ByZWFkYWJsZVwiLFxuICAgIFwiaXNDb25uZWN0ZWRcIixcbiAgICBcImlzQ29udGVudEVkaXRhYmxlXCIsXG4gICAgXCJpc0NvbnRlbnRIYW5kbGVyUmVnaXN0ZXJlZFwiLFxuICAgIFwiaXNDb250ZXh0TG9zdFwiLFxuICAgIFwiaXNEZWZhdWx0TmFtZXNwYWNlXCIsXG4gICAgXCJpc0RpcmVjdG9yeVwiLFxuICAgIFwiaXNEaXNhYmxlZFwiLFxuICAgIFwiaXNFbmFibGVkXCIsXG4gICAgXCJpc0VxdWFsXCIsXG4gICAgXCJpc0VxdWFsTm9kZVwiLFxuICAgIFwiaXNFeHRlbnNpYmxlXCIsXG4gICAgXCJpc0V4dGVybmFsQ1RBUDJTZWN1cml0eUtleVN1cHBvcnRlZFwiLFxuICAgIFwiaXNGaWxlXCIsXG4gICAgXCJpc0Zpbml0ZVwiLFxuICAgIFwiaXNGcmFtZWJ1ZmZlclwiLFxuICAgIFwiaXNGcm96ZW5cIixcbiAgICBcImlzR2VuZXJhdG9yXCIsXG4gICAgXCJpc0hUTUxcIixcbiAgICBcImlzSGlzdG9yeU5hdmlnYXRpb25cIixcbiAgICBcImlzSWRcIixcbiAgICBcImlzSWRlbnRpdHlcIixcbiAgICBcImlzSW5qZWN0ZWRcIixcbiAgICBcImlzSW50ZWdlclwiLFxuICAgIFwiaXNJbnRlcnNlY3RpbmdcIixcbiAgICBcImlzTG9ja0ZyZWVcIixcbiAgICBcImlzTWFwXCIsXG4gICAgXCJpc011bHRpTGluZVwiLFxuICAgIFwiaXNOYU5cIixcbiAgICBcImlzT3BlblwiLFxuICAgIFwiaXNQb2ludEluRmlsbFwiLFxuICAgIFwiaXNQb2ludEluUGF0aFwiLFxuICAgIFwiaXNQb2ludEluUmFuZ2VcIixcbiAgICBcImlzUG9pbnRJblN0cm9rZVwiLFxuICAgIFwiaXNQcmVmQWx0ZXJuYXRlXCIsXG4gICAgXCJpc1ByZXNlbnRpbmdcIixcbiAgICBcImlzUHJpbWFyeVwiLFxuICAgIFwiaXNQcm9ncmFtXCIsXG4gICAgXCJpc1Byb3BlcnR5SW1wbGljaXRcIixcbiAgICBcImlzUHJvdG9jb2xIYW5kbGVyUmVnaXN0ZXJlZFwiLFxuICAgIFwiaXNQcm90b3R5cGVPZlwiLFxuICAgIFwiaXNRdWVyeVwiLFxuICAgIFwiaXNSZW5kZXJidWZmZXJcIixcbiAgICBcImlzU2FmZUludGVnZXJcIixcbiAgICBcImlzU2FtZU5vZGVcIixcbiAgICBcImlzU2FtcGxlclwiLFxuICAgIFwiaXNTY3JpcHRcIixcbiAgICBcImlzU2NyaXB0VVJMXCIsXG4gICAgXCJpc1NlYWxlZFwiLFxuICAgIFwiaXNTZWN1cmVDb250ZXh0XCIsXG4gICAgXCJpc1Nlc3Npb25TdXBwb3J0ZWRcIixcbiAgICBcImlzU2hhZGVyXCIsXG4gICAgXCJpc1N1cHBvcnRlZFwiLFxuICAgIFwiaXNTeW5jXCIsXG4gICAgXCJpc1RleHRFZGl0XCIsXG4gICAgXCJpc1RleHR1cmVcIixcbiAgICBcImlzVHJhbnNmb3JtRmVlZGJhY2tcIixcbiAgICBcImlzVHJ1c3RlZFwiLFxuICAgIFwiaXNUeXBlU3VwcG9ydGVkXCIsXG4gICAgXCJpc1VzZXJWZXJpZnlpbmdQbGF0Zm9ybUF1dGhlbnRpY2F0b3JBdmFpbGFibGVcIixcbiAgICBcImlzVmVydGV4QXJyYXlcIixcbiAgICBcImlzVmlld1wiLFxuICAgIFwiaXNWaXNpYmxlXCIsXG4gICAgXCJpc29jaHJvbm91c1RyYW5zZmVySW5cIixcbiAgICBcImlzb2Nocm9ub3VzVHJhbnNmZXJPdXRcIixcbiAgICBcImlzb2xhdGlvblwiLFxuICAgIFwiaXRhbGljc1wiLFxuICAgIFwiaXRlbVwiLFxuICAgIFwiaXRlbUlkXCIsXG4gICAgXCJpdGVtUHJvcFwiLFxuICAgIFwiaXRlbVJlZlwiLFxuICAgIFwiaXRlbVNjb3BlXCIsXG4gICAgXCJpdGVtVHlwZVwiLFxuICAgIFwiaXRlbVZhbHVlXCIsXG4gICAgXCJpdGVtc1wiLFxuICAgIFwiaXRlcmF0ZU5leHRcIixcbiAgICBcIml0ZXJhdGlvbkNvbXBvc2l0ZVwiLFxuICAgIFwiaXRlcmF0b3JcIixcbiAgICBcImphdmFFbmFibGVkXCIsXG4gICAgXCJqb2JUaXRsZVwiLFxuICAgIFwiam9pblwiLFxuICAgIFwianNvblwiLFxuICAgIFwianVzdGlmeS1jb250ZW50XCIsXG4gICAgXCJqdXN0aWZ5LWl0ZW1zXCIsXG4gICAgXCJqdXN0aWZ5LXNlbGZcIixcbiAgICBcImp1c3RpZnlDb250ZW50XCIsXG4gICAgXCJqdXN0aWZ5SXRlbXNcIixcbiAgICBcImp1c3RpZnlTZWxmXCIsXG4gICAgXCJrMVwiLFxuICAgIFwiazJcIixcbiAgICBcImszXCIsXG4gICAgXCJrNFwiLFxuICAgIFwia0h6XCIsXG4gICAgXCJrZWVwYWxpdmVcIixcbiAgICBcImtlcm5lbE1hdHJpeFwiLFxuICAgIFwia2VybmVsVW5pdExlbmd0aFhcIixcbiAgICBcImtlcm5lbFVuaXRMZW5ndGhZXCIsXG4gICAgXCJrZXJuaW5nXCIsXG4gICAgXCJrZXlcIixcbiAgICBcImtleUNvZGVcIixcbiAgICBcImtleUZvclwiLFxuICAgIFwia2V5SWRlbnRpZmllclwiLFxuICAgIFwia2V5TGlnaHRFbmFibGVkXCIsXG4gICAgXCJrZXlMb2NhdGlvblwiLFxuICAgIFwia2V5UGF0aFwiLFxuICAgIFwia2V5U3RhdHVzZXNcIixcbiAgICBcImtleVN5c3RlbVwiLFxuICAgIFwia2V5VGV4dFwiLFxuICAgIFwia2V5VXNhZ2VcIixcbiAgICBcImtleWJvYXJkXCIsXG4gICAgXCJrZXlzXCIsXG4gICAgXCJrZXl0eXBlXCIsXG4gICAgXCJraW5kXCIsXG4gICAgXCJrbmVlXCIsXG4gICAgXCJsYWJlbFwiLFxuICAgIFwibGFiZWxzXCIsXG4gICAgXCJsYW5nXCIsXG4gICAgXCJsYW5ndWFnZVwiLFxuICAgIFwibGFuZ3VhZ2VzXCIsXG4gICAgXCJsYXJnZUFyY0ZsYWdcIixcbiAgICBcImxhc3RDaGlsZFwiLFxuICAgIFwibGFzdEVsZW1lbnRDaGlsZFwiLFxuICAgIFwibGFzdEV2ZW50SWRcIixcbiAgICBcImxhc3RJbmRleFwiLFxuICAgIFwibGFzdEluZGV4T2ZcIixcbiAgICBcImxhc3RJbnB1dFRpbWVcIixcbiAgICBcImxhc3RNYXRjaFwiLFxuICAgIFwibGFzdE1lc3NhZ2VTdWJqZWN0XCIsXG4gICAgXCJsYXN0TWVzc2FnZVR5cGVcIixcbiAgICBcImxhc3RNb2RpZmllZFwiLFxuICAgIFwibGFzdE1vZGlmaWVkRGF0ZVwiLFxuICAgIFwibGFzdFBhZ2VcIixcbiAgICBcImxhc3RQYXJlblwiLFxuICAgIFwibGFzdFN0YXRlXCIsXG4gICAgXCJsYXN0U3R5bGVTaGVldFNldFwiLFxuICAgIFwibGF0aXR1ZGVcIixcbiAgICBcImxheWVyWFwiLFxuICAgIFwibGF5ZXJZXCIsXG4gICAgXCJsYXlvdXRGbG93XCIsXG4gICAgXCJsYXlvdXRHcmlkXCIsXG4gICAgXCJsYXlvdXRHcmlkQ2hhclwiLFxuICAgIFwibGF5b3V0R3JpZExpbmVcIixcbiAgICBcImxheW91dEdyaWRNb2RlXCIsXG4gICAgXCJsYXlvdXRHcmlkVHlwZVwiLFxuICAgIFwibGJvdW5kXCIsXG4gICAgXCJsZWZ0XCIsXG4gICAgXCJsZWZ0Q29udGV4dFwiLFxuICAgIFwibGVmdERlZ3JlZXNcIixcbiAgICBcImxlZnRNYXJnaW5cIixcbiAgICBcImxlZnRQcm9qZWN0aW9uTWF0cml4XCIsXG4gICAgXCJsZWZ0Vmlld01hdHJpeFwiLFxuICAgIFwibGVuZ3RoXCIsXG4gICAgXCJsZW5ndGhBZGp1c3RcIixcbiAgICBcImxlbmd0aENvbXB1dGFibGVcIixcbiAgICBcImxldHRlci1zcGFjaW5nXCIsXG4gICAgXCJsZXR0ZXJTcGFjaW5nXCIsXG4gICAgXCJsZXZlbFwiLFxuICAgIFwibGlnaHRpbmctY29sb3JcIixcbiAgICBcImxpZ2h0aW5nQ29sb3JcIixcbiAgICBcImxpbWl0aW5nQ29uZUFuZ2xlXCIsXG4gICAgXCJsaW5lXCIsXG4gICAgXCJsaW5lLWJyZWFrXCIsXG4gICAgXCJsaW5lLWhlaWdodFwiLFxuICAgIFwibGluZUFsaWduXCIsXG4gICAgXCJsaW5lQnJlYWtcIixcbiAgICBcImxpbmVDYXBcIixcbiAgICBcImxpbmVEYXNoT2Zmc2V0XCIsXG4gICAgXCJsaW5lSGVpZ2h0XCIsXG4gICAgXCJsaW5lSm9pblwiLFxuICAgIFwibGluZU51bWJlclwiLFxuICAgIFwibGluZVRvXCIsXG4gICAgXCJsaW5lV2lkdGhcIixcbiAgICBcImxpbmVhckFjY2VsZXJhdGlvblwiLFxuICAgIFwibGluZWFyUmFtcFRvVmFsdWVBdFRpbWVcIixcbiAgICBcImxpbmVhclZlbG9jaXR5XCIsXG4gICAgXCJsaW5lbm9cIixcbiAgICBcImxpbmVzXCIsXG4gICAgXCJsaW5rXCIsXG4gICAgXCJsaW5rQ29sb3JcIixcbiAgICBcImxpbmtQcm9ncmFtXCIsXG4gICAgXCJsaW5rc1wiLFxuICAgIFwibGlzdFwiLFxuICAgIFwibGlzdC1zdHlsZVwiLFxuICAgIFwibGlzdC1zdHlsZS1pbWFnZVwiLFxuICAgIFwibGlzdC1zdHlsZS1wb3NpdGlvblwiLFxuICAgIFwibGlzdC1zdHlsZS10eXBlXCIsXG4gICAgXCJsaXN0U3R5bGVcIixcbiAgICBcImxpc3RTdHlsZUltYWdlXCIsXG4gICAgXCJsaXN0U3R5bGVQb3NpdGlvblwiLFxuICAgIFwibGlzdFN0eWxlVHlwZVwiLFxuICAgIFwibGlzdGVuZXJcIixcbiAgICBcImxvYWRcIixcbiAgICBcImxvYWRFdmVudEVuZFwiLFxuICAgIFwibG9hZEV2ZW50U3RhcnRcIixcbiAgICBcImxvYWRUaW1lXCIsXG4gICAgXCJsb2FkVGltZXNcIixcbiAgICBcImxvYWRlZFwiLFxuICAgIFwibG9hZGluZ1wiLFxuICAgIFwibG9jYWxEZXNjcmlwdGlvblwiLFxuICAgIFwibG9jYWxOYW1lXCIsXG4gICAgXCJsb2NhbFNlcnZpY2VcIixcbiAgICBcImxvY2FsU3RvcmFnZVwiLFxuICAgIFwibG9jYWxlXCIsXG4gICAgXCJsb2NhbGVDb21wYXJlXCIsXG4gICAgXCJsb2NhdGlvblwiLFxuICAgIFwibG9jYXRpb25iYXJcIixcbiAgICBcImxvY2tcIixcbiAgICBcImxvY2tlZFwiLFxuICAgIFwibG9ja2VkRmlsZVwiLFxuICAgIFwibG9ja3NcIixcbiAgICBcImxvZ1wiLFxuICAgIFwibG9nMTBcIixcbiAgICBcImxvZzFwXCIsXG4gICAgXCJsb2cyXCIsXG4gICAgXCJsb2dpY2FsWERQSVwiLFxuICAgIFwibG9naWNhbFlEUElcIixcbiAgICBcImxvbmdEZXNjXCIsXG4gICAgXCJsb25naXR1ZGVcIixcbiAgICBcImxvb2t1cE5hbWVzcGFjZVVSSVwiLFxuICAgIFwibG9va3VwUHJlZml4XCIsXG4gICAgXCJsb29wXCIsXG4gICAgXCJsb29wRW5kXCIsXG4gICAgXCJsb29wU3RhcnRcIixcbiAgICBcImxvb3BpbmdcIixcbiAgICBcImxvd1wiLFxuICAgIFwibG93ZXJcIixcbiAgICBcImxvd2VyQm91bmRcIixcbiAgICBcImxvd2VyT3BlblwiLFxuICAgIFwibG93c3JjXCIsXG4gICAgXCJtMTFcIixcbiAgICBcIm0xMlwiLFxuICAgIFwibTEzXCIsXG4gICAgXCJtMTRcIixcbiAgICBcIm0yMVwiLFxuICAgIFwibTIyXCIsXG4gICAgXCJtMjNcIixcbiAgICBcIm0yNFwiLFxuICAgIFwibTMxXCIsXG4gICAgXCJtMzJcIixcbiAgICBcIm0zM1wiLFxuICAgIFwibTM0XCIsXG4gICAgXCJtNDFcIixcbiAgICBcIm00MlwiLFxuICAgIFwibTQzXCIsXG4gICAgXCJtNDRcIixcbiAgICBcIm1ha2VYUkNvbXBhdGlibGVcIixcbiAgICBcIm1hbmlmZXN0XCIsXG4gICAgXCJtYW51ZmFjdHVyZXJcIixcbiAgICBcIm1hbnVmYWN0dXJlck5hbWVcIixcbiAgICBcIm1hcFwiLFxuICAgIFwibWFwcGluZ1wiLFxuICAgIFwibWFyZ2luXCIsXG4gICAgXCJtYXJnaW4tYmxvY2tcIixcbiAgICBcIm1hcmdpbi1ibG9jay1lbmRcIixcbiAgICBcIm1hcmdpbi1ibG9jay1zdGFydFwiLFxuICAgIFwibWFyZ2luLWJvdHRvbVwiLFxuICAgIFwibWFyZ2luLWlubGluZVwiLFxuICAgIFwibWFyZ2luLWlubGluZS1lbmRcIixcbiAgICBcIm1hcmdpbi1pbmxpbmUtc3RhcnRcIixcbiAgICBcIm1hcmdpbi1sZWZ0XCIsXG4gICAgXCJtYXJnaW4tcmlnaHRcIixcbiAgICBcIm1hcmdpbi10b3BcIixcbiAgICBcIm1hcmdpbkJsb2NrXCIsXG4gICAgXCJtYXJnaW5CbG9ja0VuZFwiLFxuICAgIFwibWFyZ2luQmxvY2tTdGFydFwiLFxuICAgIFwibWFyZ2luQm90dG9tXCIsXG4gICAgXCJtYXJnaW5IZWlnaHRcIixcbiAgICBcIm1hcmdpbklubGluZVwiLFxuICAgIFwibWFyZ2luSW5saW5lRW5kXCIsXG4gICAgXCJtYXJnaW5JbmxpbmVTdGFydFwiLFxuICAgIFwibWFyZ2luTGVmdFwiLFxuICAgIFwibWFyZ2luUmlnaHRcIixcbiAgICBcIm1hcmdpblRvcFwiLFxuICAgIFwibWFyZ2luV2lkdGhcIixcbiAgICBcIm1hcmtcIixcbiAgICBcIm1hcmtlclwiLFxuICAgIFwibWFya2VyLWVuZFwiLFxuICAgIFwibWFya2VyLW1pZFwiLFxuICAgIFwibWFya2VyLW9mZnNldFwiLFxuICAgIFwibWFya2VyLXN0YXJ0XCIsXG4gICAgXCJtYXJrZXJFbmRcIixcbiAgICBcIm1hcmtlckhlaWdodFwiLFxuICAgIFwibWFya2VyTWlkXCIsXG4gICAgXCJtYXJrZXJPZmZzZXRcIixcbiAgICBcIm1hcmtlclN0YXJ0XCIsXG4gICAgXCJtYXJrZXJVbml0c1wiLFxuICAgIFwibWFya2VyV2lkdGhcIixcbiAgICBcIm1hcmtzXCIsXG4gICAgXCJtYXNrXCIsXG4gICAgXCJtYXNrLWNsaXBcIixcbiAgICBcIm1hc2stY29tcG9zaXRlXCIsXG4gICAgXCJtYXNrLWltYWdlXCIsXG4gICAgXCJtYXNrLW1vZGVcIixcbiAgICBcIm1hc2stb3JpZ2luXCIsXG4gICAgXCJtYXNrLXBvc2l0aW9uXCIsXG4gICAgXCJtYXNrLXBvc2l0aW9uLXhcIixcbiAgICBcIm1hc2stcG9zaXRpb24teVwiLFxuICAgIFwibWFzay1yZXBlYXRcIixcbiAgICBcIm1hc2stc2l6ZVwiLFxuICAgIFwibWFzay10eXBlXCIsXG4gICAgXCJtYXNrQ2xpcFwiLFxuICAgIFwibWFza0NvbXBvc2l0ZVwiLFxuICAgIFwibWFza0NvbnRlbnRVbml0c1wiLFxuICAgIFwibWFza0ltYWdlXCIsXG4gICAgXCJtYXNrTW9kZVwiLFxuICAgIFwibWFza09yaWdpblwiLFxuICAgIFwibWFza1Bvc2l0aW9uXCIsXG4gICAgXCJtYXNrUG9zaXRpb25YXCIsXG4gICAgXCJtYXNrUG9zaXRpb25ZXCIsXG4gICAgXCJtYXNrUmVwZWF0XCIsXG4gICAgXCJtYXNrU2l6ZVwiLFxuICAgIFwibWFza1R5cGVcIixcbiAgICBcIm1hc2tVbml0c1wiLFxuICAgIFwibWF0Y2hcIixcbiAgICBcIm1hdGNoQWxsXCIsXG4gICAgXCJtYXRjaE1lZGlhXCIsXG4gICAgXCJtYXRjaE1lZGl1bVwiLFxuICAgIFwibWF0Y2hlc1wiLFxuICAgIFwibWF0cml4XCIsXG4gICAgXCJtYXRyaXhUcmFuc2Zvcm1cIixcbiAgICBcIm1heFwiLFxuICAgIFwibWF4LWJsb2NrLXNpemVcIixcbiAgICBcIm1heC1oZWlnaHRcIixcbiAgICBcIm1heC1pbmxpbmUtc2l6ZVwiLFxuICAgIFwibWF4LXdpZHRoXCIsXG4gICAgXCJtYXhBY3Rpb25zXCIsXG4gICAgXCJtYXhBbHRlcm5hdGl2ZXNcIixcbiAgICBcIm1heEJsb2NrU2l6ZVwiLFxuICAgIFwibWF4Q2hhbm5lbENvdW50XCIsXG4gICAgXCJtYXhDaGFubmVsc1wiLFxuICAgIFwibWF4Q29ubmVjdGlvbnNQZXJTZXJ2ZXJcIixcbiAgICBcIm1heERlY2liZWxzXCIsXG4gICAgXCJtYXhEaXN0YW5jZVwiLFxuICAgIFwibWF4SGVpZ2h0XCIsXG4gICAgXCJtYXhJbmxpbmVTaXplXCIsXG4gICAgXCJtYXhMYXllcnNcIixcbiAgICBcIm1heExlbmd0aFwiLFxuICAgIFwibWF4TWVzc2FnZVNpemVcIixcbiAgICBcIm1heFBhY2tldExpZmVUaW1lXCIsXG4gICAgXCJtYXhSZXRyYW5zbWl0c1wiLFxuICAgIFwibWF4VG91Y2hQb2ludHNcIixcbiAgICBcIm1heFZhbHVlXCIsXG4gICAgXCJtYXhXaWR0aFwiLFxuICAgIFwibWVhc3VyZVwiLFxuICAgIFwibWVhc3VyZVRleHRcIixcbiAgICBcIm1lZGlhXCIsXG4gICAgXCJtZWRpYUNhcGFiaWxpdGllc1wiLFxuICAgIFwibWVkaWFEZXZpY2VzXCIsXG4gICAgXCJtZWRpYUVsZW1lbnRcIixcbiAgICBcIm1lZGlhR3JvdXBcIixcbiAgICBcIm1lZGlhS2V5c1wiLFxuICAgIFwibWVkaWFTZXNzaW9uXCIsXG4gICAgXCJtZWRpYVN0cmVhbVwiLFxuICAgIFwibWVkaWFUZXh0XCIsXG4gICAgXCJtZWV0T3JTbGljZVwiLFxuICAgIFwibWVtb3J5XCIsXG4gICAgXCJtZW51YmFyXCIsXG4gICAgXCJtZXJnZUF0dHJpYnV0ZXNcIixcbiAgICBcIm1lc3NhZ2VcIixcbiAgICBcIm1lc3NhZ2VDbGFzc1wiLFxuICAgIFwibWVzc2FnZUhhbmRsZXJzXCIsXG4gICAgXCJtZXNzYWdlVHlwZVwiLFxuICAgIFwibWV0YUtleVwiLFxuICAgIFwibWV0YWRhdGFcIixcbiAgICBcIm1ldGhvZFwiLFxuICAgIFwibWV0aG9kRGV0YWlsc1wiLFxuICAgIFwibWV0aG9kTmFtZVwiLFxuICAgIFwibWlkXCIsXG4gICAgXCJtaW1lVHlwZVwiLFxuICAgIFwibWltZVR5cGVzXCIsXG4gICAgXCJtaW5cIixcbiAgICBcIm1pbi1ibG9jay1zaXplXCIsXG4gICAgXCJtaW4taGVpZ2h0XCIsXG4gICAgXCJtaW4taW5saW5lLXNpemVcIixcbiAgICBcIm1pbi13aWR0aFwiLFxuICAgIFwibWluQmxvY2tTaXplXCIsXG4gICAgXCJtaW5EZWNpYmVsc1wiLFxuICAgIFwibWluSGVpZ2h0XCIsXG4gICAgXCJtaW5JbmxpbmVTaXplXCIsXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcIm1pblZhbHVlXCIsXG4gICAgXCJtaW5XaWR0aFwiLFxuICAgIFwibWl0ZXJMaW1pdFwiLFxuICAgIFwibWl4LWJsZW5kLW1vZGVcIixcbiAgICBcIm1peEJsZW5kTW9kZVwiLFxuICAgIFwibW1cIixcbiAgICBcIm1vZGVcIixcbiAgICBcIm1vZGlmeVwiLFxuICAgIFwibW91bnRcIixcbiAgICBcIm1vdmVcIixcbiAgICBcIm1vdmVCeVwiLFxuICAgIFwibW92ZUVuZFwiLFxuICAgIFwibW92ZUZpcnN0XCIsXG4gICAgXCJtb3ZlRm9jdXNEb3duXCIsXG4gICAgXCJtb3ZlRm9jdXNMZWZ0XCIsXG4gICAgXCJtb3ZlRm9jdXNSaWdodFwiLFxuICAgIFwibW92ZUZvY3VzVXBcIixcbiAgICBcIm1vdmVOZXh0XCIsXG4gICAgXCJtb3ZlUm93XCIsXG4gICAgXCJtb3ZlU3RhcnRcIixcbiAgICBcIm1vdmVUb1wiLFxuICAgIFwibW92ZVRvQm9va21hcmtcIixcbiAgICBcIm1vdmVUb0VsZW1lbnRUZXh0XCIsXG4gICAgXCJtb3ZlVG9Qb2ludFwiLFxuICAgIFwibW92ZW1lbnRYXCIsXG4gICAgXCJtb3ZlbWVudFlcIixcbiAgICBcIm1vekFkZFwiLFxuICAgIFwibW96QW5pbWF0aW9uU3RhcnRUaW1lXCIsXG4gICAgXCJtb3pBbm9uXCIsXG4gICAgXCJtb3pBcHBzXCIsXG4gICAgXCJtb3pBdWRpb0NhcHR1cmVkXCIsXG4gICAgXCJtb3pBdWRpb0NoYW5uZWxUeXBlXCIsXG4gICAgXCJtb3pBdXRvcGxheUVuYWJsZWRcIixcbiAgICBcIm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lXCIsXG4gICAgXCJtb3pDYW5jZWxGdWxsU2NyZWVuXCIsXG4gICAgXCJtb3pDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIixcbiAgICBcIm1vekNhcHR1cmVTdHJlYW1cIixcbiAgICBcIm1vekNhcHR1cmVTdHJlYW1VbnRpbEVuZGVkXCIsXG4gICAgXCJtb3pDbGVhckRhdGFBdFwiLFxuICAgIFwibW96Q29udGFjdFwiLFxuICAgIFwibW96Q29udGFjdHNcIixcbiAgICBcIm1vekNyZWF0ZUZpbGVIYW5kbGVcIixcbiAgICBcIm1vekN1cnJlbnRUcmFuc2Zvcm1cIixcbiAgICBcIm1vekN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlXCIsXG4gICAgXCJtb3pDdXJzb3JcIixcbiAgICBcIm1vekRhc2hcIixcbiAgICBcIm1vekRhc2hPZmZzZXRcIixcbiAgICBcIm1vekRlY29kZWRGcmFtZXNcIixcbiAgICBcIm1vekV4aXRQb2ludGVyTG9ja1wiLFxuICAgIFwibW96RmlsbFJ1bGVcIixcbiAgICBcIm1vekZyYWdtZW50RW5kXCIsXG4gICAgXCJtb3pGcmFtZURlbGF5XCIsXG4gICAgXCJtb3pGdWxsU2NyZWVuXCIsXG4gICAgXCJtb3pGdWxsU2NyZWVuRWxlbWVudFwiLFxuICAgIFwibW96RnVsbFNjcmVlbkVuYWJsZWRcIixcbiAgICBcIm1vekdldEFsbFwiLFxuICAgIFwibW96R2V0QWxsS2V5c1wiLFxuICAgIFwibW96R2V0QXNGaWxlXCIsXG4gICAgXCJtb3pHZXREYXRhQXRcIixcbiAgICBcIm1vekdldE1ldGFkYXRhXCIsXG4gICAgXCJtb3pHZXRVc2VyTWVkaWFcIixcbiAgICBcIm1vekhhc0F1ZGlvXCIsXG4gICAgXCJtb3pIYXNJdGVtXCIsXG4gICAgXCJtb3pIaWRkZW5cIixcbiAgICBcIm1vekltYWdlU21vb3RoaW5nRW5hYmxlZFwiLFxuICAgIFwibW96SW5kZXhlZERCXCIsXG4gICAgXCJtb3pJbm5lclNjcmVlblhcIixcbiAgICBcIm1veklubmVyU2NyZWVuWVwiLFxuICAgIFwibW96SW5wdXRTb3VyY2VcIixcbiAgICBcIm1veklzVGV4dEZpZWxkXCIsXG4gICAgXCJtb3pJdGVtXCIsXG4gICAgXCJtb3pJdGVtQ291bnRcIixcbiAgICBcIm1vekl0ZW1zXCIsXG4gICAgXCJtb3pMZW5ndGhcIixcbiAgICBcIm1vekxvY2tPcmllbnRhdGlvblwiLFxuICAgIFwibW96TWF0Y2hlc1NlbGVjdG9yXCIsXG4gICAgXCJtb3pNb3ZlbWVudFhcIixcbiAgICBcIm1vek1vdmVtZW50WVwiLFxuICAgIFwibW96T3BhcXVlXCIsXG4gICAgXCJtb3pPcmllbnRhdGlvblwiLFxuICAgIFwibW96UGFpbnRDb3VudFwiLFxuICAgIFwibW96UGFpbnRlZEZyYW1lc1wiLFxuICAgIFwibW96UGFyc2VkRnJhbWVzXCIsXG4gICAgXCJtb3pQYXlcIixcbiAgICBcIm1velBvaW50ZXJMb2NrRWxlbWVudFwiLFxuICAgIFwibW96UHJlc2VudGVkRnJhbWVzXCIsXG4gICAgXCJtb3pQcmVzZXJ2ZXNQaXRjaFwiLFxuICAgIFwibW96UHJlc3N1cmVcIixcbiAgICBcIm1velByaW50Q2FsbGJhY2tcIixcbiAgICBcIm1velJUQ0ljZUNhbmRpZGF0ZVwiLFxuICAgIFwibW96UlRDUGVlckNvbm5lY3Rpb25cIixcbiAgICBcIm1velJUQ1Nlc3Npb25EZXNjcmlwdGlvblwiLFxuICAgIFwibW96UmVtb3ZlXCIsXG4gICAgXCJtb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIixcbiAgICBcIm1velJlcXVlc3RGdWxsU2NyZWVuXCIsXG4gICAgXCJtb3pSZXF1ZXN0UG9pbnRlckxvY2tcIixcbiAgICBcIm1velNldERhdGFBdFwiLFxuICAgIFwibW96U2V0SW1hZ2VFbGVtZW50XCIsXG4gICAgXCJtb3pTb3VyY2VOb2RlXCIsXG4gICAgXCJtb3pTcmNPYmplY3RcIixcbiAgICBcIm1velN5c3RlbVwiLFxuICAgIFwibW96VENQU29ja2V0XCIsXG4gICAgXCJtb3pUZXh0U3R5bGVcIixcbiAgICBcIm1velR5cGVzQXRcIixcbiAgICBcIm1velVubG9ja09yaWVudGF0aW9uXCIsXG4gICAgXCJtb3pVc2VyQ2FuY2VsbGVkXCIsXG4gICAgXCJtb3pWaXNpYmlsaXR5U3RhdGVcIixcbiAgICBcIm1zXCIsXG4gICAgXCJtc0FuaW1hdGlvblwiLFxuICAgIFwibXNBbmltYXRpb25EZWxheVwiLFxuICAgIFwibXNBbmltYXRpb25EaXJlY3Rpb25cIixcbiAgICBcIm1zQW5pbWF0aW9uRHVyYXRpb25cIixcbiAgICBcIm1zQW5pbWF0aW9uRmlsbE1vZGVcIixcbiAgICBcIm1zQW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIixcbiAgICBcIm1zQW5pbWF0aW9uTmFtZVwiLFxuICAgIFwibXNBbmltYXRpb25QbGF5U3RhdGVcIixcbiAgICBcIm1zQW5pbWF0aW9uU3RhcnRUaW1lXCIsXG4gICAgXCJtc0FuaW1hdGlvblRpbWluZ0Z1bmN0aW9uXCIsXG4gICAgXCJtc0JhY2tmYWNlVmlzaWJpbGl0eVwiLFxuICAgIFwibXNCbG9ja1Byb2dyZXNzaW9uXCIsXG4gICAgXCJtc0NTU09NRWxlbWVudEZsb2F0TWV0cmljc1wiLFxuICAgIFwibXNDYWNoaW5nXCIsXG4gICAgXCJtc0NhY2hpbmdFbmFibGVkXCIsXG4gICAgXCJtc0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVwiLFxuICAgIFwibXNDYXBzTG9ja1dhcm5pbmdPZmZcIixcbiAgICBcIm1zQ2xlYXJJbW1lZGlhdGVcIixcbiAgICBcIm1zQ2xvc2VcIixcbiAgICBcIm1zQ29udGVudFpvb21DaGFpbmluZ1wiLFxuICAgIFwibXNDb250ZW50Wm9vbUZhY3RvclwiLFxuICAgIFwibXNDb250ZW50Wm9vbUxpbWl0XCIsXG4gICAgXCJtc0NvbnRlbnRab29tTGltaXRNYXhcIixcbiAgICBcIm1zQ29udGVudFpvb21MaW1pdE1pblwiLFxuICAgIFwibXNDb250ZW50Wm9vbVNuYXBcIixcbiAgICBcIm1zQ29udGVudFpvb21TbmFwUG9pbnRzXCIsXG4gICAgXCJtc0NvbnRlbnRab29tU25hcFR5cGVcIixcbiAgICBcIm1zQ29udGVudFpvb21pbmdcIixcbiAgICBcIm1zQ29udmVydFVSTFwiLFxuICAgIFwibXNDcnlwdG9cIixcbiAgICBcIm1zRG9Ob3RUcmFja1wiLFxuICAgIFwibXNFbGVtZW50c0Zyb21Qb2ludFwiLFxuICAgIFwibXNFbGVtZW50c0Zyb21SZWN0XCIsXG4gICAgXCJtc0V4aXRGdWxsc2NyZWVuXCIsXG4gICAgXCJtc0V4dGVuZGVkQ29kZVwiLFxuICAgIFwibXNGaWxsUnVsZVwiLFxuICAgIFwibXNGaXJzdFBhaW50XCIsXG4gICAgXCJtc0ZsZXhcIixcbiAgICBcIm1zRmxleEFsaWduXCIsXG4gICAgXCJtc0ZsZXhEaXJlY3Rpb25cIixcbiAgICBcIm1zRmxleEZsb3dcIixcbiAgICBcIm1zRmxleEl0ZW1BbGlnblwiLFxuICAgIFwibXNGbGV4TGluZVBhY2tcIixcbiAgICBcIm1zRmxleE5lZ2F0aXZlXCIsXG4gICAgXCJtc0ZsZXhPcmRlclwiLFxuICAgIFwibXNGbGV4UGFja1wiLFxuICAgIFwibXNGbGV4UG9zaXRpdmVcIixcbiAgICBcIm1zRmxleFByZWZlcnJlZFNpemVcIixcbiAgICBcIm1zRmxleFdyYXBcIixcbiAgICBcIm1zRmxvd0Zyb21cIixcbiAgICBcIm1zRmxvd0ludG9cIixcbiAgICBcIm1zRm9udEZlYXR1cmVTZXR0aW5nc1wiLFxuICAgIFwibXNGdWxsc2NyZWVuRWxlbWVudFwiLFxuICAgIFwibXNGdWxsc2NyZWVuRW5hYmxlZFwiLFxuICAgIFwibXNHZXRJbnB1dENvbnRleHRcIixcbiAgICBcIm1zR2V0UmVnaW9uQ29udGVudFwiLFxuICAgIFwibXNHZXRVbnRyYW5zZm9ybWVkQm91bmRzXCIsXG4gICAgXCJtc0dyYXBoaWNzVHJ1c3RTdGF0dXNcIixcbiAgICBcIm1zR3JpZENvbHVtblwiLFxuICAgIFwibXNHcmlkQ29sdW1uQWxpZ25cIixcbiAgICBcIm1zR3JpZENvbHVtblNwYW5cIixcbiAgICBcIm1zR3JpZENvbHVtbnNcIixcbiAgICBcIm1zR3JpZFJvd1wiLFxuICAgIFwibXNHcmlkUm93QWxpZ25cIixcbiAgICBcIm1zR3JpZFJvd1NwYW5cIixcbiAgICBcIm1zR3JpZFJvd3NcIixcbiAgICBcIm1zSGlkZGVuXCIsXG4gICAgXCJtc0hpZ2hDb250cmFzdEFkanVzdFwiLFxuICAgIFwibXNIeXBoZW5hdGVMaW1pdENoYXJzXCIsXG4gICAgXCJtc0h5cGhlbmF0ZUxpbWl0TGluZXNcIixcbiAgICBcIm1zSHlwaGVuYXRlTGltaXRab25lXCIsXG4gICAgXCJtc0h5cGhlbnNcIixcbiAgICBcIm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIsXG4gICAgXCJtc0ltZUFsaWduXCIsXG4gICAgXCJtc0luZGV4ZWREQlwiLFxuICAgIFwibXNJbnRlcnBvbGF0aW9uTW9kZVwiLFxuICAgIFwibXNJc1N0YXRpY0hUTUxcIixcbiAgICBcIm1zS2V5U3lzdGVtXCIsXG4gICAgXCJtc0tleXNcIixcbiAgICBcIm1zTGF1bmNoVXJpXCIsXG4gICAgXCJtc0xvY2tPcmllbnRhdGlvblwiLFxuICAgIFwibXNNYW5pcHVsYXRpb25WaWV3c0VuYWJsZWRcIixcbiAgICBcIm1zTWF0Y2hNZWRpYVwiLFxuICAgIFwibXNNYXRjaGVzU2VsZWN0b3JcIixcbiAgICBcIm1zTWF4VG91Y2hQb2ludHNcIixcbiAgICBcIm1zT3JpZW50YXRpb25cIixcbiAgICBcIm1zT3ZlcmZsb3dTdHlsZVwiLFxuICAgIFwibXNQZXJzcGVjdGl2ZVwiLFxuICAgIFwibXNQZXJzcGVjdGl2ZU9yaWdpblwiLFxuICAgIFwibXNQbGF5VG9EaXNhYmxlZFwiLFxuICAgIFwibXNQbGF5VG9QcmVmZXJyZWRTb3VyY2VVcmlcIixcbiAgICBcIm1zUGxheVRvUHJpbWFyeVwiLFxuICAgIFwibXNQb2ludGVyRW5hYmxlZFwiLFxuICAgIFwibXNSZWdpb25PdmVyZmxvd1wiLFxuICAgIFwibXNSZWxlYXNlUG9pbnRlckNhcHR1cmVcIixcbiAgICBcIm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIsXG4gICAgXCJtc1JlcXVlc3RGdWxsc2NyZWVuXCIsXG4gICAgXCJtc1NhdmVCbG9iXCIsXG4gICAgXCJtc1NhdmVPck9wZW5CbG9iXCIsXG4gICAgXCJtc1Njcm9sbENoYWluaW5nXCIsXG4gICAgXCJtc1Njcm9sbExpbWl0XCIsXG4gICAgXCJtc1Njcm9sbExpbWl0WE1heFwiLFxuICAgIFwibXNTY3JvbGxMaW1pdFhNaW5cIixcbiAgICBcIm1zU2Nyb2xsTGltaXRZTWF4XCIsXG4gICAgXCJtc1Njcm9sbExpbWl0WU1pblwiLFxuICAgIFwibXNTY3JvbGxSYWlsc1wiLFxuICAgIFwibXNTY3JvbGxTbmFwUG9pbnRzWFwiLFxuICAgIFwibXNTY3JvbGxTbmFwUG9pbnRzWVwiLFxuICAgIFwibXNTY3JvbGxTbmFwVHlwZVwiLFxuICAgIFwibXNTY3JvbGxTbmFwWFwiLFxuICAgIFwibXNTY3JvbGxTbmFwWVwiLFxuICAgIFwibXNTY3JvbGxUcmFuc2xhdGlvblwiLFxuICAgIFwibXNTZXRJbW1lZGlhdGVcIixcbiAgICBcIm1zU2V0TWVkaWFLZXlzXCIsXG4gICAgXCJtc1NldFBvaW50ZXJDYXB0dXJlXCIsXG4gICAgXCJtc1RleHRDb21iaW5lSG9yaXpvbnRhbFwiLFxuICAgIFwibXNUZXh0U2l6ZUFkanVzdFwiLFxuICAgIFwibXNUb0Jsb2JcIixcbiAgICBcIm1zVG91Y2hBY3Rpb25cIixcbiAgICBcIm1zVG91Y2hTZWxlY3RcIixcbiAgICBcIm1zVHJhY2VBc3luY0NhbGxiYWNrQ29tcGxldGVkXCIsXG4gICAgXCJtc1RyYWNlQXN5bmNDYWxsYmFja1N0YXJ0aW5nXCIsXG4gICAgXCJtc1RyYWNlQXN5bmNPcGVyYXRpb25Db21wbGV0ZWRcIixcbiAgICBcIm1zVHJhY2VBc3luY09wZXJhdGlvblN0YXJ0aW5nXCIsXG4gICAgXCJtc1RyYW5zZm9ybVwiLFxuICAgIFwibXNUcmFuc2Zvcm1PcmlnaW5cIixcbiAgICBcIm1zVHJhbnNmb3JtU3R5bGVcIixcbiAgICBcIm1zVHJhbnNpdGlvblwiLFxuICAgIFwibXNUcmFuc2l0aW9uRGVsYXlcIixcbiAgICBcIm1zVHJhbnNpdGlvbkR1cmF0aW9uXCIsXG4gICAgXCJtc1RyYW5zaXRpb25Qcm9wZXJ0eVwiLFxuICAgIFwibXNUcmFuc2l0aW9uVGltaW5nRnVuY3Rpb25cIixcbiAgICBcIm1zVW5sb2NrT3JpZW50YXRpb25cIixcbiAgICBcIm1zVXBkYXRlQXN5bmNDYWxsYmFja1JlbGF0aW9uXCIsXG4gICAgXCJtc1VzZXJTZWxlY3RcIixcbiAgICBcIm1zVmlzaWJpbGl0eVN0YXRlXCIsXG4gICAgXCJtc1dyYXBGbG93XCIsXG4gICAgXCJtc1dyYXBNYXJnaW5cIixcbiAgICBcIm1zV3JhcFRocm91Z2hcIixcbiAgICBcIm1zV3JpdGVQcm9maWxlck1hcmtcIixcbiAgICBcIm1zWm9vbVwiLFxuICAgIFwibXNab29tVG9cIixcbiAgICBcIm10XCIsXG4gICAgXCJtdWxcIixcbiAgICBcIm11bHRpRW50cnlcIixcbiAgICBcIm11bHRpU2VsZWN0aW9uT2JqXCIsXG4gICAgXCJtdWx0aWxpbmVcIixcbiAgICBcIm11bHRpcGxlXCIsXG4gICAgXCJtdWx0aXBseVwiLFxuICAgIFwibXVsdGlwbHlTZWxmXCIsXG4gICAgXCJtdXRhYmxlRmlsZVwiLFxuICAgIFwibXV0ZWRcIixcbiAgICBcIm5cIixcbiAgICBcIm5hbWVcIixcbiAgICBcIm5hbWVQcm9wXCIsXG4gICAgXCJuYW1lZEl0ZW1cIixcbiAgICBcIm5hbWVkUmVjb3Jkc2V0XCIsXG4gICAgXCJuYW1lc1wiLFxuICAgIFwibmFtZXNwYWNlVVJJXCIsXG4gICAgXCJuYW1lc3BhY2VzXCIsXG4gICAgXCJuYXR1cmFsSGVpZ2h0XCIsXG4gICAgXCJuYXR1cmFsV2lkdGhcIixcbiAgICBcIm5hdmlnYXRlXCIsXG4gICAgXCJuYXZpZ2F0aW9uXCIsXG4gICAgXCJuYXZpZ2F0aW9uTW9kZVwiLFxuICAgIFwibmF2aWdhdGlvblByZWxvYWRcIixcbiAgICBcIm5hdmlnYXRpb25TdGFydFwiLFxuICAgIFwibmF2aWdhdG9yXCIsXG4gICAgXCJuZWFyXCIsXG4gICAgXCJuZWFyZXN0Vmlld3BvcnRFbGVtZW50XCIsXG4gICAgXCJuZWdhdGl2ZVwiLFxuICAgIFwibmVnb3RpYXRlZFwiLFxuICAgIFwibmV0c2NhcGVcIixcbiAgICBcIm5ldHdvcmtTdGF0ZVwiLFxuICAgIFwibmV3U2NhbGVcIixcbiAgICBcIm5ld1RyYW5zbGF0ZVwiLFxuICAgIFwibmV3VVJMXCIsXG4gICAgXCJuZXdWYWx1ZVwiLFxuICAgIFwibmV3VmFsdWVTcGVjaWZpZWRVbml0c1wiLFxuICAgIFwibmV3VmVyc2lvblwiLFxuICAgIFwibmV3aG9tZVwiLFxuICAgIFwibmV4dFwiLFxuICAgIFwibmV4dEVsZW1lbnRTaWJsaW5nXCIsXG4gICAgXCJuZXh0SG9wUHJvdG9jb2xcIixcbiAgICBcIm5leHROb2RlXCIsXG4gICAgXCJuZXh0UGFnZVwiLFxuICAgIFwibmV4dFNpYmxpbmdcIixcbiAgICBcIm5pY2tuYW1lXCIsXG4gICAgXCJub0hyZWZcIixcbiAgICBcIm5vTW9kdWxlXCIsXG4gICAgXCJub1Jlc2l6ZVwiLFxuICAgIFwibm9TaGFkZVwiLFxuICAgIFwibm9WYWxpZGF0ZVwiLFxuICAgIFwibm9XcmFwXCIsXG4gICAgXCJub2RlXCIsXG4gICAgXCJub2RlTmFtZVwiLFxuICAgIFwibm9kZVR5cGVcIixcbiAgICBcIm5vZGVWYWx1ZVwiLFxuICAgIFwibm9uY2VcIixcbiAgICBcIm5vcm1hbGl6ZVwiLFxuICAgIFwibm9ybWFsaXplZFBhdGhTZWdMaXN0XCIsXG4gICAgXCJub3RhdGlvbk5hbWVcIixcbiAgICBcIm5vdGF0aW9uc1wiLFxuICAgIFwibm90ZVwiLFxuICAgIFwibm90ZUdyYWluT25cIixcbiAgICBcIm5vdGVPZmZcIixcbiAgICBcIm5vdGVPblwiLFxuICAgIFwibm90aWZ5XCIsXG4gICAgXCJub3dcIixcbiAgICBcIm51bU9jdGF2ZXNcIixcbiAgICBcIm51bWJlclwiLFxuICAgIFwibnVtYmVyT2ZDaGFubmVsc1wiLFxuICAgIFwibnVtYmVyT2ZJbnB1dHNcIixcbiAgICBcIm51bWJlck9mSXRlbXNcIixcbiAgICBcIm51bWJlck9mT3V0cHV0c1wiLFxuICAgIFwibnVtYmVyVmFsdWVcIixcbiAgICBcIm9NYXRjaGVzU2VsZWN0b3JcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwib2JqZWN0LWZpdFwiLFxuICAgIFwib2JqZWN0LXBvc2l0aW9uXCIsXG4gICAgXCJvYmplY3RGaXRcIixcbiAgICBcIm9iamVjdFBvc2l0aW9uXCIsXG4gICAgXCJvYmplY3RTdG9yZVwiLFxuICAgIFwib2JqZWN0U3RvcmVOYW1lc1wiLFxuICAgIFwib2JqZWN0VHlwZVwiLFxuICAgIFwib2JzZXJ2ZVwiLFxuICAgIFwib2ZcIixcbiAgICBcIm9mZnNjcmVlbkJ1ZmZlcmluZ1wiLFxuICAgIFwib2Zmc2V0XCIsXG4gICAgXCJvZmZzZXQtYW5jaG9yXCIsXG4gICAgXCJvZmZzZXQtZGlzdGFuY2VcIixcbiAgICBcIm9mZnNldC1wYXRoXCIsXG4gICAgXCJvZmZzZXQtcm90YXRlXCIsXG4gICAgXCJvZmZzZXRBbmNob3JcIixcbiAgICBcIm9mZnNldERpc3RhbmNlXCIsXG4gICAgXCJvZmZzZXRIZWlnaHRcIixcbiAgICBcIm9mZnNldExlZnRcIixcbiAgICBcIm9mZnNldE5vZGVcIixcbiAgICBcIm9mZnNldFBhcmVudFwiLFxuICAgIFwib2Zmc2V0UGF0aFwiLFxuICAgIFwib2Zmc2V0Um90YXRlXCIsXG4gICAgXCJvZmZzZXRUb3BcIixcbiAgICBcIm9mZnNldFdpZHRoXCIsXG4gICAgXCJvZmZzZXRYXCIsXG4gICAgXCJvZmZzZXRZXCIsXG4gICAgXCJva1wiLFxuICAgIFwib2xkVVJMXCIsXG4gICAgXCJvbGRWYWx1ZVwiLFxuICAgIFwib2xkVmVyc2lvblwiLFxuICAgIFwib2xkZXJTaGFkb3dSb290XCIsXG4gICAgXCJvbkxpbmVcIixcbiAgICBcIm9uYWJvcnRcIixcbiAgICBcIm9uYWJzb2x1dGVkZXZpY2VvcmllbnRhdGlvblwiLFxuICAgIFwib25hY3RpdmF0ZVwiLFxuICAgIFwib25hY3RpdmVcIixcbiAgICBcIm9uYWRkc291cmNlYnVmZmVyXCIsXG4gICAgXCJvbmFkZHN0cmVhbVwiLFxuICAgIFwib25hZGR0cmFja1wiLFxuICAgIFwib25hZnRlcnByaW50XCIsXG4gICAgXCJvbmFmdGVyc2NyaXB0ZXhlY3V0ZVwiLFxuICAgIFwib25hZnRlcnVwZGF0ZVwiLFxuICAgIFwib25hbmltYXRpb25jYW5jZWxcIixcbiAgICBcIm9uYW5pbWF0aW9uZW5kXCIsXG4gICAgXCJvbmFuaW1hdGlvbml0ZXJhdGlvblwiLFxuICAgIFwib25hbmltYXRpb25zdGFydFwiLFxuICAgIFwib25hcHBpbnN0YWxsZWRcIixcbiAgICBcIm9uYXVkaW9lbmRcIixcbiAgICBcIm9uYXVkaW9wcm9jZXNzXCIsXG4gICAgXCJvbmF1ZGlvc3RhcnRcIixcbiAgICBcIm9uYXV0b2NvbXBsZXRlXCIsXG4gICAgXCJvbmF1dG9jb21wbGV0ZWVycm9yXCIsXG4gICAgXCJvbmF1eGNsaWNrXCIsXG4gICAgXCJvbmJlZm9yZWFjdGl2YXRlXCIsXG4gICAgXCJvbmJlZm9yZWNvcHlcIixcbiAgICBcIm9uYmVmb3JlY3V0XCIsXG4gICAgXCJvbmJlZm9yZWRlYWN0aXZhdGVcIixcbiAgICBcIm9uYmVmb3JlZWRpdGZvY3VzXCIsXG4gICAgXCJvbmJlZm9yZWluc3RhbGxwcm9tcHRcIixcbiAgICBcIm9uYmVmb3JlcGFzdGVcIixcbiAgICBcIm9uYmVmb3JlcHJpbnRcIixcbiAgICBcIm9uYmVmb3Jlc2NyaXB0ZXhlY3V0ZVwiLFxuICAgIFwib25iZWZvcmV1bmxvYWRcIixcbiAgICBcIm9uYmVmb3JldXBkYXRlXCIsXG4gICAgXCJvbmJlZm9yZXhyc2VsZWN0XCIsXG4gICAgXCJvbmJlZ2luXCIsXG4gICAgXCJvbmJsb2NrZWRcIixcbiAgICBcIm9uYmx1clwiLFxuICAgIFwib25ib3VuY2VcIixcbiAgICBcIm9uYm91bmRhcnlcIixcbiAgICBcIm9uYnVmZmVyZWRhbW91bnRsb3dcIixcbiAgICBcIm9uY2FjaGVkXCIsXG4gICAgXCJvbmNhbmNlbFwiLFxuICAgIFwib25jYW5kaWRhdGV3aW5kb3doaWRlXCIsXG4gICAgXCJvbmNhbmRpZGF0ZXdpbmRvd3Nob3dcIixcbiAgICBcIm9uY2FuZGlkYXRld2luZG93dXBkYXRlXCIsXG4gICAgXCJvbmNhbnBsYXlcIixcbiAgICBcIm9uY2FucGxheXRocm91Z2hcIixcbiAgICBcIm9uY2VcIixcbiAgICBcIm9uY2VsbGNoYW5nZVwiLFxuICAgIFwib25jaGFuZ2VcIixcbiAgICBcIm9uY2hhcmFjdGVyaXN0aWN2YWx1ZWNoYW5nZWRcIixcbiAgICBcIm9uY2hhcmdpbmdjaGFuZ2VcIixcbiAgICBcIm9uY2hhcmdpbmd0aW1lY2hhbmdlXCIsXG4gICAgXCJvbmNoZWNraW5nXCIsXG4gICAgXCJvbmNsaWNrXCIsXG4gICAgXCJvbmNsb3NlXCIsXG4gICAgXCJvbmNsb3NpbmdcIixcbiAgICBcIm9uY29tcGFzc25lZWRzY2FsaWJyYXRpb25cIixcbiAgICBcIm9uY29tcGxldGVcIixcbiAgICBcIm9uY29ubmVjdFwiLFxuICAgIFwib25jb25uZWN0aW5nXCIsXG4gICAgXCJvbmNvbm5lY3Rpb25hdmFpbGFibGVcIixcbiAgICBcIm9uY29ubmVjdGlvbnN0YXRlY2hhbmdlXCIsXG4gICAgXCJvbmNvbnRleHRtZW51XCIsXG4gICAgXCJvbmNvbnRyb2xsZXJjaGFuZ2VcIixcbiAgICBcIm9uY29udHJvbHNlbGVjdFwiLFxuICAgIFwib25jb3B5XCIsXG4gICAgXCJvbmN1ZWNoYW5nZVwiLFxuICAgIFwib25jdXRcIixcbiAgICBcIm9uZGF0YWF2YWlsYWJsZVwiLFxuICAgIFwib25kYXRhY2hhbm5lbFwiLFxuICAgIFwib25kYXRhc2V0Y2hhbmdlZFwiLFxuICAgIFwib25kYXRhc2V0Y29tcGxldGVcIixcbiAgICBcIm9uZGJsY2xpY2tcIixcbiAgICBcIm9uZGVhY3RpdmF0ZVwiLFxuICAgIFwib25kZXZpY2VjaGFuZ2VcIixcbiAgICBcIm9uZGV2aWNlbGlnaHRcIixcbiAgICBcIm9uZGV2aWNlbW90aW9uXCIsXG4gICAgXCJvbmRldmljZW9yaWVudGF0aW9uXCIsXG4gICAgXCJvbmRldmljZW9yaWVudGF0aW9uYWJzb2x1dGVcIixcbiAgICBcIm9uZGV2aWNlcHJveGltaXR5XCIsXG4gICAgXCJvbmRpc2NoYXJnaW5ndGltZWNoYW5nZVwiLFxuICAgIFwib25kaXNjb25uZWN0XCIsXG4gICAgXCJvbmRpc3BsYXlcIixcbiAgICBcIm9uZG93bmxvYWRpbmdcIixcbiAgICBcIm9uZHJhZ1wiLFxuICAgIFwib25kcmFnZW5kXCIsXG4gICAgXCJvbmRyYWdlbnRlclwiLFxuICAgIFwib25kcmFnZXhpdFwiLFxuICAgIFwib25kcmFnbGVhdmVcIixcbiAgICBcIm9uZHJhZ292ZXJcIixcbiAgICBcIm9uZHJhZ3N0YXJ0XCIsXG4gICAgXCJvbmRyb3BcIixcbiAgICBcIm9uZHVyYXRpb25jaGFuZ2VcIixcbiAgICBcIm9uZW1wdGllZFwiLFxuICAgIFwib25lbmNyeXB0ZWRcIixcbiAgICBcIm9uZW5kXCIsXG4gICAgXCJvbmVuZGVkXCIsXG4gICAgXCJvbmVudGVyXCIsXG4gICAgXCJvbmVudGVycGljdHVyZWlucGljdHVyZVwiLFxuICAgIFwib25lcnJvclwiLFxuICAgIFwib25lcnJvcnVwZGF0ZVwiLFxuICAgIFwib25leGl0XCIsXG4gICAgXCJvbmZpbHRlcmNoYW5nZVwiLFxuICAgIFwib25maW5pc2hcIixcbiAgICBcIm9uZm9jdXNcIixcbiAgICBcIm9uZm9jdXNpblwiLFxuICAgIFwib25mb2N1c291dFwiLFxuICAgIFwib25mb3JtZGF0YVwiLFxuICAgIFwib25mcmVlemVcIixcbiAgICBcIm9uZnVsbHNjcmVlbmNoYW5nZVwiLFxuICAgIFwib25mdWxsc2NyZWVuZXJyb3JcIixcbiAgICBcIm9uZ2F0aGVyaW5nc3RhdGVjaGFuZ2VcIixcbiAgICBcIm9uZ2F0dHNlcnZlcmRpc2Nvbm5lY3RlZFwiLFxuICAgIFwib25nZXN0dXJlY2hhbmdlXCIsXG4gICAgXCJvbmdlc3R1cmVlbmRcIixcbiAgICBcIm9uZ2VzdHVyZXN0YXJ0XCIsXG4gICAgXCJvbmdvdHBvaW50ZXJjYXB0dXJlXCIsXG4gICAgXCJvbmhhc2hjaGFuZ2VcIixcbiAgICBcIm9uaGVscFwiLFxuICAgIFwib25pY2VjYW5kaWRhdGVcIixcbiAgICBcIm9uaWNlY2FuZGlkYXRlZXJyb3JcIixcbiAgICBcIm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlXCIsXG4gICAgXCJvbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlXCIsXG4gICAgXCJvbmluYWN0aXZlXCIsXG4gICAgXCJvbmlucHV0XCIsXG4gICAgXCJvbmlucHV0c291cmNlc2NoYW5nZVwiLFxuICAgIFwib25pbnZhbGlkXCIsXG4gICAgXCJvbmtleWRvd25cIixcbiAgICBcIm9ua2V5cHJlc3NcIixcbiAgICBcIm9ua2V5c3RhdHVzZXNjaGFuZ2VcIixcbiAgICBcIm9ua2V5dXBcIixcbiAgICBcIm9ubGFuZ3VhZ2VjaGFuZ2VcIixcbiAgICBcIm9ubGF5b3V0Y29tcGxldGVcIixcbiAgICBcIm9ubGVhdmVwaWN0dXJlaW5waWN0dXJlXCIsXG4gICAgXCJvbmxldmVsY2hhbmdlXCIsXG4gICAgXCJvbmxvYWRcIixcbiAgICBcIm9ubG9hZGVkZGF0YVwiLFxuICAgIFwib25sb2FkZWRtZXRhZGF0YVwiLFxuICAgIFwib25sb2FkZW5kXCIsXG4gICAgXCJvbmxvYWRpbmdcIixcbiAgICBcIm9ubG9hZGluZ2RvbmVcIixcbiAgICBcIm9ubG9hZGluZ2Vycm9yXCIsXG4gICAgXCJvbmxvYWRzdGFydFwiLFxuICAgIFwib25sb3NlY2FwdHVyZVwiLFxuICAgIFwib25sb3N0cG9pbnRlcmNhcHR1cmVcIixcbiAgICBcIm9ubHlcIixcbiAgICBcIm9ubWFya1wiLFxuICAgIFwib25tZXNzYWdlXCIsXG4gICAgXCJvbm1lc3NhZ2VlcnJvclwiLFxuICAgIFwib25taWRpbWVzc2FnZVwiLFxuICAgIFwib25tb3VzZWRvd25cIixcbiAgICBcIm9ubW91c2VlbnRlclwiLFxuICAgIFwib25tb3VzZWxlYXZlXCIsXG4gICAgXCJvbm1vdXNlbW92ZVwiLFxuICAgIFwib25tb3VzZW91dFwiLFxuICAgIFwib25tb3VzZW92ZXJcIixcbiAgICBcIm9ubW91c2V1cFwiLFxuICAgIFwib25tb3VzZXdoZWVsXCIsXG4gICAgXCJvbm1vdmVcIixcbiAgICBcIm9ubW92ZWVuZFwiLFxuICAgIFwib25tb3Zlc3RhcnRcIixcbiAgICBcIm9ubW96ZnVsbHNjcmVlbmNoYW5nZVwiLFxuICAgIFwib25tb3pmdWxsc2NyZWVuZXJyb3JcIixcbiAgICBcIm9ubW96b3JpZW50YXRpb25jaGFuZ2VcIixcbiAgICBcIm9ubW96cG9pbnRlcmxvY2tjaGFuZ2VcIixcbiAgICBcIm9ubW96cG9pbnRlcmxvY2tlcnJvclwiLFxuICAgIFwib25tc2NvbnRlbnR6b29tXCIsXG4gICAgXCJvbm1zZnVsbHNjcmVlbmNoYW5nZVwiLFxuICAgIFwib25tc2Z1bGxzY3JlZW5lcnJvclwiLFxuICAgIFwib25tc2dlc3R1cmVjaGFuZ2VcIixcbiAgICBcIm9ubXNnZXN0dXJlZG91YmxldGFwXCIsXG4gICAgXCJvbm1zZ2VzdHVyZWVuZFwiLFxuICAgIFwib25tc2dlc3R1cmVob2xkXCIsXG4gICAgXCJvbm1zZ2VzdHVyZXN0YXJ0XCIsXG4gICAgXCJvbm1zZ2VzdHVyZXRhcFwiLFxuICAgIFwib25tc2dvdHBvaW50ZXJjYXB0dXJlXCIsXG4gICAgXCJvbm1zaW5lcnRpYXN0YXJ0XCIsXG4gICAgXCJvbm1zbG9zdHBvaW50ZXJjYXB0dXJlXCIsXG4gICAgXCJvbm1zbWFuaXB1bGF0aW9uc3RhdGVjaGFuZ2VkXCIsXG4gICAgXCJvbm1zbmVlZGtleVwiLFxuICAgIFwib25tc29yaWVudGF0aW9uY2hhbmdlXCIsXG4gICAgXCJvbm1zcG9pbnRlcmNhbmNlbFwiLFxuICAgIFwib25tc3BvaW50ZXJkb3duXCIsXG4gICAgXCJvbm1zcG9pbnRlcmVudGVyXCIsXG4gICAgXCJvbm1zcG9pbnRlcmhvdmVyXCIsXG4gICAgXCJvbm1zcG9pbnRlcmxlYXZlXCIsXG4gICAgXCJvbm1zcG9pbnRlcm1vdmVcIixcbiAgICBcIm9ubXNwb2ludGVyb3V0XCIsXG4gICAgXCJvbm1zcG9pbnRlcm92ZXJcIixcbiAgICBcIm9ubXNwb2ludGVydXBcIixcbiAgICBcIm9ubXNzaXRlbW9kZWp1bXBsaXN0aXRlbXJlbW92ZWRcIixcbiAgICBcIm9ubXN0aHVtYm5haWxjbGlja1wiLFxuICAgIFwib25tdXRlXCIsXG4gICAgXCJvbm5lZ290aWF0aW9ubmVlZGVkXCIsXG4gICAgXCJvbm5vbWF0Y2hcIixcbiAgICBcIm9ubm91cGRhdGVcIixcbiAgICBcIm9ub2Jzb2xldGVcIixcbiAgICBcIm9ub2ZmbGluZVwiLFxuICAgIFwib25vbmxpbmVcIixcbiAgICBcIm9ub3BlblwiLFxuICAgIFwib25vcmllbnRhdGlvbmNoYW5nZVwiLFxuICAgIFwib25wYWdlY2hhbmdlXCIsXG4gICAgXCJvbnBhZ2VoaWRlXCIsXG4gICAgXCJvbnBhZ2VzaG93XCIsXG4gICAgXCJvbnBhc3RlXCIsXG4gICAgXCJvbnBhdXNlXCIsXG4gICAgXCJvbnBheWVyZGV0YWlsY2hhbmdlXCIsXG4gICAgXCJvbnBheW1lbnRtZXRob2RjaGFuZ2VcIixcbiAgICBcIm9ucGxheVwiLFxuICAgIFwib25wbGF5aW5nXCIsXG4gICAgXCJvbnBsdWdpbnN0cmVhbXN0YXJ0XCIsXG4gICAgXCJvbnBvaW50ZXJjYW5jZWxcIixcbiAgICBcIm9ucG9pbnRlcmRvd25cIixcbiAgICBcIm9ucG9pbnRlcmVudGVyXCIsXG4gICAgXCJvbnBvaW50ZXJsZWF2ZVwiLFxuICAgIFwib25wb2ludGVybG9ja2NoYW5nZVwiLFxuICAgIFwib25wb2ludGVybG9ja2Vycm9yXCIsXG4gICAgXCJvbnBvaW50ZXJtb3ZlXCIsXG4gICAgXCJvbnBvaW50ZXJvdXRcIixcbiAgICBcIm9ucG9pbnRlcm92ZXJcIixcbiAgICBcIm9ucG9pbnRlcnJhd3VwZGF0ZVwiLFxuICAgIFwib25wb2ludGVydXBcIixcbiAgICBcIm9ucG9wc3RhdGVcIixcbiAgICBcIm9ucHJvY2Vzc29yZXJyb3JcIixcbiAgICBcIm9ucHJvZ3Jlc3NcIixcbiAgICBcIm9ucHJvcGVydHljaGFuZ2VcIixcbiAgICBcIm9ucmF0ZWNoYW5nZVwiLFxuICAgIFwib25yZWFkaW5nXCIsXG4gICAgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIixcbiAgICBcIm9ucmVqZWN0aW9uaGFuZGxlZFwiLFxuICAgIFwib25yZWxlYXNlXCIsXG4gICAgXCJvbnJlbW92ZVwiLFxuICAgIFwib25yZW1vdmVzb3VyY2VidWZmZXJcIixcbiAgICBcIm9ucmVtb3Zlc3RyZWFtXCIsXG4gICAgXCJvbnJlbW92ZXRyYWNrXCIsXG4gICAgXCJvbnJlcGVhdFwiLFxuICAgIFwib25yZXNldFwiLFxuICAgIFwib25yZXNpemVcIixcbiAgICBcIm9ucmVzaXplZW5kXCIsXG4gICAgXCJvbnJlc2l6ZXN0YXJ0XCIsXG4gICAgXCJvbnJlc291cmNldGltaW5nYnVmZmVyZnVsbFwiLFxuICAgIFwib25yZXN1bHRcIixcbiAgICBcIm9ucmVzdW1lXCIsXG4gICAgXCJvbnJvd2VudGVyXCIsXG4gICAgXCJvbnJvd2V4aXRcIixcbiAgICBcIm9ucm93c2RlbGV0ZVwiLFxuICAgIFwib25yb3dzaW5zZXJ0ZWRcIixcbiAgICBcIm9uc2Nyb2xsXCIsXG4gICAgXCJvbnNlYXJjaFwiLFxuICAgIFwib25zZWN1cml0eXBvbGljeXZpb2xhdGlvblwiLFxuICAgIFwib25zZWVrZWRcIixcbiAgICBcIm9uc2Vla2luZ1wiLFxuICAgIFwib25zZWxlY3RcIixcbiAgICBcIm9uc2VsZWN0ZWRjYW5kaWRhdGVwYWlyY2hhbmdlXCIsXG4gICAgXCJvbnNlbGVjdGVuZFwiLFxuICAgIFwib25zZWxlY3Rpb25jaGFuZ2VcIixcbiAgICBcIm9uc2VsZWN0c3RhcnRcIixcbiAgICBcIm9uc2hpcHBpbmdhZGRyZXNzY2hhbmdlXCIsXG4gICAgXCJvbnNoaXBwaW5nb3B0aW9uY2hhbmdlXCIsXG4gICAgXCJvbnNob3dcIixcbiAgICBcIm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2VcIixcbiAgICBcIm9uc291bmRlbmRcIixcbiAgICBcIm9uc291bmRzdGFydFwiLFxuICAgIFwib25zb3VyY2VjbG9zZVwiLFxuICAgIFwib25zb3VyY2VjbG9zZWRcIixcbiAgICBcIm9uc291cmNlZW5kZWRcIixcbiAgICBcIm9uc291cmNlb3BlblwiLFxuICAgIFwib25zcGVlY2hlbmRcIixcbiAgICBcIm9uc3BlZWNoc3RhcnRcIixcbiAgICBcIm9uc3F1ZWV6ZVwiLFxuICAgIFwib25zcXVlZXplZW5kXCIsXG4gICAgXCJvbnNxdWVlemVzdGFydFwiLFxuICAgIFwib25zdGFsbGVkXCIsXG4gICAgXCJvbnN0YXJ0XCIsXG4gICAgXCJvbnN0YXRlY2hhbmdlXCIsXG4gICAgXCJvbnN0b3BcIixcbiAgICBcIm9uc3RvcmFnZVwiLFxuICAgIFwib25zdG9yYWdlY29tbWl0XCIsXG4gICAgXCJvbnN1Ym1pdFwiLFxuICAgIFwib25zdWNjZXNzXCIsXG4gICAgXCJvbnN1c3BlbmRcIixcbiAgICBcIm9udGVybWluYXRlXCIsXG4gICAgXCJvbnRleHRpbnB1dFwiLFxuICAgIFwib250aW1lb3V0XCIsXG4gICAgXCJvbnRpbWV1cGRhdGVcIixcbiAgICBcIm9udG9nZ2xlXCIsXG4gICAgXCJvbnRvbmVjaGFuZ2VcIixcbiAgICBcIm9udG91Y2hjYW5jZWxcIixcbiAgICBcIm9udG91Y2hlbmRcIixcbiAgICBcIm9udG91Y2htb3ZlXCIsXG4gICAgXCJvbnRvdWNoc3RhcnRcIixcbiAgICBcIm9udHJhY2tcIixcbiAgICBcIm9udHJhbnNpdGlvbmNhbmNlbFwiLFxuICAgIFwib250cmFuc2l0aW9uZW5kXCIsXG4gICAgXCJvbnRyYW5zaXRpb25ydW5cIixcbiAgICBcIm9udHJhbnNpdGlvbnN0YXJ0XCIsXG4gICAgXCJvbnVuaGFuZGxlZHJlamVjdGlvblwiLFxuICAgIFwib251bmxvYWRcIixcbiAgICBcIm9udW5tdXRlXCIsXG4gICAgXCJvbnVwZGF0ZVwiLFxuICAgIFwib251cGRhdGVlbmRcIixcbiAgICBcIm9udXBkYXRlZm91bmRcIixcbiAgICBcIm9udXBkYXRlcmVhZHlcIixcbiAgICBcIm9udXBkYXRlc3RhcnRcIixcbiAgICBcIm9udXBncmFkZW5lZWRlZFwiLFxuICAgIFwib251c2VycHJveGltaXR5XCIsXG4gICAgXCJvbnZlcnNpb25jaGFuZ2VcIixcbiAgICBcIm9udmlzaWJpbGl0eWNoYW5nZVwiLFxuICAgIFwib252b2ljZXNjaGFuZ2VkXCIsXG4gICAgXCJvbnZvbHVtZWNoYW5nZVwiLFxuICAgIFwib252cmRpc3BsYXlhY3RpdmF0ZVwiLFxuICAgIFwib252cmRpc3BsYXljb25uZWN0XCIsXG4gICAgXCJvbnZyZGlzcGxheWRlYWN0aXZhdGVcIixcbiAgICBcIm9udnJkaXNwbGF5ZGlzY29ubmVjdFwiLFxuICAgIFwib252cmRpc3BsYXlwcmVzZW50Y2hhbmdlXCIsXG4gICAgXCJvbndhaXRpbmdcIixcbiAgICBcIm9ud2FpdGluZ2ZvcmtleVwiLFxuICAgIFwib253YXJuaW5nXCIsXG4gICAgXCJvbndlYmtpdGFuaW1hdGlvbmVuZFwiLFxuICAgIFwib253ZWJraXRhbmltYXRpb25pdGVyYXRpb25cIixcbiAgICBcIm9ud2Via2l0YW5pbWF0aW9uc3RhcnRcIixcbiAgICBcIm9ud2Via2l0Y3VycmVudHBsYXliYWNrdGFyZ2V0aXN3aXJlbGVzc2NoYW5nZWRcIixcbiAgICBcIm9ud2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiLFxuICAgIFwib253ZWJraXRmdWxsc2NyZWVuZXJyb3JcIixcbiAgICBcIm9ud2Via2l0a2V5YWRkZWRcIixcbiAgICBcIm9ud2Via2l0a2V5ZXJyb3JcIixcbiAgICBcIm9ud2Via2l0a2V5bWVzc2FnZVwiLFxuICAgIFwib253ZWJraXRuZWVka2V5XCIsXG4gICAgXCJvbndlYmtpdG9yaWVudGF0aW9uY2hhbmdlXCIsXG4gICAgXCJvbndlYmtpdHBsYXliYWNrdGFyZ2V0YXZhaWxhYmlsaXR5Y2hhbmdlZFwiLFxuICAgIFwib253ZWJraXRwb2ludGVybG9ja2NoYW5nZVwiLFxuICAgIFwib253ZWJraXRwb2ludGVybG9ja2Vycm9yXCIsXG4gICAgXCJvbndlYmtpdHJlc291cmNldGltaW5nYnVmZmVyZnVsbFwiLFxuICAgIFwib253ZWJraXR0cmFuc2l0aW9uZW5kXCIsXG4gICAgXCJvbndoZWVsXCIsXG4gICAgXCJvbnpvb21cIixcbiAgICBcIm9wYWNpdHlcIixcbiAgICBcIm9wZW5cIixcbiAgICBcIm9wZW5DdXJzb3JcIixcbiAgICBcIm9wZW5EYXRhYmFzZVwiLFxuICAgIFwib3BlbktleUN1cnNvclwiLFxuICAgIFwib3BlbmVkXCIsXG4gICAgXCJvcGVuZXJcIixcbiAgICBcIm9wZXJhXCIsXG4gICAgXCJvcGVyYXRpb25UeXBlXCIsXG4gICAgXCJvcGVyYXRvclwiLFxuICAgIFwib3ByXCIsXG4gICAgXCJvcHRpbXVtXCIsXG4gICAgXCJvcHRpb25zXCIsXG4gICAgXCJvclwiLFxuICAgIFwib3JkZXJcIixcbiAgICBcIm9yZGVyWFwiLFxuICAgIFwib3JkZXJZXCIsXG4gICAgXCJvcmRlcmVkXCIsXG4gICAgXCJvcmdcIixcbiAgICBcIm9yZ2FuaXphdGlvblwiLFxuICAgIFwib3JpZW50XCIsXG4gICAgXCJvcmllbnRBbmdsZVwiLFxuICAgIFwib3JpZW50VHlwZVwiLFxuICAgIFwib3JpZW50YXRpb25cIixcbiAgICBcIm9yaWVudGF0aW9uWFwiLFxuICAgIFwib3JpZW50YXRpb25ZXCIsXG4gICAgXCJvcmllbnRhdGlvblpcIixcbiAgICBcIm9yaWdpblwiLFxuICAgIFwib3JpZ2luYWxQb2xpY3lcIixcbiAgICBcIm9yaWdpbmFsVGFyZ2V0XCIsXG4gICAgXCJvcnBoYW5zXCIsXG4gICAgXCJvc2NwdVwiLFxuICAgIFwib3V0ZXJIVE1MXCIsXG4gICAgXCJvdXRlckhlaWdodFwiLFxuICAgIFwib3V0ZXJUZXh0XCIsXG4gICAgXCJvdXRlcldpZHRoXCIsXG4gICAgXCJvdXRsaW5lXCIsXG4gICAgXCJvdXRsaW5lLWNvbG9yXCIsXG4gICAgXCJvdXRsaW5lLW9mZnNldFwiLFxuICAgIFwib3V0bGluZS1zdHlsZVwiLFxuICAgIFwib3V0bGluZS13aWR0aFwiLFxuICAgIFwib3V0bGluZUNvbG9yXCIsXG4gICAgXCJvdXRsaW5lT2Zmc2V0XCIsXG4gICAgXCJvdXRsaW5lU3R5bGVcIixcbiAgICBcIm91dGxpbmVXaWR0aFwiLFxuICAgIFwib3V0cHV0QnVmZmVyXCIsXG4gICAgXCJvdXRwdXRMYXRlbmN5XCIsXG4gICAgXCJvdXRwdXRzXCIsXG4gICAgXCJvdmVyZmxvd1wiLFxuICAgIFwib3ZlcmZsb3ctYW5jaG9yXCIsXG4gICAgXCJvdmVyZmxvdy1ibG9ja1wiLFxuICAgIFwib3ZlcmZsb3ctaW5saW5lXCIsXG4gICAgXCJvdmVyZmxvdy13cmFwXCIsXG4gICAgXCJvdmVyZmxvdy14XCIsXG4gICAgXCJvdmVyZmxvdy15XCIsXG4gICAgXCJvdmVyZmxvd0FuY2hvclwiLFxuICAgIFwib3ZlcmZsb3dCbG9ja1wiLFxuICAgIFwib3ZlcmZsb3dJbmxpbmVcIixcbiAgICBcIm92ZXJmbG93V3JhcFwiLFxuICAgIFwib3ZlcmZsb3dYXCIsXG4gICAgXCJvdmVyZmxvd1lcIixcbiAgICBcIm92ZXJyaWRlTWltZVR5cGVcIixcbiAgICBcIm92ZXJzYW1wbGVcIixcbiAgICBcIm92ZXJzY3JvbGwtYmVoYXZpb3JcIixcbiAgICBcIm92ZXJzY3JvbGwtYmVoYXZpb3ItYmxvY2tcIixcbiAgICBcIm92ZXJzY3JvbGwtYmVoYXZpb3ItaW5saW5lXCIsXG4gICAgXCJvdmVyc2Nyb2xsLWJlaGF2aW9yLXhcIixcbiAgICBcIm92ZXJzY3JvbGwtYmVoYXZpb3IteVwiLFxuICAgIFwib3ZlcnNjcm9sbEJlaGF2aW9yXCIsXG4gICAgXCJvdmVyc2Nyb2xsQmVoYXZpb3JCbG9ja1wiLFxuICAgIFwib3ZlcnNjcm9sbEJlaGF2aW9ySW5saW5lXCIsXG4gICAgXCJvdmVyc2Nyb2xsQmVoYXZpb3JYXCIsXG4gICAgXCJvdmVyc2Nyb2xsQmVoYXZpb3JZXCIsXG4gICAgXCJvd25LZXlzXCIsXG4gICAgXCJvd25lckRvY3VtZW50XCIsXG4gICAgXCJvd25lckVsZW1lbnRcIixcbiAgICBcIm93bmVyTm9kZVwiLFxuICAgIFwib3duZXJSdWxlXCIsXG4gICAgXCJvd25lclNWR0VsZW1lbnRcIixcbiAgICBcIm93bmluZ0VsZW1lbnRcIixcbiAgICBcInAxXCIsXG4gICAgXCJwMlwiLFxuICAgIFwicDNcIixcbiAgICBcInA0XCIsXG4gICAgXCJwYWNrZXRTaXplXCIsXG4gICAgXCJwYWNrZXRzXCIsXG4gICAgXCJwYWRcIixcbiAgICBcInBhZEVuZFwiLFxuICAgIFwicGFkU3RhcnRcIixcbiAgICBcInBhZGRpbmdcIixcbiAgICBcInBhZGRpbmctYmxvY2tcIixcbiAgICBcInBhZGRpbmctYmxvY2stZW5kXCIsXG4gICAgXCJwYWRkaW5nLWJsb2NrLXN0YXJ0XCIsXG4gICAgXCJwYWRkaW5nLWJvdHRvbVwiLFxuICAgIFwicGFkZGluZy1pbmxpbmVcIixcbiAgICBcInBhZGRpbmctaW5saW5lLWVuZFwiLFxuICAgIFwicGFkZGluZy1pbmxpbmUtc3RhcnRcIixcbiAgICBcInBhZGRpbmctbGVmdFwiLFxuICAgIFwicGFkZGluZy1yaWdodFwiLFxuICAgIFwicGFkZGluZy10b3BcIixcbiAgICBcInBhZGRpbmdCbG9ja1wiLFxuICAgIFwicGFkZGluZ0Jsb2NrRW5kXCIsXG4gICAgXCJwYWRkaW5nQmxvY2tTdGFydFwiLFxuICAgIFwicGFkZGluZ0JvdHRvbVwiLFxuICAgIFwicGFkZGluZ0lubGluZVwiLFxuICAgIFwicGFkZGluZ0lubGluZUVuZFwiLFxuICAgIFwicGFkZGluZ0lubGluZVN0YXJ0XCIsXG4gICAgXCJwYWRkaW5nTGVmdFwiLFxuICAgIFwicGFkZGluZ1JpZ2h0XCIsXG4gICAgXCJwYWRkaW5nVG9wXCIsXG4gICAgXCJwYWdlXCIsXG4gICAgXCJwYWdlLWJyZWFrLWFmdGVyXCIsXG4gICAgXCJwYWdlLWJyZWFrLWJlZm9yZVwiLFxuICAgIFwicGFnZS1icmVhay1pbnNpZGVcIixcbiAgICBcInBhZ2VCcmVha0FmdGVyXCIsXG4gICAgXCJwYWdlQnJlYWtCZWZvcmVcIixcbiAgICBcInBhZ2VCcmVha0luc2lkZVwiLFxuICAgIFwicGFnZUNvdW50XCIsXG4gICAgXCJwYWdlTGVmdFwiLFxuICAgIFwicGFnZVRvcFwiLFxuICAgIFwicGFnZVhcIixcbiAgICBcInBhZ2VYT2Zmc2V0XCIsXG4gICAgXCJwYWdlWVwiLFxuICAgIFwicGFnZVlPZmZzZXRcIixcbiAgICBcInBhZ2VzXCIsXG4gICAgXCJwYWludC1vcmRlclwiLFxuICAgIFwicGFpbnRPcmRlclwiLFxuICAgIFwicGFpbnRSZXF1ZXN0c1wiLFxuICAgIFwicGFpbnRUeXBlXCIsXG4gICAgXCJwYWludFdvcmtsZXRcIixcbiAgICBcInBhbGV0dGVcIixcbiAgICBcInBhblwiLFxuICAgIFwicGFubmluZ01vZGVsXCIsXG4gICAgXCJwYXJhbWV0ZXJzXCIsXG4gICAgXCJwYXJlbnRcIixcbiAgICBcInBhcmVudEVsZW1lbnRcIixcbiAgICBcInBhcmVudE5vZGVcIixcbiAgICBcInBhcmVudFJ1bGVcIixcbiAgICBcInBhcmVudFN0eWxlU2hlZXRcIixcbiAgICBcInBhcmVudFRleHRFZGl0XCIsXG4gICAgXCJwYXJlbnRXaW5kb3dcIixcbiAgICBcInBhcnNlXCIsXG4gICAgXCJwYXJzZUFsbFwiLFxuICAgIFwicGFyc2VGbG9hdFwiLFxuICAgIFwicGFyc2VGcm9tU3RyaW5nXCIsXG4gICAgXCJwYXJzZUludFwiLFxuICAgIFwicGFydFwiLFxuICAgIFwicGFydGljaXBhbnRzXCIsXG4gICAgXCJwYXNzaXZlXCIsXG4gICAgXCJwYXNzd29yZFwiLFxuICAgIFwicGFzdGVIVE1MXCIsXG4gICAgXCJwYXRoXCIsXG4gICAgXCJwYXRoTGVuZ3RoXCIsXG4gICAgXCJwYXRoU2VnTGlzdFwiLFxuICAgIFwicGF0aFNlZ1R5cGVcIixcbiAgICBcInBhdGhTZWdUeXBlQXNMZXR0ZXJcIixcbiAgICBcInBhdGhuYW1lXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJwYXR0ZXJuQ29udGVudFVuaXRzXCIsXG4gICAgXCJwYXR0ZXJuTWlzbWF0Y2hcIixcbiAgICBcInBhdHRlcm5UcmFuc2Zvcm1cIixcbiAgICBcInBhdHRlcm5Vbml0c1wiLFxuICAgIFwicGF1c2VcIixcbiAgICBcInBhdXNlQW5pbWF0aW9uc1wiLFxuICAgIFwicGF1c2VPbkV4aXRcIixcbiAgICBcInBhdXNlUHJvZmlsZXJzXCIsXG4gICAgXCJwYXVzZVRyYW5zZm9ybUZlZWRiYWNrXCIsXG4gICAgXCJwYXVzZWRcIixcbiAgICBcInBheWVyRW1haWxcIixcbiAgICBcInBheWVyTmFtZVwiLFxuICAgIFwicGF5ZXJQaG9uZVwiLFxuICAgIFwicGF5bWVudE1hbmFnZXJcIixcbiAgICBcInBjXCIsXG4gICAgXCJwZWVySWRlbnRpdHlcIixcbiAgICBcInBlbmRpbmdcIixcbiAgICBcInBlbmRpbmdMb2NhbERlc2NyaXB0aW9uXCIsXG4gICAgXCJwZW5kaW5nUmVtb3RlRGVzY3JpcHRpb25cIixcbiAgICBcInBlcmNlbnRcIixcbiAgICBcInBlcmZvcm1hbmNlXCIsXG4gICAgXCJwZXJpb2RpY1N5bmNcIixcbiAgICBcInBlcm1pc3Npb25cIixcbiAgICBcInBlcm1pc3Npb25TdGF0ZVwiLFxuICAgIFwicGVybWlzc2lvbnNcIixcbiAgICBcInBlcnNpc3RcIixcbiAgICBcInBlcnNpc3RlZFwiLFxuICAgIFwicGVyc29uYWxiYXJcIixcbiAgICBcInBlcnNwZWN0aXZlXCIsXG4gICAgXCJwZXJzcGVjdGl2ZS1vcmlnaW5cIixcbiAgICBcInBlcnNwZWN0aXZlT3JpZ2luXCIsXG4gICAgXCJwaG9uZVwiLFxuICAgIFwicGhvbmV0aWNGYW1pbHlOYW1lXCIsXG4gICAgXCJwaG9uZXRpY0dpdmVuTmFtZVwiLFxuICAgIFwicGhvdG9cIixcbiAgICBcInBpY3R1cmVJblBpY3R1cmVFbGVtZW50XCIsXG4gICAgXCJwaWN0dXJlSW5QaWN0dXJlRW5hYmxlZFwiLFxuICAgIFwicGljdHVyZUluUGljdHVyZVdpbmRvd1wiLFxuICAgIFwicGluZ1wiLFxuICAgIFwicGlwZVRocm91Z2hcIixcbiAgICBcInBpcGVUb1wiLFxuICAgIFwicGl0Y2hcIixcbiAgICBcInBpeGVsQm90dG9tXCIsXG4gICAgXCJwaXhlbERlcHRoXCIsXG4gICAgXCJwaXhlbEhlaWdodFwiLFxuICAgIFwicGl4ZWxMZWZ0XCIsXG4gICAgXCJwaXhlbFJpZ2h0XCIsXG4gICAgXCJwaXhlbFN0b3JlaVwiLFxuICAgIFwicGl4ZWxUb3BcIixcbiAgICBcInBpeGVsVW5pdFRvTWlsbGltZXRlclhcIixcbiAgICBcInBpeGVsVW5pdFRvTWlsbGltZXRlcllcIixcbiAgICBcInBpeGVsV2lkdGhcIixcbiAgICBcInBsYWNlLWNvbnRlbnRcIixcbiAgICBcInBsYWNlLWl0ZW1zXCIsXG4gICAgXCJwbGFjZS1zZWxmXCIsXG4gICAgXCJwbGFjZUNvbnRlbnRcIixcbiAgICBcInBsYWNlSXRlbXNcIixcbiAgICBcInBsYWNlU2VsZlwiLFxuICAgIFwicGxhY2Vob2xkZXJcIixcbiAgICBcInBsYXRmb3JtXCIsXG4gICAgXCJwbGF0Zm9ybXNcIixcbiAgICBcInBsYXlcIixcbiAgICBcInBsYXlFZmZlY3RcIixcbiAgICBcInBsYXlTdGF0ZVwiLFxuICAgIFwicGxheWJhY2tSYXRlXCIsXG4gICAgXCJwbGF5YmFja1N0YXRlXCIsXG4gICAgXCJwbGF5YmFja1RpbWVcIixcbiAgICBcInBsYXllZFwiLFxuICAgIFwicGxheW91dERlbGF5SGludFwiLFxuICAgIFwicGxheXNJbmxpbmVcIixcbiAgICBcInBsdWdpbnNcIixcbiAgICBcInBsdWdpbnNwYWdlXCIsXG4gICAgXCJwbmFtZVwiLFxuICAgIFwicG9pbnRlci1ldmVudHNcIixcbiAgICBcInBvaW50ZXJCZWZvcmVSZWZlcmVuY2VOb2RlXCIsXG4gICAgXCJwb2ludGVyRW5hYmxlZFwiLFxuICAgIFwicG9pbnRlckV2ZW50c1wiLFxuICAgIFwicG9pbnRlcklkXCIsXG4gICAgXCJwb2ludGVyTG9ja0VsZW1lbnRcIixcbiAgICBcInBvaW50ZXJUeXBlXCIsXG4gICAgXCJwb2ludHNcIixcbiAgICBcInBvaW50c0F0WFwiLFxuICAgIFwicG9pbnRzQXRZXCIsXG4gICAgXCJwb2ludHNBdFpcIixcbiAgICBcInBvbHlnb25PZmZzZXRcIixcbiAgICBcInBvcFwiLFxuICAgIFwicG9wdWxhdGVNYXRyaXhcIixcbiAgICBcInBvcHVwV2luZG93RmVhdHVyZXNcIixcbiAgICBcInBvcHVwV2luZG93TmFtZVwiLFxuICAgIFwicG9wdXBXaW5kb3dVUklcIixcbiAgICBcInBvcnRcIixcbiAgICBcInBvcnQxXCIsXG4gICAgXCJwb3J0MlwiLFxuICAgIFwicG9ydHNcIixcbiAgICBcInBvc0JvdHRvbVwiLFxuICAgIFwicG9zSGVpZ2h0XCIsXG4gICAgXCJwb3NMZWZ0XCIsXG4gICAgXCJwb3NSaWdodFwiLFxuICAgIFwicG9zVG9wXCIsXG4gICAgXCJwb3NXaWR0aFwiLFxuICAgIFwicG9zZVwiLFxuICAgIFwicG9zaXRpb25cIixcbiAgICBcInBvc2l0aW9uQWxpZ25cIixcbiAgICBcInBvc2l0aW9uWFwiLFxuICAgIFwicG9zaXRpb25ZXCIsXG4gICAgXCJwb3NpdGlvblpcIixcbiAgICBcInBvc3RFcnJvclwiLFxuICAgIFwicG9zdE1lc3NhZ2VcIixcbiAgICBcInBvc3RhbENvZGVcIixcbiAgICBcInBvc3RlclwiLFxuICAgIFwicG93XCIsXG4gICAgXCJwb3dlckVmZmljaWVudFwiLFxuICAgIFwicG93ZXJPZmZcIixcbiAgICBcInByZU11bHRpcGx5U2VsZlwiLFxuICAgIFwicHJlY2lzaW9uXCIsXG4gICAgXCJwcmVmZXJyZWRTdHlsZVNoZWV0U2V0XCIsXG4gICAgXCJwcmVmZXJyZWRTdHlsZXNoZWV0U2V0XCIsXG4gICAgXCJwcmVmaXhcIixcbiAgICBcInByZWxvYWRcIixcbiAgICBcInByZXBlbmRcIixcbiAgICBcInByZXNlbnRhdGlvblwiLFxuICAgIFwicHJlc2VydmVBbHBoYVwiLFxuICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLFxuICAgIFwicHJlc2VydmVBc3BlY3RSYXRpb1N0cmluZ1wiLFxuICAgIFwicHJlc3NlZFwiLFxuICAgIFwicHJlc3N1cmVcIixcbiAgICBcInByZXZWYWx1ZVwiLFxuICAgIFwicHJldmVudERlZmF1bHRcIixcbiAgICBcInByZXZlbnRFeHRlbnNpb25zXCIsXG4gICAgXCJwcmV2ZW50U2lsZW50QWNjZXNzXCIsXG4gICAgXCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nXCIsXG4gICAgXCJwcmV2aW91c05vZGVcIixcbiAgICBcInByZXZpb3VzUGFnZVwiLFxuICAgIFwicHJldmlvdXNSZWN0XCIsXG4gICAgXCJwcmV2aW91c1NjYWxlXCIsXG4gICAgXCJwcmV2aW91c1NpYmxpbmdcIixcbiAgICBcInByZXZpb3VzVHJhbnNsYXRlXCIsXG4gICAgXCJwcmltYXJ5S2V5XCIsXG4gICAgXCJwcmltaXRpdmVUeXBlXCIsXG4gICAgXCJwcmltaXRpdmVVbml0c1wiLFxuICAgIFwicHJpbmNpcGFsc1wiLFxuICAgIFwicHJpbnRcIixcbiAgICBcInByaW9yaXR5XCIsXG4gICAgXCJwcml2YXRlS2V5XCIsXG4gICAgXCJwcm9iYWJseVN1cHBvcnRzQ29udGV4dFwiLFxuICAgIFwicHJvY2Vzc1wiLFxuICAgIFwicHJvY2Vzc0ljZU1lc3NhZ2VcIixcbiAgICBcInByb2Nlc3NpbmdFbmRcIixcbiAgICBcInByb2Nlc3NpbmdTdGFydFwiLFxuICAgIFwicHJvZHVjdFwiLFxuICAgIFwicHJvZHVjdElkXCIsXG4gICAgXCJwcm9kdWN0TmFtZVwiLFxuICAgIFwicHJvZHVjdFN1YlwiLFxuICAgIFwicHJvZmlsZVwiLFxuICAgIFwicHJvZmlsZUVuZFwiLFxuICAgIFwicHJvZmlsZXNcIixcbiAgICBcInByb2plY3Rpb25NYXRyaXhcIixcbiAgICBcInByb21pc2VcIixcbiAgICBcInByb21wdFwiLFxuICAgIFwicHJvcGVydGllc1wiLFxuICAgIFwicHJvcGVydHlJc0VudW1lcmFibGVcIixcbiAgICBcInByb3BlcnR5TmFtZVwiLFxuICAgIFwicHJvdG9jb2xcIixcbiAgICBcInByb3RvY29sTG9uZ1wiLFxuICAgIFwicHJvdG90eXBlXCIsXG4gICAgXCJwcm92aWRlclwiLFxuICAgIFwicHNldWRvQ2xhc3NcIixcbiAgICBcInBzZXVkb0VsZW1lbnRcIixcbiAgICBcInB0XCIsXG4gICAgXCJwdWJsaWNJZFwiLFxuICAgIFwicHVibGljS2V5XCIsXG4gICAgXCJwdWJsaXNoZWRcIixcbiAgICBcInB1bHNlXCIsXG4gICAgXCJwdXNoXCIsXG4gICAgXCJwdXNoTWFuYWdlclwiLFxuICAgIFwicHVzaE5vdGlmaWNhdGlvblwiLFxuICAgIFwicHVzaFN0YXRlXCIsXG4gICAgXCJwdXRcIixcbiAgICBcInB1dEltYWdlRGF0YVwiLFxuICAgIFwicHhcIixcbiAgICBcInF1YWRyYXRpY0N1cnZlVG9cIixcbiAgICBcInF1YWxpZmllclwiLFxuICAgIFwicXVhdGVybmlvblwiLFxuICAgIFwicXVlcnlcIixcbiAgICBcInF1ZXJ5Q29tbWFuZEVuYWJsZWRcIixcbiAgICBcInF1ZXJ5Q29tbWFuZEluZGV0ZXJtXCIsXG4gICAgXCJxdWVyeUNvbW1hbmRTdGF0ZVwiLFxuICAgIFwicXVlcnlDb21tYW5kU3VwcG9ydGVkXCIsXG4gICAgXCJxdWVyeUNvbW1hbmRUZXh0XCIsXG4gICAgXCJxdWVyeUNvbW1hbmRWYWx1ZVwiLFxuICAgIFwicXVlcnlTZWxlY3RvclwiLFxuICAgIFwicXVlcnlTZWxlY3RvckFsbFwiLFxuICAgIFwicXVldWVNaWNyb3Rhc2tcIixcbiAgICBcInF1b3RlXCIsXG4gICAgXCJxdW90ZXNcIixcbiAgICBcInJcIixcbiAgICBcInIxXCIsXG4gICAgXCJyMlwiLFxuICAgIFwicmFjZVwiLFxuICAgIFwicmFkXCIsXG4gICAgXCJyYWRpb2dyb3VwXCIsXG4gICAgXCJyYWRpdXNYXCIsXG4gICAgXCJyYWRpdXNZXCIsXG4gICAgXCJyYW5kb21cIixcbiAgICBcInJhbmdlXCIsXG4gICAgXCJyYW5nZUNvdW50XCIsXG4gICAgXCJyYW5nZU1heFwiLFxuICAgIFwicmFuZ2VNaW5cIixcbiAgICBcInJhbmdlT2Zmc2V0XCIsXG4gICAgXCJyYW5nZU92ZXJmbG93XCIsXG4gICAgXCJyYW5nZVBhcmVudFwiLFxuICAgIFwicmFuZ2VVbmRlcmZsb3dcIixcbiAgICBcInJhdGVcIixcbiAgICBcInJhdGlvXCIsXG4gICAgXCJyYXdcIixcbiAgICBcInJhd0lkXCIsXG4gICAgXCJyZWFkXCIsXG4gICAgXCJyZWFkQXNBcnJheUJ1ZmZlclwiLFxuICAgIFwicmVhZEFzQmluYXJ5U3RyaW5nXCIsXG4gICAgXCJyZWFkQXNCbG9iXCIsXG4gICAgXCJyZWFkQXNEYXRhVVJMXCIsXG4gICAgXCJyZWFkQXNUZXh0XCIsXG4gICAgXCJyZWFkQnVmZmVyXCIsXG4gICAgXCJyZWFkRW50cmllc1wiLFxuICAgIFwicmVhZE9ubHlcIixcbiAgICBcInJlYWRQaXhlbHNcIixcbiAgICBcInJlYWRSZXBvcnRSZXF1ZXN0ZWRcIixcbiAgICBcInJlYWRUZXh0XCIsXG4gICAgXCJyZWFkVmFsdWVcIixcbiAgICBcInJlYWRhYmxlXCIsXG4gICAgXCJyZWFkeVwiLFxuICAgIFwicmVhZHlTdGF0ZVwiLFxuICAgIFwicmVhc29uXCIsXG4gICAgXCJyZWJvb3RcIixcbiAgICBcInJlY2VpdmVkQWxlcnRcIixcbiAgICBcInJlY2VpdmVyXCIsXG4gICAgXCJyZWNlaXZlcnNcIixcbiAgICBcInJlY2lwaWVudFwiLFxuICAgIFwicmVjb25uZWN0XCIsXG4gICAgXCJyZWNvcmROdW1iZXJcIixcbiAgICBcInJlY29yZHNBdmFpbGFibGVcIixcbiAgICBcInJlY29yZHNldFwiLFxuICAgIFwicmVjdFwiLFxuICAgIFwicmVkXCIsXG4gICAgXCJyZWRFeWVSZWR1Y3Rpb25cIixcbiAgICBcInJlZGlyZWN0XCIsXG4gICAgXCJyZWRpcmVjdENvdW50XCIsXG4gICAgXCJyZWRpcmVjdEVuZFwiLFxuICAgIFwicmVkaXJlY3RTdGFydFwiLFxuICAgIFwicmVkaXJlY3RlZFwiLFxuICAgIFwicmVkdWNlXCIsXG4gICAgXCJyZWR1Y2VSaWdodFwiLFxuICAgIFwicmVkdWN0aW9uXCIsXG4gICAgXCJyZWZEaXN0YW5jZVwiLFxuICAgIFwicmVmWFwiLFxuICAgIFwicmVmWVwiLFxuICAgIFwicmVmZXJlbmNlTm9kZVwiLFxuICAgIFwicmVmZXJlbmNlU3BhY2VcIixcbiAgICBcInJlZmVycmVyXCIsXG4gICAgXCJyZWZlcnJlclBvbGljeVwiLFxuICAgIFwicmVmcmVzaFwiLFxuICAgIFwicmVnaW9uXCIsXG4gICAgXCJyZWdpb25BbmNob3JYXCIsXG4gICAgXCJyZWdpb25BbmNob3JZXCIsXG4gICAgXCJyZWdpb25JZFwiLFxuICAgIFwicmVnaW9uc1wiLFxuICAgIFwicmVnaXN0ZXJcIixcbiAgICBcInJlZ2lzdGVyQ29udGVudEhhbmRsZXJcIixcbiAgICBcInJlZ2lzdGVyRWxlbWVudFwiLFxuICAgIFwicmVnaXN0ZXJQcm9wZXJ0eVwiLFxuICAgIFwicmVnaXN0ZXJQcm90b2NvbEhhbmRsZXJcIixcbiAgICBcInJlamVjdFwiLFxuICAgIFwicmVsXCIsXG4gICAgXCJyZWxMaXN0XCIsXG4gICAgXCJyZWxhdGVkQWRkcmVzc1wiLFxuICAgIFwicmVsYXRlZE5vZGVcIixcbiAgICBcInJlbGF0ZWRQb3J0XCIsXG4gICAgXCJyZWxhdGVkVGFyZ2V0XCIsXG4gICAgXCJyZWxlYXNlXCIsXG4gICAgXCJyZWxlYXNlQ2FwdHVyZVwiLFxuICAgIFwicmVsZWFzZUV2ZW50c1wiLFxuICAgIFwicmVsZWFzZUludGVyZmFjZVwiLFxuICAgIFwicmVsZWFzZUxvY2tcIixcbiAgICBcInJlbGVhc2VQb2ludGVyQ2FwdHVyZVwiLFxuICAgIFwicmVsZWFzZVNoYWRlckNvbXBpbGVyXCIsXG4gICAgXCJyZWxpYWJsZVwiLFxuICAgIFwicmVsaWFibGVXcml0ZVwiLFxuICAgIFwicmVsb2FkXCIsXG4gICAgXCJyZW1cIixcbiAgICBcInJlbWFpbmluZ1NwYWNlXCIsXG4gICAgXCJyZW1vdGVcIixcbiAgICBcInJlbW90ZURlc2NyaXB0aW9uXCIsXG4gICAgXCJyZW1vdmVcIixcbiAgICBcInJlbW92ZUFsbFJhbmdlc1wiLFxuICAgIFwicmVtb3ZlQXR0cmlidXRlXCIsXG4gICAgXCJyZW1vdmVBdHRyaWJ1dGVOU1wiLFxuICAgIFwicmVtb3ZlQXR0cmlidXRlTm9kZVwiLFxuICAgIFwicmVtb3ZlQmVoYXZpb3JcIixcbiAgICBcInJlbW92ZUNoaWxkXCIsXG4gICAgXCJyZW1vdmVDdWVcIixcbiAgICBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICBcInJlbW92ZUZpbHRlclwiLFxuICAgIFwicmVtb3ZlSW1wb3J0XCIsXG4gICAgXCJyZW1vdmVJdGVtXCIsXG4gICAgXCJyZW1vdmVMaXN0ZW5lclwiLFxuICAgIFwicmVtb3ZlTmFtZWRJdGVtXCIsXG4gICAgXCJyZW1vdmVOYW1lZEl0ZW1OU1wiLFxuICAgIFwicmVtb3ZlTm9kZVwiLFxuICAgIFwicmVtb3ZlUGFyYW1ldGVyXCIsXG4gICAgXCJyZW1vdmVQcm9wZXJ0eVwiLFxuICAgIFwicmVtb3ZlUmFuZ2VcIixcbiAgICBcInJlbW92ZVJlZ2lvblwiLFxuICAgIFwicmVtb3ZlUnVsZVwiLFxuICAgIFwicmVtb3ZlU2l0ZVNwZWNpZmljVHJhY2tpbmdFeGNlcHRpb25cIixcbiAgICBcInJlbW92ZVNvdXJjZUJ1ZmZlclwiLFxuICAgIFwicmVtb3ZlU3RyZWFtXCIsXG4gICAgXCJyZW1vdmVUcmFja1wiLFxuICAgIFwicmVtb3ZlVmFyaWFibGVcIixcbiAgICBcInJlbW92ZVdha2VMb2NrTGlzdGVuZXJcIixcbiAgICBcInJlbW92ZVdlYldpZGVUcmFja2luZ0V4Y2VwdGlvblwiLFxuICAgIFwicmVtb3ZlZFwiLFxuICAgIFwicmVtb3ZlZE5vZGVzXCIsXG4gICAgXCJyZW5kZXJIZWlnaHRcIixcbiAgICBcInJlbmRlclN0YXRlXCIsXG4gICAgXCJyZW5kZXJUaW1lXCIsXG4gICAgXCJyZW5kZXJXaWR0aFwiLFxuICAgIFwicmVuZGVyYnVmZmVyU3RvcmFnZVwiLFxuICAgIFwicmVuZGVyYnVmZmVyU3RvcmFnZU11bHRpc2FtcGxlXCIsXG4gICAgXCJyZW5kZXJlZEJ1ZmZlclwiLFxuICAgIFwicmVuZGVyaW5nTW9kZVwiLFxuICAgIFwicmVub3RpZnlcIixcbiAgICBcInJlcGVhdFwiLFxuICAgIFwicmVwbGFjZVwiLFxuICAgIFwicmVwbGFjZUFkamFjZW50VGV4dFwiLFxuICAgIFwicmVwbGFjZUFsbFwiLFxuICAgIFwicmVwbGFjZUNoaWxkXCIsXG4gICAgXCJyZXBsYWNlQ2hpbGRyZW5cIixcbiAgICBcInJlcGxhY2VEYXRhXCIsXG4gICAgXCJyZXBsYWNlSWRcIixcbiAgICBcInJlcGxhY2VJdGVtXCIsXG4gICAgXCJyZXBsYWNlTm9kZVwiLFxuICAgIFwicmVwbGFjZVN0YXRlXCIsXG4gICAgXCJyZXBsYWNlU3luY1wiLFxuICAgIFwicmVwbGFjZVRyYWNrXCIsXG4gICAgXCJyZXBsYWNlV2hvbGVUZXh0XCIsXG4gICAgXCJyZXBsYWNlV2l0aFwiLFxuICAgIFwicmVwb3J0VmFsaWRpdHlcIixcbiAgICBcInJlcXVlc3RcIixcbiAgICBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiLFxuICAgIFwicmVxdWVzdEF1dG9jb21wbGV0ZVwiLFxuICAgIFwicmVxdWVzdERhdGFcIixcbiAgICBcInJlcXVlc3REZXZpY2VcIixcbiAgICBcInJlcXVlc3RGcmFtZVwiLFxuICAgIFwicmVxdWVzdEZ1bGxzY3JlZW5cIixcbiAgICBcInJlcXVlc3RIaXRUZXN0U291cmNlXCIsXG4gICAgXCJyZXF1ZXN0SGl0VGVzdFNvdXJjZUZvclRyYW5zaWVudElucHV0XCIsXG4gICAgXCJyZXF1ZXN0SWRcIixcbiAgICBcInJlcXVlc3RJZGxlQ2FsbGJhY2tcIixcbiAgICBcInJlcXVlc3RNSURJQWNjZXNzXCIsXG4gICAgXCJyZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NcIixcbiAgICBcInJlcXVlc3RQZXJtaXNzaW9uXCIsXG4gICAgXCJyZXF1ZXN0UGljdHVyZUluUGljdHVyZVwiLFxuICAgIFwicmVxdWVzdFBvaW50ZXJMb2NrXCIsXG4gICAgXCJyZXF1ZXN0UHJlc2VudFwiLFxuICAgIFwicmVxdWVzdFJlZmVyZW5jZVNwYWNlXCIsXG4gICAgXCJyZXF1ZXN0U2Vzc2lvblwiLFxuICAgIFwicmVxdWVzdFN0YXJ0XCIsXG4gICAgXCJyZXF1ZXN0U3RvcmFnZUFjY2Vzc1wiLFxuICAgIFwicmVxdWVzdFN1Ym1pdFwiLFxuICAgIFwicmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFja1wiLFxuICAgIFwicmVxdWVzdGluZ1dpbmRvd1wiLFxuICAgIFwicmVxdWlyZUludGVyYWN0aW9uXCIsXG4gICAgXCJyZXF1aXJlZFwiLFxuICAgIFwicmVxdWlyZWRFeHRlbnNpb25zXCIsXG4gICAgXCJyZXF1aXJlZEZlYXR1cmVzXCIsXG4gICAgXCJyZXNldFwiLFxuICAgIFwicmVzZXRQb3NlXCIsXG4gICAgXCJyZXNldFRyYW5zZm9ybVwiLFxuICAgIFwicmVzaXplXCIsXG4gICAgXCJyZXNpemVCeVwiLFxuICAgIFwicmVzaXplVG9cIixcbiAgICBcInJlc29sdmVcIixcbiAgICBcInJlc3BvbnNlXCIsXG4gICAgXCJyZXNwb25zZUJvZHlcIixcbiAgICBcInJlc3BvbnNlRW5kXCIsXG4gICAgXCJyZXNwb25zZVJlYWR5XCIsXG4gICAgXCJyZXNwb25zZVN0YXJ0XCIsXG4gICAgXCJyZXNwb25zZVRleHRcIixcbiAgICBcInJlc3BvbnNlVHlwZVwiLFxuICAgIFwicmVzcG9uc2VVUkxcIixcbiAgICBcInJlc3BvbnNlWE1MXCIsXG4gICAgXCJyZXN0YXJ0SWNlXCIsXG4gICAgXCJyZXN0b3JlXCIsXG4gICAgXCJyZXN1bHRcIixcbiAgICBcInJlc3VsdEluZGV4XCIsXG4gICAgXCJyZXN1bHRUeXBlXCIsXG4gICAgXCJyZXN1bHRzXCIsXG4gICAgXCJyZXN1bWVcIixcbiAgICBcInJlc3VtZVByb2ZpbGVyc1wiLFxuICAgIFwicmVzdW1lVHJhbnNmb3JtRmVlZGJhY2tcIixcbiAgICBcInJldHJ5XCIsXG4gICAgXCJyZXR1cm5WYWx1ZVwiLFxuICAgIFwicmV2XCIsXG4gICAgXCJyZXZlcnNlXCIsXG4gICAgXCJyZXZlcnNlZFwiLFxuICAgIFwicmV2b2NhYmxlXCIsXG4gICAgXCJyZXZva2VPYmplY3RVUkxcIixcbiAgICBcInJnYkNvbG9yXCIsXG4gICAgXCJyaWdodFwiLFxuICAgIFwicmlnaHRDb250ZXh0XCIsXG4gICAgXCJyaWdodERlZ3JlZXNcIixcbiAgICBcInJpZ2h0TWFyZ2luXCIsXG4gICAgXCJyaWdodFByb2plY3Rpb25NYXRyaXhcIixcbiAgICBcInJpZ2h0Vmlld01hdHJpeFwiLFxuICAgIFwicm9sZVwiLFxuICAgIFwicm9sbG9mZkZhY3RvclwiLFxuICAgIFwicm9vdFwiLFxuICAgIFwicm9vdEJvdW5kc1wiLFxuICAgIFwicm9vdEVsZW1lbnRcIixcbiAgICBcInJvb3RNYXJnaW5cIixcbiAgICBcInJvdGF0ZVwiLFxuICAgIFwicm90YXRlQXhpc0FuZ2xlXCIsXG4gICAgXCJyb3RhdGVBeGlzQW5nbGVTZWxmXCIsXG4gICAgXCJyb3RhdGVGcm9tVmVjdG9yXCIsXG4gICAgXCJyb3RhdGVGcm9tVmVjdG9yU2VsZlwiLFxuICAgIFwicm90YXRlU2VsZlwiLFxuICAgIFwicm90YXRpb25cIixcbiAgICBcInJvdGF0aW9uQW5nbGVcIixcbiAgICBcInJvdGF0aW9uUmF0ZVwiLFxuICAgIFwicm91bmRcIixcbiAgICBcInJvdy1nYXBcIixcbiAgICBcInJvd0dhcFwiLFxuICAgIFwicm93SW5kZXhcIixcbiAgICBcInJvd1NwYW5cIixcbiAgICBcInJvd3NcIixcbiAgICBcInJ0Y3BUcmFuc3BvcnRcIixcbiAgICBcInJ0dFwiLFxuICAgIFwicnVieS1hbGlnblwiLFxuICAgIFwicnVieS1wb3NpdGlvblwiLFxuICAgIFwicnVieUFsaWduXCIsXG4gICAgXCJydWJ5T3ZlcmhhbmdcIixcbiAgICBcInJ1YnlQb3NpdGlvblwiLFxuICAgIFwicnVsZXNcIixcbiAgICBcInJ1bnRpbWVcIixcbiAgICBcInJ1bnRpbWVTdHlsZVwiLFxuICAgIFwicnhcIixcbiAgICBcInJ5XCIsXG4gICAgXCJzXCIsXG4gICAgXCJzYWZhcmlcIixcbiAgICBcInNhbXBsZVwiLFxuICAgIFwic2FtcGxlQ292ZXJhZ2VcIixcbiAgICBcInNhbXBsZVJhdGVcIixcbiAgICBcInNhbXBsZXJQYXJhbWV0ZXJmXCIsXG4gICAgXCJzYW1wbGVyUGFyYW1ldGVyaVwiLFxuICAgIFwic2FuZGJveFwiLFxuICAgIFwic2F2ZVwiLFxuICAgIFwic2F2ZURhdGFcIixcbiAgICBcInNjYWxlXCIsXG4gICAgXCJzY2FsZTNkXCIsXG4gICAgXCJzY2FsZTNkU2VsZlwiLFxuICAgIFwic2NhbGVOb25Vbmlmb3JtXCIsXG4gICAgXCJzY2FsZU5vblVuaWZvcm1TZWxmXCIsXG4gICAgXCJzY2FsZVNlbGZcIixcbiAgICBcInNjaGVtZVwiLFxuICAgIFwic2Npc3NvclwiLFxuICAgIFwic2NvcGVcIixcbiAgICBcInNjb3BlTmFtZVwiLFxuICAgIFwic2NvcGVkXCIsXG4gICAgXCJzY3JlZW5cIixcbiAgICBcInNjcmVlbkJyaWdodG5lc3NcIixcbiAgICBcInNjcmVlbkVuYWJsZWRcIixcbiAgICBcInNjcmVlbkxlZnRcIixcbiAgICBcInNjcmVlblBpeGVsVG9NaWxsaW1ldGVyWFwiLFxuICAgIFwic2NyZWVuUGl4ZWxUb01pbGxpbWV0ZXJZXCIsXG4gICAgXCJzY3JlZW5Ub3BcIixcbiAgICBcInNjcmVlblhcIixcbiAgICBcInNjcmVlbllcIixcbiAgICBcInNjcmlwdFVSTFwiLFxuICAgIFwic2NyaXB0c1wiLFxuICAgIFwic2Nyb2xsXCIsXG4gICAgXCJzY3JvbGwtYmVoYXZpb3JcIixcbiAgICBcInNjcm9sbC1tYXJnaW5cIixcbiAgICBcInNjcm9sbC1tYXJnaW4tYmxvY2tcIixcbiAgICBcInNjcm9sbC1tYXJnaW4tYmxvY2stZW5kXCIsXG4gICAgXCJzY3JvbGwtbWFyZ2luLWJsb2NrLXN0YXJ0XCIsXG4gICAgXCJzY3JvbGwtbWFyZ2luLWJvdHRvbVwiLFxuICAgIFwic2Nyb2xsLW1hcmdpbi1pbmxpbmVcIixcbiAgICBcInNjcm9sbC1tYXJnaW4taW5saW5lLWVuZFwiLFxuICAgIFwic2Nyb2xsLW1hcmdpbi1pbmxpbmUtc3RhcnRcIixcbiAgICBcInNjcm9sbC1tYXJnaW4tbGVmdFwiLFxuICAgIFwic2Nyb2xsLW1hcmdpbi1yaWdodFwiLFxuICAgIFwic2Nyb2xsLW1hcmdpbi10b3BcIixcbiAgICBcInNjcm9sbC1wYWRkaW5nXCIsXG4gICAgXCJzY3JvbGwtcGFkZGluZy1ibG9ja1wiLFxuICAgIFwic2Nyb2xsLXBhZGRpbmctYmxvY2stZW5kXCIsXG4gICAgXCJzY3JvbGwtcGFkZGluZy1ibG9jay1zdGFydFwiLFxuICAgIFwic2Nyb2xsLXBhZGRpbmctYm90dG9tXCIsXG4gICAgXCJzY3JvbGwtcGFkZGluZy1pbmxpbmVcIixcbiAgICBcInNjcm9sbC1wYWRkaW5nLWlubGluZS1lbmRcIixcbiAgICBcInNjcm9sbC1wYWRkaW5nLWlubGluZS1zdGFydFwiLFxuICAgIFwic2Nyb2xsLXBhZGRpbmctbGVmdFwiLFxuICAgIFwic2Nyb2xsLXBhZGRpbmctcmlnaHRcIixcbiAgICBcInNjcm9sbC1wYWRkaW5nLXRvcFwiLFxuICAgIFwic2Nyb2xsLXNuYXAtYWxpZ25cIixcbiAgICBcInNjcm9sbC1zbmFwLXR5cGVcIixcbiAgICBcInNjcm9sbEFtb3VudFwiLFxuICAgIFwic2Nyb2xsQmVoYXZpb3JcIixcbiAgICBcInNjcm9sbEJ5XCIsXG4gICAgXCJzY3JvbGxCeUxpbmVzXCIsXG4gICAgXCJzY3JvbGxCeVBhZ2VzXCIsXG4gICAgXCJzY3JvbGxEZWxheVwiLFxuICAgIFwic2Nyb2xsSGVpZ2h0XCIsXG4gICAgXCJzY3JvbGxJbnRvVmlld1wiLFxuICAgIFwic2Nyb2xsSW50b1ZpZXdJZk5lZWRlZFwiLFxuICAgIFwic2Nyb2xsTGVmdFwiLFxuICAgIFwic2Nyb2xsTGVmdE1heFwiLFxuICAgIFwic2Nyb2xsTWFyZ2luXCIsXG4gICAgXCJzY3JvbGxNYXJnaW5CbG9ja1wiLFxuICAgIFwic2Nyb2xsTWFyZ2luQmxvY2tFbmRcIixcbiAgICBcInNjcm9sbE1hcmdpbkJsb2NrU3RhcnRcIixcbiAgICBcInNjcm9sbE1hcmdpbkJvdHRvbVwiLFxuICAgIFwic2Nyb2xsTWFyZ2luSW5saW5lXCIsXG4gICAgXCJzY3JvbGxNYXJnaW5JbmxpbmVFbmRcIixcbiAgICBcInNjcm9sbE1hcmdpbklubGluZVN0YXJ0XCIsXG4gICAgXCJzY3JvbGxNYXJnaW5MZWZ0XCIsXG4gICAgXCJzY3JvbGxNYXJnaW5SaWdodFwiLFxuICAgIFwic2Nyb2xsTWFyZ2luVG9wXCIsXG4gICAgXCJzY3JvbGxNYXhYXCIsXG4gICAgXCJzY3JvbGxNYXhZXCIsXG4gICAgXCJzY3JvbGxQYWRkaW5nXCIsXG4gICAgXCJzY3JvbGxQYWRkaW5nQmxvY2tcIixcbiAgICBcInNjcm9sbFBhZGRpbmdCbG9ja0VuZFwiLFxuICAgIFwic2Nyb2xsUGFkZGluZ0Jsb2NrU3RhcnRcIixcbiAgICBcInNjcm9sbFBhZGRpbmdCb3R0b21cIixcbiAgICBcInNjcm9sbFBhZGRpbmdJbmxpbmVcIixcbiAgICBcInNjcm9sbFBhZGRpbmdJbmxpbmVFbmRcIixcbiAgICBcInNjcm9sbFBhZGRpbmdJbmxpbmVTdGFydFwiLFxuICAgIFwic2Nyb2xsUGFkZGluZ0xlZnRcIixcbiAgICBcInNjcm9sbFBhZGRpbmdSaWdodFwiLFxuICAgIFwic2Nyb2xsUGFkZGluZ1RvcFwiLFxuICAgIFwic2Nyb2xsUmVzdG9yYXRpb25cIixcbiAgICBcInNjcm9sbFNuYXBBbGlnblwiLFxuICAgIFwic2Nyb2xsU25hcFR5cGVcIixcbiAgICBcInNjcm9sbFRvXCIsXG4gICAgXCJzY3JvbGxUb3BcIixcbiAgICBcInNjcm9sbFRvcE1heFwiLFxuICAgIFwic2Nyb2xsV2lkdGhcIixcbiAgICBcInNjcm9sbFhcIixcbiAgICBcInNjcm9sbFlcIixcbiAgICBcInNjcm9sbGJhci1jb2xvclwiLFxuICAgIFwic2Nyb2xsYmFyLXdpZHRoXCIsXG4gICAgXCJzY3JvbGxiYXIzZExpZ2h0Q29sb3JcIixcbiAgICBcInNjcm9sbGJhckFycm93Q29sb3JcIixcbiAgICBcInNjcm9sbGJhckJhc2VDb2xvclwiLFxuICAgIFwic2Nyb2xsYmFyQ29sb3JcIixcbiAgICBcInNjcm9sbGJhckRhcmtTaGFkb3dDb2xvclwiLFxuICAgIFwic2Nyb2xsYmFyRmFjZUNvbG9yXCIsXG4gICAgXCJzY3JvbGxiYXJIaWdobGlnaHRDb2xvclwiLFxuICAgIFwic2Nyb2xsYmFyU2hhZG93Q29sb3JcIixcbiAgICBcInNjcm9sbGJhclRyYWNrQ29sb3JcIixcbiAgICBcInNjcm9sbGJhcldpZHRoXCIsXG4gICAgXCJzY3JvbGxiYXJzXCIsXG4gICAgXCJzY3JvbGxpbmdcIixcbiAgICBcInNjcm9sbGluZ0VsZW1lbnRcIixcbiAgICBcInNjdHBcIixcbiAgICBcInNjdHBDYXVzZUNvZGVcIixcbiAgICBcInNkcFwiLFxuICAgIFwic2RwTGluZU51bWJlclwiLFxuICAgIFwic2RwTUxpbmVJbmRleFwiLFxuICAgIFwic2RwTWlkXCIsXG4gICAgXCJzZWFsXCIsXG4gICAgXCJzZWFyY2hcIixcbiAgICBcInNlYXJjaEJveFwiLFxuICAgIFwic2VhcmNoQm94SmF2YUJyaWRnZV9cIixcbiAgICBcInNlYXJjaFBhcmFtc1wiLFxuICAgIFwic2VjdGlvblJvd0luZGV4XCIsXG4gICAgXCJzZWN1cmVDb25uZWN0aW9uU3RhcnRcIixcbiAgICBcInNlY3VyaXR5XCIsXG4gICAgXCJzZWVkXCIsXG4gICAgXCJzZWVrVG9OZXh0RnJhbWVcIixcbiAgICBcInNlZWthYmxlXCIsXG4gICAgXCJzZWVraW5nXCIsXG4gICAgXCJzZWxlY3RcIixcbiAgICBcInNlbGVjdEFsbENoaWxkcmVuXCIsXG4gICAgXCJzZWxlY3RBbHRlcm5hdGVJbnRlcmZhY2VcIixcbiAgICBcInNlbGVjdENvbmZpZ3VyYXRpb25cIixcbiAgICBcInNlbGVjdE5vZGVcIixcbiAgICBcInNlbGVjdE5vZGVDb250ZW50c1wiLFxuICAgIFwic2VsZWN0Tm9kZXNcIixcbiAgICBcInNlbGVjdFNpbmdsZU5vZGVcIixcbiAgICBcInNlbGVjdFN1YlN0cmluZ1wiLFxuICAgIFwic2VsZWN0ZWRcIixcbiAgICBcInNlbGVjdGVkSW5kZXhcIixcbiAgICBcInNlbGVjdGVkT3B0aW9uc1wiLFxuICAgIFwic2VsZWN0ZWRTdHlsZVNoZWV0U2V0XCIsXG4gICAgXCJzZWxlY3RlZFN0eWxlc2hlZXRTZXRcIixcbiAgICBcInNlbGVjdGlvblwiLFxuICAgIFwic2VsZWN0aW9uRGlyZWN0aW9uXCIsXG4gICAgXCJzZWxlY3Rpb25FbmRcIixcbiAgICBcInNlbGVjdGlvblN0YXJ0XCIsXG4gICAgXCJzZWxlY3RvclwiLFxuICAgIFwic2VsZWN0b3JUZXh0XCIsXG4gICAgXCJzZWxmXCIsXG4gICAgXCJzZW5kXCIsXG4gICAgXCJzZW5kQXNCaW5hcnlcIixcbiAgICBcInNlbmRCZWFjb25cIixcbiAgICBcInNlbmRlclwiLFxuICAgIFwic2VudEFsZXJ0XCIsXG4gICAgXCJzZW50VGltZXN0YW1wXCIsXG4gICAgXCJzZXBhcmF0b3JcIixcbiAgICBcInNlcmlhbE51bWJlclwiLFxuICAgIFwic2VyaWFsaXplVG9TdHJpbmdcIixcbiAgICBcInNlcnZlclRpbWluZ1wiLFxuICAgIFwic2VydmljZVwiLFxuICAgIFwic2VydmljZVdvcmtlclwiLFxuICAgIFwic2Vzc2lvblwiLFxuICAgIFwic2Vzc2lvbklkXCIsXG4gICAgXCJzZXNzaW9uU3RvcmFnZVwiLFxuICAgIFwic2V0XCIsXG4gICAgXCJzZXRBY3Rpb25IYW5kbGVyXCIsXG4gICAgXCJzZXRBY3RpdmVcIixcbiAgICBcInNldEFscGhhXCIsXG4gICAgXCJzZXRBcHBCYWRnZVwiLFxuICAgIFwic2V0QXR0cmlidXRlXCIsXG4gICAgXCJzZXRBdHRyaWJ1dGVOU1wiLFxuICAgIFwic2V0QXR0cmlidXRlTm9kZVwiLFxuICAgIFwic2V0QXR0cmlidXRlTm9kZU5TXCIsXG4gICAgXCJzZXRCYXNlQW5kRXh0ZW50XCIsXG4gICAgXCJzZXRCaWdJbnQ2NFwiLFxuICAgIFwic2V0QmlnVWludDY0XCIsXG4gICAgXCJzZXRCaW5nQ3VycmVudFNlYXJjaERlZmF1bHRcIixcbiAgICBcInNldENhcHR1cmVcIixcbiAgICBcInNldENvZGVjUHJlZmVyZW5jZXNcIixcbiAgICBcInNldENvbG9yXCIsXG4gICAgXCJzZXRDb21wb3NpdGVPcGVyYXRpb25cIixcbiAgICBcInNldENvbmZpZ3VyYXRpb25cIixcbiAgICBcInNldEN1cnJlbnRUaW1lXCIsXG4gICAgXCJzZXRDdXN0b21WYWxpZGl0eVwiLFxuICAgIFwic2V0RGF0YVwiLFxuICAgIFwic2V0RGF0ZVwiLFxuICAgIFwic2V0RHJhZ0ltYWdlXCIsXG4gICAgXCJzZXRFbmRcIixcbiAgICBcInNldEVuZEFmdGVyXCIsXG4gICAgXCJzZXRFbmRCZWZvcmVcIixcbiAgICBcInNldEVuZFBvaW50XCIsXG4gICAgXCJzZXRGaWxsQ29sb3JcIixcbiAgICBcInNldEZpbHRlclJlc1wiLFxuICAgIFwic2V0RmxvYXQzMlwiLFxuICAgIFwic2V0RmxvYXQ2NFwiLFxuICAgIFwic2V0RmxvYXRWYWx1ZVwiLFxuICAgIFwic2V0Rm9ybVZhbHVlXCIsXG4gICAgXCJzZXRGdWxsWWVhclwiLFxuICAgIFwic2V0SGVhZGVyVmFsdWVcIixcbiAgICBcInNldEhvdXJzXCIsXG4gICAgXCJzZXRJZGVudGl0eVByb3ZpZGVyXCIsXG4gICAgXCJzZXRJbW1lZGlhdGVcIixcbiAgICBcInNldEludDE2XCIsXG4gICAgXCJzZXRJbnQzMlwiLFxuICAgIFwic2V0SW50OFwiLFxuICAgIFwic2V0SW50ZXJ2YWxcIixcbiAgICBcInNldEl0ZW1cIixcbiAgICBcInNldEtleWZyYW1lc1wiLFxuICAgIFwic2V0TGluZUNhcFwiLFxuICAgIFwic2V0TGluZURhc2hcIixcbiAgICBcInNldExpbmVKb2luXCIsXG4gICAgXCJzZXRMaW5lV2lkdGhcIixcbiAgICBcInNldExpdmVTZWVrYWJsZVJhbmdlXCIsXG4gICAgXCJzZXRMb2NhbERlc2NyaXB0aW9uXCIsXG4gICAgXCJzZXRNYXRyaXhcIixcbiAgICBcInNldE1hdHJpeFZhbHVlXCIsXG4gICAgXCJzZXRNZWRpYUtleXNcIixcbiAgICBcInNldE1pbGxpc2Vjb25kc1wiLFxuICAgIFwic2V0TWludXRlc1wiLFxuICAgIFwic2V0TWl0ZXJMaW1pdFwiLFxuICAgIFwic2V0TW9udGhcIixcbiAgICBcInNldE5hbWVkSXRlbVwiLFxuICAgIFwic2V0TmFtZWRJdGVtTlNcIixcbiAgICBcInNldE5vblVzZXJDb2RlRXhjZXB0aW9uc1wiLFxuICAgIFwic2V0T3JpZW50VG9BbmdsZVwiLFxuICAgIFwic2V0T3JpZW50VG9BdXRvXCIsXG4gICAgXCJzZXRPcmllbnRhdGlvblwiLFxuICAgIFwic2V0T3ZlcnJpZGVIaXN0b3J5TmF2aWdhdGlvbk1vZGVcIixcbiAgICBcInNldFBhaW50XCIsXG4gICAgXCJzZXRQYXJhbWV0ZXJcIixcbiAgICBcInNldFBhcmFtZXRlcnNcIixcbiAgICBcInNldFBlcmlvZGljV2F2ZVwiLFxuICAgIFwic2V0UG9pbnRlckNhcHR1cmVcIixcbiAgICBcInNldFBvc2l0aW9uXCIsXG4gICAgXCJzZXRQb3NpdGlvblN0YXRlXCIsXG4gICAgXCJzZXRQcmVmZXJlbmNlXCIsXG4gICAgXCJzZXRQcm9wZXJ0eVwiLFxuICAgIFwic2V0UHJvdG90eXBlT2ZcIixcbiAgICBcInNldFJHQkNvbG9yXCIsXG4gICAgXCJzZXRSR0JDb2xvcklDQ0NvbG9yXCIsXG4gICAgXCJzZXRSYWRpdXNcIixcbiAgICBcInNldFJhbmdlVGV4dFwiLFxuICAgIFwic2V0UmVtb3RlRGVzY3JpcHRpb25cIixcbiAgICBcInNldFJlcXVlc3RIZWFkZXJcIixcbiAgICBcInNldFJlc2l6YWJsZVwiLFxuICAgIFwic2V0UmVzb3VyY2VUaW1pbmdCdWZmZXJTaXplXCIsXG4gICAgXCJzZXRSb3RhdGVcIixcbiAgICBcInNldFNjYWxlXCIsXG4gICAgXCJzZXRTZWNvbmRzXCIsXG4gICAgXCJzZXRTZWxlY3Rpb25SYW5nZVwiLFxuICAgIFwic2V0U2VydmVyQ2VydGlmaWNhdGVcIixcbiAgICBcInNldFNoYWRvd1wiLFxuICAgIFwic2V0U2lua0lkXCIsXG4gICAgXCJzZXRTa2V3WFwiLFxuICAgIFwic2V0U2tld1lcIixcbiAgICBcInNldFN0YXJ0XCIsXG4gICAgXCJzZXRTdGFydEFmdGVyXCIsXG4gICAgXCJzZXRTdGFydEJlZm9yZVwiLFxuICAgIFwic2V0U3RkRGV2aWF0aW9uXCIsXG4gICAgXCJzZXRTdHJlYW1zXCIsXG4gICAgXCJzZXRTdHJpbmdWYWx1ZVwiLFxuICAgIFwic2V0U3Ryb2tlQ29sb3JcIixcbiAgICBcInNldFN1Z2dlc3RSZXN1bHRcIixcbiAgICBcInNldFRhcmdldEF0VGltZVwiLFxuICAgIFwic2V0VGFyZ2V0VmFsdWVBdFRpbWVcIixcbiAgICBcInNldFRpbWVcIixcbiAgICBcInNldFRpbWVvdXRcIixcbiAgICBcInNldFRyYW5zZm9ybVwiLFxuICAgIFwic2V0VHJhbnNsYXRlXCIsXG4gICAgXCJzZXRVVENEYXRlXCIsXG4gICAgXCJzZXRVVENGdWxsWWVhclwiLFxuICAgIFwic2V0VVRDSG91cnNcIixcbiAgICBcInNldFVUQ01pbGxpc2Vjb25kc1wiLFxuICAgIFwic2V0VVRDTWludXRlc1wiLFxuICAgIFwic2V0VVRDTW9udGhcIixcbiAgICBcInNldFVUQ1NlY29uZHNcIixcbiAgICBcInNldFVpbnQxNlwiLFxuICAgIFwic2V0VWludDMyXCIsXG4gICAgXCJzZXRVaW50OFwiLFxuICAgIFwic2V0VXJpXCIsXG4gICAgXCJzZXRWYWxpZGl0eVwiLFxuICAgIFwic2V0VmFsdWVBdFRpbWVcIixcbiAgICBcInNldFZhbHVlQ3VydmVBdFRpbWVcIixcbiAgICBcInNldFZhcmlhYmxlXCIsXG4gICAgXCJzZXRWZWxvY2l0eVwiLFxuICAgIFwic2V0VmVyc2lvblwiLFxuICAgIFwic2V0WWVhclwiLFxuICAgIFwic2V0dGluZ05hbWVcIixcbiAgICBcInNldHRpbmdWYWx1ZVwiLFxuICAgIFwic2V4XCIsXG4gICAgXCJzaGFkZXJTb3VyY2VcIixcbiAgICBcInNoYWRvd0JsdXJcIixcbiAgICBcInNoYWRvd0NvbG9yXCIsXG4gICAgXCJzaGFkb3dPZmZzZXRYXCIsXG4gICAgXCJzaGFkb3dPZmZzZXRZXCIsXG4gICAgXCJzaGFkb3dSb290XCIsXG4gICAgXCJzaGFwZVwiLFxuICAgIFwic2hhcGUtaW1hZ2UtdGhyZXNob2xkXCIsXG4gICAgXCJzaGFwZS1tYXJnaW5cIixcbiAgICBcInNoYXBlLW91dHNpZGVcIixcbiAgICBcInNoYXBlLXJlbmRlcmluZ1wiLFxuICAgIFwic2hhcGVJbWFnZVRocmVzaG9sZFwiLFxuICAgIFwic2hhcGVNYXJnaW5cIixcbiAgICBcInNoYXBlT3V0c2lkZVwiLFxuICAgIFwic2hhcGVSZW5kZXJpbmdcIixcbiAgICBcInNoZWV0XCIsXG4gICAgXCJzaGlmdFwiLFxuICAgIFwic2hpZnRLZXlcIixcbiAgICBcInNoaWZ0TGVmdFwiLFxuICAgIFwic2hpcHBpbmdBZGRyZXNzXCIsXG4gICAgXCJzaGlwcGluZ09wdGlvblwiLFxuICAgIFwic2hpcHBpbmdUeXBlXCIsXG4gICAgXCJzaG93XCIsXG4gICAgXCJzaG93SGVscFwiLFxuICAgIFwic2hvd01vZGFsXCIsXG4gICAgXCJzaG93TW9kYWxEaWFsb2dcIixcbiAgICBcInNob3dNb2RlbGVzc0RpYWxvZ1wiLFxuICAgIFwic2hvd05vdGlmaWNhdGlvblwiLFxuICAgIFwic2lkZWJhclwiLFxuICAgIFwic2lnblwiLFxuICAgIFwic2lnbmFsXCIsXG4gICAgXCJzaWduYWxpbmdTdGF0ZVwiLFxuICAgIFwic2lnbmF0dXJlXCIsXG4gICAgXCJzaWxlbnRcIixcbiAgICBcInNpblwiLFxuICAgIFwic2luZ2xlTm9kZVZhbHVlXCIsXG4gICAgXCJzaW5oXCIsXG4gICAgXCJzaW5rSWRcIixcbiAgICBcInNpdHRpbmdUb1N0YW5kaW5nVHJhbnNmb3JtXCIsXG4gICAgXCJzaXplXCIsXG4gICAgXCJzaXplVG9Db250ZW50XCIsXG4gICAgXCJzaXplWFwiLFxuICAgIFwic2l6ZVpcIixcbiAgICBcInNpemVzXCIsXG4gICAgXCJza2V3WFwiLFxuICAgIFwic2tld1hTZWxmXCIsXG4gICAgXCJza2V3WVwiLFxuICAgIFwic2tld1lTZWxmXCIsXG4gICAgXCJzbGljZVwiLFxuICAgIFwic2xvcGVcIixcbiAgICBcInNsb3RcIixcbiAgICBcInNtYWxsXCIsXG4gICAgXCJzbWlsXCIsXG4gICAgXCJzbW9vdGhcIixcbiAgICBcInNtb290aGluZ1RpbWVDb25zdGFudFwiLFxuICAgIFwic25hcFRvTGluZXNcIixcbiAgICBcInNuYXBzaG90SXRlbVwiLFxuICAgIFwic25hcHNob3RMZW5ndGhcIixcbiAgICBcInNvbWVcIixcbiAgICBcInNvcnRcIixcbiAgICBcInNvcnRpbmdDb2RlXCIsXG4gICAgXCJzb3VyY2VcIixcbiAgICBcInNvdXJjZUJ1ZmZlclwiLFxuICAgIFwic291cmNlQnVmZmVyc1wiLFxuICAgIFwic291cmNlQ2FwYWJpbGl0aWVzXCIsXG4gICAgXCJzb3VyY2VGaWxlXCIsXG4gICAgXCJzb3VyY2VJbmRleFwiLFxuICAgIFwic291cmNlc1wiLFxuICAgIFwic3BhY2luZ1wiLFxuICAgIFwic3BhblwiLFxuICAgIFwic3BlYWtcIixcbiAgICBcInNwZWFrQXNcIixcbiAgICBcInNwZWFraW5nXCIsXG4gICAgXCJzcGVjaWVzXCIsXG4gICAgXCJzcGVjaWZpZWRcIixcbiAgICBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgICBcInNwZWN1bGFyRXhwb25lbnRcIixcbiAgICBcInNwZWVjaFN5bnRoZXNpc1wiLFxuICAgIFwic3BlZWRcIixcbiAgICBcInNwZWVkT2ZTb3VuZFwiLFxuICAgIFwic3BlbGxjaGVja1wiLFxuICAgIFwic3BsaWNlXCIsXG4gICAgXCJzcGxpdFwiLFxuICAgIFwic3BsaXRUZXh0XCIsXG4gICAgXCJzcHJlYWRNZXRob2RcIixcbiAgICBcInNxcnRcIixcbiAgICBcInNyY1wiLFxuICAgIFwic3JjRWxlbWVudFwiLFxuICAgIFwic3JjRmlsdGVyXCIsXG4gICAgXCJzcmNPYmplY3RcIixcbiAgICBcInNyY1VyblwiLFxuICAgIFwic3JjZG9jXCIsXG4gICAgXCJzcmNsYW5nXCIsXG4gICAgXCJzcmNzZXRcIixcbiAgICBcInN0YWNrXCIsXG4gICAgXCJzdGFja1RyYWNlTGltaXRcIixcbiAgICBcInN0YWNrdHJhY2VcIixcbiAgICBcInN0YWdlUGFyYW1ldGVyc1wiLFxuICAgIFwic3RhbmRhbG9uZVwiLFxuICAgIFwic3RhbmRieVwiLFxuICAgIFwic3RhcnRcIixcbiAgICBcInN0YXJ0Q29udGFpbmVyXCIsXG4gICAgXCJzdGFydEljZVwiLFxuICAgIFwic3RhcnRNZXNzYWdlc1wiLFxuICAgIFwic3RhcnROb3RpZmljYXRpb25zXCIsXG4gICAgXCJzdGFydE9mZnNldFwiLFxuICAgIFwic3RhcnRQcm9maWxpbmdcIixcbiAgICBcInN0YXJ0UmVuZGVyaW5nXCIsXG4gICAgXCJzdGFydFNoYXJrXCIsXG4gICAgXCJzdGFydFRpbWVcIixcbiAgICBcInN0YXJ0c1dpdGhcIixcbiAgICBcInN0YXRlXCIsXG4gICAgXCJzdGF0dXNcIixcbiAgICBcInN0YXR1c0NvZGVcIixcbiAgICBcInN0YXR1c01lc3NhZ2VcIixcbiAgICBcInN0YXR1c1RleHRcIixcbiAgICBcInN0YXR1c2JhclwiLFxuICAgIFwic3RkRGV2aWF0aW9uWFwiLFxuICAgIFwic3RkRGV2aWF0aW9uWVwiLFxuICAgIFwic3RlbmNpbEZ1bmNcIixcbiAgICBcInN0ZW5jaWxGdW5jU2VwYXJhdGVcIixcbiAgICBcInN0ZW5jaWxNYXNrXCIsXG4gICAgXCJzdGVuY2lsTWFza1NlcGFyYXRlXCIsXG4gICAgXCJzdGVuY2lsT3BcIixcbiAgICBcInN0ZW5jaWxPcFNlcGFyYXRlXCIsXG4gICAgXCJzdGVwXCIsXG4gICAgXCJzdGVwRG93blwiLFxuICAgIFwic3RlcE1pc21hdGNoXCIsXG4gICAgXCJzdGVwVXBcIixcbiAgICBcInN0aWNreVwiLFxuICAgIFwic3RpdGNoVGlsZXNcIixcbiAgICBcInN0b3BcIixcbiAgICBcInN0b3AtY29sb3JcIixcbiAgICBcInN0b3Atb3BhY2l0eVwiLFxuICAgIFwic3RvcENvbG9yXCIsXG4gICAgXCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cIixcbiAgICBcInN0b3BOb3RpZmljYXRpb25zXCIsXG4gICAgXCJzdG9wT3BhY2l0eVwiLFxuICAgIFwic3RvcFByb2ZpbGluZ1wiLFxuICAgIFwic3RvcFByb3BhZ2F0aW9uXCIsXG4gICAgXCJzdG9wU2hhcmtcIixcbiAgICBcInN0b3BwZWRcIixcbiAgICBcInN0b3JhZ2VcIixcbiAgICBcInN0b3JhZ2VBcmVhXCIsXG4gICAgXCJzdG9yYWdlTmFtZVwiLFxuICAgIFwic3RvcmFnZVN0YXR1c1wiLFxuICAgIFwic3RvcmVcIixcbiAgICBcInN0b3JlU2l0ZVNwZWNpZmljVHJhY2tpbmdFeGNlcHRpb25cIixcbiAgICBcInN0b3JlV2ViV2lkZVRyYWNraW5nRXhjZXB0aW9uXCIsXG4gICAgXCJzdHBWZXJzaW9uXCIsXG4gICAgXCJzdHJlYW1cIixcbiAgICBcInN0cmVhbXNcIixcbiAgICBcInN0cmV0Y2hcIixcbiAgICBcInN0cmlrZVwiLFxuICAgIFwic3RyaW5nXCIsXG4gICAgXCJzdHJpbmdWYWx1ZVwiLFxuICAgIFwic3RyaW5naWZ5XCIsXG4gICAgXCJzdHJva2VcIixcbiAgICBcInN0cm9rZS1kYXNoYXJyYXlcIixcbiAgICBcInN0cm9rZS1kYXNob2Zmc2V0XCIsXG4gICAgXCJzdHJva2UtbGluZWNhcFwiLFxuICAgIFwic3Ryb2tlLWxpbmVqb2luXCIsXG4gICAgXCJzdHJva2UtbWl0ZXJsaW1pdFwiLFxuICAgIFwic3Ryb2tlLW9wYWNpdHlcIixcbiAgICBcInN0cm9rZS13aWR0aFwiLFxuICAgIFwic3Ryb2tlRGFzaGFycmF5XCIsXG4gICAgXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgXCJzdHJva2VMaW5lY2FwXCIsXG4gICAgXCJzdHJva2VMaW5lam9pblwiLFxuICAgIFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICAgIFwic3Ryb2tlT3BhY2l0eVwiLFxuICAgIFwic3Ryb2tlUmVjdFwiLFxuICAgIFwic3Ryb2tlU3R5bGVcIixcbiAgICBcInN0cm9rZVRleHRcIixcbiAgICBcInN0cm9rZVdpZHRoXCIsXG4gICAgXCJzdHlsZVwiLFxuICAgIFwic3R5bGVGbG9hdFwiLFxuICAgIFwic3R5bGVNYXBcIixcbiAgICBcInN0eWxlTWVkaWFcIixcbiAgICBcInN0eWxlU2hlZXRcIixcbiAgICBcInN0eWxlU2hlZXRTZXRzXCIsXG4gICAgXCJzdHlsZVNoZWV0c1wiLFxuICAgIFwic3ViXCIsXG4gICAgXCJzdWJhcnJheVwiLFxuICAgIFwic3ViamVjdFwiLFxuICAgIFwic3VibWl0XCIsXG4gICAgXCJzdWJtaXRGcmFtZVwiLFxuICAgIFwic3VibWl0dGVyXCIsXG4gICAgXCJzdWJzY3JpYmVcIixcbiAgICBcInN1YnN0clwiLFxuICAgIFwic3Vic3RyaW5nXCIsXG4gICAgXCJzdWJzdHJpbmdEYXRhXCIsXG4gICAgXCJzdWJ0bGVcIixcbiAgICBcInN1YnRyZWVcIixcbiAgICBcInN1ZmZpeFwiLFxuICAgIFwic3VmZml4ZXNcIixcbiAgICBcInN1bW1hcnlcIixcbiAgICBcInN1cFwiLFxuICAgIFwic3VwcG9ydGVkXCIsXG4gICAgXCJzdXBwb3J0ZWRDb250ZW50RW5jb2RpbmdzXCIsXG4gICAgXCJzdXBwb3J0ZWRFbnRyeVR5cGVzXCIsXG4gICAgXCJzdXBwb3J0c1wiLFxuICAgIFwic3VwcG9ydHNTZXNzaW9uXCIsXG4gICAgXCJzdXJmYWNlU2NhbGVcIixcbiAgICBcInN1cnJvdW5kQ29udGVudHNcIixcbiAgICBcInN1c3BlbmRcIixcbiAgICBcInN1c3BlbmRSZWRyYXdcIixcbiAgICBcInN3YXBDYWNoZVwiLFxuICAgIFwic3dhcE5vZGVcIixcbiAgICBcInN3ZWVwRmxhZ1wiLFxuICAgIFwic3ltYm9sc1wiLFxuICAgIFwic3luY1wiLFxuICAgIFwic3lzZXhFbmFibGVkXCIsXG4gICAgXCJzeXN0ZW1cIixcbiAgICBcInN5c3RlbUNvZGVcIixcbiAgICBcInN5c3RlbUlkXCIsXG4gICAgXCJzeXN0ZW1MYW5ndWFnZVwiLFxuICAgIFwic3lzdGVtWERQSVwiLFxuICAgIFwic3lzdGVtWURQSVwiLFxuICAgIFwidEJvZGllc1wiLFxuICAgIFwidEZvb3RcIixcbiAgICBcInRIZWFkXCIsXG4gICAgXCJ0YWJJbmRleFwiLFxuICAgIFwidGFibGVcIixcbiAgICBcInRhYmxlLWxheW91dFwiLFxuICAgIFwidGFibGVMYXlvdXRcIixcbiAgICBcInRhYmxlVmFsdWVzXCIsXG4gICAgXCJ0YWdcIixcbiAgICBcInRhZ05hbWVcIixcbiAgICBcInRhZ1VyblwiLFxuICAgIFwidGFnc1wiLFxuICAgIFwidGFpbnRFbmFibGVkXCIsXG4gICAgXCJ0YWtlUGhvdG9cIixcbiAgICBcInRha2VSZWNvcmRzXCIsXG4gICAgXCJ0YW5cIixcbiAgICBcInRhbmdlbnRpYWxQcmVzc3VyZVwiLFxuICAgIFwidGFuaFwiLFxuICAgIFwidGFyZ2V0XCIsXG4gICAgXCJ0YXJnZXRFbGVtZW50XCIsXG4gICAgXCJ0YXJnZXRSYXlNb2RlXCIsXG4gICAgXCJ0YXJnZXRSYXlTcGFjZVwiLFxuICAgIFwidGFyZ2V0VG91Y2hlc1wiLFxuICAgIFwidGFyZ2V0WFwiLFxuICAgIFwidGFyZ2V0WVwiLFxuICAgIFwidGNwVHlwZVwiLFxuICAgIFwidGVlXCIsXG4gICAgXCJ0ZWxcIixcbiAgICBcInRlcm1pbmF0ZVwiLFxuICAgIFwidGVzdFwiLFxuICAgIFwidGV4SW1hZ2UyRFwiLFxuICAgIFwidGV4SW1hZ2UzRFwiLFxuICAgIFwidGV4UGFyYW1ldGVyZlwiLFxuICAgIFwidGV4UGFyYW1ldGVyaVwiLFxuICAgIFwidGV4U3RvcmFnZTJEXCIsXG4gICAgXCJ0ZXhTdG9yYWdlM0RcIixcbiAgICBcInRleFN1YkltYWdlMkRcIixcbiAgICBcInRleFN1YkltYWdlM0RcIixcbiAgICBcInRleHRcIixcbiAgICBcInRleHQtYWxpZ25cIixcbiAgICBcInRleHQtYWxpZ24tbGFzdFwiLFxuICAgIFwidGV4dC1hbmNob3JcIixcbiAgICBcInRleHQtY29tYmluZS11cHJpZ2h0XCIsXG4gICAgXCJ0ZXh0LWRlY29yYXRpb25cIixcbiAgICBcInRleHQtZGVjb3JhdGlvbi1jb2xvclwiLFxuICAgIFwidGV4dC1kZWNvcmF0aW9uLWxpbmVcIixcbiAgICBcInRleHQtZGVjb3JhdGlvbi1za2lwLWlua1wiLFxuICAgIFwidGV4dC1kZWNvcmF0aW9uLXN0eWxlXCIsXG4gICAgXCJ0ZXh0LWRlY29yYXRpb24tdGhpY2tuZXNzXCIsXG4gICAgXCJ0ZXh0LWVtcGhhc2lzXCIsXG4gICAgXCJ0ZXh0LWVtcGhhc2lzLWNvbG9yXCIsXG4gICAgXCJ0ZXh0LWVtcGhhc2lzLXBvc2l0aW9uXCIsXG4gICAgXCJ0ZXh0LWVtcGhhc2lzLXN0eWxlXCIsXG4gICAgXCJ0ZXh0LWluZGVudFwiLFxuICAgIFwidGV4dC1qdXN0aWZ5XCIsXG4gICAgXCJ0ZXh0LW9yaWVudGF0aW9uXCIsXG4gICAgXCJ0ZXh0LW92ZXJmbG93XCIsXG4gICAgXCJ0ZXh0LXJlbmRlcmluZ1wiLFxuICAgIFwidGV4dC1zaGFkb3dcIixcbiAgICBcInRleHQtdHJhbnNmb3JtXCIsXG4gICAgXCJ0ZXh0LXVuZGVybGluZS1vZmZzZXRcIixcbiAgICBcInRleHQtdW5kZXJsaW5lLXBvc2l0aW9uXCIsXG4gICAgXCJ0ZXh0QWxpZ25cIixcbiAgICBcInRleHRBbGlnbkxhc3RcIixcbiAgICBcInRleHRBbmNob3JcIixcbiAgICBcInRleHRBdXRvc3BhY2VcIixcbiAgICBcInRleHRCYXNlbGluZVwiLFxuICAgIFwidGV4dENvbWJpbmVVcHJpZ2h0XCIsXG4gICAgXCJ0ZXh0Q29udGVudFwiLFxuICAgIFwidGV4dERlY29yYXRpb25cIixcbiAgICBcInRleHREZWNvcmF0aW9uQmxpbmtcIixcbiAgICBcInRleHREZWNvcmF0aW9uQ29sb3JcIixcbiAgICBcInRleHREZWNvcmF0aW9uTGluZVwiLFxuICAgIFwidGV4dERlY29yYXRpb25MaW5lVGhyb3VnaFwiLFxuICAgIFwidGV4dERlY29yYXRpb25Ob25lXCIsXG4gICAgXCJ0ZXh0RGVjb3JhdGlvbk92ZXJsaW5lXCIsXG4gICAgXCJ0ZXh0RGVjb3JhdGlvblNraXBJbmtcIixcbiAgICBcInRleHREZWNvcmF0aW9uU3R5bGVcIixcbiAgICBcInRleHREZWNvcmF0aW9uVGhpY2tuZXNzXCIsXG4gICAgXCJ0ZXh0RGVjb3JhdGlvblVuZGVybGluZVwiLFxuICAgIFwidGV4dEVtcGhhc2lzXCIsXG4gICAgXCJ0ZXh0RW1waGFzaXNDb2xvclwiLFxuICAgIFwidGV4dEVtcGhhc2lzUG9zaXRpb25cIixcbiAgICBcInRleHRFbXBoYXNpc1N0eWxlXCIsXG4gICAgXCJ0ZXh0SW5kZW50XCIsXG4gICAgXCJ0ZXh0SnVzdGlmeVwiLFxuICAgIFwidGV4dEp1c3RpZnlUcmltXCIsXG4gICAgXCJ0ZXh0S2FzaGlkYVwiLFxuICAgIFwidGV4dEthc2hpZGFTcGFjZVwiLFxuICAgIFwidGV4dExlbmd0aFwiLFxuICAgIFwidGV4dE9yaWVudGF0aW9uXCIsXG4gICAgXCJ0ZXh0T3ZlcmZsb3dcIixcbiAgICBcInRleHRSZW5kZXJpbmdcIixcbiAgICBcInRleHRTaGFkb3dcIixcbiAgICBcInRleHRUcmFja3NcIixcbiAgICBcInRleHRUcmFuc2Zvcm1cIixcbiAgICBcInRleHRVbmRlcmxpbmVPZmZzZXRcIixcbiAgICBcInRleHRVbmRlcmxpbmVQb3NpdGlvblwiLFxuICAgIFwidGhlblwiLFxuICAgIFwidGhyZWFkSWRcIixcbiAgICBcInRocmVzaG9sZFwiLFxuICAgIFwidGhyZXNob2xkc1wiLFxuICAgIFwidGlsdFhcIixcbiAgICBcInRpbHRZXCIsXG4gICAgXCJ0aW1lXCIsXG4gICAgXCJ0aW1lRW5kXCIsXG4gICAgXCJ0aW1lTG9nXCIsXG4gICAgXCJ0aW1lT3JpZ2luXCIsXG4gICAgXCJ0aW1lUmVtYWluaW5nXCIsXG4gICAgXCJ0aW1lU3RhbXBcIixcbiAgICBcInRpbWVjb2RlXCIsXG4gICAgXCJ0aW1lbGluZVwiLFxuICAgIFwidGltZWxpbmVUaW1lXCIsXG4gICAgXCJ0aW1lb3V0XCIsXG4gICAgXCJ0aW1lc3RhbXBcIixcbiAgICBcInRpbWVzdGFtcE9mZnNldFwiLFxuICAgIFwidGltaW5nXCIsXG4gICAgXCJ0aXRsZVwiLFxuICAgIFwidG9cIixcbiAgICBcInRvQXJyYXlcIixcbiAgICBcInRvQmxvYlwiLFxuICAgIFwidG9EYXRhVVJMXCIsXG4gICAgXCJ0b0RhdGVTdHJpbmdcIixcbiAgICBcInRvRWxlbWVudFwiLFxuICAgIFwidG9FeHBvbmVudGlhbFwiLFxuICAgIFwidG9GaXhlZFwiLFxuICAgIFwidG9GbG9hdDMyQXJyYXlcIixcbiAgICBcInRvRmxvYXQ2NEFycmF5XCIsXG4gICAgXCJ0b0dNVFN0cmluZ1wiLFxuICAgIFwidG9JU09TdHJpbmdcIixcbiAgICBcInRvSlNPTlwiLFxuICAgIFwidG9Mb2NhbGVEYXRlU3RyaW5nXCIsXG4gICAgXCJ0b0xvY2FsZUZvcm1hdFwiLFxuICAgIFwidG9Mb2NhbGVMb3dlckNhc2VcIixcbiAgICBcInRvTG9jYWxlU3RyaW5nXCIsXG4gICAgXCJ0b0xvY2FsZVRpbWVTdHJpbmdcIixcbiAgICBcInRvTG9jYWxlVXBwZXJDYXNlXCIsXG4gICAgXCJ0b0xvd2VyQ2FzZVwiLFxuICAgIFwidG9NYXRyaXhcIixcbiAgICBcInRvTWV0aG9kXCIsXG4gICAgXCJ0b1ByZWNpc2lvblwiLFxuICAgIFwidG9QcmltaXRpdmVcIixcbiAgICBcInRvU2RwXCIsXG4gICAgXCJ0b1NvdXJjZVwiLFxuICAgIFwidG9TdGF0aWNIVE1MXCIsXG4gICAgXCJ0b1N0cmluZ1wiLFxuICAgIFwidG9TdHJpbmdUYWdcIixcbiAgICBcInRvU3VtXCIsXG4gICAgXCJ0b1RpbWVTdHJpbmdcIixcbiAgICBcInRvVVRDU3RyaW5nXCIsXG4gICAgXCJ0b1VwcGVyQ2FzZVwiLFxuICAgIFwidG9nZ2xlXCIsXG4gICAgXCJ0b2dnbGVBdHRyaWJ1dGVcIixcbiAgICBcInRvZ2dsZUxvbmdQcmVzc0VuYWJsZWRcIixcbiAgICBcInRvbmVcIixcbiAgICBcInRvbmVCdWZmZXJcIixcbiAgICBcInRvb0xvbmdcIixcbiAgICBcInRvb1Nob3J0XCIsXG4gICAgXCJ0b29sYmFyXCIsXG4gICAgXCJ0b3BcIixcbiAgICBcInRvcE1hcmdpblwiLFxuICAgIFwidG90YWxcIixcbiAgICBcInRvdGFsRnJhbWVEZWxheVwiLFxuICAgIFwidG90YWxWaWRlb0ZyYW1lc1wiLFxuICAgIFwidG91Y2gtYWN0aW9uXCIsXG4gICAgXCJ0b3VjaEFjdGlvblwiLFxuICAgIFwidG91Y2hlZFwiLFxuICAgIFwidG91Y2hlc1wiLFxuICAgIFwidHJhY2VcIixcbiAgICBcInRyYWNrXCIsXG4gICAgXCJ0cmFja1Zpc2liaWxpdHlcIixcbiAgICBcInRyYW5zYWN0aW9uXCIsXG4gICAgXCJ0cmFuc2FjdGlvbnNcIixcbiAgICBcInRyYW5zY2VpdmVyXCIsXG4gICAgXCJ0cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlblwiLFxuICAgIFwidHJhbnNmZXJGcm9tSW1hZ2VCaXRtYXBcIixcbiAgICBcInRyYW5zZmVySW1hZ2VCaXRtYXBcIixcbiAgICBcInRyYW5zZmVySW5cIixcbiAgICBcInRyYW5zZmVyT3V0XCIsXG4gICAgXCJ0cmFuc2ZlclNpemVcIixcbiAgICBcInRyYW5zZmVyVG9JbWFnZUJpdG1hcFwiLFxuICAgIFwidHJhbnNmb3JtXCIsXG4gICAgXCJ0cmFuc2Zvcm0tYm94XCIsXG4gICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCIsXG4gICAgXCJ0cmFuc2Zvcm0tc3R5bGVcIixcbiAgICBcInRyYW5zZm9ybUJveFwiLFxuICAgIFwidHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5nc1wiLFxuICAgIFwidHJhbnNmb3JtT3JpZ2luXCIsXG4gICAgXCJ0cmFuc2Zvcm1Qb2ludFwiLFxuICAgIFwidHJhbnNmb3JtU3RyaW5nXCIsXG4gICAgXCJ0cmFuc2Zvcm1TdHlsZVwiLFxuICAgIFwidHJhbnNmb3JtVG9Eb2N1bWVudFwiLFxuICAgIFwidHJhbnNmb3JtVG9GcmFnbWVudFwiLFxuICAgIFwidHJhbnNpdGlvblwiLFxuICAgIFwidHJhbnNpdGlvbi1kZWxheVwiLFxuICAgIFwidHJhbnNpdGlvbi1kdXJhdGlvblwiLFxuICAgIFwidHJhbnNpdGlvbi1wcm9wZXJ0eVwiLFxuICAgIFwidHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb25cIixcbiAgICBcInRyYW5zaXRpb25EZWxheVwiLFxuICAgIFwidHJhbnNpdGlvbkR1cmF0aW9uXCIsXG4gICAgXCJ0cmFuc2l0aW9uUHJvcGVydHlcIixcbiAgICBcInRyYW5zaXRpb25UaW1pbmdGdW5jdGlvblwiLFxuICAgIFwidHJhbnNsYXRlXCIsXG4gICAgXCJ0cmFuc2xhdGVTZWxmXCIsXG4gICAgXCJ0cmFuc2xhdGlvblhcIixcbiAgICBcInRyYW5zbGF0aW9uWVwiLFxuICAgIFwidHJhbnNwb3J0XCIsXG4gICAgXCJ0cmltXCIsXG4gICAgXCJ0cmltRW5kXCIsXG4gICAgXCJ0cmltTGVmdFwiLFxuICAgIFwidHJpbVJpZ2h0XCIsXG4gICAgXCJ0cmltU3RhcnRcIixcbiAgICBcInRydWVTcGVlZFwiLFxuICAgIFwidHJ1bmNcIixcbiAgICBcInRydW5jYXRlXCIsXG4gICAgXCJ0cnVzdGVkVHlwZXNcIixcbiAgICBcInR1cm5cIixcbiAgICBcInR3aXN0XCIsXG4gICAgXCJ0eXBlXCIsXG4gICAgXCJ0eXBlRGV0YWlsXCIsXG4gICAgXCJ0eXBlTWlzbWF0Y2hcIixcbiAgICBcInR5cGVNdXN0TWF0Y2hcIixcbiAgICBcInR5cGVzXCIsXG4gICAgXCJ1MmZcIixcbiAgICBcInVib3VuZFwiLFxuICAgIFwidWludDE2XCIsXG4gICAgXCJ1aW50MzJcIixcbiAgICBcInVpbnQ4XCIsXG4gICAgXCJ1aW50OENsYW1wZWRcIixcbiAgICBcInVuZGVmaW5lZFwiLFxuICAgIFwidW5lc2NhcGVcIixcbiAgICBcInVuZXZhbFwiLFxuICAgIFwidW5pY29kZVwiLFxuICAgIFwidW5pY29kZS1iaWRpXCIsXG4gICAgXCJ1bmljb2RlQmlkaVwiLFxuICAgIFwidW5pY29kZVJhbmdlXCIsXG4gICAgXCJ1bmlmb3JtMWZcIixcbiAgICBcInVuaWZvcm0xZnZcIixcbiAgICBcInVuaWZvcm0xaVwiLFxuICAgIFwidW5pZm9ybTFpdlwiLFxuICAgIFwidW5pZm9ybTF1aVwiLFxuICAgIFwidW5pZm9ybTF1aXZcIixcbiAgICBcInVuaWZvcm0yZlwiLFxuICAgIFwidW5pZm9ybTJmdlwiLFxuICAgIFwidW5pZm9ybTJpXCIsXG4gICAgXCJ1bmlmb3JtMml2XCIsXG4gICAgXCJ1bmlmb3JtMnVpXCIsXG4gICAgXCJ1bmlmb3JtMnVpdlwiLFxuICAgIFwidW5pZm9ybTNmXCIsXG4gICAgXCJ1bmlmb3JtM2Z2XCIsXG4gICAgXCJ1bmlmb3JtM2lcIixcbiAgICBcInVuaWZvcm0zaXZcIixcbiAgICBcInVuaWZvcm0zdWlcIixcbiAgICBcInVuaWZvcm0zdWl2XCIsXG4gICAgXCJ1bmlmb3JtNGZcIixcbiAgICBcInVuaWZvcm00ZnZcIixcbiAgICBcInVuaWZvcm00aVwiLFxuICAgIFwidW5pZm9ybTRpdlwiLFxuICAgIFwidW5pZm9ybTR1aVwiLFxuICAgIFwidW5pZm9ybTR1aXZcIixcbiAgICBcInVuaWZvcm1CbG9ja0JpbmRpbmdcIixcbiAgICBcInVuaWZvcm1NYXRyaXgyZnZcIixcbiAgICBcInVuaWZvcm1NYXRyaXgyeDNmdlwiLFxuICAgIFwidW5pZm9ybU1hdHJpeDJ4NGZ2XCIsXG4gICAgXCJ1bmlmb3JtTWF0cml4M2Z2XCIsXG4gICAgXCJ1bmlmb3JtTWF0cml4M3gyZnZcIixcbiAgICBcInVuaWZvcm1NYXRyaXgzeDRmdlwiLFxuICAgIFwidW5pZm9ybU1hdHJpeDRmdlwiLFxuICAgIFwidW5pZm9ybU1hdHJpeDR4MmZ2XCIsXG4gICAgXCJ1bmlmb3JtTWF0cml4NHgzZnZcIixcbiAgICBcInVuaXF1ZVwiLFxuICAgIFwidW5pcXVlSURcIixcbiAgICBcInVuaXF1ZU51bWJlclwiLFxuICAgIFwidW5pdFwiLFxuICAgIFwidW5pdFR5cGVcIixcbiAgICBcInVuaXRzXCIsXG4gICAgXCJ1bmxvYWRFdmVudEVuZFwiLFxuICAgIFwidW5sb2FkRXZlbnRTdGFydFwiLFxuICAgIFwidW5sb2NrXCIsXG4gICAgXCJ1bm1vdW50XCIsXG4gICAgXCJ1bm9ic2VydmVcIixcbiAgICBcInVucGF1c2VcIixcbiAgICBcInVucGF1c2VBbmltYXRpb25zXCIsXG4gICAgXCJ1bnJlYWRDb3VudFwiLFxuICAgIFwidW5yZWdpc3RlclwiLFxuICAgIFwidW5yZWdpc3RlckNvbnRlbnRIYW5kbGVyXCIsXG4gICAgXCJ1bnJlZ2lzdGVyUHJvdG9jb2xIYW5kbGVyXCIsXG4gICAgXCJ1bnNjb3BhYmxlc1wiLFxuICAgIFwidW5zZWxlY3RhYmxlXCIsXG4gICAgXCJ1bnNoaWZ0XCIsXG4gICAgXCJ1bnN1YnNjcmliZVwiLFxuICAgIFwidW5zdXNwZW5kUmVkcmF3XCIsXG4gICAgXCJ1bnN1c3BlbmRSZWRyYXdBbGxcIixcbiAgICBcInVud2F0Y2hcIixcbiAgICBcInVud3JhcEtleVwiLFxuICAgIFwidXBEZWdyZWVzXCIsXG4gICAgXCJ1cFhcIixcbiAgICBcInVwWVwiLFxuICAgIFwidXBaXCIsXG4gICAgXCJ1cGRhdGVcIixcbiAgICBcInVwZGF0ZUNvbW1hbmRzXCIsXG4gICAgXCJ1cGRhdGVJY2VcIixcbiAgICBcInVwZGF0ZUludGVydmFsXCIsXG4gICAgXCJ1cGRhdGVQbGF5YmFja1JhdGVcIixcbiAgICBcInVwZGF0ZVJlbmRlclN0YXRlXCIsXG4gICAgXCJ1cGRhdGVTZXR0aW5nc1wiLFxuICAgIFwidXBkYXRlVGltaW5nXCIsXG4gICAgXCJ1cGRhdGVWaWFDYWNoZVwiLFxuICAgIFwidXBkYXRlV2l0aFwiLFxuICAgIFwidXBkYXRlZFwiLFxuICAgIFwidXBkYXRpbmdcIixcbiAgICBcInVwZ3JhZGVcIixcbiAgICBcInVwbG9hZFwiLFxuICAgIFwidXBsb2FkVG90YWxcIixcbiAgICBcInVwbG9hZGVkXCIsXG4gICAgXCJ1cHBlclwiLFxuICAgIFwidXBwZXJCb3VuZFwiLFxuICAgIFwidXBwZXJPcGVuXCIsXG4gICAgXCJ1cmlcIixcbiAgICBcInVybFwiLFxuICAgIFwidXJuXCIsXG4gICAgXCJ1cm5zXCIsXG4gICAgXCJ1c2FnZXNcIixcbiAgICBcInVzYlwiLFxuICAgIFwidXNiVmVyc2lvbk1ham9yXCIsXG4gICAgXCJ1c2JWZXJzaW9uTWlub3JcIixcbiAgICBcInVzYlZlcnNpb25TdWJtaW5vclwiLFxuICAgIFwidXNlQ3VycmVudFZpZXdcIixcbiAgICBcInVzZU1hcFwiLFxuICAgIFwidXNlUHJvZ3JhbVwiLFxuICAgIFwidXNlZFNwYWNlXCIsXG4gICAgXCJ1c2VyLXNlbGVjdFwiLFxuICAgIFwidXNlckFjdGl2YXRpb25cIixcbiAgICBcInVzZXJBZ2VudFwiLFxuICAgIFwidXNlckNob2ljZVwiLFxuICAgIFwidXNlckhhbmRsZVwiLFxuICAgIFwidXNlckhpbnRcIixcbiAgICBcInVzZXJMYW5ndWFnZVwiLFxuICAgIFwidXNlclNlbGVjdFwiLFxuICAgIFwidXNlclZpc2libGVPbmx5XCIsXG4gICAgXCJ1c2VybmFtZVwiLFxuICAgIFwidXNlcm5hbWVGcmFnbWVudFwiLFxuICAgIFwidXR0ZXJhbmNlXCIsXG4gICAgXCJ1dWlkXCIsXG4gICAgXCJ2OEJyZWFrSXRlcmF0b3JcIixcbiAgICBcInZBbGlnblwiLFxuICAgIFwidkxpbmtcIixcbiAgICBcInZhbGlkXCIsXG4gICAgXCJ2YWxpZGF0ZVwiLFxuICAgIFwidmFsaWRhdGVQcm9ncmFtXCIsXG4gICAgXCJ2YWxpZGF0aW9uTWVzc2FnZVwiLFxuICAgIFwidmFsaWRpdHlcIixcbiAgICBcInZhbHVlXCIsXG4gICAgXCJ2YWx1ZUFzRGF0ZVwiLFxuICAgIFwidmFsdWVBc051bWJlclwiLFxuICAgIFwidmFsdWVBc1N0cmluZ1wiLFxuICAgIFwidmFsdWVJblNwZWNpZmllZFVuaXRzXCIsXG4gICAgXCJ2YWx1ZU1pc3NpbmdcIixcbiAgICBcInZhbHVlT2ZcIixcbiAgICBcInZhbHVlVGV4dFwiLFxuICAgIFwidmFsdWVUeXBlXCIsXG4gICAgXCJ2YWx1ZXNcIixcbiAgICBcInZhcmlhYmxlXCIsXG4gICAgXCJ2YXJpYW50XCIsXG4gICAgXCJ2YXJpYXRpb25TZXR0aW5nc1wiLFxuICAgIFwidmVjdG9yLWVmZmVjdFwiLFxuICAgIFwidmVjdG9yRWZmZWN0XCIsXG4gICAgXCJ2ZWxvY2l0eUFuZ3VsYXJcIixcbiAgICBcInZlbG9jaXR5RXhwYW5zaW9uXCIsXG4gICAgXCJ2ZWxvY2l0eVhcIixcbiAgICBcInZlbG9jaXR5WVwiLFxuICAgIFwidmVuZG9yXCIsXG4gICAgXCJ2ZW5kb3JJZFwiLFxuICAgIFwidmVuZG9yU3ViXCIsXG4gICAgXCJ2ZXJpZnlcIixcbiAgICBcInZlcnNpb25cIixcbiAgICBcInZlcnRleEF0dHJpYjFmXCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWIxZnZcIixcbiAgICBcInZlcnRleEF0dHJpYjJmXCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWIyZnZcIixcbiAgICBcInZlcnRleEF0dHJpYjNmXCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWIzZnZcIixcbiAgICBcInZlcnRleEF0dHJpYjRmXCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWI0ZnZcIixcbiAgICBcInZlcnRleEF0dHJpYkRpdmlzb3JcIixcbiAgICBcInZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRVwiLFxuICAgIFwidmVydGV4QXR0cmliSTRpXCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWJJNGl2XCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWJJNHVpXCIsXG4gICAgXCJ2ZXJ0ZXhBdHRyaWJJNHVpdlwiLFxuICAgIFwidmVydGV4QXR0cmliSVBvaW50ZXJcIixcbiAgICBcInZlcnRleEF0dHJpYlBvaW50ZXJcIixcbiAgICBcInZlcnRpY2FsXCIsXG4gICAgXCJ2ZXJ0aWNhbC1hbGlnblwiLFxuICAgIFwidmVydGljYWxBbGlnblwiLFxuICAgIFwidmVydGljYWxPdmVyZmxvd1wiLFxuICAgIFwidmhcIixcbiAgICBcInZpYnJhdGVcIixcbiAgICBcInZpYnJhdGlvbkFjdHVhdG9yXCIsXG4gICAgXCJ2aWRlb0JpdHNQZXJTZWNvbmRcIixcbiAgICBcInZpZGVvSGVpZ2h0XCIsXG4gICAgXCJ2aWRlb1RyYWNrc1wiLFxuICAgIFwidmlkZW9XaWR0aFwiLFxuICAgIFwidmlld1wiLFxuICAgIFwidmlld0JveFwiLFxuICAgIFwidmlld0JveFN0cmluZ1wiLFxuICAgIFwidmlld1RhcmdldFwiLFxuICAgIFwidmlld1RhcmdldFN0cmluZ1wiLFxuICAgIFwidmlld3BvcnRcIixcbiAgICBcInZpZXdwb3J0QW5jaG9yWFwiLFxuICAgIFwidmlld3BvcnRBbmNob3JZXCIsXG4gICAgXCJ2aWV3cG9ydEVsZW1lbnRcIixcbiAgICBcInZpZXdzXCIsXG4gICAgXCJ2aW9sYXRlZERpcmVjdGl2ZVwiLFxuICAgIFwidmlzaWJpbGl0eVwiLFxuICAgIFwidmlzaWJpbGl0eVN0YXRlXCIsXG4gICAgXCJ2aXNpYmxlXCIsXG4gICAgXCJ2aXN1YWxWaWV3cG9ydFwiLFxuICAgIFwidmxpbmtDb2xvclwiLFxuICAgIFwidm1heFwiLFxuICAgIFwidm1pblwiLFxuICAgIFwidm9pY2VcIixcbiAgICBcInZvaWNlVVJJXCIsXG4gICAgXCJ2b2x1bWVcIixcbiAgICBcInZybWxcIixcbiAgICBcInZzcGFjZVwiLFxuICAgIFwidndcIixcbiAgICBcIndcIixcbiAgICBcIndhaXRcIixcbiAgICBcIndhaXRTeW5jXCIsXG4gICAgXCJ3YWl0aW5nXCIsXG4gICAgXCJ3YWtlXCIsXG4gICAgXCJ3YWtlTG9ja1wiLFxuICAgIFwid2FuZFwiLFxuICAgIFwid2FyblwiLFxuICAgIFwid2FzQ2xlYW5cIixcbiAgICBcIndhc0Rpc2NhcmRlZFwiLFxuICAgIFwid2F0Y2hcIixcbiAgICBcIndhdGNoQXZhaWxhYmlsaXR5XCIsXG4gICAgXCJ3YXRjaFBvc2l0aW9uXCIsXG4gICAgXCJ3ZWJkcml2ZXJcIixcbiAgICBcIndlYmtpdEFkZEtleVwiLFxuICAgIFwid2Via2l0QWxpZ25Db250ZW50XCIsXG4gICAgXCJ3ZWJraXRBbGlnbkl0ZW1zXCIsXG4gICAgXCJ3ZWJraXRBbGlnblNlbGZcIixcbiAgICBcIndlYmtpdEFuaW1hdGlvblwiLFxuICAgIFwid2Via2l0QW5pbWF0aW9uRGVsYXlcIixcbiAgICBcIndlYmtpdEFuaW1hdGlvbkRpcmVjdGlvblwiLFxuICAgIFwid2Via2l0QW5pbWF0aW9uRHVyYXRpb25cIixcbiAgICBcIndlYmtpdEFuaW1hdGlvbkZpbGxNb2RlXCIsXG4gICAgXCJ3ZWJraXRBbmltYXRpb25JdGVyYXRpb25Db3VudFwiLFxuICAgIFwid2Via2l0QW5pbWF0aW9uTmFtZVwiLFxuICAgIFwid2Via2l0QW5pbWF0aW9uUGxheVN0YXRlXCIsXG4gICAgXCJ3ZWJraXRBbmltYXRpb25UaW1pbmdGdW5jdGlvblwiLFxuICAgIFwid2Via2l0QXBwZWFyYW5jZVwiLFxuICAgIFwid2Via2l0QXVkaW9Db250ZXh0XCIsXG4gICAgXCJ3ZWJraXRBdWRpb0RlY29kZWRCeXRlQ291bnRcIixcbiAgICBcIndlYmtpdEF1ZGlvUGFubmVyTm9kZVwiLFxuICAgIFwid2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5XCIsXG4gICAgXCJ3ZWJraXRCYWNrZ3JvdW5kXCIsXG4gICAgXCJ3ZWJraXRCYWNrZ3JvdW5kQXR0YWNobWVudFwiLFxuICAgIFwid2Via2l0QmFja2dyb3VuZENsaXBcIixcbiAgICBcIndlYmtpdEJhY2tncm91bmRDb2xvclwiLFxuICAgIFwid2Via2l0QmFja2dyb3VuZEltYWdlXCIsXG4gICAgXCJ3ZWJraXRCYWNrZ3JvdW5kT3JpZ2luXCIsXG4gICAgXCJ3ZWJraXRCYWNrZ3JvdW5kUG9zaXRpb25cIixcbiAgICBcIndlYmtpdEJhY2tncm91bmRQb3NpdGlvblhcIixcbiAgICBcIndlYmtpdEJhY2tncm91bmRQb3NpdGlvbllcIixcbiAgICBcIndlYmtpdEJhY2tncm91bmRSZXBlYXRcIixcbiAgICBcIndlYmtpdEJhY2tncm91bmRTaXplXCIsXG4gICAgXCJ3ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvXCIsXG4gICAgXCJ3ZWJraXRCb3JkZXJCb3R0b21MZWZ0UmFkaXVzXCIsXG4gICAgXCJ3ZWJraXRCb3JkZXJCb3R0b21SaWdodFJhZGl1c1wiLFxuICAgIFwid2Via2l0Qm9yZGVySW1hZ2VcIixcbiAgICBcIndlYmtpdEJvcmRlckltYWdlT3V0c2V0XCIsXG4gICAgXCJ3ZWJraXRCb3JkZXJJbWFnZVJlcGVhdFwiLFxuICAgIFwid2Via2l0Qm9yZGVySW1hZ2VTbGljZVwiLFxuICAgIFwid2Via2l0Qm9yZGVySW1hZ2VTb3VyY2VcIixcbiAgICBcIndlYmtpdEJvcmRlckltYWdlV2lkdGhcIixcbiAgICBcIndlYmtpdEJvcmRlclJhZGl1c1wiLFxuICAgIFwid2Via2l0Qm9yZGVyVG9wTGVmdFJhZGl1c1wiLFxuICAgIFwid2Via2l0Qm9yZGVyVG9wUmlnaHRSYWRpdXNcIixcbiAgICBcIndlYmtpdEJveEFsaWduXCIsXG4gICAgXCJ3ZWJraXRCb3hEaXJlY3Rpb25cIixcbiAgICBcIndlYmtpdEJveEZsZXhcIixcbiAgICBcIndlYmtpdEJveE9yZGluYWxHcm91cFwiLFxuICAgIFwid2Via2l0Qm94T3JpZW50XCIsXG4gICAgXCJ3ZWJraXRCb3hQYWNrXCIsXG4gICAgXCJ3ZWJraXRCb3hTaGFkb3dcIixcbiAgICBcIndlYmtpdEJveFNpemluZ1wiLFxuICAgIFwid2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWVcIixcbiAgICBcIndlYmtpdENhbmNlbEZ1bGxTY3JlZW5cIixcbiAgICBcIndlYmtpdENhbmNlbEtleVJlcXVlc3RcIixcbiAgICBcIndlYmtpdENhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVwiLFxuICAgIFwid2Via2l0Q2xlYXJSZXNvdXJjZVRpbWluZ3NcIixcbiAgICBcIndlYmtpdENsb3NlZENhcHRpb25zVmlzaWJsZVwiLFxuICAgIFwid2Via2l0Q29udmVydFBvaW50RnJvbU5vZGVUb1BhZ2VcIixcbiAgICBcIndlYmtpdENvbnZlcnRQb2ludEZyb21QYWdlVG9Ob2RlXCIsXG4gICAgXCJ3ZWJraXRDcmVhdGVTaGFkb3dSb290XCIsXG4gICAgXCJ3ZWJraXRDdXJyZW50RnVsbFNjcmVlbkVsZW1lbnRcIixcbiAgICBcIndlYmtpdEN1cnJlbnRQbGF5YmFja1RhcmdldElzV2lyZWxlc3NcIixcbiAgICBcIndlYmtpdERlY29kZWRGcmFtZUNvdW50XCIsXG4gICAgXCJ3ZWJraXREaXJlY3Rpb25JbnZlcnRlZEZyb21EZXZpY2VcIixcbiAgICBcIndlYmtpdERpc3BsYXlpbmdGdWxsc2NyZWVuXCIsXG4gICAgXCJ3ZWJraXREcm9wcGVkRnJhbWVDb3VudFwiLFxuICAgIFwid2Via2l0RW50ZXJGdWxsU2NyZWVuXCIsXG4gICAgXCJ3ZWJraXRFbnRlckZ1bGxzY3JlZW5cIixcbiAgICBcIndlYmtpdEVudHJpZXNcIixcbiAgICBcIndlYmtpdEV4aXRGdWxsU2NyZWVuXCIsXG4gICAgXCJ3ZWJraXRFeGl0RnVsbHNjcmVlblwiLFxuICAgIFwid2Via2l0RXhpdFBvaW50ZXJMb2NrXCIsXG4gICAgXCJ3ZWJraXRGaWx0ZXJcIixcbiAgICBcIndlYmtpdEZsZXhcIixcbiAgICBcIndlYmtpdEZsZXhCYXNpc1wiLFxuICAgIFwid2Via2l0RmxleERpcmVjdGlvblwiLFxuICAgIFwid2Via2l0RmxleEZsb3dcIixcbiAgICBcIndlYmtpdEZsZXhHcm93XCIsXG4gICAgXCJ3ZWJraXRGbGV4U2hyaW5rXCIsXG4gICAgXCJ3ZWJraXRGbGV4V3JhcFwiLFxuICAgIFwid2Via2l0RnVsbFNjcmVlbktleWJvYXJkSW5wdXRBbGxvd2VkXCIsXG4gICAgXCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudFwiLFxuICAgIFwid2Via2l0RnVsbHNjcmVlbkVuYWJsZWRcIixcbiAgICBcIndlYmtpdEdlbmVyYXRlS2V5UmVxdWVzdFwiLFxuICAgIFwid2Via2l0R2V0QXNFbnRyeVwiLFxuICAgIFwid2Via2l0R2V0RGF0YWJhc2VOYW1lc1wiLFxuICAgIFwid2Via2l0R2V0RW50cmllc1wiLFxuICAgIFwid2Via2l0R2V0RW50cmllc0J5TmFtZVwiLFxuICAgIFwid2Via2l0R2V0RW50cmllc0J5VHlwZVwiLFxuICAgIFwid2Via2l0R2V0Rmxvd0J5TmFtZVwiLFxuICAgIFwid2Via2l0R2V0R2FtZXBhZHNcIixcbiAgICBcIndlYmtpdEdldEltYWdlRGF0YUhEXCIsXG4gICAgXCJ3ZWJraXRHZXROYW1lZEZsb3dzXCIsXG4gICAgXCJ3ZWJraXRHZXRSZWdpb25GbG93UmFuZ2VzXCIsXG4gICAgXCJ3ZWJraXRHZXRVc2VyTWVkaWFcIixcbiAgICBcIndlYmtpdEhhc0Nsb3NlZENhcHRpb25zXCIsXG4gICAgXCJ3ZWJraXRIaWRkZW5cIixcbiAgICBcIndlYmtpdElEQkN1cnNvclwiLFxuICAgIFwid2Via2l0SURCRGF0YWJhc2VcIixcbiAgICBcIndlYmtpdElEQkRhdGFiYXNlRXJyb3JcIixcbiAgICBcIndlYmtpdElEQkRhdGFiYXNlRXhjZXB0aW9uXCIsXG4gICAgXCJ3ZWJraXRJREJGYWN0b3J5XCIsXG4gICAgXCJ3ZWJraXRJREJJbmRleFwiLFxuICAgIFwid2Via2l0SURCS2V5UmFuZ2VcIixcbiAgICBcIndlYmtpdElEQk9iamVjdFN0b3JlXCIsXG4gICAgXCJ3ZWJraXRJREJSZXF1ZXN0XCIsXG4gICAgXCJ3ZWJraXRJREJUcmFuc2FjdGlvblwiLFxuICAgIFwid2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIsXG4gICAgXCJ3ZWJraXRJbmRleGVkREJcIixcbiAgICBcIndlYmtpdEluaXRNZXNzYWdlRXZlbnRcIixcbiAgICBcIndlYmtpdElzRnVsbFNjcmVlblwiLFxuICAgIFwid2Via2l0SnVzdGlmeUNvbnRlbnRcIixcbiAgICBcIndlYmtpdEtleXNcIixcbiAgICBcIndlYmtpdExpbmVDbGFtcFwiLFxuICAgIFwid2Via2l0TGluZURhc2hPZmZzZXRcIixcbiAgICBcIndlYmtpdExvY2tPcmllbnRhdGlvblwiLFxuICAgIFwid2Via2l0TWFza1wiLFxuICAgIFwid2Via2l0TWFza0NsaXBcIixcbiAgICBcIndlYmtpdE1hc2tDb21wb3NpdGVcIixcbiAgICBcIndlYmtpdE1hc2tJbWFnZVwiLFxuICAgIFwid2Via2l0TWFza09yaWdpblwiLFxuICAgIFwid2Via2l0TWFza1Bvc2l0aW9uXCIsXG4gICAgXCJ3ZWJraXRNYXNrUG9zaXRpb25YXCIsXG4gICAgXCJ3ZWJraXRNYXNrUG9zaXRpb25ZXCIsXG4gICAgXCJ3ZWJraXRNYXNrUmVwZWF0XCIsXG4gICAgXCJ3ZWJraXRNYXNrU2l6ZVwiLFxuICAgIFwid2Via2l0TWF0Y2hlc1NlbGVjdG9yXCIsXG4gICAgXCJ3ZWJraXRNZWRpYVN0cmVhbVwiLFxuICAgIFwid2Via2l0Tm90aWZpY2F0aW9uc1wiLFxuICAgIFwid2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dFwiLFxuICAgIFwid2Via2l0T3JkZXJcIixcbiAgICBcIndlYmtpdE9yaWVudGF0aW9uXCIsXG4gICAgXCJ3ZWJraXRQZWVyQ29ubmVjdGlvbjAwXCIsXG4gICAgXCJ3ZWJraXRQZXJzaXN0ZW50U3RvcmFnZVwiLFxuICAgIFwid2Via2l0UGVyc3BlY3RpdmVcIixcbiAgICBcIndlYmtpdFBlcnNwZWN0aXZlT3JpZ2luXCIsXG4gICAgXCJ3ZWJraXRQb2ludGVyTG9ja0VsZW1lbnRcIixcbiAgICBcIndlYmtpdFBvc3RNZXNzYWdlXCIsXG4gICAgXCJ3ZWJraXRQcmVzZXJ2ZXNQaXRjaFwiLFxuICAgIFwid2Via2l0UHV0SW1hZ2VEYXRhSERcIixcbiAgICBcIndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uXCIsXG4gICAgXCJ3ZWJraXRSZWdpb25PdmVyc2V0XCIsXG4gICAgXCJ3ZWJraXRSZWxhdGl2ZVBhdGhcIixcbiAgICBcIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZVwiLFxuICAgIFwid2Via2l0UmVxdWVzdEZpbGVTeXN0ZW1cIixcbiAgICBcIndlYmtpdFJlcXVlc3RGdWxsU2NyZWVuXCIsXG4gICAgXCJ3ZWJraXRSZXF1ZXN0RnVsbHNjcmVlblwiLFxuICAgIFwid2Via2l0UmVxdWVzdFBvaW50ZXJMb2NrXCIsXG4gICAgXCJ3ZWJraXRSZXNvbHZlTG9jYWxGaWxlU3lzdGVtVVJMXCIsXG4gICAgXCJ3ZWJraXRTZXRNZWRpYUtleXNcIixcbiAgICBcIndlYmtpdFNldFJlc291cmNlVGltaW5nQnVmZmVyU2l6ZVwiLFxuICAgIFwid2Via2l0U2hhZG93Um9vdFwiLFxuICAgIFwid2Via2l0U2hvd1BsYXliYWNrVGFyZ2V0UGlja2VyXCIsXG4gICAgXCJ3ZWJraXRTbGljZVwiLFxuICAgIFwid2Via2l0U3BlZWNoR3JhbW1hclwiLFxuICAgIFwid2Via2l0U3BlZWNoR3JhbW1hckxpc3RcIixcbiAgICBcIndlYmtpdFNwZWVjaFJlY29nbml0aW9uXCIsXG4gICAgXCJ3ZWJraXRTcGVlY2hSZWNvZ25pdGlvbkVycm9yXCIsXG4gICAgXCJ3ZWJraXRTcGVlY2hSZWNvZ25pdGlvbkV2ZW50XCIsXG4gICAgXCJ3ZWJraXRTdG9yYWdlSW5mb1wiLFxuICAgIFwid2Via2l0U3VwcG9ydHNGdWxsc2NyZWVuXCIsXG4gICAgXCJ3ZWJraXRUZW1wb3JhcnlTdG9yYWdlXCIsXG4gICAgXCJ3ZWJraXRUZXh0RmlsbENvbG9yXCIsXG4gICAgXCJ3ZWJraXRUZXh0U2l6ZUFkanVzdFwiLFxuICAgIFwid2Via2l0VGV4dFN0cm9rZVwiLFxuICAgIFwid2Via2l0VGV4dFN0cm9rZUNvbG9yXCIsXG4gICAgXCJ3ZWJraXRUZXh0U3Ryb2tlV2lkdGhcIixcbiAgICBcIndlYmtpdFRyYW5zZm9ybVwiLFxuICAgIFwid2Via2l0VHJhbnNmb3JtT3JpZ2luXCIsXG4gICAgXCJ3ZWJraXRUcmFuc2Zvcm1TdHlsZVwiLFxuICAgIFwid2Via2l0VHJhbnNpdGlvblwiLFxuICAgIFwid2Via2l0VHJhbnNpdGlvbkRlbGF5XCIsXG4gICAgXCJ3ZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cIixcbiAgICBcIndlYmtpdFRyYW5zaXRpb25Qcm9wZXJ0eVwiLFxuICAgIFwid2Via2l0VHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uXCIsXG4gICAgXCJ3ZWJraXRVUkxcIixcbiAgICBcIndlYmtpdFVubG9ja09yaWVudGF0aW9uXCIsXG4gICAgXCJ3ZWJraXRVc2VyU2VsZWN0XCIsXG4gICAgXCJ3ZWJraXRWaWRlb0RlY29kZWRCeXRlQ291bnRcIixcbiAgICBcIndlYmtpdFZpc2liaWxpdHlTdGF0ZVwiLFxuICAgIFwid2Via2l0V2lyZWxlc3NWaWRlb1BsYXliYWNrRGlzYWJsZWRcIixcbiAgICBcIndlYmtpdGRpcmVjdG9yeVwiLFxuICAgIFwid2Via2l0ZHJvcHpvbmVcIixcbiAgICBcIndlYnN0b3JlXCIsXG4gICAgXCJ3ZWlnaHRcIixcbiAgICBcIndoYXRUb1Nob3dcIixcbiAgICBcIndoZWVsRGVsdGFcIixcbiAgICBcIndoZWVsRGVsdGFYXCIsXG4gICAgXCJ3aGVlbERlbHRhWVwiLFxuICAgIFwid2hlbkRlZmluZWRcIixcbiAgICBcIndoaWNoXCIsXG4gICAgXCJ3aGl0ZS1zcGFjZVwiLFxuICAgIFwid2hpdGVTcGFjZVwiLFxuICAgIFwid2hvbGVUZXh0XCIsXG4gICAgXCJ3aWRvd3NcIixcbiAgICBcIndpZHRoXCIsXG4gICAgXCJ3aWxsLWNoYW5nZVwiLFxuICAgIFwid2lsbENoYW5nZVwiLFxuICAgIFwid2lsbFZhbGlkYXRlXCIsXG4gICAgXCJ3aW5kb3dcIixcbiAgICBcIndpdGhDcmVkZW50aWFsc1wiLFxuICAgIFwid29yZC1icmVha1wiLFxuICAgIFwid29yZC1zcGFjaW5nXCIsXG4gICAgXCJ3b3JkLXdyYXBcIixcbiAgICBcIndvcmRCcmVha1wiLFxuICAgIFwid29yZFNwYWNpbmdcIixcbiAgICBcIndvcmRXcmFwXCIsXG4gICAgXCJ3b3JrZXJTdGFydFwiLFxuICAgIFwid3JhcFwiLFxuICAgIFwid3JhcEtleVwiLFxuICAgIFwid3JpdGFibGVcIixcbiAgICBcIndyaXRhYmxlQXV4aWxpYXJpZXNcIixcbiAgICBcIndyaXRlXCIsXG4gICAgXCJ3cml0ZVRleHRcIixcbiAgICBcIndyaXRlVmFsdWVcIixcbiAgICBcIndyaXRlV2l0aG91dFJlc3BvbnNlXCIsXG4gICAgXCJ3cml0ZWxuXCIsXG4gICAgXCJ3cml0aW5nLW1vZGVcIixcbiAgICBcIndyaXRpbmdNb2RlXCIsXG4gICAgXCJ4XCIsXG4gICAgXCJ4MVwiLFxuICAgIFwieDJcIixcbiAgICBcInhDaGFubmVsU2VsZWN0b3JcIixcbiAgICBcInhtbEVuY29kaW5nXCIsXG4gICAgXCJ4bWxTdGFuZGFsb25lXCIsXG4gICAgXCJ4bWxWZXJzaW9uXCIsXG4gICAgXCJ4bWxiYXNlXCIsXG4gICAgXCJ4bWxsYW5nXCIsXG4gICAgXCJ4bWxzcGFjZVwiLFxuICAgIFwieG9yXCIsXG4gICAgXCJ4clwiLFxuICAgIFwieVwiLFxuICAgIFwieTFcIixcbiAgICBcInkyXCIsXG4gICAgXCJ5Q2hhbm5lbFNlbGVjdG9yXCIsXG4gICAgXCJ5YW5kZXhcIixcbiAgICBcInpcIixcbiAgICBcInotaW5kZXhcIixcbiAgICBcInpJbmRleFwiLFxuICAgIFwiem9vbVwiLFxuICAgIFwiem9vbUFuZFBhblwiLFxuICAgIFwiem9vbVJlY3RTY3JlZW5cIixcbl07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gIEEgSmF2YVNjcmlwdCB0b2tlbml6ZXIgLyBwYXJzZXIgLyBiZWF1dGlmaWVyIC8gY29tcHJlc3Nvci5cbiAgaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzJcblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAoQykgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEF1dGhvcjogTWloYWkgQmF6b25cbiAgICAgICAgICAgICAgICAgICAgICAgICA8bWloYWkuYmF6b25AZ21haWwuY29tPlxuICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vbWloYWkuYmF6b24ubmV0L2Jsb2dcblxuICBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIGxpY2Vuc2U6XG5cbiAgICBDb3B5cmlnaHQgMjAxMiAoYykgTWloYWkgQmF6b24gPG1paGFpLmJhem9uQGdtYWlsLmNvbT5cblxuICAgIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgIGFyZSBtZXQ6XG5cbiAgICAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXG4gICAgICAgICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICBkaXNjbGFpbWVyLlxuXG4gICAgICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICAgICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUiDigJxBUyBJU+KAnSBBTkQgQU5ZXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBCRVxuICAgIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSxcbiAgICBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICAgIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SXG4gICAgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GXG4gICAgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gICAgU1VDSCBEQU1BR0UuXG5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZnVuY3Rpb24gZmluZF9idWlsdGlucyhyZXNlcnZlZCkge1xuICAgIGRvbXByb3BzLmZvckVhY2goYWRkKTtcblxuICAgIC8vIENvbXBhdGliaWxpdHkgZml4IGZvciBzb21lIHN0YW5kYXJkIGRlZmluZWQgZ2xvYmFscyBub3QgZGVmaW5lZCBvbiBldmVyeSBqcyBlbnZpcm9ubWVudFxuICAgIHZhciBuZXdfZ2xvYmFscyA9IFtcIlN5bWJvbFwiLCBcIk1hcFwiLCBcIlByb21pc2VcIiwgXCJQcm94eVwiLCBcIlJlZmxlY3RcIiwgXCJTZXRcIiwgXCJXZWFrTWFwXCIsIFwiV2Vha1NldFwiXTtcbiAgICB2YXIgb2JqZWN0cyA9IHt9O1xuICAgIHZhciBnbG9iYWxfcmVmID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHNlbGY7XG5cbiAgICBuZXdfZ2xvYmFscy5mb3JFYWNoKGZ1bmN0aW9uIChuZXdfZ2xvYmFsKSB7XG4gICAgICAgIG9iamVjdHNbbmV3X2dsb2JhbF0gPSBnbG9iYWxfcmVmW25ld19nbG9iYWxdIHx8IG5ldyBGdW5jdGlvbigpO1xuICAgIH0pO1xuXG4gICAgW1xuICAgICAgICBcIm51bGxcIixcbiAgICAgICAgXCJ0cnVlXCIsXG4gICAgICAgIFwiZmFsc2VcIixcbiAgICAgICAgXCJOYU5cIixcbiAgICAgICAgXCJJbmZpbml0eVwiLFxuICAgICAgICBcIi1JbmZpbml0eVwiLFxuICAgICAgICBcInVuZGVmaW5lZFwiLFxuICAgIF0uZm9yRWFjaChhZGQpO1xuICAgIFsgT2JqZWN0LCBBcnJheSwgRnVuY3Rpb24sIE51bWJlcixcbiAgICAgIFN0cmluZywgQm9vbGVhbiwgRXJyb3IsIE1hdGgsXG4gICAgICBEYXRlLCBSZWdFeHAsIG9iamVjdHMuU3ltYm9sLCBBcnJheUJ1ZmZlcixcbiAgICAgIERhdGFWaWV3LCBkZWNvZGVVUkksIGRlY29kZVVSSUNvbXBvbmVudCxcbiAgICAgIGVuY29kZVVSSSwgZW5jb2RlVVJJQ29tcG9uZW50LCBldmFsLCBFdmFsRXJyb3IsXG4gICAgICBGbG9hdDMyQXJyYXksIEZsb2F0NjRBcnJheSwgSW50OEFycmF5LCBJbnQxNkFycmF5LFxuICAgICAgSW50MzJBcnJheSwgaXNGaW5pdGUsIGlzTmFOLCBKU09OLCBvYmplY3RzLk1hcCwgcGFyc2VGbG9hdCxcbiAgICAgIHBhcnNlSW50LCBvYmplY3RzLlByb21pc2UsIG9iamVjdHMuUHJveHksIFJhbmdlRXJyb3IsIFJlZmVyZW5jZUVycm9yLFxuICAgICAgb2JqZWN0cy5SZWZsZWN0LCBvYmplY3RzLlNldCwgU3ludGF4RXJyb3IsIFR5cGVFcnJvciwgVWludDhBcnJheSxcbiAgICAgIFVpbnQ4Q2xhbXBlZEFycmF5LCBVaW50MTZBcnJheSwgVWludDMyQXJyYXksIFVSSUVycm9yLFxuICAgICAgb2JqZWN0cy5XZWFrTWFwLCBvYmplY3RzLldlYWtTZXRcbiAgICBdLmZvckVhY2goZnVuY3Rpb24oY3Rvcikge1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdG9yKS5tYXAoYWRkKTtcbiAgICAgICAgaWYgKGN0b3IucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdG9yLnByb3RvdHlwZSkubWFwKGFkZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBhZGQobmFtZSkge1xuICAgICAgICByZXNlcnZlZC5hZGQobmFtZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXNlcnZlX3F1b3RlZF9rZXlzKGFzdCwgcmVzZXJ2ZWQpIHtcbiAgICBmdW5jdGlvbiBhZGQobmFtZSkge1xuICAgICAgICBwdXNoX3VuaXEocmVzZXJ2ZWQsIG5hbWUpO1xuICAgIH1cblxuICAgIGFzdC53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0S2V5VmFsICYmIG5vZGUucXVvdGUpIHtcbiAgICAgICAgICAgIGFkZChub2RlLmtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9PYmplY3RQcm9wZXJ0eSAmJiBub2RlLnF1b3RlKSB7XG4gICAgICAgICAgICBhZGQobm9kZS5rZXkubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TdWIpIHtcbiAgICAgICAgICAgIGFkZFN0cmluZ3Mobm9kZS5wcm9wZXJ0eSwgYWRkKTtcbiAgICAgICAgfVxuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gYWRkU3RyaW5ncyhub2RlLCBhZGQpIHtcbiAgICBub2RlLndhbGsobmV3IFRyZWVXYWxrZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkge1xuICAgICAgICAgICAgYWRkU3RyaW5ncyhub2RlLnRhaWxfbm9kZSgpLCBhZGQpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU3RyaW5nKSB7XG4gICAgICAgICAgICBhZGQobm9kZS52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Db25kaXRpb25hbCkge1xuICAgICAgICAgICAgYWRkU3RyaW5ncyhub2RlLmNvbnNlcXVlbnQsIGFkZCk7XG4gICAgICAgICAgICBhZGRTdHJpbmdzKG5vZGUuYWx0ZXJuYXRpdmUsIGFkZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiBtYW5nbGVfcHJvcGVydGllcyhhc3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBidWlsdGluczogZmFsc2UsXG4gICAgICAgIGNhY2hlOiBudWxsLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIGtlZXBfcXVvdGVkOiBmYWxzZSxcbiAgICAgICAgb25seV9jYWNoZTogZmFsc2UsXG4gICAgICAgIHJlZ2V4OiBudWxsLFxuICAgICAgICByZXNlcnZlZDogbnVsbCxcbiAgICAgICAgdW5kZWNsYXJlZDogZmFsc2UsXG4gICAgfSwgdHJ1ZSk7XG5cbiAgICB2YXIgcmVzZXJ2ZWRfb3B0aW9uID0gb3B0aW9ucy5yZXNlcnZlZDtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzZXJ2ZWRfb3B0aW9uKSkgcmVzZXJ2ZWRfb3B0aW9uID0gW3Jlc2VydmVkX29wdGlvbl07XG4gICAgdmFyIHJlc2VydmVkID0gbmV3IFNldChyZXNlcnZlZF9vcHRpb24pO1xuICAgIGlmICghb3B0aW9ucy5idWlsdGlucykgZmluZF9idWlsdGlucyhyZXNlcnZlZCk7XG5cbiAgICB2YXIgY25hbWUgPSAtMTtcbiAgICB2YXIgY3ByaXZhdGUgPSAtMTtcblxuICAgIHZhciBjYWNoZTtcbiAgICB2YXIgcHJpdmF0ZV9jYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBpZiAob3B0aW9ucy5jYWNoZSkge1xuICAgICAgICBjYWNoZSA9IG9wdGlvbnMuY2FjaGUucHJvcHM7XG4gICAgICAgIGNhY2hlLmZvckVhY2goZnVuY3Rpb24obWFuZ2xlZF9uYW1lKSB7XG4gICAgICAgICAgICByZXNlcnZlZC5hZGQobWFuZ2xlZF9uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgdmFyIHJlZ2V4ID0gb3B0aW9ucy5yZWdleCAmJiBuZXcgUmVnRXhwKG9wdGlvbnMucmVnZXgpO1xuXG4gICAgLy8gbm90ZSBkZWJ1ZyBpcyBlaXRoZXIgZmFsc2UgKGRpc2FibGVkKSwgb3IgYSBzdHJpbmcgb2YgdGhlIGRlYnVnIHN1ZmZpeCB0byB1c2UgKGVuYWJsZWQpLlxuICAgIC8vIG5vdGUgZGVidWcgbWF5IGJlIGVuYWJsZWQgYXMgYW4gZW1wdHkgc3RyaW5nLCB3aGljaCBpcyBmYWxzZXkuIEFsc28gdHJlYXQgcGFzc2luZyAndHJ1ZSdcbiAgICAvLyB0aGUgc2FtZSBhcyBwYXNzaW5nIGFuIGVtcHR5IHN0cmluZy5cbiAgICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnICE9PSBmYWxzZTtcbiAgICB2YXIgZGVidWdfbmFtZV9zdWZmaXg7XG4gICAgaWYgKGRlYnVnKSB7XG4gICAgICAgIGRlYnVnX25hbWVfc3VmZml4ID0gKG9wdGlvbnMuZGVidWcgPT09IHRydWUgPyBcIlwiIDogb3B0aW9ucy5kZWJ1Zyk7XG4gICAgfVxuXG4gICAgdmFyIG5hbWVzX3RvX21hbmdsZSA9IG5ldyBTZXQoKTtcbiAgICB2YXIgdW5tYW5nbGVhYmxlID0gbmV3IFNldCgpO1xuICAgIHZhciBwcml2YXRlX3Byb3BlcnRpZXMgPSBuZXcgU2V0KCk7XG5cbiAgICB2YXIga2VlcF9xdW90ZWRfc3RyaWN0ID0gb3B0aW9ucy5rZWVwX3F1b3RlZCA9PT0gXCJzdHJpY3RcIjtcblxuICAgIC8vIHN0ZXAgMTogZmluZCBjYW5kaWRhdGVzIHRvIG1hbmdsZVxuICAgIGFzdC53YWxrKG5ldyBUcmVlV2Fsa2VyKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbm9kZSBpbnN0YW5jZW9mIEFTVF9DbGFzc1ByaXZhdGVQcm9wZXJ0eVxuICAgICAgICAgICAgfHwgbm9kZSBpbnN0YW5jZW9mIEFTVF9Qcml2YXRlTWV0aG9kXG4gICAgICAgICkge1xuICAgICAgICAgICAgcHJpdmF0ZV9wcm9wZXJ0aWVzLmFkZChub2RlLmtleS5uYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RvdEhhc2gpIHtcbiAgICAgICAgICAgIHByaXZhdGVfcHJvcGVydGllcy5hZGQobm9kZS5wcm9wZXJ0eSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9PYmplY3RLZXlWYWwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZS5rZXkgPT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICgha2VlcF9xdW90ZWRfc3RyaWN0IHx8ICFub2RlLnF1b3RlKSkge1xuICAgICAgICAgICAgICAgIGFkZChub2RlLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9PYmplY3RQcm9wZXJ0eSkge1xuICAgICAgICAgICAgLy8gc2V0dGVyIG9yIGdldHRlciwgc2luY2UgS2V5VmFsIGlzIGhhbmRsZWQgYWJvdmVcbiAgICAgICAgICAgIGlmICgha2VlcF9xdW90ZWRfc3RyaWN0IHx8ICFub2RlLmtleS5lbmQucXVvdGUpIHtcbiAgICAgICAgICAgICAgICBhZGQobm9kZS5rZXkubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9Eb3QpIHtcbiAgICAgICAgICAgIHZhciBkZWNsYXJlZCA9ICEhb3B0aW9ucy51bmRlY2xhcmVkO1xuICAgICAgICAgICAgaWYgKCFkZWNsYXJlZCkge1xuICAgICAgICAgICAgICAgIHZhciByb290ID0gbm9kZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocm9vdC5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSByb290LmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY2xhcmVkID0gIShyb290LnRoZWRlZiAmJiByb290LnRoZWRlZi51bmRlY2xhcmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWNsYXJlZCAmJlxuICAgICAgICAgICAgICAgICgha2VlcF9xdW90ZWRfc3RyaWN0IHx8ICFub2RlLnF1b3RlKSkge1xuICAgICAgICAgICAgICAgIGFkZChub2RlLnByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N1Yikge1xuICAgICAgICAgICAgaWYgKCFrZWVwX3F1b3RlZF9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBhZGRTdHJpbmdzKG5vZGUucHJvcGVydHksIGFkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9DYWxsXG4gICAgICAgICAgICAmJiBub2RlLmV4cHJlc3Npb24ucHJpbnRfdG9fc3RyaW5nKCkgPT0gXCJPYmplY3QuZGVmaW5lUHJvcGVydHlcIikge1xuICAgICAgICAgICAgYWRkU3RyaW5ncyhub2RlLmFyZ3NbMV0sIGFkZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9CaW5hcnkgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCJpblwiKSB7XG4gICAgICAgICAgICBhZGRTdHJpbmdzKG5vZGUubGVmdCwgYWRkKTtcbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8vIHN0ZXAgMjogdHJhbnNmb3JtIHRoZSB0cmVlLCByZW5hbWluZyBwcm9wZXJ0aWVzXG4gICAgcmV0dXJuIGFzdC50cmFuc2Zvcm0obmV3IFRyZWVUcmFuc2Zvcm1lcihmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2xhc3NQcml2YXRlUHJvcGVydHlcbiAgICAgICAgICAgIHx8IG5vZGUgaW5zdGFuY2VvZiBBU1RfUHJpdmF0ZU1ldGhvZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIG5vZGUua2V5Lm5hbWUgPSBtYW5nbGVfcHJpdmF0ZShub2RlLmtleS5uYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0RvdEhhc2gpIHtcbiAgICAgICAgICAgIG5vZGUucHJvcGVydHkgPSBtYW5nbGVfcHJpdmF0ZShub2RlLnByb3BlcnR5KTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX09iamVjdEtleVZhbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub2RlLmtleSA9PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgKCFrZWVwX3F1b3RlZF9zdHJpY3QgfHwgIW5vZGUucXVvdGUpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5rZXkgPSBtYW5nbGUobm9kZS5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfT2JqZWN0UHJvcGVydHkpIHtcbiAgICAgICAgICAgIC8vIHNldHRlciwgZ2V0dGVyLCBtZXRob2Qgb3IgY2xhc3MgZmllbGRcbiAgICAgICAgICAgIGlmICgha2VlcF9xdW90ZWRfc3RyaWN0IHx8ICFub2RlLmtleS5lbmQucXVvdGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmtleS5uYW1lID0gbWFuZ2xlKG5vZGUua2V5Lm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfRG90KSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBfcXVvdGVkX3N0cmljdCB8fCAhbm9kZS5xdW90ZSkge1xuICAgICAgICAgICAgICAgIG5vZGUucHJvcGVydHkgPSBtYW5nbGUobm9kZS5wcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMua2VlcF9xdW90ZWQgJiYgbm9kZSBpbnN0YW5jZW9mIEFTVF9TdWIpIHtcbiAgICAgICAgICAgIG5vZGUucHJvcGVydHkgPSBtYW5nbGVTdHJpbmdzKG5vZGUucHJvcGVydHkpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfQ2FsbFxuICAgICAgICAgICAgJiYgbm9kZS5leHByZXNzaW9uLnByaW50X3RvX3N0cmluZygpID09IFwiT2JqZWN0LmRlZmluZVByb3BlcnR5XCIpIHtcbiAgICAgICAgICAgIG5vZGUuYXJnc1sxXSA9IG1hbmdsZVN0cmluZ3Mobm9kZS5hcmdzWzFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0JpbmFyeSAmJiBub2RlLm9wZXJhdG9yID09PSBcImluXCIpIHtcbiAgICAgICAgICAgIG5vZGUubGVmdCA9IG1hbmdsZVN0cmluZ3Mobm9kZS5sZWZ0KTtcbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8vIG9ubHkgZnVuY3Rpb24gZGVjbGFyYXRpb25zIGFmdGVyIHRoaXMgbGluZVxuXG4gICAgZnVuY3Rpb24gY2FuX21hbmdsZShuYW1lKSB7XG4gICAgICAgIGlmICh1bm1hbmdsZWFibGUuaGFzKG5hbWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChyZXNlcnZlZC5oYXMobmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnMub25seV9jYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmhhcyhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL14tP1swLTldKyhcXC5bMC05XSspPyhlWystXVswLTldKyk/JC8udGVzdChuYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRfbWFuZ2xlKG5hbWUpIHtcbiAgICAgICAgaWYgKHJlZ2V4ICYmICFyZWdleC50ZXN0KG5hbWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChyZXNlcnZlZC5oYXMobmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmhhcyhuYW1lKVxuICAgICAgICAgICAgfHwgbmFtZXNfdG9fbWFuZ2xlLmhhcyhuYW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGQobmFtZSkge1xuICAgICAgICBpZiAoY2FuX21hbmdsZShuYW1lKSlcbiAgICAgICAgICAgIG5hbWVzX3RvX21hbmdsZS5hZGQobmFtZSk7XG5cbiAgICAgICAgaWYgKCFzaG91bGRfbWFuZ2xlKG5hbWUpKSB7XG4gICAgICAgICAgICB1bm1hbmdsZWFibGUuYWRkKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFuZ2xlKG5hbWUpIHtcbiAgICAgICAgaWYgKCFzaG91bGRfbWFuZ2xlKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYW5nbGVkID0gY2FjaGUuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIW1hbmdsZWQpIHtcbiAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgIC8vIGRlYnVnIG1vZGU6IHVzZSBhIHByZWZpeCBhbmQgc3VmZml4IHRvIHByZXNlcnZlIHJlYWRhYmlsaXR5LCBlLmcuIG8uZm9vIC0+IG8uXyRmb28kTk5OXy5cbiAgICAgICAgICAgICAgICB2YXIgZGVidWdfbWFuZ2xlZCA9IFwiXyRcIiArIG5hbWUgKyBcIiRcIiArIGRlYnVnX25hbWVfc3VmZml4ICsgXCJfXCI7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FuX21hbmdsZShkZWJ1Z19tYW5nbGVkKSkge1xuICAgICAgICAgICAgICAgICAgICBtYW5nbGVkID0gZGVidWdfbWFuZ2xlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGVpdGhlciBkZWJ1ZyBtb2RlIGlzIG9mZiwgb3IgaXQgaXMgb24gYW5kIHdlIGNvdWxkIG5vdCB1c2UgdGhlIG1hbmdsZWQgbmFtZVxuICAgICAgICAgICAgaWYgKCFtYW5nbGVkKSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBtYW5nbGVkID0gYmFzZTU0KCsrY25hbWUpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKCFjYW5fbWFuZ2xlKG1hbmdsZWQpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FjaGUuc2V0KG5hbWUsIG1hbmdsZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYW5nbGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hbmdsZV9wcml2YXRlKG5hbWUpIHtcbiAgICAgICAgbGV0IG1hbmdsZWQgPSBwcml2YXRlX2NhY2hlLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCFtYW5nbGVkKSB7XG4gICAgICAgICAgICBtYW5nbGVkID0gYmFzZTU0KCsrY3ByaXZhdGUpO1xuICAgICAgICAgICAgcHJpdmF0ZV9jYWNoZS5zZXQobmFtZSwgbWFuZ2xlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFuZ2xlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYW5nbGVTdHJpbmdzKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUudHJhbnNmb3JtKG5ldyBUcmVlVHJhbnNmb3JtZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBU1RfU2VxdWVuY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IG5vZGUuZXhwcmVzc2lvbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb25zW2xhc3RdID0gbWFuZ2xlU3RyaW5ncyhub2RlLmV4cHJlc3Npb25zW2xhc3RdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFTVF9TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbWFuZ2xlKG5vZGUudmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jb25zZXF1ZW50ID0gbWFuZ2xlU3RyaW5ncyhub2RlLmNvbnNlcXVlbnQpO1xuICAgICAgICAgICAgICAgIG5vZGUuYWx0ZXJuYXRpdmUgPSBtYW5nbGVTdHJpbmdzKG5vZGUuYWx0ZXJuYXRpdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5cbnZhciB0b19hc2NpaSA9IHR5cGVvZiBhdG9iID09IFwidW5kZWZpbmVkXCIgPyBmdW5jdGlvbihiNjQpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xufSA6IGF0b2I7XG52YXIgdG9fYmFzZTY0ID0gdHlwZW9mIGJ0b2EgPT0gXCJ1bmRlZmluZWRcIiA/IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufSA6IGJ0b2E7XG5cbmZ1bmN0aW9uIHJlYWRfc291cmNlX21hcChjb2RlKSB7XG4gICAgdmFyIG1hdGNoID0gLyg/Ol58W14uXSlcXC9cXC8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvblxcL2pzb24oO1tcXHc9LV0qKT87YmFzZTY0LChbKy8wLTlBLVphLXpdKj0qKVxccyokLy5leGVjKGNvZGUpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiaW5saW5lIHNvdXJjZSBtYXAgbm90IGZvdW5kXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRvX2FzY2lpKG1hdGNoWzJdKTtcbn1cblxuZnVuY3Rpb24gc2V0X3Nob3J0aGFuZChuYW1lLCBvcHRpb25zLCBrZXlzKSB7XG4gICAgaWYgKG9wdGlvbnNbbmFtZV0pIHtcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1trZXldICE9IFwib2JqZWN0XCIpIG9wdGlvbnNba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICghKG5hbWUgaW4gb3B0aW9uc1trZXldKSkgb3B0aW9uc1trZXldW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0X2NhY2hlKGNhY2hlKSB7XG4gICAgaWYgKCFjYWNoZSkgcmV0dXJuO1xuICAgIGlmICghKFwicHJvcHNcIiBpbiBjYWNoZSkpIHtcbiAgICAgICAgY2FjaGUucHJvcHMgPSBuZXcgTWFwKCk7XG4gICAgfSBlbHNlIGlmICghKGNhY2hlLnByb3BzIGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgICBjYWNoZS5wcm9wcyA9IG1hcF9mcm9tX29iamVjdChjYWNoZS5wcm9wcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYWNoZV90b19qc29uKGNhY2hlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHM6IG1hcF90b19vYmplY3QoY2FjaGUucHJvcHMpXG4gICAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbWluaWZ5KGZpbGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgY29tcHJlc3M6IHt9LFxuICAgICAgICBlY21hOiB1bmRlZmluZWQsXG4gICAgICAgIGVuY2xvc2U6IGZhbHNlLFxuICAgICAgICBpZTg6IGZhbHNlLFxuICAgICAgICBrZWVwX2NsYXNzbmFtZXM6IHVuZGVmaW5lZCxcbiAgICAgICAga2VlcF9mbmFtZXM6IGZhbHNlLFxuICAgICAgICBtYW5nbGU6IHt9LFxuICAgICAgICBtb2R1bGU6IGZhbHNlLFxuICAgICAgICBuYW1lQ2FjaGU6IG51bGwsXG4gICAgICAgIG91dHB1dDogbnVsbCxcbiAgICAgICAgZm9ybWF0OiBudWxsLFxuICAgICAgICBwYXJzZToge30sXG4gICAgICAgIHJlbmFtZTogdW5kZWZpbmVkLFxuICAgICAgICBzYWZhcmkxMDogZmFsc2UsXG4gICAgICAgIHNvdXJjZU1hcDogZmFsc2UsXG4gICAgICAgIHNwaWRlcm1vbmtleTogZmFsc2UsXG4gICAgICAgIHRpbWluZ3M6IGZhbHNlLFxuICAgICAgICB0b3BsZXZlbDogZmFsc2UsXG4gICAgICAgIHdhcm5pbmdzOiBmYWxzZSxcbiAgICAgICAgd3JhcDogZmFsc2UsXG4gICAgfSwgdHJ1ZSk7XG4gICAgdmFyIHRpbWluZ3MgPSBvcHRpb25zLnRpbWluZ3MgJiYge1xuICAgICAgICBzdGFydDogRGF0ZS5ub3coKVxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMua2VlcF9jbGFzc25hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5rZWVwX2NsYXNzbmFtZXMgPSBvcHRpb25zLmtlZXBfZm5hbWVzO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZW5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLnJlbmFtZSA9IG9wdGlvbnMuY29tcHJlc3MgJiYgb3B0aW9ucy5tYW5nbGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm91dHB1dCAmJiBvcHRpb25zLmZvcm1hdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2Ugb25seSBzcGVjaWZ5IGVpdGhlciBvdXRwdXQgb3IgZm9ybWF0IG9wdGlvbiwgcHJlZmVycmFibHkgZm9ybWF0LlwiKTtcbiAgICB9XG4gICAgb3B0aW9ucy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdCB8fCBvcHRpb25zLm91dHB1dCB8fCB7fTtcbiAgICBzZXRfc2hvcnRoYW5kKFwiZWNtYVwiLCBvcHRpb25zLCBbIFwicGFyc2VcIiwgXCJjb21wcmVzc1wiLCBcImZvcm1hdFwiIF0pO1xuICAgIHNldF9zaG9ydGhhbmQoXCJpZThcIiwgb3B0aW9ucywgWyBcImNvbXByZXNzXCIsIFwibWFuZ2xlXCIsIFwiZm9ybWF0XCIgXSk7XG4gICAgc2V0X3Nob3J0aGFuZChcImtlZXBfY2xhc3NuYW1lc1wiLCBvcHRpb25zLCBbIFwiY29tcHJlc3NcIiwgXCJtYW5nbGVcIiBdKTtcbiAgICBzZXRfc2hvcnRoYW5kKFwia2VlcF9mbmFtZXNcIiwgb3B0aW9ucywgWyBcImNvbXByZXNzXCIsIFwibWFuZ2xlXCIgXSk7XG4gICAgc2V0X3Nob3J0aGFuZChcIm1vZHVsZVwiLCBvcHRpb25zLCBbIFwicGFyc2VcIiwgXCJjb21wcmVzc1wiLCBcIm1hbmdsZVwiIF0pO1xuICAgIHNldF9zaG9ydGhhbmQoXCJzYWZhcmkxMFwiLCBvcHRpb25zLCBbIFwibWFuZ2xlXCIsIFwiZm9ybWF0XCIgXSk7XG4gICAgc2V0X3Nob3J0aGFuZChcInRvcGxldmVsXCIsIG9wdGlvbnMsIFsgXCJjb21wcmVzc1wiLCBcIm1hbmdsZVwiIF0pO1xuICAgIHNldF9zaG9ydGhhbmQoXCJ3YXJuaW5nc1wiLCBvcHRpb25zLCBbIFwiY29tcHJlc3NcIiBdKTsgLy8gbGVnYWN5XG4gICAgdmFyIHF1b3RlZF9wcm9wcztcbiAgICBpZiAob3B0aW9ucy5tYW5nbGUpIHtcbiAgICAgICAgb3B0aW9ucy5tYW5nbGUgPSBkZWZhdWx0cyhvcHRpb25zLm1hbmdsZSwge1xuICAgICAgICAgICAgY2FjaGU6IG9wdGlvbnMubmFtZUNhY2hlICYmIChvcHRpb25zLm5hbWVDYWNoZS52YXJzIHx8IHt9KSxcbiAgICAgICAgICAgIGV2YWw6IGZhbHNlLFxuICAgICAgICAgICAgaWU4OiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBfY2xhc3NuYW1lczogZmFsc2UsXG4gICAgICAgICAgICBrZWVwX2ZuYW1lczogZmFsc2UsXG4gICAgICAgICAgICBtb2R1bGU6IGZhbHNlLFxuICAgICAgICAgICAgcHJvcGVydGllczogZmFsc2UsXG4gICAgICAgICAgICByZXNlcnZlZDogW10sXG4gICAgICAgICAgICBzYWZhcmkxMDogZmFsc2UsXG4gICAgICAgICAgICB0b3BsZXZlbDogZmFsc2UsXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBpZiAob3B0aW9ucy5tYW5nbGUucHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1hbmdsZS5wcm9wZXJ0aWVzICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1hbmdsZS5wcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tYW5nbGUucHJvcGVydGllcy5rZWVwX3F1b3RlZCkge1xuICAgICAgICAgICAgICAgIHF1b3RlZF9wcm9wcyA9IG9wdGlvbnMubWFuZ2xlLnByb3BlcnRpZXMucmVzZXJ2ZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHF1b3RlZF9wcm9wcykpIHF1b3RlZF9wcm9wcyA9IFtdO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubWFuZ2xlLnByb3BlcnRpZXMucmVzZXJ2ZWQgPSBxdW90ZWRfcHJvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5uYW1lQ2FjaGUgJiYgIShcImNhY2hlXCIgaW4gb3B0aW9ucy5tYW5nbGUucHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1hbmdsZS5wcm9wZXJ0aWVzLmNhY2hlID0gb3B0aW9ucy5uYW1lQ2FjaGUucHJvcHMgfHwge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5pdF9jYWNoZShvcHRpb25zLm1hbmdsZS5jYWNoZSk7XG4gICAgICAgIGluaXRfY2FjaGUob3B0aW9ucy5tYW5nbGUucHJvcGVydGllcy5jYWNoZSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcCkge1xuICAgICAgICBvcHRpb25zLnNvdXJjZU1hcCA9IGRlZmF1bHRzKG9wdGlvbnMuc291cmNlTWFwLCB7XG4gICAgICAgICAgICBhc09iamVjdDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBudWxsLFxuICAgICAgICAgICAgZmlsZW5hbWU6IG51bGwsXG4gICAgICAgICAgICBpbmNsdWRlU291cmNlczogZmFsc2UsXG4gICAgICAgICAgICByb290OiBudWxsLFxuICAgICAgICAgICAgdXJsOiBudWxsLFxuICAgICAgICB9LCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRpbWluZ3MpIHRpbWluZ3MucGFyc2UgPSBEYXRlLm5vdygpO1xuICAgIHZhciB0b3BsZXZlbDtcbiAgICBpZiAoZmlsZXMgaW5zdGFuY2VvZiBBU1RfVG9wbGV2ZWwpIHtcbiAgICAgICAgdG9wbGV2ZWwgPSBmaWxlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGZpbGVzID09IFwic3RyaW5nXCIgfHwgKG9wdGlvbnMucGFyc2Uuc3BpZGVybW9ua2V5ICYmICFBcnJheS5pc0FycmF5KGZpbGVzKSkpIHtcbiAgICAgICAgICAgIGZpbGVzID0gWyBmaWxlcyBdO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMucGFyc2UgPSBvcHRpb25zLnBhcnNlIHx8IHt9O1xuICAgICAgICBvcHRpb25zLnBhcnNlLnRvcGxldmVsID0gbnVsbDtcblxuICAgICAgICBpZiAob3B0aW9ucy5wYXJzZS5zcGlkZXJtb25rZXkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyc2UudG9wbGV2ZWwgPSBBU1RfTm9kZS5mcm9tX21vemlsbGFfYXN0KE9iamVjdC5rZXlzKGZpbGVzKS5yZWR1Y2UoZnVuY3Rpb24odG9wbGV2ZWwsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRvcGxldmVsKSByZXR1cm4gZmlsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgdG9wbGV2ZWwuYm9keSA9IHRvcGxldmVsLmJvZHkuY29uY2F0KGZpbGVzW25hbWVdLmJvZHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b3BsZXZlbDtcbiAgICAgICAgICAgIH0sIG51bGwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnBhcnNlLnNwaWRlcm1vbmtleTtcblxuICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBmaWxlcykgaWYgKEhPUChmaWxlcywgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhcnNlLmZpbGVuYW1lID0gbmFtZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhcnNlLnRvcGxldmVsID0gcGFyc2UoZmlsZXNbbmFtZV0sIG9wdGlvbnMucGFyc2UpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcCAmJiBvcHRpb25zLnNvdXJjZU1hcC5jb250ZW50ID09IFwiaW5saW5lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGZpbGVzKS5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5saW5lIHNvdXJjZSBtYXAgb25seSB3b3JrcyB3aXRoIHNpbmd1bGFyIGlucHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNvdXJjZU1hcC5jb250ZW50ID0gcmVhZF9zb3VyY2VfbWFwKGZpbGVzW25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0b3BsZXZlbCA9IG9wdGlvbnMucGFyc2UudG9wbGV2ZWw7XG4gICAgfVxuICAgIGlmIChxdW90ZWRfcHJvcHMgJiYgb3B0aW9ucy5tYW5nbGUucHJvcGVydGllcy5rZWVwX3F1b3RlZCAhPT0gXCJzdHJpY3RcIikge1xuICAgICAgICByZXNlcnZlX3F1b3RlZF9rZXlzKHRvcGxldmVsLCBxdW90ZWRfcHJvcHMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53cmFwKSB7XG4gICAgICAgIHRvcGxldmVsID0gdG9wbGV2ZWwud3JhcF9jb21tb25qcyhvcHRpb25zLndyYXApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5lbmNsb3NlKSB7XG4gICAgICAgIHRvcGxldmVsID0gdG9wbGV2ZWwud3JhcF9lbmNsb3NlKG9wdGlvbnMuZW5jbG9zZSk7XG4gICAgfVxuICAgIGlmICh0aW1pbmdzKSB0aW1pbmdzLnJlbmFtZSA9IERhdGUubm93KCk7XG4gICAgaWYgKHRpbWluZ3MpIHRpbWluZ3MuY29tcHJlc3MgPSBEYXRlLm5vdygpO1xuICAgIGlmIChvcHRpb25zLmNvbXByZXNzKSB7XG4gICAgICAgIHRvcGxldmVsID0gbmV3IENvbXByZXNzb3Iob3B0aW9ucy5jb21wcmVzcywge1xuICAgICAgICAgICAgbWFuZ2xlX29wdGlvbnM6IG9wdGlvbnMubWFuZ2xlXG4gICAgICAgIH0pLmNvbXByZXNzKHRvcGxldmVsKTtcbiAgICB9XG4gICAgaWYgKHRpbWluZ3MpIHRpbWluZ3Muc2NvcGUgPSBEYXRlLm5vdygpO1xuICAgIGlmIChvcHRpb25zLm1hbmdsZSkgdG9wbGV2ZWwuZmlndXJlX291dF9zY29wZShvcHRpb25zLm1hbmdsZSk7XG4gICAgaWYgKHRpbWluZ3MpIHRpbWluZ3MubWFuZ2xlID0gRGF0ZS5ub3coKTtcbiAgICBpZiAob3B0aW9ucy5tYW5nbGUpIHtcbiAgICAgICAgYmFzZTU0LnJlc2V0KCk7XG4gICAgICAgIHRvcGxldmVsLmNvbXB1dGVfY2hhcl9mcmVxdWVuY3kob3B0aW9ucy5tYW5nbGUpO1xuICAgICAgICB0b3BsZXZlbC5tYW5nbGVfbmFtZXMob3B0aW9ucy5tYW5nbGUpO1xuICAgIH1cbiAgICBpZiAodGltaW5ncykgdGltaW5ncy5wcm9wZXJ0aWVzID0gRGF0ZS5ub3coKTtcbiAgICBpZiAob3B0aW9ucy5tYW5nbGUgJiYgb3B0aW9ucy5tYW5nbGUucHJvcGVydGllcykge1xuICAgICAgICB0b3BsZXZlbCA9IG1hbmdsZV9wcm9wZXJ0aWVzKHRvcGxldmVsLCBvcHRpb25zLm1hbmdsZS5wcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgaWYgKHRpbWluZ3MpIHRpbWluZ3MuZm9ybWF0ID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG9wdGlvbnMuZm9ybWF0LmFzdCkge1xuICAgICAgICByZXN1bHQuYXN0ID0gdG9wbGV2ZWw7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZvcm1hdC5zcGlkZXJtb25rZXkpIHtcbiAgICAgICAgcmVzdWx0LmFzdCA9IHRvcGxldmVsLnRvX21vemlsbGFfYXN0KCk7XG4gICAgfVxuICAgIGlmICghSE9QKG9wdGlvbnMuZm9ybWF0LCBcImNvZGVcIikgfHwgb3B0aW9ucy5mb3JtYXQuY29kZSkge1xuICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0LnNvdXJjZV9tYXAgPSBhd2FpdCBTb3VyY2VNYXAoe1xuICAgICAgICAgICAgICAgIGZpbGU6IG9wdGlvbnMuc291cmNlTWFwLmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIG9yaWc6IG9wdGlvbnMuc291cmNlTWFwLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgcm9vdDogb3B0aW9ucy5zb3VyY2VNYXAucm9vdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2VNYXAuaW5jbHVkZVNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZXMgaW5zdGFuY2VvZiBBU1RfVG9wbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3JpZ2luYWwgc291cmNlIGNvbnRlbnQgdW5hdmFpbGFibGVcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGZvciAodmFyIG5hbWUgaW4gZmlsZXMpIGlmIChIT1AoZmlsZXMsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZm9ybWF0LnNvdXJjZV9tYXAuZ2V0KCkuc2V0U291cmNlQ29udGVudChuYW1lLCBmaWxlc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmZvcm1hdC5hc3Q7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmZvcm1hdC5jb2RlO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5mb3JtYXQuc3BpZGVybW9ua2V5O1xuICAgICAgICB2YXIgc3RyZWFtID0gT3V0cHV0U3RyZWFtKG9wdGlvbnMuZm9ybWF0KTtcbiAgICAgICAgdG9wbGV2ZWwucHJpbnQoc3RyZWFtKTtcbiAgICAgICAgcmVzdWx0LmNvZGUgPSBzdHJlYW0uZ2V0KCk7XG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcCkge1xuICAgICAgICAgICAgaWYob3B0aW9ucy5zb3VyY2VNYXAuYXNPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubWFwID0gb3B0aW9ucy5mb3JtYXQuc291cmNlX21hcC5nZXQoKS50b0pTT04oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lm1hcCA9IG9wdGlvbnMuZm9ybWF0LnNvdXJjZV9tYXAudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcC51cmwgPT0gXCJpbmxpbmVcIikge1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VNYXAgPSB0eXBlb2YgcmVzdWx0Lm1hcCA9PT0gXCJvYmplY3RcIiA/IEpTT04uc3RyaW5naWZ5KHJlc3VsdC5tYXApIDogcmVzdWx0Lm1hcDtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29kZSArPSBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIiArIHRvX2Jhc2U2NChzb3VyY2VNYXApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnNvdXJjZU1hcC51cmwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY29kZSArPSBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgb3B0aW9ucy5zb3VyY2VNYXAudXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm5hbWVDYWNoZSAmJiBvcHRpb25zLm1hbmdsZSkge1xuICAgICAgICBpZiAob3B0aW9ucy5tYW5nbGUuY2FjaGUpIG9wdGlvbnMubmFtZUNhY2hlLnZhcnMgPSBjYWNoZV90b19qc29uKG9wdGlvbnMubWFuZ2xlLmNhY2hlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMubWFuZ2xlLnByb3BlcnRpZXMgJiYgb3B0aW9ucy5tYW5nbGUucHJvcGVydGllcy5jYWNoZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5uYW1lQ2FjaGUucHJvcHMgPSBjYWNoZV90b19qc29uKG9wdGlvbnMubWFuZ2xlLnByb3BlcnRpZXMuY2FjaGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZvcm1hdCAmJiBvcHRpb25zLmZvcm1hdC5zb3VyY2VfbWFwKSB7XG4gICAgICAgIG9wdGlvbnMuZm9ybWF0LnNvdXJjZV9tYXAuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGltaW5ncykge1xuICAgICAgICB0aW1pbmdzLmVuZCA9IERhdGUubm93KCk7XG4gICAgICAgIHJlc3VsdC50aW1pbmdzID0ge1xuICAgICAgICAgICAgcGFyc2U6IDFlLTMgKiAodGltaW5ncy5yZW5hbWUgLSB0aW1pbmdzLnBhcnNlKSxcbiAgICAgICAgICAgIHJlbmFtZTogMWUtMyAqICh0aW1pbmdzLmNvbXByZXNzIC0gdGltaW5ncy5yZW5hbWUpLFxuICAgICAgICAgICAgY29tcHJlc3M6IDFlLTMgKiAodGltaW5ncy5zY29wZSAtIHRpbWluZ3MuY29tcHJlc3MpLFxuICAgICAgICAgICAgc2NvcGU6IDFlLTMgKiAodGltaW5ncy5tYW5nbGUgLSB0aW1pbmdzLnNjb3BlKSxcbiAgICAgICAgICAgIG1hbmdsZTogMWUtMyAqICh0aW1pbmdzLnByb3BlcnRpZXMgLSB0aW1pbmdzLm1hbmdsZSksXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiAxZS0zICogKHRpbWluZ3MuZm9ybWF0IC0gdGltaW5ncy5wcm9wZXJ0aWVzKSxcbiAgICAgICAgICAgIGZvcm1hdDogMWUtMyAqICh0aW1pbmdzLmVuZCAtIHRpbWluZ3MuZm9ybWF0KSxcbiAgICAgICAgICAgIHRvdGFsOiAxZS0zICogKHRpbWluZ3MuZW5kIC0gdGltaW5ncy5zdGFydClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuX2NsaSh7IHByb2dyYW0sIHBhY2thZ2VKc29uLCBmcywgcGF0aCB9KSB7XG4gICAgY29uc3Qgc2tpcF9rZXlzID0gbmV3IFNldChbIFwiY25hbWVcIiwgXCJwYXJlbnRfc2NvcGVcIiwgXCJzY29wZVwiLCBcInVzZXNfZXZhbFwiLCBcInVzZXNfd2l0aFwiIF0pO1xuICAgIHZhciBmaWxlcyA9IHt9O1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBjb21wcmVzczogZmFsc2UsXG4gICAgICAgIG1hbmdsZTogZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGRlZmF1bHRfb3B0aW9ucyA9IGF3YWl0IF9kZWZhdWx0X29wdGlvbnMoKTtcbiAgICBwcm9ncmFtLnZlcnNpb24ocGFja2FnZUpzb24ubmFtZSArIFwiIFwiICsgcGFja2FnZUpzb24udmVyc2lvbik7XG4gICAgcHJvZ3JhbS5wYXJzZUFyZ3YgPSBwcm9ncmFtLnBhcnNlO1xuICAgIHByb2dyYW0ucGFyc2UgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAocHJvY2Vzcy5hcmd2LmluY2x1ZGVzKFwiYXN0XCIpKSBwcm9ncmFtLmhlbHBJbmZvcm1hdGlvbiA9IGRlc2NyaWJlX2FzdDtcbiAgICBlbHNlIGlmIChwcm9jZXNzLmFyZ3YuaW5jbHVkZXMoXCJvcHRpb25zXCIpKSBwcm9ncmFtLmhlbHBJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGV4dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBvcHRpb24gaW4gZGVmYXVsdF9vcHRpb25zKSB7XG4gICAgICAgICAgICB0ZXh0LnB1c2goXCItLVwiICsgKG9wdGlvbiA9PT0gXCJzb3VyY2VNYXBcIiA/IFwic291cmNlLW1hcFwiIDogb3B0aW9uKSArIFwiIG9wdGlvbnM6XCIpO1xuICAgICAgICAgICAgdGV4dC5wdXNoKGZvcm1hdF9vYmplY3QoZGVmYXVsdF9vcHRpb25zW29wdGlvbl0pKTtcbiAgICAgICAgICAgIHRleHQucHVzaChcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5qb2luKFwiXFxuXCIpO1xuICAgIH07XG5cbiAgICBwcm9ncmFtLm9wdGlvbihcIi1wLCAtLXBhcnNlIDxvcHRpb25zPlwiLCBcIlNwZWNpZnkgcGFyc2VyIG9wdGlvbnMuXCIsIHBhcnNlX2pzKCkpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLWMsIC0tY29tcHJlc3MgW29wdGlvbnNdXCIsIFwiRW5hYmxlIGNvbXByZXNzb3Ivc3BlY2lmeSBjb21wcmVzc29yIG9wdGlvbnMuXCIsIHBhcnNlX2pzKCkpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLW0sIC0tbWFuZ2xlIFtvcHRpb25zXVwiLCBcIk1hbmdsZSBuYW1lcy9zcGVjaWZ5IG1hbmdsZXIgb3B0aW9ucy5cIiwgcGFyc2VfanMoKSk7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItLW1hbmdsZS1wcm9wcyBbb3B0aW9uc11cIiwgXCJNYW5nbGUgcHJvcGVydGllcy9zcGVjaWZ5IG1hbmdsZXIgb3B0aW9ucy5cIiwgcGFyc2VfanMoKSk7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItZiwgLS1mb3JtYXQgW29wdGlvbnNdXCIsIFwiRm9ybWF0IG9wdGlvbnMuXCIsIHBhcnNlX2pzKCkpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLWIsIC0tYmVhdXRpZnkgW29wdGlvbnNdXCIsIFwiQWxpYXMgZm9yIC0tZm9ybWF0LlwiLCBwYXJzZV9qcygpKTtcbiAgICBwcm9ncmFtLm9wdGlvbihcIi1vLCAtLW91dHB1dCA8ZmlsZT5cIiwgXCJPdXRwdXQgZmlsZSAoZGVmYXVsdCBTVERPVVQpLlwiKTtcbiAgICBwcm9ncmFtLm9wdGlvbihcIi0tY29tbWVudHMgW2ZpbHRlcl1cIiwgXCJQcmVzZXJ2ZSBjb3B5cmlnaHQgY29tbWVudHMgaW4gdGhlIG91dHB1dC5cIik7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItLWNvbmZpZy1maWxlIDxmaWxlPlwiLCBcIlJlYWQgbWluaWZ5KCkgb3B0aW9ucyBmcm9tIEpTT04gZmlsZS5cIik7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItZCwgLS1kZWZpbmUgPGV4cHI+Wz12YWx1ZV1cIiwgXCJHbG9iYWwgZGVmaW5pdGlvbnMuXCIsIHBhcnNlX2pzKFwiZGVmaW5lXCIpKTtcbiAgICBwcm9ncmFtLm9wdGlvbihcIi0tZWNtYSA8dmVyc2lvbj5cIiwgXCJTcGVjaWZ5IEVDTUFTY3JpcHQgcmVsZWFzZTogNSwgMjAxNSwgMjAxNiBvciAyMDE3Li4uXCIpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLWUsIC0tZW5jbG9zZSBbYXJnWywuLi5dWzp2YWx1ZVssLi4uXV1dXCIsIFwiRW1iZWQgb3V0cHV0IGluIGEgYmlnIGZ1bmN0aW9uIHdpdGggY29uZmlndXJhYmxlIGFyZ3VtZW50cyBhbmQgdmFsdWVzLlwiKTtcbiAgICBwcm9ncmFtLm9wdGlvbihcIi0taWU4XCIsIFwiU3VwcG9ydCBub24tc3RhbmRhcmQgSW50ZXJuZXQgRXhwbG9yZXIgOC5cIik7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItLWtlZXAtY2xhc3NuYW1lc1wiLCBcIkRvIG5vdCBtYW5nbGUvZHJvcCBjbGFzcyBuYW1lcy5cIik7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItLWtlZXAtZm5hbWVzXCIsIFwiRG8gbm90IG1hbmdsZS9kcm9wIGZ1bmN0aW9uIG5hbWVzLiBVc2VmdWwgZm9yIGNvZGUgcmVseWluZyBvbiBGdW5jdGlvbi5wcm90b3R5cGUubmFtZS5cIik7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItLW1vZHVsZVwiLCBcIklucHV0IGlzIGFuIEVTNiBtb2R1bGVcIik7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItLW5hbWUtY2FjaGUgPGZpbGU+XCIsIFwiRmlsZSB0byBob2xkIG1hbmdsZWQgbmFtZSBtYXBwaW5ncy5cIik7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItLXJlbmFtZVwiLCBcIkZvcmNlIHN5bWJvbCBleHBhbnNpb24uXCIpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLS1uby1yZW5hbWVcIiwgXCJEaXNhYmxlIHN5bWJvbCBleHBhbnNpb24uXCIpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLS1zYWZhcmkxMFwiLCBcIlN1cHBvcnQgbm9uLXN0YW5kYXJkIFNhZmFyaSAxMC5cIik7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItLXNvdXJjZS1tYXAgW29wdGlvbnNdXCIsIFwiRW5hYmxlIHNvdXJjZSBtYXAvc3BlY2lmeSBzb3VyY2UgbWFwIG9wdGlvbnMuXCIsIHBhcnNlX2pzKCkpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLS10aW1pbmdzXCIsIFwiRGlzcGxheSBvcGVyYXRpb25zIHJ1biB0aW1lIG9uIFNUREVSUi5cIik7XG4gICAgcHJvZ3JhbS5vcHRpb24oXCItLXRvcGxldmVsXCIsIFwiQ29tcHJlc3MgYW5kL29yIG1hbmdsZSB2YXJpYWJsZXMgaW4gdG9wbGV2ZWwgc2NvcGUuXCIpO1xuICAgIHByb2dyYW0ub3B0aW9uKFwiLS13cmFwIDxuYW1lPlwiLCBcIkVtYmVkIGV2ZXJ5dGhpbmcgYXMgYSBmdW5jdGlvbiB3aXRoIOKAnGV4cG9ydHPigJ0gY29ycmVzcG9uZGluZyB0byDigJxuYW1l4oCdIGdsb2JhbGx5LlwiKTtcbiAgICBwcm9ncmFtLmFyZ3VtZW50cyhcIltmaWxlcy4uLl1cIikucGFyc2VBcmd2KHByb2Nlc3MuYXJndik7XG4gICAgaWYgKHByb2dyYW0uY29uZmlnRmlsZSkge1xuICAgICAgICBvcHRpb25zID0gSlNPTi5wYXJzZShyZWFkX2ZpbGUocHJvZ3JhbS5jb25maWdGaWxlKSk7XG4gICAgfVxuICAgIGlmICghcHJvZ3JhbS5vdXRwdXQgJiYgcHJvZ3JhbS5zb3VyY2VNYXAgJiYgcHJvZ3JhbS5zb3VyY2VNYXAudXJsICE9IFwiaW5saW5lXCIpIHtcbiAgICAgICAgZmF0YWwoXCJFUlJPUjogY2Fubm90IHdyaXRlIHNvdXJjZSBtYXAgdG8gU1RET1VUXCIpO1xuICAgIH1cblxuICAgIFtcbiAgICAgICAgXCJjb21wcmVzc1wiLFxuICAgICAgICBcImVuY2xvc2VcIixcbiAgICAgICAgXCJpZThcIixcbiAgICAgICAgXCJtYW5nbGVcIixcbiAgICAgICAgXCJtb2R1bGVcIixcbiAgICAgICAgXCJzYWZhcmkxMFwiLFxuICAgICAgICBcInNvdXJjZU1hcFwiLFxuICAgICAgICBcInRvcGxldmVsXCIsXG4gICAgICAgIFwid3JhcFwiXG4gICAgXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgaW4gcHJvZ3JhbSkge1xuICAgICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IHByb2dyYW1bbmFtZV07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChcImVjbWFcIiBpbiBwcm9ncmFtKSB7XG4gICAgICAgIGlmIChwcm9ncmFtLmVjbWEgIT0gKHByb2dyYW0uZWNtYSB8IDApKSBmYXRhbChcIkVSUk9SOiBlY21hIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcbiAgICAgICAgY29uc3QgZWNtYSA9IHByb2dyYW0uZWNtYSB8IDA7XG4gICAgICAgIGlmIChlY21hID4gNSAmJiBlY21hIDwgMjAxNSlcbiAgICAgICAgICAgIG9wdGlvbnMuZWNtYSA9IGVjbWEgKyAyMDA5O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvcHRpb25zLmVjbWEgPSBlY21hO1xuICAgIH1cbiAgICBpZiAocHJvZ3JhbS5mb3JtYXQgfHwgcHJvZ3JhbS5iZWF1dGlmeSkge1xuICAgICAgICBjb25zdCBjaG9zZW5PcHRpb24gPSBwcm9ncmFtLmZvcm1hdCB8fCBwcm9ncmFtLmJlYXV0aWZ5O1xuICAgICAgICBvcHRpb25zLmZvcm1hdCA9IHR5cGVvZiBjaG9zZW5PcHRpb24gPT09IFwib2JqZWN0XCIgPyBjaG9zZW5PcHRpb24gOiB7fTtcbiAgICB9XG4gICAgaWYgKHByb2dyYW0uY29tbWVudHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmZvcm1hdCAhPSBcIm9iamVjdFwiKSBvcHRpb25zLmZvcm1hdCA9IHt9O1xuICAgICAgICBvcHRpb25zLmZvcm1hdC5jb21tZW50cyA9IHR5cGVvZiBwcm9ncmFtLmNvbW1lbnRzID09IFwic3RyaW5nXCIgPyAocHJvZ3JhbS5jb21tZW50cyA9PSBcImZhbHNlXCIgPyBmYWxzZSA6IHByb2dyYW0uY29tbWVudHMpIDogXCJzb21lXCI7XG4gICAgfVxuICAgIGlmIChwcm9ncmFtLmRlZmluZSkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29tcHJlc3MgIT0gXCJvYmplY3RcIikgb3B0aW9ucy5jb21wcmVzcyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY29tcHJlc3MuZ2xvYmFsX2RlZnMgIT0gXCJvYmplY3RcIikgb3B0aW9ucy5jb21wcmVzcy5nbG9iYWxfZGVmcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBleHByIGluIHByb2dyYW0uZGVmaW5lKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNvbXByZXNzLmdsb2JhbF9kZWZzW2V4cHJdID0gcHJvZ3JhbS5kZWZpbmVbZXhwcl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2dyYW0ua2VlcENsYXNzbmFtZXMpIHtcbiAgICAgICAgb3B0aW9ucy5rZWVwX2NsYXNzbmFtZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvZ3JhbS5rZWVwRm5hbWVzKSB7XG4gICAgICAgIG9wdGlvbnMua2VlcF9mbmFtZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvZ3JhbS5tYW5nbGVQcm9wcykge1xuICAgICAgICBpZiAocHJvZ3JhbS5tYW5nbGVQcm9wcy5kb21wcm9wcykge1xuICAgICAgICAgICAgZGVsZXRlIHByb2dyYW0ubWFuZ2xlUHJvcHMuZG9tcHJvcHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb2dyYW0ubWFuZ2xlUHJvcHMgIT0gXCJvYmplY3RcIikgcHJvZ3JhbS5tYW5nbGVQcm9wcyA9IHt9O1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb2dyYW0ubWFuZ2xlUHJvcHMucmVzZXJ2ZWQpKSBwcm9ncmFtLm1hbmdsZVByb3BzLnJlc2VydmVkID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1hbmdsZSAhPSBcIm9iamVjdFwiKSBvcHRpb25zLm1hbmdsZSA9IHt9O1xuICAgICAgICBvcHRpb25zLm1hbmdsZS5wcm9wZXJ0aWVzID0gcHJvZ3JhbS5tYW5nbGVQcm9wcztcbiAgICB9XG4gICAgaWYgKHByb2dyYW0ubmFtZUNhY2hlKSB7XG4gICAgICAgIG9wdGlvbnMubmFtZUNhY2hlID0gSlNPTi5wYXJzZShyZWFkX2ZpbGUocHJvZ3JhbS5uYW1lQ2FjaGUsIFwie31cIikpO1xuICAgIH1cbiAgICBpZiAocHJvZ3JhbS5vdXRwdXQgPT0gXCJhc3RcIikge1xuICAgICAgICBvcHRpb25zLmZvcm1hdCA9IHtcbiAgICAgICAgICAgIGFzdDogdHJ1ZSxcbiAgICAgICAgICAgIGNvZGU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChwcm9ncmFtLnBhcnNlKSB7XG4gICAgICAgIGlmICghcHJvZ3JhbS5wYXJzZS5hY29ybiAmJiAhcHJvZ3JhbS5wYXJzZS5zcGlkZXJtb25rZXkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMucGFyc2UgPSBwcm9ncmFtLnBhcnNlO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2dyYW0uc291cmNlTWFwICYmIHByb2dyYW0uc291cmNlTWFwLmNvbnRlbnQgPT0gXCJpbmxpbmVcIikge1xuICAgICAgICAgICAgZmF0YWwoXCJFUlJPUjogaW5saW5lIHNvdXJjZSBtYXAgb25seSB3b3JrcyB3aXRoIGJ1aWx0LWluIHBhcnNlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAofnByb2dyYW0ucmF3QXJncy5pbmRleE9mKFwiLS1yZW5hbWVcIikpIHtcbiAgICAgICAgb3B0aW9ucy5yZW5hbWUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXByb2dyYW0ucmVuYW1lKSB7XG4gICAgICAgIG9wdGlvbnMucmVuYW1lID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGNvbnZlcnRfcGF0aCA9IG5hbWUgPT4gbmFtZTtcbiAgICBpZiAodHlwZW9mIHByb2dyYW0uc291cmNlTWFwID09IFwib2JqZWN0XCIgJiYgXCJiYXNlXCIgaW4gcHJvZ3JhbS5zb3VyY2VNYXApIHtcbiAgICAgICAgY29udmVydF9wYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IHByb2dyYW0uc291cmNlTWFwLmJhc2U7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5zb3VyY2VNYXAuYmFzZTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGgucmVsYXRpdmUoYmFzZSwgbmFtZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgfVxuXG4gICAgbGV0IGZpbGVzTGlzdDtcbiAgICBpZiAob3B0aW9ucy5maWxlcyAmJiBvcHRpb25zLmZpbGVzLmxlbmd0aCkge1xuICAgICAgICBmaWxlc0xpc3QgPSBvcHRpb25zLmZpbGVzO1xuXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmZpbGVzO1xuICAgIH0gZWxzZSBpZiAocHJvZ3JhbS5hcmdzLmxlbmd0aCkge1xuICAgICAgICBmaWxlc0xpc3QgPSBwcm9ncmFtLmFyZ3M7XG4gICAgfVxuXG4gICAgaWYgKGZpbGVzTGlzdCkge1xuICAgICAgICBzaW1wbGVfZ2xvYihmaWxlc0xpc3QpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgZmlsZXNbY29udmVydF9wYXRoKG5hbWUpXSA9IHJlYWRfZmlsZShuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHZhciBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgIHByb2Nlc3Muc3RkaW4uc2V0RW5jb2RpbmcoXCJ1dGY4XCIpO1xuICAgICAgICAgICAgcHJvY2Vzcy5zdGRpbi5vbihcImRhdGFcIiwgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICB9KS5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmaWxlcyA9IFsgY2h1bmtzLmpvaW4oXCJcIikgXTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb2Nlc3Muc3RkaW4ucmVzdW1lKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGF3YWl0IHJ1bl9jbGkoKTtcblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRfYXN0KGZuKSB7XG4gICAgICAgIHJldHVybiBBU1RfTm9kZS5mcm9tX21vemlsbGFfYXN0KE9iamVjdC5rZXlzKGZpbGVzKS5yZWR1Y2UoZm4sIG51bGwpKTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBydW5fY2xpKCkge1xuICAgICAgICB2YXIgY29udGVudCA9IHByb2dyYW0uc291cmNlTWFwICYmIHByb2dyYW0uc291cmNlTWFwLmNvbnRlbnQ7XG4gICAgICAgIGlmIChjb250ZW50ICYmIGNvbnRlbnQgIT09IFwiaW5saW5lXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc291cmNlTWFwLmNvbnRlbnQgPSByZWFkX2ZpbGUoY29udGVudCwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW0udGltaW5ncykgb3B0aW9ucy50aW1pbmdzID0gdHJ1ZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHByb2dyYW0ucGFyc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvZ3JhbS5wYXJzZS5hY29ybikge1xuICAgICAgICAgICAgICAgICAgICBmaWxlcyA9IGNvbnZlcnRfYXN0KGZ1bmN0aW9uKHRvcGxldmVsLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWlyZShcImFjb3JuXCIpLnBhcnNlKGZpbGVzW25hbWVdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWNtYVZlcnNpb246IDIwMTgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25zOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW06IHRvcGxldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUZpbGU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVHlwZTogb3B0aW9ucy5tb2R1bGUgfHwgcHJvZ3JhbS5wYXJzZS5tb2R1bGUgPyBcIm1vZHVsZVwiIDogXCJzY3JpcHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvZ3JhbS5wYXJzZS5zcGlkZXJtb25rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZXMgPSBjb252ZXJ0X2FzdChmdW5jdGlvbih0b3BsZXZlbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IEpTT04ucGFyc2UoZmlsZXNbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0b3BsZXZlbCkgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcGxldmVsLmJvZHkgPSB0b3BsZXZlbC5ib2R5LmNvbmNhdChvYmouYm9keSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9wbGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGZhdGFsKGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBtaW5pZnkoZmlsZXMsIG9wdGlvbnMpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT0gXCJTeW50YXhFcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRfZXJyb3IoXCJQYXJzZSBlcnJvciBhdCBcIiArIGV4LmZpbGVuYW1lICsgXCI6XCIgKyBleC5saW5lICsgXCIsXCIgKyBleC5jb2wpO1xuICAgICAgICAgICAgICAgIHZhciBjb2wgPSBleC5jb2w7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gZmlsZXNbZXguZmlsZW5hbWVdLnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tleC5saW5lIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5lICYmICFjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmVzW2V4LmxpbmUgLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgY29sID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW1pdCA9IDcwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKGNvbCAtIGxpbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbCA9IGxpbWl0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByaW50X2Vycm9yKGxpbmUuc2xpY2UoMCwgODApKTtcbiAgICAgICAgICAgICAgICAgICAgcHJpbnRfZXJyb3IobGluZS5zbGljZSgwLCBjb2wpLnJlcGxhY2UoL1xcUy9nLCBcIiBcIikgKyBcIl5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4LmRlZnMpIHtcbiAgICAgICAgICAgICAgICBwcmludF9lcnJvcihcIlN1cHBvcnRlZCBvcHRpb25zOlwiKTtcbiAgICAgICAgICAgICAgICBwcmludF9lcnJvcihmb3JtYXRfb2JqZWN0KGV4LmRlZnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZhdGFsKGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9ncmFtLm91dHB1dCA9PSBcImFzdFwiKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuY29tcHJlc3MgJiYgIW9wdGlvbnMubWFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFzdC5maWd1cmVfb3V0X3Njb3BlKHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHJlc3VsdC5hc3QsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwidGhlZGVmXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1kZWYodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcImVuY2xvc2VkXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPyB2YWx1ZS5tYXAoc3ltZGVmKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJ2YXJpYWJsZXNcIjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJnbG9iYWxzXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zaXplID8gY29sbGVjdF9mcm9tX21hcCh2YWx1ZSwgc3ltZGVmKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNraXBfa2V5cy5oYXMoa2V5KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFTVF9Ub2tlbikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFTVF9Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3M6IFwiQVNUX1wiICsgdmFsdWUuVFlQRVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuYmxvY2tfc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YXJpYWJsZXMgPSB2YWx1ZS5ibG9ja19zY29wZS52YXJpYWJsZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuZW5jbG9zZWQgPSB2YWx1ZS5ibG9ja19zY29wZS5lbmNsb3NlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5DVE9SLlBST1BTLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gdmFsdWVbcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LCAyKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvZ3JhbS5vdXRwdXQgPT0gXCJzcGlkZXJtb25rZXlcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5pZmllZCA9IGF3YWl0IG1pbmlmeShyZXN1bHQuY29kZSwge1xuICAgICAgICAgICAgICAgICAgICBjb21wcmVzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1hbmdsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KG1pbmlmaWVkLmFzdC50b19tb3ppbGxhX2FzdCgpLCBudWxsLCAyKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGZhdGFsKGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJvZ3JhbS5vdXRwdXQpIHtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMocHJvZ3JhbS5vdXRwdXQsIHJlc3VsdC5jb2RlKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcCAmJiBvcHRpb25zLnNvdXJjZU1hcC51cmwgIT09IFwiaW5saW5lXCIgJiYgcmVzdWx0Lm1hcCkge1xuICAgICAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMocHJvZ3JhbS5vdXRwdXQgKyBcIi5tYXBcIiwgcmVzdWx0Lm1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQuY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW0ubmFtZUNhY2hlKSB7XG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHByb2dyYW0ubmFtZUNhY2hlLCBKU09OLnN0cmluZ2lmeShvcHRpb25zLm5hbWVDYWNoZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQudGltaW5ncykgZm9yICh2YXIgcGhhc2UgaW4gcmVzdWx0LnRpbWluZ3MpIHtcbiAgICAgICAgICAgIHByaW50X2Vycm9yKFwiLSBcIiArIHBoYXNlICsgXCI6IFwiICsgcmVzdWx0LnRpbWluZ3NbcGhhc2VdLnRvRml4ZWQoMykgKyBcInNcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYXRhbChtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIG1lc3NhZ2UgPSBtZXNzYWdlLnN0YWNrLnJlcGxhY2UoL15cXFMqP0Vycm9yOi8sIFwiRVJST1I6XCIpO1xuICAgICAgICBwcmludF9lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cblxuICAgIC8vIEEgZmlsZSBnbG9iIGZ1bmN0aW9uIHRoYXQgb25seSBzdXBwb3J0cyBcIipcIiBhbmQgXCI/XCIgd2lsZGNhcmRzIGluIHRoZSBiYXNlbmFtZS5cbiAgICAvLyBFeGFtcGxlOiBcImZvby9iYXIvKmJhej8/LiouanNcIlxuICAgIC8vIEFyZ3VtZW50IGBnbG9iYCBtYXkgYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHN0cmluZ3MuIEdhcmJhZ2UgaW4sIGdhcmJhZ2Ugb3V0LlxuICAgIGZ1bmN0aW9uIHNpbXBsZV9nbG9iKGdsb2IpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZ2xvYikpIHtcbiAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGdsb2IubWFwKHNpbXBsZV9nbG9iKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsb2IgJiYgZ2xvYi5tYXRjaCgvWyo/XS8pKSB7XG4gICAgICAgICAgICB2YXIgZGlyID0gcGF0aC5kaXJuYW1lKGdsb2IpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgZW50cmllcyA9IGZzLnJlYWRkaXJTeW5jKGRpcik7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge31cbiAgICAgICAgICAgIGlmIChlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBcIl5cIiArIHBhdGguYmFzZW5hbWUoZ2xvYilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1suK14kW1xcXVxcXFwoKXt9XS9nLCBcIlxcXFwkJlwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwqL2csIFwiW14vXFxcXFxcXFxdKlwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFw/L2csIFwiW14vXFxcXFxcXFxdXCIpICsgXCIkXCI7XG4gICAgICAgICAgICAgICAgdmFyIG1vZCA9IHByb2Nlc3MucGxhdGZvcm0gPT09IFwid2luMzJcIiA/IFwiaVwiIDogXCJcIjtcbiAgICAgICAgICAgICAgICB2YXIgcnggPSBuZXcgUmVnRXhwKHBhdHRlcm4sIG1vZCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByeC50ZXN0KG5hbWUpO1xuICAgICAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLmpvaW4oZGlyLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGgpIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbIGdsb2IgXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkX2ZpbGUocGF0aCwgZGVmYXVsdF92YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhwYXRoLCBcInV0ZjhcIik7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBpZiAoKGV4LmNvZGUgPT0gXCJFTk9FTlRcIiB8fCBleC5jb2RlID09IFwiRU5BTUVUT09MT05HXCIpICYmIGRlZmF1bHRfdmFsdWUgIT0gbnVsbCkgcmV0dXJuIGRlZmF1bHRfdmFsdWU7XG4gICAgICAgICAgICBmYXRhbChleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZV9qcyhmbGFnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdhbGsocGFyc2UodmFsdWUsIHsgZXhwcmVzc2lvbjogdHJ1ZSB9KSwgbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX0Fzc2lnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBub2RlLmxlZnQucHJpbnRfdG9fc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQVNUX0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tuYW1lXSA9IHZhbHVlLmVsZW1lbnRzLm1hcCh0b19zdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFTVF9SZWdFeHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSBuZXcgUmVnRXhwKHZhbHVlLnNvdXJjZSwgdmFsdWUuZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gdG9fc3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgQVNUX1N5bWJvbCB8fCBub2RlIGluc3RhbmNlb2YgQVNUX1Byb3BBY2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5wcmludF90b19zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIEFTVF9TZXF1ZW5jZSkpIHRocm93IG5vZGU7XG5cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdG9fc3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBBU1RfQ29uc3RhbnQgPyB2YWx1ZS5nZXRWYWx1ZSgpIDogdmFsdWUucHJpbnRfdG9fc3RyaW5nKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdW90ZV9rZXlzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhdGFsKFwiRXJyb3IgcGFyc2luZyBhcmd1bWVudHMgZm9yICdcIiArIGZsYWcgKyBcIic6IFwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbdmFsdWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzeW1kZWYoZGVmKSB7XG4gICAgICAgIHZhciByZXQgPSAoMWU2ICsgZGVmLmlkKSArIFwiIFwiICsgZGVmLm5hbWU7XG4gICAgICAgIGlmIChkZWYubWFuZ2xlZF9uYW1lKSByZXQgKz0gXCIgXCIgKyBkZWYubWFuZ2xlZF9uYW1lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbGxlY3RfZnJvbV9tYXAobWFwLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uIChkZWYpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrKGRlZikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRfb2JqZWN0KG9iaikge1xuICAgICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBcIlwiO1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBpZiAocGFkZGluZy5sZW5ndGggPCBuYW1lLmxlbmd0aCkgcGFkZGluZyA9IEFycmF5KG5hbWUubGVuZ3RoICsgMSkuam9pbihcIiBcIik7XG4gICAgICAgICAgICByZXR1cm4gWyBuYW1lLCBKU09OLnN0cmluZ2lmeShvYmpbbmFtZV0pIF07XG4gICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24odG9rZW5zKSB7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKFwiICBcIiArIHRva2Vuc1swXSArIHBhZGRpbmcuc2xpY2UodG9rZW5zWzBdLmxlbmd0aCAtIDIpICsgdG9rZW5zWzFdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByaW50X2Vycm9yKG1zZykge1xuICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShtc2cpO1xuICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShcIlxcblwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXNjcmliZV9hc3QoKSB7XG4gICAgICAgIHZhciBvdXQgPSBPdXRwdXRTdHJlYW0oeyBiZWF1dGlmeTogdHJ1ZSB9KTtcbiAgICAgICAgZnVuY3Rpb24gZG9pdGVtKGN0b3IpIHtcbiAgICAgICAgICAgIG91dC5wcmludChcIkFTVF9cIiArIGN0b3IuVFlQRSk7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IGN0b3IuU0VMRl9QUk9QUy5maWx0ZXIocHJvcCA9PiAhL15cXCQvLnRlc3QocHJvcCkpO1xuXG4gICAgICAgICAgICBpZiAocHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG91dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgIG91dC53aXRoX3BhcmVucyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSkgb3V0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHJpbnQocHJvcCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3Rvci5kb2N1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3V0LnNwYWNlKCk7XG4gICAgICAgICAgICAgICAgb3V0LnByaW50X3N0cmluZyhjdG9yLmRvY3VtZW50YXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3Rvci5TVUJDTEFTU0VTLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBvdXQuc3BhY2UoKTtcbiAgICAgICAgICAgICAgICBvdXQud2l0aF9ibG9jayhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Rvci5TVUJDTEFTU0VTLmZvckVhY2goZnVuY3Rpb24oY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9pdGVtKGN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0Lm5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZG9pdGVtKEFTVF9Ob2RlKTtcbiAgICAgICAgcmV0dXJuIG91dCArIFwiXFxuXCI7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBfZGVmYXVsdF9vcHRpb25zKCkge1xuICAgIGNvbnN0IGRlZnMgPSB7fTtcblxuICAgIE9iamVjdC5rZXlzKGluZmVyX29wdGlvbnMoeyAwOiAwIH0pKS5mb3JFYWNoKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGluZmVyX29wdGlvbnMoe1xuICAgICAgICAgICAgW2NvbXBvbmVudF06IHswOiAwfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAob3B0aW9ucykgZGVmc1tjb21wb25lbnRdID0gb3B0aW9ucztcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5mZXJfb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbWluaWZ5KFwiXCIsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5kZWZzO1xuICAgIH1cbn1cblxuZXhwb3J0cy5fZGVmYXVsdF9vcHRpb25zID0gX2RlZmF1bHRfb3B0aW9ucztcbmV4cG9ydHMuX3J1bl9jbGkgPSBydW5fY2xpO1xuZXhwb3J0cy5taW5pZnkgPSBtaW5pZnk7XG5cbn0pKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/terser/dist/bundle.min.js\n");

/***/ }),

/***/ "./node_modules/terser/node_modules/source-map/lib/array-set.js":
/*!**********************************************************************!*\
  !*** ./node_modules/terser/node_modules/source-map/lib/array-set.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nclass ArraySet {\n  constructor() {\n    this._array = [];\n    this._set = new Map();\n  }\n\n  /**\n   * Static method for creating ArraySet instances from an existing array.\n   */\n  static fromArray(aArray, aAllowDuplicates) {\n    const set = new ArraySet();\n    for (let i = 0, len = aArray.length; i < len; i++) {\n      set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n  }\n\n  /**\n   * Return how many unique items are in this ArraySet. If duplicates have been\n   * added, than those do not count towards the size.\n   *\n   * @returns Number\n   */\n  size() {\n    return this._set.size;\n  }\n\n  /**\n   * Add the given string to this set.\n   *\n   * @param String aStr\n   */\n  add(aStr, aAllowDuplicates) {\n    const isDuplicate = this.has(aStr);\n    const idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n      this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n      this._set.set(aStr, idx);\n    }\n  }\n\n  /**\n   * Is the given string a member of this set?\n   *\n   * @param String aStr\n   */\n  has(aStr) {\n      return this._set.has(aStr);\n  }\n\n  /**\n   * What is the index of the given string in the array?\n   *\n   * @param String aStr\n   */\n  indexOf(aStr) {\n    const idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n  }\n\n  /**\n   * What is the element at the given index?\n   *\n   * @param Number aIdx\n   */\n  at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n      return this._array[aIdx];\n    }\n    throw new Error(\"No element indexed by \" + aIdx);\n  }\n\n  /**\n   * Returns the array representation of this set (which has the proper indices\n   * indicated by indexOf). Note that this is a copy of the internal array used\n   * for storing the members so that no one can mess with internal state.\n   */\n  toArray() {\n    return this._array.slice();\n  }\n}\nexports.ArraySet = ArraySet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9hcnJheS1zZXQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbS1sZXZpdHkvLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9hcnJheS1zZXQuanM/YWVjOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB3aGljaCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFuIGFycmF5IGFuZCBhIHNldC4gQWRkaW5nIGEgbmV3XG4gKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAqIGVsZW1lbnQgaXMgTygxKS4gUmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHlcbiAqIHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgbWVtYmVyc2hpcC5cbiAqL1xuY2xhc3MgQXJyYXlTZXQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9hcnJheSA9IFtdO1xuICAgIHRoaXMuX3NldCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAgICovXG4gIHN0YXRpYyBmcm9tQXJyYXkoYUFycmF5LCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgY29uc3Qgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBob3cgbWFueSB1bmlxdWUgaXRlbXMgYXJlIGluIHRoaXMgQXJyYXlTZXQuIElmIGR1cGxpY2F0ZXMgaGF2ZSBiZWVuXG4gICAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICAgKlxuICAgKiBAcmV0dXJucyBOdW1iZXJcbiAgICovXG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldC5zaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIGFkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgY29uc3QgaXNEdXBsaWNhdGUgPSB0aGlzLmhhcyhhU3RyKTtcbiAgICBjb25zdCBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gICAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICAgIH1cbiAgICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgICB0aGlzLl9zZXQuc2V0KGFTdHIsIGlkeCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gICAqXG4gICAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICAgKi9cbiAgaGFzKGFTdHIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXQuaGFzKGFTdHIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICAgKlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAgICovXG4gIGluZGV4T2YoYVN0cikge1xuICAgIGNvbnN0IGlkeCA9IHRoaXMuX3NldC5nZXQoYVN0cik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAgICpcbiAgICogQHBhcmFtIE51bWJlciBhSWR4XG4gICAqL1xuICBhdChhSWR4KSB7XG4gICAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVsZW1lbnQgaW5kZXhlZCBieSBcIiArIGFJZHgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gICAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gICAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gICAqL1xuICB0b0FycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xuICB9XG59XG5leHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/terser/node_modules/source-map/lib/array-set.js\n");

/***/ }),

/***/ "./node_modules/terser/node_modules/source-map/lib/base64-vlq.js":
/*!***********************************************************************!*\
  !*** ./node_modules/terser/node_modules/source-map/lib/base64-vlq.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst base64 = __webpack_require__(/*! ./base64 */ \"./node_modules/terser/node_modules/source-map/lib/base64.js\");\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nconst VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nconst VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nconst VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nconst VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\n// eslint-disable-next-line no-unused-vars\nfunction fromVLQSigned(aValue) {\n  const isNegative = (aValue & 1) === 1;\n  const shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  let encoded = \"\";\n  let digit;\n\n  let vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQtdmxxLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDZFQUFVOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbS1sZXZpdHkvLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQtdmxxLmpzPzE2ZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKFwiLi9iYXNlNjRcIik7XG5cbi8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4vLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbi8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbi8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuLy9cbi8vICAgQ29udGludWF0aW9uXG4vLyAgIHwgICAgU2lnblxuLy8gICB8ICAgIHxcbi8vICAgViAgICBWXG4vLyAgIDEwMTAxMVxuXG5jb25zdCBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG5jb25zdCBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbi8vIGJpbmFyeTogMDExMTExXG5jb25zdCBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxuY29uc3QgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuLyoqXG4gKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICovXG5mdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gIGNvbnN0IGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gIGNvbnN0IHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICA/IC1zaGlmdGVkXG4gICAgOiBzaGlmdGVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgbGV0IGVuY29kZWQgPSBcIlwiO1xuICBsZXQgZGlnaXQ7XG5cbiAgbGV0IHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgZG8ge1xuICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICBpZiAodmxxID4gMCkge1xuICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICB9XG4gICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/terser/node_modules/source-map/lib/base64-vlq.js\n");

/***/ }),

/***/ "./node_modules/terser/node_modules/source-map/lib/base64.js":
/*!*******************************************************************!*\
  !*** ./node_modules/terser/node_modules/source-map/lib/base64.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst intToCharMap = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function(number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW0tbGV2aXR5Ly4vbm9kZV9tb2R1bGVzL3RlcnNlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvYmFzZTY0LmpzP2IwYzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG5jb25zdCBpbnRUb0NoYXJNYXAgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5zcGxpdChcIlwiKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKG51bWJlcikge1xuICBpZiAoMCA8PSBudW1iZXIgJiYgbnVtYmVyIDwgaW50VG9DaGFyTWFwLmxlbmd0aCkge1xuICAgIHJldHVybiBpbnRUb0NoYXJNYXBbbnVtYmVyXTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDYzOiBcIiArIG51bWJlcik7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/terser/node_modules/source-map/lib/base64.js\n");

/***/ }),

/***/ "./node_modules/terser/node_modules/source-map/lib/binary-search.js":
/*!**************************************************************************!*\
  !*** ./node_modules/terser/node_modules/source-map/lib/binary-search.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  const mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  const cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  } else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    }\n    return mid;\n  }\n\n  // Our needle is less than aHaystack[mid].\n  if (mid - aLow > 1) {\n    // The element is in the lower half.\n    return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n  }\n\n  // we are in termination case (3) or (2) and return the appropriate thing.\n  if (aBias == exports.LEAST_UPPER_BOUND) {\n    return mid;\n  }\n  return aLow < 0 ? -1 : aLow;\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  let index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tLWxldml0eS8uL25vZGVfbW9kdWxlcy90ZXJzZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL2JpbmFyeS1zZWFyY2guanM/ODRkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgY29uc3QgY21wID0gYUNvbXBhcmUoYU5lZWRsZSwgYUhheXN0YWNrW21pZF0sIHRydWUpO1xuICBpZiAoY21wID09PSAwKSB7XG4gICAgLy8gRm91bmQgdGhlIGVsZW1lbnQgd2UgYXJlIGxvb2tpbmcgZm9yLlxuICAgIHJldHVybiBtaWQ7XG4gIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgIC8vIE91ciBuZWVkbGUgaXMgZ3JlYXRlciB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgIGlmIChhSGlnaCAtIG1pZCA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGV4YWN0IG5lZWRsZSBlbGVtZW50IHdhcyBub3QgZm91bmQgaW4gdGhpcyBoYXlzdGFjay4gRGV0ZXJtaW5lIGlmXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIGFIaWdoIDwgYUhheXN0YWNrLmxlbmd0aCA/IGFIaWdoIDogLTE7XG4gICAgfVxuICAgIHJldHVybiBtaWQ7XG4gIH1cblxuICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIGxvd2VyIGhhbGYuXG4gICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgfVxuXG4gIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG59XG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAqXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICovXG5leHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGxldCBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLS1pbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/terser/node_modules/source-map/lib/binary-search.js\n");

/***/ }),

/***/ "./node_modules/terser/node_modules/source-map/lib/mapping-list.js":
/*!*************************************************************************!*\
  !*** ./node_modules/terser/node_modules/source-map/lib/mapping-list.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/terser/node_modules/source-map/lib/util.js\");\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  const lineA = mappingA.generatedLine;\n  const lineB = mappingB.generatedLine;\n  const columnA = mappingA.generatedColumn;\n  const columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a negligible overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nclass MappingList {\n  constructor() {\n    this._array = [];\n    this._sorted = true;\n    // Serves as infimum\n    this._last = {generatedLine: -1, generatedColumn: 0};\n  }\n\n  /**\n   * Iterate through internal items. This method takes the same arguments that\n   * `Array.prototype.forEach` takes.\n   *\n   * NOTE: The order of the mappings is NOT guaranteed.\n   */\n  unsortedForEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  }\n\n  /**\n   * Add the given source mapping.\n   *\n   * @param Object aMapping\n   */\n  add(aMapping) {\n    if (generatedPositionAfter(this._last, aMapping)) {\n      this._last = aMapping;\n      this._array.push(aMapping);\n    } else {\n      this._sorted = false;\n      this._array.push(aMapping);\n    }\n  }\n\n  /**\n   * Returns the flat, sorted array of mappings. The mappings are sorted by\n   * generated position.\n   *\n   * WARNING: This method returns internal data without copying, for\n   * performance. The return value must NOT be mutated, and should be treated as\n   * an immutable borrow. If you want to take ownership, you must make your own\n   * copy.\n   */\n  toArray() {\n    if (!this._sorted) {\n      this._array.sort(util.compareByGeneratedPositionsInflated);\n      this._sorted = true;\n    }\n    return this._array;\n  }\n}\n\nexports.MappingList = MappingList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyx5RUFBUTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tLWxldml0eS8uL25vZGVfbW9kdWxlcy90ZXJzZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL21hcHBpbmctbGlzdC5qcz9kMmQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICogcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICBjb25zdCBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gIGNvbnN0IGxpbmVCID0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgY29uc3QgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgY29uc3QgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbn1cblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWdpYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICovXG5jbGFzcyBNYXBwaW5nTGlzdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2FycmF5ID0gW107XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICAvLyBTZXJ2ZXMgYXMgaW5maW11bVxuICAgIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG4gIH1cblxuICAvKipcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICAgKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICAgKi9cbiAgdW5zb3J0ZWRGb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAgICovXG4gIGFkZChhTWFwcGluZykge1xuICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgICAgdGhpcy5fbGFzdCA9IGFNYXBwaW5nO1xuICAgICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAgICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICAgKlxuICAgKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAgICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gICAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gICAqIGNvcHkuXG4gICAqL1xuICB0b0FycmF5KCkge1xuICAgIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgICB0aGlzLl9hcnJheS5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQpO1xuICAgICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5O1xuICB9XG59XG5cbmV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/terser/node_modules/source-map/lib/mapping-list.js\n");

/***/ }),

/***/ "./node_modules/terser/node_modules/source-map/lib/read-wasm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/terser/node_modules/source-map/lib/read-wasm.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var __dirname = \"/\";\nif (typeof fetch === \"function\") {\n  // Web version of reading a wasm file into an array buffer.\n\n  let mappingsWasmUrl = null;\n\n  module.exports = function readWasm() {\n    if (typeof mappingsWasmUrl !== \"string\") {\n      throw new Error(\"You must provide the URL of lib/mappings.wasm by calling \" +\n                      \"SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) \" +\n                      \"before using SourceMapConsumer\");\n    }\n\n    return fetch(mappingsWasmUrl)\n      .then(response => response.arrayBuffer());\n  };\n\n  module.exports.initialize = url => mappingsWasmUrl = url;\n} else {\n  // Node version of reading a wasm file into an array buffer.\n  const fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'fs'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n  const path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'path'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n  module.exports = function readWasm() {\n    return new Promise((resolve, reject) => {\n      const wasmPath = path.join(__dirname, \"mappings.wasm\");\n      fs.readFile(wasmPath, null, (error, data) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(data.buffer);\n      });\n    });\n  };\n\n  module.exports.initialize = _ => {\n    console.debug(\"SourceMapConsumer.initialize is a no-op when running in node.js\");\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9yZWFkLXdhc20uanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDBCQUEwQjtBQUNoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLHlCQUF5QjtBQUMzQixFQUFFO0FBQ0Y7QUFDQSxhQUFhLG1CQUFPLENBQUMsaUlBQUk7QUFDekIsZUFBZSxtQkFBTyxDQUFDLG1JQUFNOztBQUU3QjtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUEsRUFBRSx5QkFBeUI7QUFDM0I7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW0tbGV2aXR5Ly4vbm9kZV9tb2R1bGVzL3RlcnNlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvcmVhZC13YXNtLmpzPzJiN2YiXSwic291cmNlc0NvbnRlbnQiOlsiaWYgKHR5cGVvZiBmZXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIC8vIFdlYiB2ZXJzaW9uIG9mIHJlYWRpbmcgYSB3YXNtIGZpbGUgaW50byBhbiBhcnJheSBidWZmZXIuXG5cbiAgbGV0IG1hcHBpbmdzV2FzbVVybCA9IG51bGw7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWFkV2FzbSgpIHtcbiAgICBpZiAodHlwZW9mIG1hcHBpbmdzV2FzbVVybCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcHJvdmlkZSB0aGUgVVJMIG9mIGxpYi9tYXBwaW5ncy53YXNtIGJ5IGNhbGxpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiU291cmNlTWFwQ29uc3VtZXIuaW5pdGlhbGl6ZSh7ICdsaWIvbWFwcGluZ3Mud2FzbSc6IC4uLiB9KSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgXCJiZWZvcmUgdXNpbmcgU291cmNlTWFwQ29uc3VtZXJcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZldGNoKG1hcHBpbmdzV2FzbVVybClcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpO1xuICB9O1xuXG4gIG1vZHVsZS5leHBvcnRzLmluaXRpYWxpemUgPSB1cmwgPT4gbWFwcGluZ3NXYXNtVXJsID0gdXJsO1xufSBlbHNlIHtcbiAgLy8gTm9kZSB2ZXJzaW9uIG9mIHJlYWRpbmcgYSB3YXNtIGZpbGUgaW50byBhbiBhcnJheSBidWZmZXIuXG4gIGNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuICBjb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWFkV2FzbSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3Qgd2FzbVBhdGggPSBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIm1hcHBpbmdzLndhc21cIik7XG4gICAgICBmcy5yZWFkRmlsZSh3YXNtUGF0aCwgbnVsbCwgKGVycm9yLCBkYXRhKSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShkYXRhLmJ1ZmZlcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cy5pbml0aWFsaXplID0gXyA9PiB7XG4gICAgY29uc29sZS5kZWJ1ZyhcIlNvdXJjZU1hcENvbnN1bWVyLmluaXRpYWxpemUgaXMgYSBuby1vcCB3aGVuIHJ1bm5pbmcgaW4gbm9kZS5qc1wiKTtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/terser/node_modules/source-map/lib/read-wasm.js\n");

/***/ }),

/***/ "./node_modules/terser/node_modules/source-map/lib/source-map-consumer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/terser/node_modules/source-map/lib/source-map-consumer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/terser/node_modules/source-map/lib/util.js\");\nconst binarySearch = __webpack_require__(/*! ./binary-search */ \"./node_modules/terser/node_modules/source-map/lib/binary-search.js\");\nconst ArraySet = __webpack_require__(/*! ./array-set */ \"./node_modules/terser/node_modules/source-map/lib/array-set.js\").ArraySet;\nconst base64VLQ = __webpack_require__(/*! ./base64-vlq */ \"./node_modules/terser/node_modules/source-map/lib/base64-vlq.js\"); // eslint-disable-line no-unused-vars\nconst readWasm = __webpack_require__(/*! ../lib/read-wasm */ \"./node_modules/terser/node_modules/source-map/lib/read-wasm.js\");\nconst wasm = __webpack_require__(/*! ./wasm */ \"./node_modules/terser/node_modules/source-map/lib/wasm.js\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n  static with(rawSourceMap, sourceMapUrl, f) {\n    // Note: The `acorn` version that `webpack` currently depends on doesn't\n    // support `async` functions, and the nodes that we support don't all have\n    // `.finally`. Therefore, this is written a bit more convolutedly than it\n    // should really be.\n\n    let consumer = null;\n    const promise = new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n    return promise\n      .then(c => {\n        consumer = c;\n        return f(c);\n      })\n      .then(x => {\n        if (consumer) {\n          consumer.destroy();\n        }\n        return x;\n      }, e => {\n        if (consumer) {\n          consumer.destroy();\n        }\n        throw e;\n      });\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  }\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      let sources = util.getArg(sourceMap, \"sources\");\n      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n      const names = util.getArg(sourceMap, \"names\", []);\n      let sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null);\n\n      // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      if (sourceRoot) {\n        sourceRoot = util.normalize(sourceRoot);\n      }\n\n      sources = sources\n        .map(String)\n        // Some source maps produce relative source paths like \"./foo.js\" instead of\n        // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n        // See bugzil.la/1090768.\n        .map(util.normalize)\n        // Always ensure that absolute sources are internally stored relative to\n        // the source root, if the source root is absolute. Not doing this would\n        // be particularly problematic when the source root is a prefix of the\n        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n        .map(function(source) {\n          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n            ? util.relative(sourceRoot, source)\n            : source;\n        });\n\n      // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n\n      that._absoluteSources = that._sources.toArray().map(function(s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      });\n\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n  _findSourceIndex(aSource) {\n    let relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    if (this._sources.has(relativeSource)) {\n      return this._sources.indexOf(relativeSource);\n    }\n\n    // Maybe aSource is an absolute URL as returned by |sources|.  In\n    // this case we can't simply undo the transform.\n    for (let i = 0; i < this._absoluteSources.length; ++i) {\n      if (this._absoluteSources[i] == aSource) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.slice();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this._mappingsPtr;\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    const size = aStr.length;\n\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n      let msg = `Error parsing mappings (code ${error}): `;\n\n      // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n      switch (error) {\n        case 1:\n          msg += \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n    const sourceRoot = this.sourceRoot;\n\n    this._wasm.withMappingCallback(\n      mapping => {\n        if (mapping.source !== null) {\n          mapping.source = this._sources.at(mapping.source);\n          mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);\n\n          if (mapping.name !== null) {\n            mapping.name = this._names.at(mapping.name);\n          }\n        }\n\n        aCallback.call(context, mapping);\n      },\n      () => {\n        switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          this._wasm.exports.by_generated_location(this._getMappingsPtr());\n          break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          this._wasm.exports.by_original_location(this._getMappingsPtr());\n          break;\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n        }\n      }\n    );\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(\n      m => {\n        let lastColumn = m.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        mappings.push({\n          line: m.generatedLine,\n          column: m.generatedColumn,\n          lastColumn,\n        });\n      }, () => {\n        this._wasm.exports.all_generated_locations_for(\n          this._getMappingsPtr(),\n          source,\n          originalLine - 1,\n          \"column\" in aArgs,\n          originalColumn\n        );\n      }\n    );\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n      this._mappingsPtr = 0;\n    }\n  }\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n    this._computedColumnSpans = true;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.original_location_for(\n        this._getMappingsPtr(),\n        needle.generatedLine - 1,\n        needle.generatedColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function(sc) { return sc == null; });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    let relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    let url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      const fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.generated_location_for(\n        this._getMappingsPtr(),\n        needle.source,\n        needle.originalLine - 1,\n        needle.originalColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn,\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sources = new ArraySet();\n      that._names = new ArraySet();\n      that.__generatedMappings = null;\n      that.__originalMappings = null;\n      that.__generatedMappingsUnsorted = null;\n      that.__originalMappingsUnsorted = null;\n\n      let lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(s => {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n        const offset = util.getArg(s, \"offset\");\n        const offsetLine = util.getArg(offset, \"line\");\n        const offsetColumn = util.getArg(offset, \"column\");\n\n        if (offsetLine < lastOffset.line ||\n            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n        lastOffset = offset;\n\n        const cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(consumer => {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer\n          };\n        });\n      })).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  }\n\n  // `__generatedMappings` and `__originalMappings` are arrays that hold the\n  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n  // are lazily instantiated, accessed via the `_generatedMappings` and\n  // `_originalMappings` getters respectively, and we only parse the mappings\n  // and create these arrays once queried for a source location. We jump through\n  // these hoops because there can be many thousands of mappings, and parsing\n  // them is expensive, so we only want to do it if we must.\n  //\n  // Each object in the arrays is of the form:\n  //\n  //     {\n  //       generatedLine: The line number in the generated code,\n  //       generatedColumn: The column number in the generated code,\n  //       source: The path to the original source file that generated this\n  //               chunk of code,\n  //       originalLine: The line number in the original source that\n  //                     corresponds to this chunk of generated code,\n  //       originalColumn: The column number in the original source that\n  //                       corresponds to this chunk of generated code,\n  //       name: The name of the original symbol which generated this chunk of\n  //             code.\n  //     }\n  //\n  // All properties except for `generatedLine` and `generatedColumn` can be\n  // `null`.\n  //\n  // `_generatedMappings` is ordered by the generated positions.\n  //\n  // `_originalMappings` is ordered by the original positions.\n  get _generatedMappings() {\n    if (!this.__generatedMappings) {\n      this._sortGeneratedMappings();\n    }\n\n    return this.__generatedMappings;\n  }\n\n  get _originalMappings() {\n    if (!this.__originalMappings) {\n      this._sortOriginalMappings();\n    }\n\n    return this.__originalMappings;\n  }\n\n  get _generatedMappingsUnsorted() {\n    if (!this.__generatedMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappingsUnsorted;\n  }\n\n  get _originalMappingsUnsorted() {\n    if (!this.__originalMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappingsUnsorted;\n  }\n\n  _sortGeneratedMappings() {\n    const mappings = this._generatedMappingsUnsorted;\n    mappings.sort(util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = mappings;\n  }\n\n  _sortOriginalMappings() {\n    const mappings = this._originalMappingsUnsorted;\n    mappings.sort(util.compareByOriginalPositions);\n    this.__originalMappings = mappings;\n  }\n\n  /**\n   * The list of original sources.\n   */\n  get sources() {\n    const sources = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    const sectionIndex = binarySearch.search(needle, this._sections,\n      function(aNeedle, section) {\n        const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (aNeedle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    return this._sections.every(function(s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, \"source\")) === -1) {\n        continue;\n      }\n      const generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        const ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    const generatedMappings = this.__generatedMappingsUnsorted = [];\n    const originalMappings = this.__originalMappingsUnsorted = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const sectionMappings = [];\n      section.consumer.eachMapping(m => sectionMappings.push(m));\n\n      for (let j = 0; j < sectionMappings.length; j++) {\n        const mapping = sectionMappings[j];\n\n        // TODO: test if null is correct here.  The original code used\n        // `source`, which would actually have gotten used as null because\n        // var's get hoisted.\n        // See: https://github.com/mozilla/source-map/issues/333\n        let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        let name = null;\n        if (mapping.name) {\n          this._names.add(mapping.name);\n          name = this._names.indexOf(mapping.name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        const adjustedMapping = {\n          source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name\n        };\n\n        generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === \"number\") {\n          originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    let mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    const sourceRoot = this.sourceRoot;\n    mappings.map(function(mapping) {\n      let source = null;\n      if (mapping.source !== null) {\n        source = this._sources.at(mapping.source);\n        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      }\n      return {\n        source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  }\n\n  /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */\n  _findMapping(aNeedle, aMappings, aLineName,\n              aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError(\"Line must be greater than or equal to 1, got \"\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError(\"Column must be greater than or equal to 0, got \"\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const line = util.getArg(aArgs, \"line\");\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    const needle = {\n      source: util.getArg(aArgs, \"source\"),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, \"column\", 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    let index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      let mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        const originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          let lastColumn = mapping.lastGeneratedColumn;\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn,\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        const originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          let lastColumn = mapping.lastGeneratedColumn;\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn,\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n}\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer = sourceMap.sections != null\n      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMseUVBQVE7QUFDN0IscUJBQXFCLG1CQUFPLENBQUMsMkZBQWlCO0FBQzlDLGlCQUFpQixpSEFBK0I7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMscUZBQWMsR0FBRztBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLHlFQUFROztBQUU3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsTUFBTTs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0I7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLHNCQUFzQiwrQ0FBK0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQzs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tLWxldml0eS8uL25vZGVfbW9kdWxlcy90ZXJzZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtY29uc3VtZXIuanM/YWQ1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgYmluYXJ5U2VhcmNoID0gcmVxdWlyZShcIi4vYmluYXJ5LXNlYXJjaFwiKTtcbmNvbnN0IEFycmF5U2V0ID0gcmVxdWlyZShcIi4vYXJyYXktc2V0XCIpLkFycmF5U2V0O1xuY29uc3QgYmFzZTY0VkxRID0gcmVxdWlyZShcIi4vYmFzZTY0LXZscVwiKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuY29uc3QgcmVhZFdhc20gPSByZXF1aXJlKFwiLi4vbGliL3JlYWQtd2FzbVwiKTtcbmNvbnN0IHdhc20gPSByZXF1aXJlKFwiLi93YXNtXCIpO1xuXG5jb25zdCBJTlRFUk5BTCA9IFN5bWJvbChcInNtY0ludGVybmFsXCIpO1xuXG5jbGFzcyBTb3VyY2VNYXBDb25zdW1lciB7XG4gIGNvbnN0cnVjdG9yKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgICAvLyBJZiB0aGUgY29uc3RydWN0b3Igd2FzIGNhbGxlZCBieSBzdXBlcigpLCBqdXN0IHJldHVybiBQcm9taXNlPHRoaXM+LlxuICAgIC8vIFllcywgdGhpcyBpcyBhIGhhY2sgdG8gcmV0YWluIHRoZSBwcmUtZXhpc3RpbmcgQVBJIG9mIHRoZSBiYXNlLWNsYXNzXG4gICAgLy8gY29uc3RydWN0b3IgYWxzbyBiZWluZyBhbiBhc3luYyBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgIGlmIChhU291cmNlTWFwID09IElOVEVSTkFMKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBfZmFjdG9yeShhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbiAgfVxuXG4gIHN0YXRpYyBpbml0aWFsaXplKG9wdHMpIHtcbiAgICByZWFkV2FzbS5pbml0aWFsaXplKG9wdHNbXCJsaWIvbWFwcGluZ3Mud2FzbVwiXSk7XG4gIH1cblxuICBzdGF0aWMgZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gICAgcmV0dXJuIF9mYWN0b3J5QlNNKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBgU291cmNlTWFwQ29uc3VtZXJgIGZyb20gYHJhd1NvdXJjZU1hcGAgYW5kIGBzb3VyY2VNYXBVcmxgXG4gICAqIChzZWUgdGhlIGBTb3VyY2VNYXBDb25zdW1lcmAgY29uc3RydWN0b3IgZm9yIGRldGFpbHMuIFRoZW4sIGludm9rZSB0aGUgYGFzeW5jXG4gICAqIGZ1bmN0aW9uIGYoU291cmNlTWFwQ29uc3VtZXIpIC0+IFRgIHdpdGggdGhlIG5ld2x5IGNvbnN0cnVjdGVkIGNvbnN1bWVyLCB3YWl0XG4gICAqIGZvciBgZmAgdG8gY29tcGxldGUsIGNhbGwgYGRlc3Ryb3lgIG9uIHRoZSBjb25zdW1lciwgYW5kIHJldHVybiBgZmAncyByZXR1cm5cbiAgICogdmFsdWUuXG4gICAqXG4gICAqIFlvdSBtdXN0IG5vdCB1c2UgdGhlIGNvbnN1bWVyIGFmdGVyIGBmYCBjb21wbGV0ZXMhXG4gICAqXG4gICAqIEJ5IHVzaW5nIGB3aXRoYCwgeW91IGRvIG5vdCBoYXZlIHRvIHJlbWVtYmVyIHRvIG1hbnVhbGx5IGNhbGwgYGRlc3Ryb3lgIG9uXG4gICAqIHRoZSBjb25zdW1lciwgc2luY2UgaXQgd2lsbCBiZSBjYWxsZWQgYXV0b21hdGljYWxseSBvbmNlIGBmYCBjb21wbGV0ZXMuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHhTcXVhcmVkID0gYXdhaXQgU291cmNlTWFwQ29uc3VtZXIud2l0aChcbiAgICogICBteVJhd1NvdXJjZU1hcCxcbiAgICogICBudWxsLFxuICAgKiAgIGFzeW5jIGZ1bmN0aW9uIChjb25zdW1lcikge1xuICAgKiAgICAgLy8gVXNlIGBjb25zdW1lcmAgaW5zaWRlIGhlcmUgYW5kIGRvbid0IHdvcnJ5IGFib3V0IHJlbWVtYmVyaW5nXG4gICAqICAgICAvLyB0byBjYWxsIGBkZXN0cm95YC5cbiAgICpcbiAgICogICAgIGNvbnN0IHggPSBhd2FpdCB3aGF0ZXZlcihjb25zdW1lcik7XG4gICAqICAgICByZXR1cm4geCAqIHg7XG4gICAqICAgfVxuICAgKiApO1xuICAgKlxuICAgKiAvLyBZb3UgbWF5IG5vdCB1c2UgdGhhdCBgY29uc3VtZXJgIGFueW1vcmUgb3V0IGhlcmU7IGl0IGhhc1xuICAgKiAvLyBiZWVuIGRlc3Ryb3llZC4gQnV0IHlvdSBjYW4gdXNlIGB4U3F1YXJlZGAuXG4gICAqIGNvbnNvbGUubG9nKHhTcXVhcmVkKTtcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgd2l0aChyYXdTb3VyY2VNYXAsIHNvdXJjZU1hcFVybCwgZikge1xuICAgIC8vIE5vdGU6IFRoZSBgYWNvcm5gIHZlcnNpb24gdGhhdCBgd2VicGFja2AgY3VycmVudGx5IGRlcGVuZHMgb24gZG9lc24ndFxuICAgIC8vIHN1cHBvcnQgYGFzeW5jYCBmdW5jdGlvbnMsIGFuZCB0aGUgbm9kZXMgdGhhdCB3ZSBzdXBwb3J0IGRvbid0IGFsbCBoYXZlXG4gICAgLy8gYC5maW5hbGx5YC4gVGhlcmVmb3JlLCB0aGlzIGlzIHdyaXR0ZW4gYSBiaXQgbW9yZSBjb252b2x1dGVkbHkgdGhhbiBpdFxuICAgIC8vIHNob3VsZCByZWFsbHkgYmUuXG5cbiAgICBsZXQgY29uc3VtZXIgPSBudWxsO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIocmF3U291cmNlTWFwLCBzb3VyY2VNYXBVcmwpO1xuICAgIHJldHVybiBwcm9taXNlXG4gICAgICAudGhlbihjID0+IHtcbiAgICAgICAgY29uc3VtZXIgPSBjO1xuICAgICAgICByZXR1cm4gZihjKTtcbiAgICAgIH0pXG4gICAgICAudGhlbih4ID0+IHtcbiAgICAgICAgaWYgKGNvbnN1bWVyKSB7XG4gICAgICAgICAgY29uc3VtZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfSwgZSA9PiB7XG4gICAgICAgIGlmIChjb25zdW1lcikge1xuICAgICAgICAgIGNvbnN1bWVyLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIF9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIG92ZXIgZWFjaCBtYXBwaW5nIGJldHdlZW4gYW4gb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uIGFuZCBhXG4gICAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBGdW5jdGlvbiBhQ2FsbGJhY2tcbiAgICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAgICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICAgKiAgICAgICAgT3B0aW9uYWwuIElmIHNwZWNpZmllZCwgdGhpcyBvYmplY3Qgd2lsbCBiZSB0aGUgdmFsdWUgb2YgYHRoaXNgIGV2ZXJ5XG4gICAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICAgKiBAcGFyYW0gYU9yZGVyXG4gICAqICAgICAgICBFaXRoZXIgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAgb3JcbiAgICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gICAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICAgKiAgICAgICAgb3JkZXIgb3IgdGhlIG9yaWdpbmFsJ3Mgc291cmNlL2xpbmUvY29sdW1uIG9yZGVyLCByZXNwZWN0aXZlbHkuIERlZmF1bHRzIHRvXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAgICovXG4gIGVhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnQgZWFjaE1hcHBpbmdcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICAgKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0XG4gICAqIGNsb3Nlc3QgbGluZSB0aGF0IGhhcyBhbnkgbWFwcGluZ3MuIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAgICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAgICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuXG4gICAqXG4gICAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICAgKiAgIC0gY29sdW1uOiBPcHRpb25hbC4gdGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAgICpcbiAgICogYW5kIGFuIGFycmF5IG9mIG9iamVjdHMgaXMgcmV0dXJuZWQsIGVhY2ggd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAgICogICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gICAqL1xuICBhbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IGFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvclwiKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBkZXN0cm95XCIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJlbmNlZCBieSBpbmRpdmlkdWFsIG1hcHBpbmdzLlxuICogICAtIHNvdXJjZVJvb3Q6IE9wdGlvbmFsLiBUaGUgVVJMIHJvb3QgZnJvbSB3aGljaCBhbGwgc291cmNlcyBhcmUgcmVsYXRpdmUuXG4gKiAgIC0gc291cmNlc0NvbnRlbnQ6IE9wdGlvbmFsLiBBbiBhcnJheSBvZiBjb250ZW50cyBvZiB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG1hcHBpbmdzOiBBIHN0cmluZyBvZiBiYXNlNjQgVkxRcyB3aGljaCBjb250YWluIHRoZSBhY3R1YWwgbWFwcGluZ3MuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICpcbiAqIEhlcmUgaXMgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF06XG4gKlxuICogICAgIHtcbiAqICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAqICAgICAgIHNvdXJjZVJvb3QgOiBcIlwiLFxuICogICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICBtYXBwaW5nczogXCJBQSxBQjs7QUJDREU7XCJcbiAqICAgICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0P3BsaT0xI1xuICovXG5jbGFzcyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGV4dGVuZHMgU291cmNlTWFwQ29uc3VtZXIge1xuICBjb25zdHJ1Y3RvcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gICAgcmV0dXJuIHN1cGVyKElOVEVSTkFMKS50aGVuKHRoYXQgPT4ge1xuICAgICAgbGV0IHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCBcInZlcnNpb25cIik7XG4gICAgICBsZXQgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgXCJzb3VyY2VzXCIpO1xuICAgICAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAgICAgLy8gcmVxdWlyZXMgdGhlIGFycmF5KSB0byBwbGF5IG5pY2UgaGVyZS5cbiAgICAgIGNvbnN0IG5hbWVzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCBcIm5hbWVzXCIsIFtdKTtcbiAgICAgIGxldCBzb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCBcInNvdXJjZVJvb3RcIiwgbnVsbCk7XG4gICAgICBjb25zdCBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgXCJzb3VyY2VzQ29udGVudFwiLCBudWxsKTtcbiAgICAgIGNvbnN0IG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCBcIm1hcHBpbmdzXCIpO1xuICAgICAgY29uc3QgZmlsZSA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgXCJmaWxlXCIsIG51bGwpO1xuXG4gICAgICAvLyBPbmNlIGFnYWluLCBTYXNzIGRldmlhdGVzIGZyb20gdGhlIHNwZWMgYW5kIHN1cHBsaWVzIHRoZSB2ZXJzaW9uIGFzIGFcbiAgICAgIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gICAgICBpZiAodmVyc2lvbiAhPSB0aGF0Ll92ZXJzaW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHZlcnNpb246IFwiICsgdmVyc2lvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2VSb290KSB7XG4gICAgICAgIHNvdXJjZVJvb3QgPSB1dGlsLm5vcm1hbGl6ZShzb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgc291cmNlcyA9IHNvdXJjZXNcbiAgICAgICAgLm1hcChTdHJpbmcpXG4gICAgICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgICAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAgICAgLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuICAgICAgICAubWFwKHV0aWwubm9ybWFsaXplKVxuICAgICAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAgICAgLy8gdGhlIHNvdXJjZSByb290LCBpZiB0aGUgc291cmNlIHJvb3QgaXMgYWJzb2x1dGUuIE5vdCBkb2luZyB0aGlzIHdvdWxkXG4gICAgICAgIC8vIGJlIHBhcnRpY3VsYXJseSBwcm9ibGVtYXRpYyB3aGVuIHRoZSBzb3VyY2Ugcm9vdCBpcyBhIHByZWZpeCBvZiB0aGVcbiAgICAgICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAgICAgLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICByZXR1cm4gc291cmNlUm9vdCAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlUm9vdCkgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZSlcbiAgICAgICAgICAgID8gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2UpXG4gICAgICAgICAgICA6IHNvdXJjZTtcbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgICAgIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gICAgICAvLyBzb21ldGltZXMgZ2VuZXJhdGVzIHNvdXJjZSBtYXBzIHdpdGggZHVwbGljYXRlcyBpbiB0aGVtLiBTZWUgR2l0aHViIGlzc3VlXG4gICAgICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gICAgICB0aGF0Ll9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSwgdHJ1ZSk7XG4gICAgICB0aGF0Ll9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuXG4gICAgICB0aGF0Ll9hYnNvbHV0ZVNvdXJjZXMgPSB0aGF0Ll9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHMsIGFTb3VyY2VNYXBVUkwpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoYXQuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgICB0aGF0LnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gICAgICB0aGF0Ll9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICAgICAgdGhhdC5fc291cmNlTWFwVVJMID0gYVNvdXJjZU1hcFVSTDtcbiAgICAgIHRoYXQuZmlsZSA9IGZpbGU7XG5cbiAgICAgIHRoYXQuX2NvbXB1dGVkQ29sdW1uU3BhbnMgPSBmYWxzZTtcbiAgICAgIHRoYXQuX21hcHBpbmdzUHRyID0gMDtcbiAgICAgIHRoYXQuX3dhc20gPSBudWxsO1xuXG4gICAgICByZXR1cm4gd2FzbSgpLnRoZW4odyA9PiB7XG4gICAgICAgIHRoYXQuX3dhc20gPSB3O1xuICAgICAgICByZXR1cm4gdGhhdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZmluZCB0aGUgaW5kZXggb2YgYSBzb3VyY2UuICBSZXR1cm5zIC0xIGlmIG5vdFxuICAgKiBmb3VuZC5cbiAgICovXG4gIF9maW5kU291cmNlSW5kZXgoYVNvdXJjZSkge1xuICAgIGxldCByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICByZWxhdGl2ZVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCByZWxhdGl2ZVNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKHJlbGF0aXZlU291cmNlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZXMuaW5kZXhPZihyZWxhdGl2ZVNvdXJjZSk7XG4gICAgfVxuXG4gICAgLy8gTWF5YmUgYVNvdXJjZSBpcyBhbiBhYnNvbHV0ZSBVUkwgYXMgcmV0dXJuZWQgYnkgfHNvdXJjZXN8LiAgSW5cbiAgICAvLyB0aGlzIGNhc2Ugd2UgY2FuJ3Qgc2ltcGx5IHVuZG8gdGhlIHRyYW5zZm9ybS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2Fic29sdXRlU291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuX2Fic29sdXRlU291cmNlc1tpXSA9PSBhU291cmNlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gICAqXG4gICAqIEBwYXJhbSBTb3VyY2VNYXBHZW5lcmF0b3IgYVNvdXJjZU1hcFxuICAgKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICAgKiBAcGFyYW0gU3RyaW5nIGFTb3VyY2VNYXBVUkxcbiAgICogICAgICAgIFRoZSBVUkwgYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgY2FuIGJlIGZvdW5kIChvcHRpb25hbClcbiAgICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICAgKi9cbiAgc3RhdGljIGZyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICAgIHJldHVybiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgZ2V0IHNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fic29sdXRlU291cmNlcy5zbGljZSgpO1xuICB9XG5cbiAgX2dldE1hcHBpbmdzUHRyKCkge1xuICAgIGlmICh0aGlzLl9tYXBwaW5nc1B0ciA9PT0gMCkge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbWFwcGluZ3NQdHI7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIF9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgY29uc3Qgc2l6ZSA9IGFTdHIubGVuZ3RoO1xuXG4gICAgY29uc3QgbWFwcGluZ3NCdWZQdHIgPSB0aGlzLl93YXNtLmV4cG9ydHMuYWxsb2NhdGVfbWFwcGluZ3Moc2l6ZSk7XG4gICAgY29uc3QgbWFwcGluZ3NCdWYgPSBuZXcgVWludDhBcnJheSh0aGlzLl93YXNtLmV4cG9ydHMubWVtb3J5LmJ1ZmZlciwgbWFwcGluZ3NCdWZQdHIsIHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBtYXBwaW5nc0J1ZltpXSA9IGFTdHIuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXBwaW5nc1B0ciA9IHRoaXMuX3dhc20uZXhwb3J0cy5wYXJzZV9tYXBwaW5ncyhtYXBwaW5nc0J1ZlB0cik7XG5cbiAgICBpZiAoIW1hcHBpbmdzUHRyKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuX3dhc20uZXhwb3J0cy5nZXRfbGFzdF9lcnJvcigpO1xuICAgICAgbGV0IG1zZyA9IGBFcnJvciBwYXJzaW5nIG1hcHBpbmdzIChjb2RlICR7ZXJyb3J9KTogYDtcblxuICAgICAgLy8gWFhYOiBrZWVwIHRoZXNlIGVycm9yIGNvZGVzIGluIHN5bmMgd2l0aCBgZml0emdlbi9zb3VyY2UtbWFwLW1hcHBpbmdzYC5cbiAgICAgIHN3aXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1zZyArPSBcInRoZSBtYXBwaW5ncyBjb250YWluZWQgYSBuZWdhdGl2ZSBsaW5lLCBjb2x1bW4sIHNvdXJjZSBpbmRleCwgb3IgbmFtZSBpbmRleFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbXNnICs9IFwidGhlIG1hcHBpbmdzIGNvbnRhaW5lZCBhIG51bWJlciBsYXJnZXIgdGhhbiAyKiozMlwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgbXNnICs9IFwicmVhY2hlZCBFT0Ygd2hpbGUgaW4gdGhlIG1pZGRsZSBvZiBwYXJzaW5nIGEgVkxRXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBtc2cgKz0gXCJpbnZhbGlkIGJhc2UgNjQgY2hhcmFjdGVyIHdoaWxlIHBhcnNpbmcgYSBWTFFcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBtc2cgKz0gXCJ1bmtub3duIGVycm9yIGNvZGVcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwcGluZ3NQdHIgPSBtYXBwaW5nc1B0cjtcbiAgfVxuXG4gIGVhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgIGNvbnN0IGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgIGNvbnN0IG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcbiAgICBjb25zdCBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuXG4gICAgdGhpcy5fd2FzbS53aXRoTWFwcGluZ0NhbGxiYWNrKFxuICAgICAgbWFwcGluZyA9PiB7XG4gICAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFDYWxsYmFjay5jYWxsKGNvbnRleHQsIG1hcHBpbmcpO1xuICAgICAgfSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgc3dpdGNoIChvcmRlcikge1xuICAgICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgICAgICB0aGlzLl93YXNtLmV4cG9ydHMuYnlfZ2VuZXJhdGVkX2xvY2F0aW9uKHRoaXMuX2dldE1hcHBpbmdzUHRyKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgICAgIHRoaXMuX3dhc20uZXhwb3J0cy5ieV9vcmlnaW5hbF9sb2NhdGlvbih0aGlzLl9nZXRNYXBwaW5nc1B0cigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgbGV0IHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCBcInNvdXJjZVwiKTtcbiAgICBjb25zdCBvcmlnaW5hbExpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgXCJsaW5lXCIpO1xuICAgIGNvbnN0IG9yaWdpbmFsQ29sdW1uID0gYUFyZ3MuY29sdW1uIHx8IDA7XG5cbiAgICBzb3VyY2UgPSB0aGlzLl9maW5kU291cmNlSW5kZXgoc291cmNlKTtcbiAgICBpZiAoc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW5hbExpbmUgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMaW5lIG51bWJlcnMgbXVzdCBiZSA+PSAxXCIpO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW5hbENvbHVtbiA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbHVtbiBudW1iZXJzIG11c3QgYmUgPj0gMFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXBwaW5ncyA9IFtdO1xuXG4gICAgdGhpcy5fd2FzbS53aXRoTWFwcGluZ0NhbGxiYWNrKFxuICAgICAgbSA9PiB7XG4gICAgICAgIGxldCBsYXN0Q29sdW1uID0gbS5sYXN0R2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICBpZiAodGhpcy5fY29tcHV0ZWRDb2x1bW5TcGFucyAmJiBsYXN0Q29sdW1uID09PSBudWxsKSB7XG4gICAgICAgICAgbGFzdENvbHVtbiA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgIGxpbmU6IG0uZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBjb2x1bW46IG0uZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICAgIGxhc3RDb2x1bW4sXG4gICAgICAgIH0pO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICB0aGlzLl93YXNtLmV4cG9ydHMuYWxsX2dlbmVyYXRlZF9sb2NhdGlvbnNfZm9yKFxuICAgICAgICAgIHRoaXMuX2dldE1hcHBpbmdzUHRyKCksXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsTGluZSAtIDEsXG4gICAgICAgICAgXCJjb2x1bW5cIiBpbiBhQXJncyxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtblxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gbWFwcGluZ3M7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9tYXBwaW5nc1B0ciAhPT0gMCkge1xuICAgICAgdGhpcy5fd2FzbS5leHBvcnRzLmZyZWVfbWFwcGluZ3ModGhpcy5fbWFwcGluZ3NQdHIpO1xuICAgICAgdGhpcy5fbWFwcGluZ3NQdHIgPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gICAqIGluY2x1c2l2ZS5cbiAgICovXG4gIGNvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICBpZiAodGhpcy5fY29tcHV0ZWRDb2x1bW5TcGFucykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3dhc20uZXhwb3J0cy5jb21wdXRlX2NvbHVtbl9zcGFucyh0aGlzLl9nZXRNYXBwaW5nc1B0cigpKTtcbiAgICB0aGlzLl9jb21wdXRlZENvbHVtblNwYW5zID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAgICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gICAqICAgICBpcyAxLWJhc2VkLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAgICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICAgKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAgICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAgICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAgICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAgICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAgICogICAgIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAgICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICAgKi9cbiAgb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIGNvbnN0IG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCBcImxpbmVcIiksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCBcImNvbHVtblwiKVxuICAgIH07XG5cbiAgICBpZiAobmVlZGxlLmdlbmVyYXRlZExpbmUgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMaW5lIG51bWJlcnMgbXVzdCBiZSA+PSAxXCIpO1xuICAgIH1cblxuICAgIGlmIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29sdW1uIG51bWJlcnMgbXVzdCBiZSA+PSAwXCIpO1xuICAgIH1cblxuICAgIGxldCBiaWFzID0gdXRpbC5nZXRBcmcoYUFyZ3MsIFwiYmlhc1wiLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCk7XG4gICAgaWYgKGJpYXMgPT0gbnVsbCkge1xuICAgICAgYmlhcyA9IFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EO1xuICAgIH1cblxuICAgIGxldCBtYXBwaW5nO1xuICAgIHRoaXMuX3dhc20ud2l0aE1hcHBpbmdDYWxsYmFjayhtID0+IG1hcHBpbmcgPSBtLCAoKSA9PiB7XG4gICAgICB0aGlzLl93YXNtLmV4cG9ydHMub3JpZ2luYWxfbG9jYXRpb25fZm9yKFxuICAgICAgICB0aGlzLl9nZXRNYXBwaW5nc1B0cigpLFxuICAgICAgICBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIDEsXG4gICAgICAgIG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgIGJpYXNcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpZiAobWFwcGluZykge1xuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsIFwic291cmNlXCIsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTCh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgXCJuYW1lXCIsIG51bGwpO1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsIFwib3JpZ2luYWxMaW5lXCIsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgXCJvcmlnaW5hbENvbHVtblwiLCBudWxsKSxcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBuYW1lOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAgICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBoYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uKHNjKSB7IHJldHVybiBzYyA9PSBudWxsOyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAgICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICAgKiBhdmFpbGFibGUuXG4gICAqL1xuICBzb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KGFTb3VyY2UpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFtpbmRleF07XG4gICAgfVxuXG4gICAgbGV0IHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHJlbGF0aXZlU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHJlbGF0aXZlU291cmNlKTtcbiAgICB9XG5cbiAgICBsZXQgdXJsO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgIGNvbnN0IGZpbGVVcmlBYnNQYXRoID0gcmVsYXRpdmVTb3VyY2UucmVwbGFjZSgvXmZpbGU6XFwvXFwvLywgXCJcIik7XG4gICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKGZpbGVVcmlBYnNQYXRoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoZmlsZVVyaUFic1BhdGgpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyByZWxhdGl2ZVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgZnJvbVxuICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuICAgIC8vIGRvbid0IHdhbnQgdG8gdGhyb3cgaWYgd2UgY2FuJ3QgZmluZCB0aGUgc291cmNlIC0gd2UganVzdCB3YW50IHRvXG4gICAgLy8gcmV0dXJuIG51bGwsIHNvIHdlIHByb3ZpZGUgYSBmbGFnIHRvIGV4aXQgZ3JhY2VmdWxseS5cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyByZWxhdGl2ZVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAgICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gICAqICAgICBpcyAxLWJhc2VkLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICAgKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gICAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICAgKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICAgKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gICAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gICAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gICAqL1xuICBnZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIGxldCBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgXCJzb3VyY2VcIik7XG4gICAgc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KHNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCBcImxpbmVcIiksXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsIFwiY29sdW1uXCIpXG4gICAgfTtcblxuICAgIGlmIChuZWVkbGUub3JpZ2luYWxMaW5lIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGluZSBudW1iZXJzIG11c3QgYmUgPj0gMVwiKTtcbiAgICB9XG5cbiAgICBpZiAobmVlZGxlLm9yaWdpbmFsQ29sdW1uIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29sdW1uIG51bWJlcnMgbXVzdCBiZSA+PSAwXCIpO1xuICAgIH1cblxuICAgIGxldCBiaWFzID0gdXRpbC5nZXRBcmcoYUFyZ3MsIFwiYmlhc1wiLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCk7XG4gICAgaWYgKGJpYXMgPT0gbnVsbCkge1xuICAgICAgYmlhcyA9IFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EO1xuICAgIH1cblxuICAgIGxldCBtYXBwaW5nO1xuICAgIHRoaXMuX3dhc20ud2l0aE1hcHBpbmdDYWxsYmFjayhtID0+IG1hcHBpbmcgPSBtLCAoKSA9PiB7XG4gICAgICB0aGlzLl93YXNtLmV4cG9ydHMuZ2VuZXJhdGVkX2xvY2F0aW9uX2ZvcihcbiAgICAgICAgdGhpcy5fZ2V0TWFwcGluZ3NQdHIoKSxcbiAgICAgICAgbmVlZGxlLnNvdXJjZSxcbiAgICAgICAgbmVlZGxlLm9yaWdpbmFsTGluZSAtIDEsXG4gICAgICAgIG5lZWRsZS5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgYmlhc1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IG5lZWRsZS5zb3VyY2UpIHtcbiAgICAgICAgbGV0IGxhc3RDb2x1bW4gPSBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgIGlmICh0aGlzLl9jb21wdXRlZENvbHVtblNwYW5zICYmIGxhc3RDb2x1bW4gPT09IG51bGwpIHtcbiAgICAgICAgICBsYXN0Q29sdW1uID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCBcImdlbmVyYXRlZExpbmVcIiwgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCBcImdlbmVyYXRlZENvbHVtblwiLCBudWxsKSxcbiAgICAgICAgICBsYXN0Q29sdW1uLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH1cbn1cblxuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAqXG4gKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gKiAgICAgICBmaWVsZC5cbiAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAqXG4gKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gKiB1bnN1cHBvcnRlZC5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAqXG4gKiAge1xuICogICAgdmVyc2lvbiA6IDMsXG4gKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICogICAgc2VjdGlvbnM6IFt7XG4gKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICogICAgICBtYXA6IHtcbiAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICogICAgICB9XG4gKiAgICB9XSxcbiAqICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAqL1xuY2xhc3MgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGV4dGVuZHMgU291cmNlTWFwQ29uc3VtZXIge1xuICBjb25zdHJ1Y3RvcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gICAgcmV0dXJuIHN1cGVyKElOVEVSTkFMKS50aGVuKHRoYXQgPT4ge1xuICAgICAgbGV0IHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gICAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCBcInZlcnNpb25cIik7XG4gICAgICBjb25zdCBzZWN0aW9ucyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgXCJzZWN0aW9uc1wiKTtcblxuICAgICAgaWYgKHZlcnNpb24gIT0gdGhhdC5fdmVyc2lvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB2ZXJzaW9uOiBcIiArIHZlcnNpb24pO1xuICAgICAgfVxuXG4gICAgICB0aGF0Ll9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgICB0aGF0Ll9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICAgICAgdGhhdC5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbiAgICAgIHRoYXQuX19vcmlnaW5hbE1hcHBpbmdzID0gbnVsbDtcbiAgICAgIHRoYXQuX19nZW5lcmF0ZWRNYXBwaW5nc1Vuc29ydGVkID0gbnVsbDtcbiAgICAgIHRoYXQuX19vcmlnaW5hbE1hcHBpbmdzVW5zb3J0ZWQgPSBudWxsO1xuXG4gICAgICBsZXQgbGFzdE9mZnNldCA9IHtcbiAgICAgICAgbGluZTogLTEsXG4gICAgICAgIGNvbHVtbjogMFxuICAgICAgfTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChzZWN0aW9ucy5tYXAocyA9PiB7XG4gICAgICAgIGlmIChzLnVybCkge1xuICAgICAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8xNlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHV0aWwuZ2V0QXJnKHMsIFwib2Zmc2V0XCIpO1xuICAgICAgICBjb25zdCBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCBcImxpbmVcIik7XG4gICAgICAgIGNvbnN0IG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgXCJjb2x1bW5cIik7XG5cbiAgICAgICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgICAgIGNvbnN0IGNvbnMgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgXCJtYXBcIiksIGFTb3VyY2VNYXBVUkwpO1xuICAgICAgICByZXR1cm4gY29ucy50aGVuKGNvbnN1bWVyID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2VuZXJhdGVkT2Zmc2V0OiB7XG4gICAgICAgICAgICAgIC8vIFRoZSBvZmZzZXQgZmllbGRzIGFyZSAwLWJhc2VkLCBidXQgd2UgdXNlIDEtYmFzZWQgaW5kaWNlcyB3aGVuXG4gICAgICAgICAgICAgIC8vIGVuY29kaW5nL2RlY29kaW5nIGZyb20gVkxRLlxuICAgICAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBvZmZzZXRMaW5lICsgMSxcbiAgICAgICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBvZmZzZXRDb2x1bW4gKyAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uc3VtZXJcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pKS50aGVuKHMgPT4ge1xuICAgICAgICB0aGF0Ll9zZWN0aW9ucyA9IHM7XG4gICAgICAgIHJldHVybiB0aGF0O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBgX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kIGBfX29yaWdpbmFsTWFwcGluZ3NgIGFyZSBhcnJheXMgdGhhdCBob2xkIHRoZVxuICAvLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuICAvLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBnZXR0ZXJzIHJlc3BlY3RpdmVseSwgYW5kIHdlIG9ubHkgcGFyc2UgdGhlIG1hcHBpbmdzXG4gIC8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuICAvLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbiAgLy8gdGhlbSBpcyBleHBlbnNpdmUsIHNvIHdlIG9ubHkgd2FudCB0byBkbyBpdCBpZiB3ZSBtdXN0LlxuICAvL1xuICAvLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuICAvL1xuICAvLyAgICAge1xuICAvLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBnZW5lcmF0ZWRDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuICAvLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuICAvLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2ZcbiAgLy8gICAgICAgICAgICAgY29kZS5cbiAgLy8gICAgIH1cbiAgLy9cbiAgLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuICAvLyBgbnVsbGAuXG4gIC8vXG4gIC8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4gIC8vXG4gIC8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuICBnZXQgX2dlbmVyYXRlZE1hcHBpbmdzKCkge1xuICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9zb3J0R2VuZXJhdGVkTWFwcGluZ3MoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICB9XG5cbiAgZ2V0IF9vcmlnaW5hbE1hcHBpbmdzKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3NvcnRPcmlnaW5hbE1hcHBpbmdzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG5cbiAgZ2V0IF9nZW5lcmF0ZWRNYXBwaW5nc1Vuc29ydGVkKCkge1xuICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzVW5zb3J0ZWQpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc1Vuc29ydGVkO1xuICB9XG5cbiAgZ2V0IF9vcmlnaW5hbE1hcHBpbmdzVW5zb3J0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc1Vuc29ydGVkKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc1Vuc29ydGVkO1xuICB9XG5cbiAgX3NvcnRHZW5lcmF0ZWRNYXBwaW5ncygpIHtcbiAgICBjb25zdCBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzVW5zb3J0ZWQ7XG4gICAgbWFwcGluZ3Muc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgfVxuXG4gIF9zb3J0T3JpZ2luYWxNYXBwaW5ncygpIHtcbiAgICBjb25zdCBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NVbnNvcnRlZDtcbiAgICBtYXBwaW5ncy5zb3J0KHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gbWFwcGluZ3M7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAgICovXG4gIGdldCBzb3VyY2VzKCkge1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc291cmNlcy5wdXNoKHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAgICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gICAqICAgICBpcyAxLWJhc2VkLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAgICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICAgKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICAgKiAgICAgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICAgKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gICAqL1xuICBvcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgY29uc3QgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsIFwibGluZVwiKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsIFwiY29sdW1uXCIpXG4gICAgfTtcblxuICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICBjb25zdCBzZWN0aW9uSW5kZXggPSBiaW5hcnlTZWFyY2guc2VhcmNoKG5lZWRsZSwgdGhpcy5fc2VjdGlvbnMsXG4gICAgICBmdW5jdGlvbihhTmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGNtcCA9IGFOZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChhTmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICA6IDApLFxuICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICAgKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gICAqIGF2YWlsYWJsZS5cbiAgICovXG4gIHNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgY29uc3QgY29udGVudCA9IHNlY3Rpb24uY29uc3VtZXIuc291cmNlQ29udGVudEZvcihhU291cmNlLCB0cnVlKTtcbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAgICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gICAqICAgICBpcyAxLWJhc2VkLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICAgKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAgICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAgICovXG4gIGdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5fZmluZFNvdXJjZUluZGV4KHV0aWwuZ2V0QXJnKGFBcmdzLCBcInNvdXJjZVwiKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgbGluZTogZ2VuZXJhdGVkUG9zaXRpb24ubGluZSArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkUG9zaXRpb24uY29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lXG4gICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgOiAwKVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICBjb25zdCBnZW5lcmF0ZWRNYXBwaW5ncyA9IHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc1Vuc29ydGVkID0gW107XG4gICAgY29uc3Qgb3JpZ2luYWxNYXBwaW5ncyA9IHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzVW5zb3J0ZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIGNvbnN0IHNlY3Rpb25NYXBwaW5ncyA9IFtdO1xuICAgICAgc2VjdGlvbi5jb25zdW1lci5lYWNoTWFwcGluZyhtID0+IHNlY3Rpb25NYXBwaW5ncy5wdXNoKG0pKTtcblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tqXTtcblxuICAgICAgICAvLyBUT0RPOiB0ZXN0IGlmIG51bGwgaXMgY29ycmVjdCBoZXJlLiAgVGhlIG9yaWdpbmFsIGNvZGUgdXNlZFxuICAgICAgICAvLyBgc291cmNlYCwgd2hpY2ggd291bGQgYWN0dWFsbHkgaGF2ZSBnb3R0ZW4gdXNlZCBhcyBudWxsIGJlY2F1c2VcbiAgICAgICAgLy8gdmFyJ3MgZ2V0IGhvaXN0ZWQuXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzMzXG4gICAgICAgIGxldCBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBudWxsLCB0aGlzLl9zb3VyY2VNYXBVUkwpO1xuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICBsZXQgbmFtZSA9IG51bGw7XG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICB0aGlzLl9uYW1lcy5hZGQobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgY29uc3QgYWRqdXN0ZWRNYXBwaW5nID0ge1xuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICBnZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgYWRqdXN0ZWRNYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIG9yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgY29uc3Qgb3JkZXIgPSBhT3JkZXIgfHwgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSO1xuXG4gICAgbGV0IG1hcHBpbmdzO1xuICAgIHN3aXRjaCAob3JkZXIpIHtcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbihtYXBwaW5nKSB7XG4gICAgICBsZXQgc291cmNlID0gbnVsbDtcbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmF0KG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgbmFtZTogbWFwcGluZy5uYW1lID09PSBudWxsID8gbnVsbCA6IHRoaXMuX25hbWVzLmF0KG1hcHBpbmcubmFtZSlcbiAgICAgIH07XG4gICAgfSwgdGhpcykuZm9yRWFjaChhQ2FsbGJhY2ssIGNvbnRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIG1hcHBpbmcgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGh5cG90aGV0aWNhbCBcIm5lZWRsZVwiIG1hcHBpbmcgdGhhdFxuICAgKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICAgKi9cbiAgX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUxpbmVOYW1lXSk7XG4gICAgfVxuICAgIGlmIChhTmVlZGxlW2FDb2x1bW5OYW1lXSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgfVxuXG4gIGFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgIGNvbnN0IGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgXCJsaW5lXCIpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgIGNvbnN0IG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsIFwic291cmNlXCIpLFxuICAgICAgb3JpZ2luYWxMaW5lOiBsaW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCBcImNvbHVtblwiLCAwKVxuICAgIH07XG5cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KG5lZWRsZS5zb3VyY2UpO1xuICAgIGlmIChuZWVkbGUuc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmIChuZWVkbGUub3JpZ2luYWxMaW5lIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGluZSBudW1iZXJzIG11c3QgYmUgPj0gMVwiKTtcbiAgICB9XG5cbiAgICBpZiAobmVlZGxlLm9yaWdpbmFsQ29sdW1uIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29sdW1uIG51bWJlcnMgbXVzdCBiZSA+PSAwXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IG1hcHBpbmdzID0gW107XG5cbiAgICBsZXQgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGxldCBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIGZvdW5kLiBTaW5jZVxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGZvdW5kLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gb3JpZ2luYWxMaW5lKSB7XG4gICAgICAgICAgbGV0IGxhc3RDb2x1bW4gPSBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgaWYgKHRoaXMuX2NvbXB1dGVkQ29sdW1uU3BhbnMgJiYgbGFzdENvbHVtbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGFzdENvbHVtbiA9IEluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsIFwiZ2VuZXJhdGVkTGluZVwiLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgXCJnZW5lcmF0ZWRDb2x1bW5cIiwgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgLy8gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBsaW5lICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID09IG9yaWdpbmFsQ29sdW1uKSB7XG4gICAgICAgICAgbGV0IGxhc3RDb2x1bW4gPSBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgaWYgKHRoaXMuX2NvbXB1dGVkQ29sdW1uU3BhbnMgJiYgbGFzdENvbHVtbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbGFzdENvbHVtbiA9IEluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsIFwiZ2VuZXJhdGVkTGluZVwiLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgXCJnZW5lcmF0ZWRDb2x1bW5cIiwgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ3M7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyID0gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKlxuICogQ2hlYXQgdG8gZ2V0IGFyb3VuZCBpbnRlci10d2luZ2xlZCBjbGFzc2VzLiAgYGZhY3RvcnkoKWAgY2FuIGJlIGF0IHRoZSBlbmRcbiAqIHdoZXJlIGl0IGhhcyBhY2Nlc3MgdG8gbm9uLWhvaXN0ZWQgY2xhc3NlcywgYnV0IGl0IGdldHMgaG9pc3RlZCBpdHNlbGYuXG4gKi9cbmZ1bmN0aW9uIF9mYWN0b3J5KGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgbGV0IHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIGNvbnN0IGNvbnN1bWVyID0gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpXG4gICAgICA6IG5ldyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCk7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoY29uc3VtZXIpO1xufVxuXG5mdW5jdGlvbiBfZmFjdG9yeUJTTShhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHJldHVybiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/terser/node_modules/source-map/lib/source-map-consumer.js\n");

/***/ }),

/***/ "./node_modules/terser/node_modules/source-map/lib/source-map-generator.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/terser/node_modules/source-map/lib/source-map-generator.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst base64VLQ = __webpack_require__(/*! ./base64-vlq */ \"./node_modules/terser/node_modules/source-map/lib/base64-vlq.js\");\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/terser/node_modules/source-map/lib/util.js\");\nconst ArraySet = __webpack_require__(/*! ./array-set */ \"./node_modules/terser/node_modules/source-map/lib/array-set.js\").ArraySet;\nconst MappingList = __webpack_require__(/*! ./mapping-list */ \"./node_modules/terser/node_modules/source-map/lib/mapping-list.js\").MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nclass SourceMapGenerator {\n  constructor(aArgs) {\n    if (!aArgs) {\n      aArgs = {};\n    }\n    this._file = util.getArg(aArgs, \"file\", null);\n    this._sourceRoot = util.getArg(aArgs, \"sourceRoot\", null);\n    this._skipValidation = util.getArg(aArgs, \"skipValidation\", false);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = new MappingList();\n    this._sourcesContents = null;\n  }\n\n  /**\n   * Creates a new SourceMapGenerator based on a SourceMapConsumer\n   *\n   * @param aSourceMapConsumer The SourceMap.\n   */\n  static fromSourceMap(aSourceMapConsumer) {\n    const sourceRoot = aSourceMapConsumer.sourceRoot;\n    const generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function(mapping) {\n      const newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n      let sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  }\n\n  /**\n   * Add a single mapping from original source line and column to the generated\n   * source's line and column for this source map being created. The mapping\n   * object should have the following properties:\n   *\n   *   - generated: An object with the generated line and column positions.\n   *   - original: An object with the original line and column positions.\n   *   - source: The original source file (relative to the sourceRoot).\n   *   - name: An optional original token name for this mapping.\n   */\n  addMapping(aArgs) {\n    const generated = util.getArg(aArgs, \"generated\");\n    const original = util.getArg(aArgs, \"original\", null);\n    let source = util.getArg(aArgs, \"source\", null);\n    let name = util.getArg(aArgs, \"name\", null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source,\n      name\n    });\n  }\n\n  /**\n   * Set the source content for a source file.\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    let source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  }\n\n  /**\n   * Applies the mappings of a sub-source-map for a specific source file to the\n   * source map being generated. Each mapping to the supplied source file is\n   * rewritten using the supplied source map. Note: The resolution for the\n   * resulting mappings is the minimium of this map and the supplied map.\n   *\n   * @param aSourceMapConsumer The source map to be applied.\n   * @param aSourceFile Optional. The filename of the source file.\n   *        If omitted, SourceMapConsumer's file property will be used.\n   * @param aSourceMapPath Optional. The dirname of the path to the source map\n   *        to be applied. If relative, it is relative to the SourceMapConsumer.\n   *        This parameter is needed when the two source maps aren't in the same\n   *        directory, and the source map to be applied contains relative source\n   *        paths. If so, those relative source paths need to be rewritten\n   *        relative to the SourceMapGenerator.\n   */\n  applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    let sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          \"SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, \" +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    const sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    const newSources = this._mappings.toArray().length > 0\n      ? new ArraySet()\n      : this._sources;\n    const newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function(mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        const original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source);\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      const source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      const name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function(srcFile) {\n      const content = aSourceMapConsumer.sourceContentFor(srcFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          srcFile = util.join(aSourceMapPath, srcFile);\n        }\n        if (sourceRoot != null) {\n          srcFile = util.relative(sourceRoot, srcFile);\n        }\n        this.setSourceContent(srcFile, content);\n      }\n    }, this);\n  }\n\n  /**\n   * A mapping can have one of the three levels of data:\n   *\n   *   1. Just the generated position.\n   *   2. The Generated position, original position, and original source.\n   *   3. Generated and original position, original source, as well as a name\n   *      token.\n   *\n   * To maintain consistency, we validate that any new mapping being added falls\n   * in to one of these categories.\n   */\n  _validateMapping(aGenerated, aOriginal, aSource, aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== \"number\" && typeof aOriginal.column !== \"number\") {\n        throw new Error(\n            \"original.line and original.column are not numbers -- you probably meant to omit \" +\n            \"the original mapping entirely and only map the generated position. If so, pass \" +\n            \"null for the original mapping instead of an object with empty or null values.\"\n        );\n    }\n\n    if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n\n    } else if (aGenerated && \"line\" in aGenerated && \"column\" in aGenerated\n             && aOriginal && \"line\" in aOriginal && \"column\" in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n\n    } else {\n      throw new Error(\"Invalid mapping: \" + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  }\n\n  /**\n   * Serialize the accumulated mappings in to the stream of base 64 VLQs\n   * specified by the source map format.\n   */\n  _serializeMappings() {\n    let previousGeneratedColumn = 0;\n    let previousGeneratedLine = 1;\n    let previousOriginalColumn = 0;\n    let previousOriginalLine = 0;\n    let previousName = 0;\n    let previousSource = 0;\n    let result = \"\";\n    let next;\n    let mapping;\n    let nameIdx;\n    let sourceIdx;\n\n    const mappings = this._mappings.toArray();\n    for (let i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = \"\";\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += \";\";\n          previousGeneratedLine++;\n        }\n      } else if (i > 0) {\n        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n          continue;\n        }\n        next += \",\";\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  }\n\n  _generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function(source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      const key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  }\n\n  /**\n   * Externalize the source map.\n   */\n  toJSON() {\n    const map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  }\n\n  /**\n   * Render the source map being generated to a string.\n   */\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n\nSourceMapGenerator.prototype._version = 3;\nexports.SourceMapGenerator = SourceMapGenerator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFPLENBQUMscUZBQWM7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLHlFQUFRO0FBQzdCLGlCQUFpQixpSEFBK0I7QUFDaEQsb0JBQW9CLDBIQUFxQzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tLWxldml0eS8uL25vZGVfbW9kdWxlcy90ZXJzZXIvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzP2UzYTciXSwic291cmNlc0NvbnRlbnQiOlsiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG5jb25zdCBiYXNlNjRWTFEgPSByZXF1aXJlKFwiLi9iYXNlNjQtdmxxXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBBcnJheVNldCA9IHJlcXVpcmUoXCIuL2FycmF5LXNldFwiKS5BcnJheVNldDtcbmNvbnN0IE1hcHBpbmdMaXN0ID0gcmVxdWlyZShcIi4vbWFwcGluZy1saXN0XCIpLk1hcHBpbmdMaXN0O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9cbmNsYXNzIFNvdXJjZU1hcEdlbmVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKGFBcmdzKSB7XG4gICAgaWYgKCFhQXJncykge1xuICAgICAgYUFyZ3MgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5fZmlsZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCBcImZpbGVcIiwgbnVsbCk7XG4gICAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCBcInNvdXJjZVJvb3RcIiwgbnVsbCk7XG4gICAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgXCJza2lwVmFsaWRhdGlvblwiLCBmYWxzZSk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdGhpcy5fbWFwcGluZ3MgPSBuZXcgTWFwcGluZ0xpc3QoKTtcbiAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwLlxuICAgKi9cbiAgc3RhdGljIGZyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgY29uc3Qgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgIGNvbnN0IGdlbmVyYXRvciA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgZmlsZTogYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUsXG4gICAgICBzb3VyY2VSb290XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uKG1hcHBpbmcpIHtcbiAgICAgIGNvbnN0IG5ld01hcHBpbmcgPSB7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2VGaWxlKSB7XG4gICAgICBsZXQgc291cmNlUmVsYXRpdmUgPSBzb3VyY2VGaWxlO1xuICAgICAgaWYgKHNvdXJjZVJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgc291cmNlUmVsYXRpdmUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdlbmVyYXRvci5fc291cmNlcy5oYXMoc291cmNlUmVsYXRpdmUpKSB7XG4gICAgICAgIGdlbmVyYXRvci5fc291cmNlcy5hZGQoc291cmNlUmVsYXRpdmUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAgICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIGZvciB0aGlzIHNvdXJjZSBtYXAgYmVpbmcgY3JlYXRlZC4gVGhlIG1hcHBpbmdcbiAgICogb2JqZWN0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGdlbmVyYXRlZDogQW4gb2JqZWN0IHdpdGggdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICAgKiAgIC0gb3JpZ2luYWw6IEFuIG9iamVjdCB3aXRoIHRoZSBvcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICAgKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAgICogICAtIG5hbWU6IEFuIG9wdGlvbmFsIG9yaWdpbmFsIHRva2VuIG5hbWUgZm9yIHRoaXMgbWFwcGluZy5cbiAgICovXG4gIGFkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICBjb25zdCBnZW5lcmF0ZWQgPSB1dGlsLmdldEFyZyhhQXJncywgXCJnZW5lcmF0ZWRcIik7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgXCJvcmlnaW5hbFwiLCBudWxsKTtcbiAgICBsZXQgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsIFwic291cmNlXCIsIG51bGwpO1xuICAgIGxldCBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsIFwibmFtZVwiLCBudWxsKTtcblxuICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gU3RyaW5nKHNvdXJjZSk7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgaWYgKCF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgc291cmNlLFxuICAgICAgbmFtZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gICAqL1xuICBzZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIGxldCBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICAgKiBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZC4gRWFjaCBtYXBwaW5nIHRvIHRoZSBzdXBwbGllZCBzb3VyY2UgZmlsZSBpc1xuICAgKiByZXdyaXR0ZW4gdXNpbmcgdGhlIHN1cHBsaWVkIHNvdXJjZSBtYXAuIE5vdGU6IFRoZSByZXNvbHV0aW9uIGZvciB0aGVcbiAgICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkLlxuICAgKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gICAqICAgICAgICBJZiBvbWl0dGVkLCBTb3VyY2VNYXBDb25zdW1lcidzIGZpbGUgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxuICAgKiBAcGFyYW0gYVNvdXJjZU1hcFBhdGggT3B0aW9uYWwuIFRoZSBkaXJuYW1lIG9mIHRoZSBwYXRoIHRvIHRoZSBzb3VyY2UgbWFwXG4gICAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICAgKiAgICAgICAgVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHdoZW4gdGhlIHR3byBzb3VyY2UgbWFwcyBhcmVuJ3QgaW4gdGhlIHNhbWVcbiAgICogICAgICAgIGRpcmVjdG9yeSwgYW5kIHRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQgY29udGFpbnMgcmVsYXRpdmUgc291cmNlXG4gICAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICAgKiAgICAgICAgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAgICovXG4gIGFwcGx5U291cmNlTWFwKGFTb3VyY2VNYXBDb25zdW1lciwgYVNvdXJjZUZpbGUsIGFTb3VyY2VNYXBQYXRoKSB7XG4gICAgbGV0IHNvdXJjZUZpbGUgPSBhU291cmNlRmlsZTtcbiAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgaWYgKGFTb3VyY2VGaWxlID09IG51bGwpIHtcbiAgICAgIGlmIChhU291cmNlTWFwQ29uc3VtZXIuZmlsZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgcmVxdWlyZXMgZWl0aGVyIGFuIGV4cGxpY2l0IHNvdXJjZSBmaWxlLCBcIiArXG4gICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgfVxuICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgIGNvbnN0IG5ld1NvdXJjZXMgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCkubGVuZ3RoID4gMFxuICAgICAgPyBuZXcgQXJyYXlTZXQoKVxuICAgICAgOiB0aGlzLl9zb3VyY2VzO1xuICAgIGNvbnN0IG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbiAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24obWFwcGluZykge1xuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgY2FuIGJlIG1hcHBlZCBieSB0aGUgc291cmNlIG1hcCwgdGhlbiB1cGRhdGUgdGhlIG1hcHBpbmcuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24oc3JjRmlsZSkge1xuICAgICAgY29uc3QgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNyY0ZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNyY0ZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNyY0ZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzcmNGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzcmNGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc3JjRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gICAqXG4gICAqICAgMS4gSnVzdCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICAgKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAgICogICAgICB0b2tlbi5cbiAgICpcbiAgICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gICAqIGluIHRvIG9uZSBvZiB0aGVzZSBjYXRlZ29yaWVzLlxuICAgKi9cbiAgX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsIGFOYW1lKSB7XG4gICAgLy8gV2hlbiBhT3JpZ2luYWwgaXMgdHJ1dGh5IGJ1dCBoYXMgZW1wdHkgdmFsdWVzIGZvciAubGluZSBhbmQgLmNvbHVtbixcbiAgICAvLyBpdCBpcyBtb3N0IGxpa2VseSBhIHByb2dyYW1tZXIgZXJyb3IuIEluIHRoaXMgY2FzZSB3ZSB0aHJvdyBhIHZlcnlcbiAgICAvLyBzcGVjaWZpYyBlcnJvciBtZXNzYWdlIHRvIHRyeSB0byBndWlkZSB0aGVtIHRoZSByaWdodCB3YXkuXG4gICAgLy8gRm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXItYnVuZGxlci9wdWxsLzUxOVxuICAgIGlmIChhT3JpZ2luYWwgJiYgdHlwZW9mIGFPcmlnaW5hbC5saW5lICE9PSBcIm51bWJlclwiICYmIHR5cGVvZiBhT3JpZ2luYWwuY29sdW1uICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwib3JpZ2luYWwubGluZSBhbmQgb3JpZ2luYWwuY29sdW1uIGFyZSBub3QgbnVtYmVycyAtLSB5b3UgcHJvYmFibHkgbWVhbnQgdG8gb21pdCBcIiArXG4gICAgICAgICAgICBcInRoZSBvcmlnaW5hbCBtYXBwaW5nIGVudGlyZWx5IGFuZCBvbmx5IG1hcCB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uLiBJZiBzbywgcGFzcyBcIiArXG4gICAgICAgICAgICBcIm51bGwgZm9yIHRoZSBvcmlnaW5hbCBtYXBwaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0IHdpdGggZW1wdHkgb3IgbnVsbCB2YWx1ZXMuXCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoYUdlbmVyYXRlZCAmJiBcImxpbmVcIiBpbiBhR2VuZXJhdGVkICYmIFwiY29sdW1uXCIgaW4gYUdlbmVyYXRlZFxuICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgJiYgIWFPcmlnaW5hbCAmJiAhYVNvdXJjZSAmJiAhYU5hbWUpIHtcbiAgICAgIC8vIENhc2UgMS5cblxuICAgIH0gZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiBcImxpbmVcIiBpbiBhR2VuZXJhdGVkICYmIFwiY29sdW1uXCIgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiBcImxpbmVcIiBpbiBhT3JpZ2luYWwgJiYgXCJjb2x1bW5cIiBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cblxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1hcHBpbmc6IFwiICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICAgKiBzcGVjaWZpZWQgYnkgdGhlIHNvdXJjZSBtYXAgZm9ybWF0LlxuICAgKi9cbiAgX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgIGxldCBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgbGV0IHByZXZpb3VzR2VuZXJhdGVkTGluZSA9IDE7XG4gICAgbGV0IHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIGxldCBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgbGV0IHByZXZpb3VzTmFtZSA9IDA7XG4gICAgbGV0IHByZXZpb3VzU291cmNlID0gMDtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBsZXQgbmV4dDtcbiAgICBsZXQgbWFwcGluZztcbiAgICBsZXQgbmFtZUlkeDtcbiAgICBsZXQgc291cmNlSWR4O1xuXG4gICAgY29uc3QgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICBuZXh0ID0gXCJcIjtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgd2hpbGUgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSAhPT0gcHJldmlvdXNHZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbmV4dCArPSBcIjtcIjtcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5leHQgKz0gXCIsXCI7XG4gICAgICB9XG5cbiAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VJZHggPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUoc291cmNlSWR4IC0gcHJldmlvdXNTb3VyY2UpO1xuICAgICAgICBwcmV2aW91c1NvdXJjZSA9IHNvdXJjZUlkeDtcblxuICAgICAgICAvLyBsaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWQgaW4gU291cmNlTWFwIHNwZWMgdmVyc2lvbiAzXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsTGluZSk7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgIG5hbWVJZHggPSB0aGlzLl9uYW1lcy5pbmRleE9mKG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG5hbWVJZHggLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgIHByZXZpb3VzTmFtZSA9IG5hbWVJZHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIF9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KGFTb3VyY2VzLCBhU291cmNlUm9vdCkge1xuICAgIHJldHVybiBhU291cmNlcy5tYXAoZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhU291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cywga2V5KVxuICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgIDogbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBtYXAgPSB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICB9O1xuICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCkpO1xuICB9XG59XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/terser/node_modules/source-map/lib/source-map-generator.js\n");

/***/ }),

/***/ "./node_modules/terser/node_modules/source-map/lib/source-node.js":
/*!************************************************************************!*\
  !*** ./node_modules/terser/node_modules/source-map/lib/source-node.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst SourceMapGenerator = __webpack_require__(/*! ./source-map-generator */ \"./node_modules/terser/node_modules/source-map/lib/source-map-generator.js\").SourceMapGenerator;\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/terser/node_modules/source-map/lib/util.js\");\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nconst REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nconst NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nconst isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nclass SourceNode {\n  constructor(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n  static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    const node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    let remainingLinesIndex = 0;\n    const shiftNextLine = function() {\n      const lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      const newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    let lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    let lastMapping = null;\n    let nextLine;\n\n    aSourceMapConsumer.eachMapping(function(mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          nextLine = remainingLines[remainingLinesIndex] || \"\";\n          const code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        nextLine = remainingLines[remainingLinesIndex] || \"\";\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function(sourceFile) {\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        const source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  }\n\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function(chunk) {\n        this.add(chunk);\n      }, this);\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (let i = aChunk.length - 1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n  walk(aFn) {\n    let chunk;\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      chunk = this.children[i];\n      if (chunk[isSourceNode]) {\n        chunk.walk(aFn);\n      } else if (chunk !== \"\") {\n        aFn(chunk, { source: this.source,\n                      line: this.line,\n                      column: this.column,\n                      name: this.name });\n      }\n    }\n  }\n\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n  join(aSep) {\n    let newChildren;\n    let i;\n    const len = this.children.length;\n    if (len > 0) {\n      newChildren = [];\n      for (i = 0; i < len - 1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n    return this;\n  }\n\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n  replaceRight(aPattern, aReplacement) {\n    const lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    } else if (typeof lastChild === \"string\") {\n      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n    } else {\n      this.children.push(\"\".replace(aPattern, aReplacement));\n    }\n    return this;\n  }\n\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  }\n\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n  walkSourceContents(aFn) {\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    const sources = Object.keys(this.sourceContents);\n    for (let i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  }\n\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n  toString() {\n    let str = \"\";\n    this.walk(function(chunk) {\n      str += chunk;\n    });\n    return str;\n  }\n\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n  toStringWithSourceMap(aArgs) {\n    const generated = {\n      code: \"\",\n      line: 1,\n      column: 0\n    };\n    const map = new SourceMapGenerator(aArgs);\n    let sourceMappingActive = false;\n    let lastOriginalSource = null;\n    let lastOriginalLine = null;\n    let lastOriginalColumn = null;\n    let lastOriginalName = null;\n    this.walk(function(chunk, original) {\n      generated.code += chunk;\n      if (original.source !== null\n          && original.line !== null\n          && original.column !== null) {\n        if (lastOriginalSource !== original.source\n          || lastOriginalLine !== original.line\n          || lastOriginalColumn !== original.column\n          || lastOriginalName !== original.name) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column\n          }\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n      for (let idx = 0, length = chunk.length; idx < length; idx++) {\n        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n          generated.line++;\n          generated.column = 0;\n          // Mappings end at eol\n          if (idx + 1 === length) {\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column\n              },\n              name: original.name\n            });\n          }\n        } else {\n          generated.column++;\n        }\n      }\n    });\n    this.walkSourceContents(function(sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n\n    return { code: generated.code, map };\n  }\n}\n\nexports.SourceNode = SourceNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi9zb3VyY2Utbm9kZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGlKQUFvRDtBQUMvRSxhQUFhLG1CQUFPLENBQUMseUVBQVE7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUwsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW0tbGV2aXR5Ly4vbm9kZV9tb2R1bGVzL3RlcnNlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvc291cmNlLW5vZGUuanM/ZmNhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmNvbnN0IFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoXCIuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yXCIpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxuY29uc3QgUkVHRVhfTkVXTElORSA9IC8oXFxyP1xcbikvO1xuXG4vLyBOZXdsaW5lIGNoYXJhY3RlciBjb2RlIGZvciBjaGFyQ29kZUF0KCkgY29tcGFyaXNvbnNcbmNvbnN0IE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4vLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4vLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuLy8gdmVyc2lvbnMhXG5jb25zdCBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4vKipcbiAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAqL1xuY2xhc3MgU291cmNlTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGFMaW5lLCBhQ29sdW1uLCBhU291cmNlLCBhQ2h1bmtzLCBhTmFtZSkge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gICAgdGhpcy5saW5lID0gYUxpbmUgPT0gbnVsbCA/IG51bGwgOiBhTGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICAgIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gICAgdGhpcy5uYW1lID0gYU5hbWUgPT0gbnVsbCA/IG51bGwgOiBhTmFtZTtcbiAgICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICAgIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gICAqXG4gICAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAgICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICogQHBhcmFtIGFSZWxhdGl2ZVBhdGggT3B0aW9uYWwuIFRoZSBwYXRoIHRoYXQgcmVsYXRpdmUgc291cmNlcyBpbiB0aGVcbiAgICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICBjb25zdCBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgIC8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAgIC8vIHdoaWxlIGFsbCBvZGQgaW5kaWNlcyBhcmUgdGhlIG5ld2xpbmVzIGJldHdlZW4gdHdvIGFkamFjZW50IGxpbmVzXG4gICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIGFjY2Vzc2VkIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgIGNvbnN0IHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgbGV0IHJlbWFpbmluZ0xpbmVzSW5kZXggPSAwO1xuICAgIGNvbnN0IHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGxpbmVDb250ZW50cyA9IGdldE5leHRMaW5lKCk7XG4gICAgICAvLyBUaGUgbGFzdCBsaW5lIG9mIGEgZmlsZSBtaWdodCBub3QgaGF2ZSBhIG5ld2xpbmUuXG4gICAgICBjb25zdCBuZXdMaW5lID0gZ2V0TmV4dExpbmUoKSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE5leHRMaW5lKCkge1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA/XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4KytdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICBsZXQgbGFzdEdlbmVyYXRlZExpbmUgPSAxLCBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgIC8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbiAgICBsZXQgbGFzdE1hcHBpbmcgPSBudWxsO1xuICAgIGxldCBuZXh0TGluZTtcblxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbihtYXBwaW5nKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBjb2RlIGZyb20gXCJsYXN0TWFwcGluZ1wiIHRvIFwibWFwcGluZ1wiOlxuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSBmaXJzdCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSB8fCBcIlwiO1xuICAgICAgICAgIGNvbnN0IGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAvLyBFYWNoIGxpbmUgaXMgYWRkZWQgYXMgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICB9XG4gICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gfHwgXCJcIjtcbiAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgfVxuICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICBpZiAocmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCkge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICB9XG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuc3BsaWNlKHJlbWFpbmluZ0xpbmVzSW5kZXgpLmpvaW4oXCJcIikpO1xuICAgIH1cblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2VGaWxlKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBub2RlO1xuXG4gICAgZnVuY3Rpb24gYWRkTWFwcGluZ1dpdGhDb2RlKG1hcHBpbmcsIGNvZGUpIHtcbiAgICAgIGlmIChtYXBwaW5nID09PSBudWxsIHx8IG1hcHBpbmcuc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZS5hZGQoY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAgICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gICAqL1xuICBhZGQoYUNodW5rKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgdGhpcy5hZGQoY2h1bmspO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoYUNodW5rKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBjaHVuayBvZiBnZW5lcmF0ZWQgSlMgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGlzIHNvdXJjZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAgICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gICAqL1xuICBwcmVwZW5kKGFDaHVuaykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICAgIGZvciAobGV0IGkgPSBhQ2h1bmsubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5wcmVwZW5kKGFDaHVua1tpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYUNodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAgICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICAgKiBzbmlwcGV0IGFuZCB0aGUgaXRzIG9yaWdpbmFsIGFzc29jaWF0ZWQgc291cmNlJ3MgbGluZS9jb2x1bW4gbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAgICovXG4gIHdhbGsoYUZuKSB7XG4gICAgbGV0IGNodW5rO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgICBjaHVuay53YWxrKGFGbik7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rICE9PSBcIlwiKSB7XG4gICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gICAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICAgKlxuICAgKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICAgKi9cbiAgam9pbihhU2VwKSB7XG4gICAgbGV0IG5ld0NoaWxkcmVuO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICBuZXdDaGlsZHJlbiA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgICAgfVxuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gICAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gICAqL1xuICByZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkge1xuICAgIGNvbnN0IGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdENoaWxkW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKFwiXCIucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gICAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAgICpcbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAgICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKi9cbiAgc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gICAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICB3YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2VzID0gT2JqZWN0LmtleXModGhpcy5zb3VyY2VDb250ZW50cyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlLiBXYWxrcyBvdmVyIHRoZSB0cmVlXG4gICAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgIHN0ciArPSBjaHVuaztcbiAgICB9KTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAgICogbWFwLlxuICAgKi9cbiAgdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gICAgY29uc3QgZ2VuZXJhdGVkID0ge1xuICAgICAgY29kZTogXCJcIixcbiAgICAgIGxpbmU6IDEsXG4gICAgICBjb2x1bW46IDBcbiAgICB9O1xuICAgIGNvbnN0IG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICAgIGxldCBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgbGV0IGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgbGV0IGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICAgIGxldCBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICAgIGxldCBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24oY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT09IG51bGxcbiAgICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxDb2x1bW4gIT09IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICAgIG1hcC5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcCB9O1xuICB9XG59XG5cbmV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/terser/node_modules/source-map/lib/source-node.js\n");

/***/ }),

/***/ "./node_modules/terser/node_modules/source-map/lib/util.js":
/*!*****************************************************************!*\
  !*** ./node_modules/terser/node_modules/source-map/lib/util.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n    throw new Error('\"' + aName + '\" is a required argument.');\n\n}\nexports.getArg = getArg;\n\nconst urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nconst dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  const match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  let url = \"\";\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + \":\";\n  }\n  url += \"//\";\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + \"@\";\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port;\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\nconst MAX_CACHED_INPUTS = 32;\n\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */\nfunction lruMemoize(f) {\n  const cache = [];\n\n  return function(input) {\n    for (let i = 0; i < cache.length; i++) {\n      if (cache[i].input === input) {\n        const temp = cache[0];\n        cache[0] = cache[i];\n        cache[i] = temp;\n        return cache[0].result;\n      }\n    }\n\n    const result = f(input);\n\n    cache.unshift({\n      input,\n      result,\n    });\n\n    if (cache.length > MAX_CACHED_INPUTS) {\n      cache.pop();\n    }\n\n    return result;\n  };\n}\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nconst normalize = lruMemoize(function normalize(aPath) {\n  let path = aPath;\n  const url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  const isAbsolute = exports.isAbsolute(path);\n\n  // Split the path into parts between `/` characters. This is much faster than\n  // using `.split(/\\/+/g)`.\n  const parts = [];\n  let start = 0;\n  let i = 0;\n  while (true) {\n    start = i;\n    i = path.indexOf(\"/\", start);\n    if (i === -1) {\n      parts.push(path.slice(start));\n      break;\n    } else {\n      parts.push(path.slice(start, i));\n      while (i < path.length && path[i] === \"/\") {\n        i++;\n      }\n    }\n  }\n\n  let up = 0;\n  for (i = parts.length - 1; i >= 0; i--) {\n    const part = parts[i];\n    if (part === \".\") {\n      parts.splice(i, 1);\n    } else if (part === \"..\") {\n      up++;\n    } else if (up > 0) {\n      if (part === \"\") {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join(\"/\");\n\n  if (path === \"\") {\n    path = isAbsolute ? \"/\" : \".\";\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  const aPathUrl = urlParse(aPath);\n  const aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || \"/\";\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  const joined = aPath.charAt(0) === \"/\"\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, \"\") + \"/\" + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function(aPath) {\n  return aPath.charAt(0) === \"/\" || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, \"\");\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  let level = 0;\n  while (aPath.indexOf(aRoot + \"/\") !== 0) {\n    const index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nconst supportsNullProto = (function() {\n  const obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n}());\n\nfunction identity(s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  const length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  /* eslint-disable no-multi-spaces */\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n  /* eslint-enable no-multi-spaces */\n\n  for (let i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  let cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || \"\";\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== \"/\" && sourceURL[0] !== \"/\") {\n      sourceRoot += \"/\";\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   “sources” entry.  This value is prepended to the individual\n    //   entries in the “source” field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   “sourceRoot”, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    const parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      const index = parsed.path.lastIndexOf(\"/\");\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi91dGlsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjOztBQUVkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVosa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW0tbGV2aXR5Ly4vbm9kZV9tb2R1bGVzL3RlcnNlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9saWIvdXRpbC5qcz9mZWFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIHZhbHVlcyBmcm9tIHBhcmFtZXRlci9vcHRpb25zXG4gKiBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSBhcmdzIFRoZSBvYmplY3Qgd2UgYXJlIGV4dHJhY3RpbmcgdmFsdWVzIGZyb21cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB3ZSBhcmUgZ2V0dGluZy5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gKiBmcm9tIHRoZSBvYmplY3QuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCBhbmQgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmcsIGFuXG4gKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZnVuY3Rpb24gZ2V0QXJnKGFBcmdzLCBhTmFtZSwgYURlZmF1bHRWYWx1ZSkge1xuICBpZiAoYU5hbWUgaW4gYUFyZ3MpIHtcbiAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gYURlZmF1bHRWYWx1ZTtcbiAgfVxuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcblxufVxuZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbmNvbnN0IHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuLV0qKSg/OjooXFxkKykpPyguKikkLztcbmNvbnN0IGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG5mdW5jdGlvbiB1cmxQYXJzZShhVXJsKSB7XG4gIGNvbnN0IG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgIGhvc3Q6IG1hdGNoWzNdLFxuICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgIHBhdGg6IG1hdGNoWzVdXG4gIH07XG59XG5leHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbmZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgbGV0IHVybCA9IFwiXCI7XG4gIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArIFwiOlwiO1xuICB9XG4gIHVybCArPSBcIi8vXCI7XG4gIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgXCJAXCI7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydDtcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG5jb25zdCBNQVhfQ0FDSEVEX0lOUFVUUyA9IDMyO1xuXG4vKipcbiAqIFRha2VzIHNvbWUgZnVuY3Rpb24gYGYoaW5wdXQpIC0+IHJlc3VsdGAgYW5kIHJldHVybnMgYSBtZW1vaXplZCB2ZXJzaW9uIG9mXG4gKiBgZmAuXG4gKlxuICogV2Uga2VlcCBhdCBtb3N0IGBNQVhfQ0FDSEVEX0lOUFVUU2AgbWVtb2l6ZWQgcmVzdWx0cyBvZiBgZmAgYWxpdmUuIFRoZVxuICogbWVtb2l6YXRpb24gaXMgYSBkdW1iLXNpbXBsZSwgbGluZWFyIGxlYXN0LXJlY2VudGx5LXVzZWQgY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIGxydU1lbW9pemUoZikge1xuICBjb25zdCBjYWNoZSA9IFtdO1xuXG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FjaGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjYWNoZVtpXS5pbnB1dCA9PT0gaW5wdXQpIHtcbiAgICAgICAgY29uc3QgdGVtcCA9IGNhY2hlWzBdO1xuICAgICAgICBjYWNoZVswXSA9IGNhY2hlW2ldO1xuICAgICAgICBjYWNoZVtpXSA9IHRlbXA7XG4gICAgICAgIHJldHVybiBjYWNoZVswXS5yZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gZihpbnB1dCk7XG5cbiAgICBjYWNoZS51bnNoaWZ0KHtcbiAgICAgIGlucHV0LFxuICAgICAgcmVzdWx0LFxuICAgIH0pO1xuXG4gICAgaWYgKGNhY2hlLmxlbmd0aCA+IE1BWF9DQUNIRURfSU5QVVRTKSB7XG4gICAgICBjYWNoZS5wb3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICpcbiAqIC0gUmVwbGFjZXMgY29uc2VjdXRpdmUgc2xhc2hlcyB3aXRoIG9uZSBzbGFzaC5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAqXG4gKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgdXJsIHRvIG5vcm1hbGl6ZS5cbiAqL1xuY29uc3Qgbm9ybWFsaXplID0gbHJ1TWVtb2l6ZShmdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgbGV0IHBhdGggPSBhUGF0aDtcbiAgY29uc3QgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICBpZiAodXJsKSB7XG4gICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cbiAgICBwYXRoID0gdXJsLnBhdGg7XG4gIH1cbiAgY29uc3QgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKTtcblxuICAvLyBTcGxpdCB0aGUgcGF0aCBpbnRvIHBhcnRzIGJldHdlZW4gYC9gIGNoYXJhY3RlcnMuIFRoaXMgaXMgbXVjaCBmYXN0ZXIgdGhhblxuICAvLyB1c2luZyBgLnNwbGl0KC9cXC8rL2cpYC5cbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN0YXJ0ID0gaTtcbiAgICBpID0gcGF0aC5pbmRleE9mKFwiL1wiLCBzdGFydCk7XG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICBwYXJ0cy5wdXNoKHBhdGguc2xpY2Uoc3RhcnQpKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cy5wdXNoKHBhdGguc2xpY2Uoc3RhcnQsIGkpKTtcbiAgICAgIHdoaWxlIChpIDwgcGF0aC5sZW5ndGggJiYgcGF0aFtpXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCB1cCA9IDA7XG4gIGZvciAoaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChwYXJ0ID09PSBcIi5cIikge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gXCIuLlwiKSB7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICBpZiAocGFydCA9PT0gXCJcIikge1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4gICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgdXAgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICB1cC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoID0gcGFydHMuam9pbihcIi9cIik7XG5cbiAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICBwYXRoID0gaXNBYnNvbHV0ZSA/IFwiL1wiIDogXCIuXCI7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgdXJsLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufSk7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICpcbiAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAqICAgZmlyc3QuXG4gKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICogICBpcyByZXR1cm5lZC5cbiAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBqb2luKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG4gIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgIGFQYXRoID0gXCIuXCI7XG4gIH1cbiAgY29uc3QgYVBhdGhVcmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIGNvbnN0IGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgXCIvXCI7XG4gIH1cblxuICAvLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVBhdGhVcmwuc2NoZW1lID0gYVJvb3RVcmwuc2NoZW1lO1xuICAgIH1cbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICB9XG5cbiAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgcmV0dXJuIGFQYXRoO1xuICB9XG5cbiAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgIGFSb290VXJsLmhvc3QgPSBhUGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG5cbiAgY29uc3Qgam9pbmVkID0gYVBhdGguY2hhckF0KDApID09PSBcIi9cIlxuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpICsgXCIvXCIgKyBhUGF0aCk7XG5cbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3RVcmwucGF0aCA9IGpvaW5lZDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG4gIHJldHVybiBqb2luZWQ7XG59XG5leHBvcnRzLmpvaW4gPSBqb2luO1xuXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSBcIi9cIiB8fCB1cmxSZWdleHAudGVzdChhUGF0aCk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG5cbiAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgZm9yIHRoZSBwYXRoIHRvIGJlIGFib3ZlIHRoZSByb290LiBJbiB0aGlzIGNhc2UsIHNpbXBseVxuICAvLyBjaGVja2luZyB3aGV0aGVyIHRoZSByb290IGlzIGEgcHJlZml4IG9mIHRoZSBwYXRoIHdvbid0IHdvcmsuIEluc3RlYWQsIHdlXG4gIC8vIG5lZWQgdG8gcmVtb3ZlIGNvbXBvbmVudHMgZnJvbSB0aGUgcm9vdCBvbmUgYnkgb25lLCB1bnRpbCBlaXRoZXIgd2UgZmluZFxuICAvLyBhIHByZWZpeCB0aGF0IGZpdHMsIG9yIHdlIHJ1biBvdXQgb2YgY29tcG9uZW50cyB0byByZW1vdmUuXG4gIGxldCBsZXZlbCA9IDA7XG4gIHdoaWxlIChhUGF0aC5pbmRleE9mKGFSb290ICsgXCIvXCIpICE9PSAwKSB7XG4gICAgY29uc3QgaW5kZXggPSBhUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBvbmx5IHBhcnQgb2YgdGhlIHJvb3QgdGhhdCBpcyBsZWZ0IGlzIHRoZSBzY2hlbWUgKGkuZS4gaHR0cDovLyxcbiAgICAvLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4gICAgLy8gaGF2ZSBleGhhdXN0ZWQgYWxsIGNvbXBvbmVudHMsIHNvIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSB0byB0aGUgcm9vdC5cbiAgICBhUm9vdCA9IGFSb290LnNsaWNlKDAsIGluZGV4KTtcbiAgICBpZiAoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICArK2xldmVsO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIFwiLi4vXCIgZm9yIGVhY2ggY29tcG9uZW50IHdlIHJlbW92ZWQgZnJvbSB0aGUgcm9vdC5cbiAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbihcIi4uL1wiKSArIGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKTtcbn1cbmV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxuY29uc3Qgc3VwcG9ydHNOdWxsUHJvdG8gPSAoZnVuY3Rpb24oKSB7XG4gIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAhKFwiX19wcm90b19fXCIgaW4gb2JqKTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuIFwiJFwiICsgYVN0cjtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy50b1NldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiB0b1NldFN0cmluZztcblxuZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuIGFTdHIuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMuZnJvbVNldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiBmcm9tU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBpc1Byb3RvU3RyaW5nKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDkgLyogXCJfX3Byb3RvX19cIi5sZW5ndGggKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1tdWx0aS1zcGFjZXMgKi9cbiAgaWYgKHMuY2hhckNvZGVBdChsZW5ndGggLSAxKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDIpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMykgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA0KSAhPT0gMTE2IC8qICd0JyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDUpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNikgIT09IDExNCAvKiAncicgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA3KSAhPT0gMTEyIC8qICdwJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDgpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOSkgIT09IDk1ICAvKiAnXycgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1tdWx0aS1zcGFjZXMgKi9cblxuICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTA7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHMuY2hhckNvZGVBdChpKSAhPT0gMzYgLyogJyQnICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgbGV0IGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMgPSBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucztcblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggZGVmbGF0ZWQgc291cmNlIGFuZCBuYW1lIGluZGljZXMgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4sIGJ1dCBkaWZmZXJlbnRcbiAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gKiBtYXBwaW5nIHdpdGggYSBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gIGxldCBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO1xuXG5mdW5jdGlvbiBzdHJjbXAoYVN0cjEsIGFTdHIyKSB7XG4gIGlmIChhU3RyMSA9PT0gYVN0cjIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhU3RyMSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAxOyAvLyBhU3RyMiAhPT0gbnVsbFxuICB9XG5cbiAgaWYgKGFTdHIyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xOyAvLyBhU3RyMSAhPT0gbnVsbFxuICB9XG5cbiAgaWYgKGFTdHIxID4gYVN0cjIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggaW5mbGF0ZWQgc291cmNlIGFuZCBuYW1lIHN0cmluZ3Mgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIGxldCBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xuXG4vKipcbiAqIFN0cmlwIGFueSBKU09OIFhTU0kgYXZvaWRhbmNlIHByZWZpeCBmcm9tIHRoZSBzdHJpbmcgKGFzIGRvY3VtZW50ZWRcbiAqIGluIHRoZSBzb3VyY2UgbWFwcyBzcGVjaWZpY2F0aW9uKSwgYW5kIHRoZW4gcGFyc2UgdGhlIHN0cmluZyBhc1xuICogSlNPTi5cbiAqL1xuZnVuY3Rpb24gcGFyc2VTb3VyY2VNYXBJbnB1dChzdHIpIHtcbiAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLnJlcGxhY2UoL15cXCldfSdbXlxcbl0qXFxuLywgXCJcIikpO1xufVxuZXhwb3J0cy5wYXJzZVNvdXJjZU1hcElucHV0ID0gcGFyc2VTb3VyY2VNYXBJbnB1dDtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBVUkwgb2YgYSBzb3VyY2UgZ2l2ZW4gdGhlIHRoZSBzb3VyY2Ugcm9vdCwgdGhlIHNvdXJjZSdzXG4gKiBVUkwsIGFuZCB0aGUgc291cmNlIG1hcCdzIFVSTC5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzb3VyY2VVUkwsIHNvdXJjZU1hcFVSTCkge1xuICBzb3VyY2VVUkwgPSBzb3VyY2VVUkwgfHwgXCJcIjtcblxuICBpZiAoc291cmNlUm9vdCkge1xuICAgIC8vIFRoaXMgZm9sbG93cyB3aGF0IENocm9tZSBkb2VzLlxuICAgIGlmIChzb3VyY2VSb290W3NvdXJjZVJvb3QubGVuZ3RoIC0gMV0gIT09IFwiL1wiICYmIHNvdXJjZVVSTFswXSAhPT0gXCIvXCIpIHtcbiAgICAgIHNvdXJjZVJvb3QgKz0gXCIvXCI7XG4gICAgfVxuICAgIC8vIFRoZSBzcGVjIHNheXM6XG4gICAgLy8gICBMaW5lIDQ6IEFuIG9wdGlvbmFsIHNvdXJjZSByb290LCB1c2VmdWwgZm9yIHJlbG9jYXRpbmcgc291cmNlXG4gICAgLy8gICBmaWxlcyBvbiBhIHNlcnZlciBvciByZW1vdmluZyByZXBlYXRlZCB2YWx1ZXMgaW4gdGhlXG4gICAgLy8gICDigJxzb3VyY2Vz4oCdIGVudHJ5LiAgVGhpcyB2YWx1ZSBpcyBwcmVwZW5kZWQgdG8gdGhlIGluZGl2aWR1YWxcbiAgICAvLyAgIGVudHJpZXMgaW4gdGhlIOKAnHNvdXJjZeKAnSBmaWVsZC5cbiAgICBzb3VyY2VVUkwgPSBzb3VyY2VSb290ICsgc291cmNlVVJMO1xuICB9XG5cbiAgLy8gSGlzdG9yaWNhbGx5LCBTb3VyY2VNYXBDb25zdW1lciBkaWQgbm90IHRha2UgdGhlIHNvdXJjZU1hcFVSTCBhc1xuICAvLyBhIHBhcmFtZXRlci4gIFRoaXMgbW9kZSBpcyBzdGlsbCBzb21ld2hhdCBzdXBwb3J0ZWQsIHdoaWNoIGlzIHdoeVxuICAvLyB0aGlzIGNvZGUgYmxvY2sgaXMgY29uZGl0aW9uYWwuICBIb3dldmVyLCBpdCdzIHByZWZlcmFibGUgdG8gcGFzc1xuICAvLyB0aGUgc291cmNlIG1hcCBVUkwgdG8gU291cmNlTWFwQ29uc3VtZXIsIHNvIHRoYXQgdGhpcyBmdW5jdGlvblxuICAvLyBjYW4gaW1wbGVtZW50IHRoZSBzb3VyY2UgVVJMIHJlc29sdXRpb24gYWxnb3JpdGhtIGFzIG91dGxpbmVkIGluXG4gIC8vIHRoZSBzcGVjLiAgVGhpcyBibG9jayBpcyBiYXNpY2FsbHkgdGhlIGVxdWl2YWxlbnQgb2Y6XG4gIC8vICAgIG5ldyBVUkwoc291cmNlVVJMLCBzb3VyY2VNYXBVUkwpLnRvU3RyaW5nKClcbiAgLy8gLi4uIGV4Y2VwdCBpdCBhdm9pZHMgdXNpbmcgVVJMLCB3aGljaCB3YXNuJ3QgYXZhaWxhYmxlIGluIHRoZVxuICAvLyBvbGRlciByZWxlYXNlcyBvZiBub2RlIHN0aWxsIHN1cHBvcnRlZCBieSB0aGlzIGxpYnJhcnkuXG4gIC8vXG4gIC8vIFRoZSBzcGVjIHNheXM6XG4gIC8vICAgSWYgdGhlIHNvdXJjZXMgYXJlIG5vdCBhYnNvbHV0ZSBVUkxzIGFmdGVyIHByZXBlbmRpbmcgb2YgdGhlXG4gIC8vICAg4oCcc291cmNlUm9vdOKAnSwgdGhlIHNvdXJjZXMgYXJlIHJlc29sdmVkIHJlbGF0aXZlIHRvIHRoZVxuICAvLyAgIFNvdXJjZU1hcCAobGlrZSByZXNvbHZpbmcgc2NyaXB0IHNyYyBpbiBhIGh0bWwgZG9jdW1lbnQpLlxuICBpZiAoc291cmNlTWFwVVJMKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdXJsUGFyc2Uoc291cmNlTWFwVVJMKTtcbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic291cmNlTWFwVVJMIGNvdWxkIG5vdCBiZSBwYXJzZWRcIik7XG4gICAgfVxuICAgIGlmIChwYXJzZWQucGF0aCkge1xuICAgICAgLy8gU3RyaXAgdGhlIGxhc3QgcGF0aCBjb21wb25lbnQsIGJ1dCBrZWVwIHRoZSBcIi9cIi5cbiAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VkLnBhdGgubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgcGFyc2VkLnBhdGggPSBwYXJzZWQucGF0aC5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlVVJMID0gam9pbih1cmxHZW5lcmF0ZShwYXJzZWQpLCBzb3VyY2VVUkwpO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZShzb3VyY2VVUkwpO1xufVxuZXhwb3J0cy5jb21wdXRlU291cmNlVVJMID0gY29tcHV0ZVNvdXJjZVVSTDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/terser/node_modules/source-map/lib/util.js\n");

/***/ }),

/***/ "./node_modules/terser/node_modules/source-map/lib/wasm.js":
/*!*****************************************************************!*\
  !*** ./node_modules/terser/node_modules/source-map/lib/wasm.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const readWasm = __webpack_require__(/*! ../lib/read-wasm */ \"./node_modules/terser/node_modules/source-map/lib/read-wasm.js\");\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.lastGeneratedColumn = null;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\nlet cachedWasm = null;\n\nmodule.exports = function wasm() {\n  if (cachedWasm) {\n    return cachedWasm;\n  }\n\n  const callbackStack = [];\n\n  cachedWasm = readWasm().then(buffer => {\n      return WebAssembly.instantiate(buffer, {\n        env: {\n          mapping_callback(\n            generatedLine,\n            generatedColumn,\n\n            hasLastGeneratedColumn,\n            lastGeneratedColumn,\n\n            hasOriginal,\n            source,\n            originalLine,\n            originalColumn,\n\n            hasName,\n            name\n          ) {\n            const mapping = new Mapping();\n            // JS uses 1-based line numbers, wasm uses 0-based.\n            mapping.generatedLine = generatedLine + 1;\n            mapping.generatedColumn = generatedColumn;\n\n            if (hasLastGeneratedColumn) {\n              // JS uses inclusive last generated column, wasm uses exclusive.\n              mapping.lastGeneratedColumn = lastGeneratedColumn - 1;\n            }\n\n            if (hasOriginal) {\n              mapping.source = source;\n              // JS uses 1-based line numbers, wasm uses 0-based.\n              mapping.originalLine = originalLine + 1;\n              mapping.originalColumn = originalColumn;\n\n              if (hasName) {\n                mapping.name = name;\n              }\n            }\n\n            callbackStack[callbackStack.length - 1](mapping);\n          },\n\n          start_all_generated_locations_for() { console.time(\"all_generated_locations_for\"); },\n          end_all_generated_locations_for() { console.timeEnd(\"all_generated_locations_for\"); },\n\n          start_compute_column_spans() { console.time(\"compute_column_spans\"); },\n          end_compute_column_spans() { console.timeEnd(\"compute_column_spans\"); },\n\n          start_generated_location_for() { console.time(\"generated_location_for\"); },\n          end_generated_location_for() { console.timeEnd(\"generated_location_for\"); },\n\n          start_original_location_for() { console.time(\"original_location_for\"); },\n          end_original_location_for() { console.timeEnd(\"original_location_for\"); },\n\n          start_parse_mappings() { console.time(\"parse_mappings\"); },\n          end_parse_mappings() { console.timeEnd(\"parse_mappings\"); },\n\n          start_sort_by_generated_location() { console.time(\"sort_by_generated_location\"); },\n          end_sort_by_generated_location() { console.timeEnd(\"sort_by_generated_location\"); },\n\n          start_sort_by_original_location() { console.time(\"sort_by_original_location\"); },\n          end_sort_by_original_location() { console.timeEnd(\"sort_by_original_location\"); },\n        }\n      });\n  }).then(Wasm => {\n    return {\n      exports: Wasm.instance.exports,\n      withMappingCallback: (mappingCallback, f) => {\n        callbackStack.push(mappingCallback);\n        try {\n          f();\n        } finally {\n          callbackStack.pop();\n        }\n      }\n    };\n  }).then(null, e => {\n    cachedWasm = null;\n    throw e;\n  });\n\n  return cachedWasm;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi93YXNtLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLHdGQUFrQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYLGdEQUFnRCw4Q0FBOEM7QUFDOUYsOENBQThDLGlEQUFpRDs7QUFFL0YseUNBQXlDLHVDQUF1QztBQUNoRix1Q0FBdUMsMENBQTBDOztBQUVqRiwyQ0FBMkMseUNBQXlDO0FBQ3BGLHlDQUF5Qyw0Q0FBNEM7O0FBRXJGLDBDQUEwQyx3Q0FBd0M7QUFDbEYsd0NBQXdDLDJDQUEyQzs7QUFFbkYsbUNBQW1DLGlDQUFpQztBQUNwRSxpQ0FBaUMsb0NBQW9DOztBQUVyRSwrQ0FBK0MsNkNBQTZDO0FBQzVGLDZDQUE2QyxnREFBZ0Q7O0FBRTdGLDhDQUE4Qyw0Q0FBNEM7QUFDMUYsNENBQTRDLCtDQUErQztBQUMzRjtBQUNBLE9BQU87QUFDUCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbS1sZXZpdHkvLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL2xpYi93YXNtLmpzPzQ4NGQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmVhZFdhc20gPSByZXF1aXJlKFwiLi4vbGliL3JlYWQtd2FzbVwiKTtcblxuLyoqXG4gKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gIHRoaXMuZ2VuZXJhdGVkTGluZSA9IDA7XG4gIHRoaXMuZ2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgdGhpcy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbnVsbDtcbiAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB0aGlzLm5hbWUgPSBudWxsO1xufVxuXG5sZXQgY2FjaGVkV2FzbSA9IG51bGw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2FzbSgpIHtcbiAgaWYgKGNhY2hlZFdhc20pIHtcbiAgICByZXR1cm4gY2FjaGVkV2FzbTtcbiAgfVxuXG4gIGNvbnN0IGNhbGxiYWNrU3RhY2sgPSBbXTtcblxuICBjYWNoZWRXYXNtID0gcmVhZFdhc20oKS50aGVuKGJ1ZmZlciA9PiB7XG4gICAgICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYnVmZmVyLCB7XG4gICAgICAgIGVudjoge1xuICAgICAgICAgIG1hcHBpbmdfY2FsbGJhY2soXG4gICAgICAgICAgICBnZW5lcmF0ZWRMaW5lLFxuICAgICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uLFxuXG4gICAgICAgICAgICBoYXNMYXN0R2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbixcblxuICAgICAgICAgICAgaGFzT3JpZ2luYWwsXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbExpbmUsXG4gICAgICAgICAgICBvcmlnaW5hbENvbHVtbixcblxuICAgICAgICAgICAgaGFzTmFtZSxcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICAgICAgLy8gSlMgdXNlcyAxLWJhc2VkIGxpbmUgbnVtYmVycywgd2FzbSB1c2VzIDAtYmFzZWQuXG4gICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lICsgMTtcbiAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgICAgICBpZiAoaGFzTGFzdEdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICAgICAgICAvLyBKUyB1c2VzIGluY2x1c2l2ZSBsYXN0IGdlbmVyYXRlZCBjb2x1bW4sIHdhc20gdXNlcyBleGNsdXNpdmUuXG4gICAgICAgICAgICAgIG1hcHBpbmcubGFzdEdlbmVyYXRlZENvbHVtbiA9IGxhc3RHZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzT3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICAgIC8vIEpTIHVzZXMgMS1iYXNlZCBsaW5lIG51bWJlcnMsIHdhc20gdXNlcyAwLWJhc2VkLlxuICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsTGluZSArIDE7XG4gICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgICAgICBpZiAoaGFzTmFtZSkge1xuICAgICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2tTdGFja1tjYWxsYmFja1N0YWNrLmxlbmd0aCAtIDFdKG1hcHBpbmcpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBzdGFydF9hbGxfZ2VuZXJhdGVkX2xvY2F0aW9uc19mb3IoKSB7IGNvbnNvbGUudGltZShcImFsbF9nZW5lcmF0ZWRfbG9jYXRpb25zX2ZvclwiKTsgfSxcbiAgICAgICAgICBlbmRfYWxsX2dlbmVyYXRlZF9sb2NhdGlvbnNfZm9yKCkgeyBjb25zb2xlLnRpbWVFbmQoXCJhbGxfZ2VuZXJhdGVkX2xvY2F0aW9uc19mb3JcIik7IH0sXG5cbiAgICAgICAgICBzdGFydF9jb21wdXRlX2NvbHVtbl9zcGFucygpIHsgY29uc29sZS50aW1lKFwiY29tcHV0ZV9jb2x1bW5fc3BhbnNcIik7IH0sXG4gICAgICAgICAgZW5kX2NvbXB1dGVfY29sdW1uX3NwYW5zKCkgeyBjb25zb2xlLnRpbWVFbmQoXCJjb21wdXRlX2NvbHVtbl9zcGFuc1wiKTsgfSxcblxuICAgICAgICAgIHN0YXJ0X2dlbmVyYXRlZF9sb2NhdGlvbl9mb3IoKSB7IGNvbnNvbGUudGltZShcImdlbmVyYXRlZF9sb2NhdGlvbl9mb3JcIik7IH0sXG4gICAgICAgICAgZW5kX2dlbmVyYXRlZF9sb2NhdGlvbl9mb3IoKSB7IGNvbnNvbGUudGltZUVuZChcImdlbmVyYXRlZF9sb2NhdGlvbl9mb3JcIik7IH0sXG5cbiAgICAgICAgICBzdGFydF9vcmlnaW5hbF9sb2NhdGlvbl9mb3IoKSB7IGNvbnNvbGUudGltZShcIm9yaWdpbmFsX2xvY2F0aW9uX2ZvclwiKTsgfSxcbiAgICAgICAgICBlbmRfb3JpZ2luYWxfbG9jYXRpb25fZm9yKCkgeyBjb25zb2xlLnRpbWVFbmQoXCJvcmlnaW5hbF9sb2NhdGlvbl9mb3JcIik7IH0sXG5cbiAgICAgICAgICBzdGFydF9wYXJzZV9tYXBwaW5ncygpIHsgY29uc29sZS50aW1lKFwicGFyc2VfbWFwcGluZ3NcIik7IH0sXG4gICAgICAgICAgZW5kX3BhcnNlX21hcHBpbmdzKCkgeyBjb25zb2xlLnRpbWVFbmQoXCJwYXJzZV9tYXBwaW5nc1wiKTsgfSxcblxuICAgICAgICAgIHN0YXJ0X3NvcnRfYnlfZ2VuZXJhdGVkX2xvY2F0aW9uKCkgeyBjb25zb2xlLnRpbWUoXCJzb3J0X2J5X2dlbmVyYXRlZF9sb2NhdGlvblwiKTsgfSxcbiAgICAgICAgICBlbmRfc29ydF9ieV9nZW5lcmF0ZWRfbG9jYXRpb24oKSB7IGNvbnNvbGUudGltZUVuZChcInNvcnRfYnlfZ2VuZXJhdGVkX2xvY2F0aW9uXCIpOyB9LFxuXG4gICAgICAgICAgc3RhcnRfc29ydF9ieV9vcmlnaW5hbF9sb2NhdGlvbigpIHsgY29uc29sZS50aW1lKFwic29ydF9ieV9vcmlnaW5hbF9sb2NhdGlvblwiKTsgfSxcbiAgICAgICAgICBlbmRfc29ydF9ieV9vcmlnaW5hbF9sb2NhdGlvbigpIHsgY29uc29sZS50aW1lRW5kKFwic29ydF9ieV9vcmlnaW5hbF9sb2NhdGlvblwiKTsgfSxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0pLnRoZW4oV2FzbSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV4cG9ydHM6IFdhc20uaW5zdGFuY2UuZXhwb3J0cyxcbiAgICAgIHdpdGhNYXBwaW5nQ2FsbGJhY2s6IChtYXBwaW5nQ2FsbGJhY2ssIGYpID0+IHtcbiAgICAgICAgY2FsbGJhY2tTdGFjay5wdXNoKG1hcHBpbmdDYWxsYmFjayk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGNhbGxiYWNrU3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KS50aGVuKG51bGwsIGUgPT4ge1xuICAgIGNhY2hlZFdhc20gPSBudWxsO1xuICAgIHRocm93IGU7XG4gIH0pO1xuXG4gIHJldHVybiBjYWNoZWRXYXNtO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/terser/node_modules/source-map/lib/wasm.js\n");

/***/ }),

/***/ "./node_modules/terser/node_modules/source-map/source-map.js":
/*!*******************************************************************!*\
  !*** ./node_modules/terser/node_modules/source-map/source-map.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ \"./node_modules/terser/node_modules/source-map/lib/source-map-generator.js\").SourceMapGenerator;\nexports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ \"./node_modules/terser/node_modules/source-map/lib/source-map-consumer.js\").SourceMapConsumer;\nexports.SourceNode = __webpack_require__(/*! ./lib/source-node */ \"./node_modules/terser/node_modules/source-map/lib/source-node.js\").SourceNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVyc2VyL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwL3NvdXJjZS1tYXAuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtMQUFxRjtBQUNyRiw4S0FBa0Y7QUFDbEYsZ0pBQTREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW0tbGV2aXR5Ly4vbm9kZV9tb2R1bGVzL3RlcnNlci9ub2RlX21vZHVsZXMvc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzPzhlNmIiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3JcIikuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoXCIuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyXCIpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZShcIi4vbGliL3NvdXJjZS1ub2RlXCIpLlNvdXJjZU5vZGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/terser/node_modules/source-map/source-map.js\n");

/***/ }),

/***/ "./node_modules/terser/package.json":
/*!******************************************!*\
  !*** ./node_modules/terser/package.json ***!
  \******************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"terser","description":"JavaScript parser, mangler/compressor and beautifier toolkit for ES6+","homepage":"https://terser.org","author":"Mihai Bazon <mihai.bazon@gmail.com> (http://lisperator.net/)","license":"BSD-2-Clause","version":"5.7.1","engines":{"node":">=10"},"maintainers":["Fábio Santos <fabiosantosart@gmail.com>"],"repository":"https://github.com/terser/terser","main":"dist/bundle.min.js","type":"module","module":"./main.js","exports":{".":[{"import":"./main.js","require":"./dist/bundle.min.js"},"./dist/bundle.min.js"],"./package":"./package.json","./package.json":"./package.json","./bin/terser":"./bin/terser"},"types":"tools/terser.d.ts","bin":{"terser":"bin/terser"},"files":["bin","dist","lib","tools","LICENSE","README.md","CHANGELOG.md","PATRONS.md","main.js"],"dependencies":{"commander":"^2.20.0","source-map":"~0.7.2","source-map-support":"~0.5.19"},"devDependencies":{"@ls-lint/ls-lint":"^1.9.2","acorn":"^8.0.5","astring":"^1.6.2","eslint":"^7.19.0","eslump":"^2.0.0","esm":"^3.2.25","mocha":"^8.2.1","pre-commit":"^1.2.2","rimraf":"^3.0.2","rollup":"2.38.4","semver":"^7.3.4"},"scripts":{"test":"node test/compress.js && mocha test/mocha","test:compress":"node test/compress.js","test:mocha":"mocha test/mocha","lint":"eslint lib","lint-fix":"eslint --fix lib","ls-lint":"ls-lint","build":"rimraf dist/bundle* && rollup --config --silent","prepare":"npm run build","postversion":"echo \'Remember to update the changelog!\'"},"keywords":["uglify","terser","uglify-es","uglify-js","minify","minifier","javascript","ecmascript","es5","es6","es7","es8","es2015","es2016","es2017","async","await"],"eslintConfig":{"parserOptions":{"sourceType":"module","ecmaVersion":"2020"},"env":{"node":true,"browser":true,"es2020":true},"globals":{"describe":false,"it":false,"require":false,"global":false,"process":false},"rules":{"brace-style":["error","1tbs",{"allowSingleLine":true}],"quotes":["error","double","avoid-escape"],"no-debugger":"error","no-undef":"error","no-unused-vars":["error",{"varsIgnorePattern":"^_"}],"no-tabs":"error","semi":["error","always"],"no-extra-semi":"error","no-irregular-whitespace":"error","space-before-blocks":["error","always"]}},"pre-commit":["build","lint-fix","ls-lint","test"]}');

/***/ })

}]);